*change.txt*    Nvim


		  VIM 参考手册    by Bram Moolenaar


本文件描述了删除或更改文本的命令。在此上下文中， 更改文本意味着删除文本并使用一个命令用其他文本替换它。
您可以撤销所有这些命令。您可以使用 "." 命令重复非Ex命令。

有关插入文本，请参见 |insert.txt|。

                                      输入 |gO| 查看目录。

==============================================================================
1. 删除文本					*deleting* *E470*

["x]<Del>	或					*<Del>* *x* *dl*
["x]x			删除光标下和光标后的 [count] 个字符
			[到寄存器 x]（非 |linewise|）。与 "dl" 相同。
			<Del> 键不接受 [count]。相反，它
			删除计数的最后一个字符。
			参见 'whichwrap' 了解删除换行符（连接
			行）。

							*X* *dh*
["x]X		        删除光标前的 [count] 个字符 [到
			寄存器 x]（非 |linewise|）。与 "dh" 相同。
			另见 'whichwrap'。

							*d*
["x]d{motion}		删除 {motion} 移动过的文本 [到寄存器
			x]。参见下面的例外情况。

							*dd*
["x]dd			删除 [count] 行 [到寄存器 x] |linewise|。

        						*D*
["x]D			删除光标下的字符直到行尾
			和 [count]-1 更多行 [到寄存器
			x]；"d$" 的同义词。
			（非 |linewise|）

{Visual}["x]x	或					*v_x* *v_d* *v_<Del>*
{Visual}["x]d   或
{Visual}["x]<Del>	删除高亮的文本 [到寄存器 x]（对于
			{Visual} 参见 |Visual-mode|）。

{Visual}["x]CTRL-H   或					*v_CTRL-H* *v_<BS>*
{Visual}["x]<BS>	在选择模式下：删除高亮的文本 [到
			寄存器 x]。

{Visual}["x]X	或					*v_X* *v_D* *v_b_D*
{Visual}["x]D		删除高亮的行 [到寄存器 x]（对于
			{Visual} 参见 |Visual-mode|）。在可视块模式下，
			"D" 删除高亮的文本加上直到行尾的所有文本。

					*:d* *:de* *:del* *:delete* *:dl* *:dp*
:[range]d[elete] [x]	删除 [range] 行（默认：当前行）[到
			寄存器 x]。
			注意这些奇怪的缩写：
			   :dl		删除并列出
			   :dell	同上
			   :delel	同上
			   :deletl	同上
			   :deletel	同上
			   :dp		删除并打印
			   :dep		同上
			   :delp	同上
			   :delep	同上
			   :deletp	同上
			   :deletep	同上

:[range]d[elete] [x] {count}
			删除 {count} 行，从 [range] 开始
			（默认：当前行 |cmdline-ranges|）[到
			寄存器 x]。

这些命令删除文本。您可以使用 `.` 命令重复它们
（除了 `:d`）并撤销它们。使用可视模式删除文本块。参见
|registers| 了解寄存器的说明。

d{motion} 命令的例外情况：如果动作不是行方式的，动作的
开始和结束不在同一行，并且开始前只有空白，动作结束后没有
非空白，删除变为行方式。这意味着删除也会移除您可能期望
保留的空白行。使用 |o_v| 操作符强制动作为字符方式。

尝试删除空文本区域（例如，在第一列的 "d0"）
当 'cpoptions' 包含 'E' 标志时是错误。

							*J*
J			连接 [count] 行，最少两行。
			移除缩进并插入最多两个空格（参见
			下面）。在缓冲区最后一行时失败。
			如果 [count] 太大，它会被减少到可用的
			行数。

							*v_J*
{Visual}J		连接高亮的行，最少两行。
			移除缩进并插入最多两个空格（参见
			下面）。

							*gJ*
gJ			连接 [count] 行，最少两行。
			不插入或删除任何空格。

							*v_gJ*
{Visual}gJ		连接高亮的行，最少两行。
			不插入或删除任何空格。

							*:j* *:join*
:[range]j[oin][!] [flags]
			连接 [range] 行。与 "J" 相同，除了使用 [!]
			连接不插入或删除任何空格。
			如果 [range] 的开始和结束值相等，此
			命令不执行任何操作。默认行为是
			将当前行与下面的行连接。
			参见 |ex-flags| 了解 [flags]。

:[range]j[oin][!] {count} [flags]
			连接 {count} 行，从 [range] 开始（默认：
			当前行 |cmdline-ranges|）。与 "J" 相同，除了
			使用 [!] 连接不插入或删除任何空格。
			参见 |ex-flags| 了解 [flags]。

这些命令删除行之间的 <EOL>。这具有将多行连接成
一行的效果。您可以重复这些命令（除了 `:j`）并撤销它们。

这些命令（除了 "gJ"）在 <EOL> 的位置插入一个空格，除非
有尾随空白或下一行以 ')' 开头。这些命令（除了 "gJ"）
删除下一行的任何前导空白。如果 'joinspaces' 选项开启，
这些命令在 '.'、'!' 或 '?' 后插入两个空格。
'formatoptions' 中的 'B' 和 'M' 标志改变在多字节字符前后
插入空格的行为 |fo-table|。

|'[| 标记设置在第一个被连接行的末尾，|']| 在
结果行的末尾。


==============================================================================
2. 删除和插入				*delete-insert* *replacing*

							*R*
R			进入替换模式：您输入的每个字符替换
			一个现有字符，从光标下的字符开始。
			重复输入的文本 [count]-1 次。参见
			|Replace-mode| 了解更多详情。

							*gR*
gR			进入虚拟替换模式：您输入的每个字符
			替换屏幕空间中的现有字符。所以 <Tab>
			可能一次替换几个字符。
			重复输入的文本 [count]-1 次。参见
			|Virtual-Replace-mode| 了解更多详情。

							*c*
["x]c{motion}		删除 {motion} 文本 [到寄存器 x] 并开始
			插入。当 'cpoptions' 包含 'E' 标志且
			没有文本要删除时（例如，当光标在 'x' 后
			时使用 "cTx"），会发生错误且插入模式
			不会启动（这与 Vi 兼容）。
			当 'cpoptions' 不包含 'E' 标志时，"c"
			命令总是启动插入模式，即使没有文本
			要删除。

							*cc*
["x]cc			删除 [count] 行 [到寄存器 x] 并开始
			插入 |linewise|。如果 'autoindent' 开启，
			保留第一行的缩进。

							*C*
["x]C			从光标位置删除到行尾
			和 [count]-1 更多行 [到寄存器 x]，
			并开始插入。"c$" 的同义词（非 |linewise|）。

							*s*
["x]s			删除 [count] 个字符 [到寄存器 x] 并开始
			插入（s 代表 Substitute）。"cl" 的同义词
			（非 |linewise|）。
*S*
["x]S			删除 [count] 行 [到寄存器 x] 并开始
			插入。"cc" 的同义词 |linewise|。

{Visual}["x]c	或					*v_c* *v_s*
{Visual}["x]s		删除高亮的文本 [到寄存器 x] 并
			开始插入（对于 {Visual} 参见 |Visual-mode|）。

							*v_r*
{Visual}r{char}		用 {char} 替换所有选中的字符。
			CTRL-C 将被字面插入。

							*v_C*
{Visual}["x]C		删除高亮的行 [到寄存器 x] 并开始
			插入。在可视块模式下工作方式不同 |v_b_C|。
							*v_S*
{Visual}["x]S		删除高亮的行 [到寄存器 x] 并开始
			插入（对于 {Visual} 参见 |Visual-mode|）。
							*v_R*
{Visual}["x]R		目前与 {Visual}["x]S 相同。在下一个版本中
			可能工作方式不同。

注意：
- 您可以使用 <Esc> 结束插入和替换模式。
- 参见"插入和替换模式"部分 |mode-ins-repl| 了解这些模式中的其他
  特殊字符。
- [count] 的效果在 Vim 退出插入或替换模式后生效。
- 当 'cpoptions' 选项包含 '$' 且更改在一行内时，
  Vim 继续显示要删除的文本并在最后一个
  删除的字符处放置一个 '$'。

参见 |registers| 了解寄存器的说明。

替换模式就像插入模式一样，除了您输入的每个字符
都删除一个字符。如果您到达行尾，Vim 会附加任何
进一步的字符（就像插入模式一样）。在替换模式下，
退格键恢复原始文本（如果有的话）。（参见"插入和
替换模式"部分 |mode-ins-repl|）。

						*cw* *cW*
特殊情况：当光标在单词中时，"cw" 和 "cW" 不包括
单词后的空白，它们只更改到单词末尾。这是因为
Vim 将 "cw" 解释为 change-word，而单词不包括
后面的空白。

如果您希望 "cw" 包括单词后的空格，请使用此映射：>
	:map cw dwi
或使用 "caw"（参见 |aw|）。

							*:c* *:ch* *:change*
:{range}c[hange][!]	用一些不同的文本替换文本行。
			输入只包含 "." 的行来停止替换。
			没有 {range} 时，此命令只更改当前行。
			添加 [!] 切换此命令执行期间的 'autoindent'。

==============================================================================
3. 简单更改				*simple-change* *changing*

							*r*
r{char}			用 {char} 替换光标下的字符。
			如果 {char} 是 <CR> 或 <NL>，则用换行符替换
			该字符。要用真正的 <CR> 替换，请使用 CTRL-V
			<CR>。CTRL-V <NL> 用 <Nul> 替换。

			如果 {char} 是 CTRL-E 或 CTRL-Y，则使用来自
			下面或上面行的字符，就像 |i_CTRL-E| 和
			|i_CTRL-Y| 一样。这也适用于计数，因此
			`10r<C-E>` 从下面行复制 10 个字符。

			如果您给出 [count]，Vim 用 [count] 个 {char}
			替换 [count] 个字符。但是，当 {char} 是 <CR> 或
			<NL> 时，Vim 只插入一个 <CR>："5r<CR>" 用单个
			换行符替换五个字符。
			当 {char} 是 <CR> 或 <NL> 时，Vim 执行
			自动缩进。这就像删除被替换的字符然后执行
			"i<CR><Esc>" 一样。
			{char} 可以作为二合字母输入 |digraph-arg|。
			|:lmap| 映射适用于 {char}。插入模式中的 CTRL-^ 命令
			可用于切换此功能 |i_CTRL-^|。当 'encoding' 是 Unicode 时，
			参见 |utf-8-char-arg| 了解使用组合字符。

							*gr*
gr{char}		用 {char} 替换光标下的虚拟字符。
			这是在屏幕空间中替换，而不是文件空间中。
			参见 |gR| 和 |Virtual-Replace-mode| 了解更多
			详情。与 |r| 一样，可以给出计数。
			{char} 可以像 |r| 一样输入，但在插入模式中
			有特殊含义的字符，如大多数 CTRL 键，不能使用。

							*gr-default*
			Nvim 创建 |lsp-defaults| 映射，这可能会抑制
			|gr| 的内置行为。使用此命令恢复内置行为：>
				nnoremap <nowait> gr gr
<

						*digraph-arg*
像 |r| 和 |t| 这样的普通模式命令的参数是单个字符。
当 'cpo' 不包含 'D' 标志时，此字符也可以像 |digraphs| 一样输入。
首先输入 CTRL-K，然后输入两个二合字母字符。

						*case*
以下命令更改字母的大小写。使用当前活动的 |locale|。
参见 |:language|。这里 LC_CTYPE 值很重要。

							*~*
~			'notildeop' 选项：切换光标下字符的大小写
			并将光标向右移动。
			如果给出 [count]，则对那么多字符执行操作。

~{motion}		'tildeop' 选项：切换 {motion} 文本的大小写。

							*g~*
g~{motion}		切换 {motion} 文本的大小写。

g~g~							*g~g~* *g~~*
g~~			切换当前行的大小写。

							*v_~*
{Visual}~		切换高亮文本的大小写（对于 {Visual} 参见
			|Visual-mode|）。

							*v_U*
{Visual}U		使高亮文本变为大写（对于 {Visual} 参见
			|Visual-mode|）。

							*gU* *uppercase*
gU{motion}		使 {motion} 文本变为大写。
			示例：>
				:map! <C-F> <Esc>gUiw`]a
<			这在插入模式中工作：按 CTRL-F 使光标前的
			单词变为大写。方便先以小写输入单词，然后
			使它们变为大写。

gUgU							*gUgU* *gUU*
gUU			使当前行变为大写。

							*v_u*
{Visual}u		使高亮文本变为小写（对于 {Visual} 参见
			|Visual-mode|）。

							*gu* *lowercase*
gu{motion}		使 {motion} 文本变为小写。

gugu							*gugu* *guu*
guu			使当前行变为小写。

							*g?* *rot13*
g?{motion}		对 {motion} 文本进行 Rot13 编码。

							*v_g?*
{Visual}g?		对高亮文本进行 Rot13 编码（对于 {Visual} 参见
			|Visual-mode|）。

g?g?							*g?g?* *g??*
g??			对当前行进行 Rot13 编码。

要将一行转换为标题大小写，使每个单词的第一个字母
变为大写：>
	:s/\v<(.)(\w*)/\u\1\L\2/g


加减 ~
							*CTRL-A*
CTRL-A			将 [count] 加到光标处或光标后的数字或字母字符。

                                                       *v_CTRL-A*
{Visual}CTRL-A		将 [count] 加到高亮文本中的数字或字母字符。

							*v_g_CTRL-A*
{Visual}g CTRL-A	将 [count] 加到高亮文本中的数字或字母字符。如果高亮了
			几行，每一行都会增加一个额外的 [count]（因此有效地
			创建一个 [count] 递增序列）。
			例如，如果您有这个数字列表：
				1. ~
				1. ~
				1. ~
				1. ~
			移动到第二个 "1." 并可视选择三行，按 g CTRL-A 结果：
				1. ~
				2. ~
				3. ~
				4. ~

							*CTRL-X*
CTRL-X			从光标处或光标后的数字或字母字符中减去 [count]。

							*v_CTRL-X*
{Visual}CTRL-X		从高亮文本中的数字或字母字符中减去 [count]。

							*v_g_CTRL-X*
{Visual}g CTRL-X	从高亮文本中的数字或字母字符中减去 [count]。如果高亮了
			几行，每个值都会减去一个额外的 [count]（因此有效地
			创建一个 [count] 递减序列）。

CTRL-A 和 CTRL-X 命令适用于（有符号）十进制数字、无符号
二进制/八进制/十六进制数字和字母字符。

这取决于 'nrformats' 选项：
- 当 'nrformats' 包含 "bin" 时，Vim 假设以 '0b' 或 '0B' 开头的数字是二进制。
- 当 'nrformats' 包含 "octal" 时，Vim 认为以 '0' 开头的数字是八进制，
  除非数字包含 '8' 或 '9'。其他数字是十进制，可能有前置负号。
  如果光标在数字上，命令应用于该数字；否则 Vim 使用光标右侧的数字。
- 当 'nrformats' 包含 "hex" 时，Vim 假设以 '0x' 或 '0X' 开头的数字是十六进制。
  数字中最右边字母的大小写决定了结果十六进制数字的大小写。如果当前数字中
  没有字母，Vim 使用之前检测到的大小写。
- 当 'nrformats' 包含 "alpha" 时，Vim 将更改光标下或光标后的字母字符。
  这对于制作带有字母索引的列表很有用。

对于十进制，前置负号在递增或递减时会被考虑，对于二进制、八进制和十六进制值，
它不会被考虑。要在使用 CTRL-A 或 CTRL-X 之前忽略符号，请可视选择数字。

对于有前导零的数字（包括所有八进制和十六进制数字），Vim 在可能时保留数字中
的字符数。对 "0077" 使用 CTRL-A 结果为 "0100"，对 "0x100" 使用 CTRL-X 结果为 "0x0ff"。
有一个例外：当发现以零开头的数字不是八进制（它包含 '8' 或 '9'），但 'nrformats'
确实包含 "octal" 时，会移除前导零以避免结果可能被识别为八进制数字。

注意，当 'nrformats' 包含 "octal" 时，有前导零的十进制数字会导致错误，
因为它们可能与八进制数字混淆。

类似地，当 'nrformats' 同时包含 "bin" 和 "hex" 时，有前导 '0x' 或 '0X' 的二进制数字
可能被解释为十六进制而不是二进制，因为 '0b' 是有效的十六进制数字。对 "0x0b11" 使用
CTRL-A 结果为 "0x0b12"，而不是 "0x0b100"。
当 'nrformats' 包含 "bin" 但不包含 "hex" 时，对 "0x0b11" 中的 "0b11" 使用 CTRL-A 结果为 "0x0b100"。

当光标下的数字太大而无法放入 64 位时，它将被舍入到可以表示的最接近数字，
并跳过加法/减法。例如，对 18446744073709551616 使用 CTRL-X 结果为 18446744073709551615。
对于更大的数字也是如此，如 18446744073709551618。

CTRL-A 命令在宏中非常有用。示例：使用以下步骤制作编号列表。

1. 创建第一个列表条目，确保它以数字开头。
2. qa	     - 开始录制到寄存器 'a'
3. Y	     - 复制条目
4. p	     - 在第一个条目下面放置一个副本
5. CTRL-A    - 增加数字
6. q	     - 停止录制
7. <count>@a - 重复复制、放置和增加 <count> 次


向左或向右移动行				*shift-left-right*

							*<*
 <{motion}		将 {motion} 行向左移动一个 'shiftwidth'。

			如果 'shiftwidth' 选项设置为零，缩进量
			在行中第一个非空白字符处计算。
							*<<*
 <<			将 [count] 行向左移动一个 'shiftwidth'。

							*v_<*
{Visual}[count]<	将高亮的行向左移动 [count] 个 'shiftwidth'
			（对于 {Visual} 参见 |Visual-mode|）。

							*>*
 >{motion}		将 {motion} 行向右移动一个 'shiftwidth'。

			如果 'shiftwidth' 选项设置为零，缩进量
			在行中第一个非空白字符处计算。
							*>>*
 >>			将 [count] 行向右移动一个 'shiftwidth'。

							*v_>*
{Visual}[count]>	将高亮的行向右移动 [count] 个 'shiftwidth'
			（对于 {Visual} 参见 |Visual-mode|）。

							*:<*
:[range]<		将 [range] 行向左移动一个 'shiftwidth'。重复 '<'
			以移动多个 'shiftwidth'。

:[range]< {count}	将 {count} 行向左移动一个 'shiftwidth'，从 [range] 开始
			（默认当前行 |cmdline-ranges|）。
			重复 '<' 以移动多个 'shiftwidth'。

:[range]le[ft] [indent]	左对齐 [range] 中的行。将行中的缩进设置为 [indent]
			（默认 0）。

							*:>*
:[range]> [flags]	将 [range] 行向右移动一个 'shiftwidth'。
			重复 '>' 以移动多个 'shiftwidth'。
			参见 |ex-flags| 了解 [flags]。

:[range]> {count} [flags]
			将 {count} 行向右移动一个 'shiftwidth'，从 [range] 开始
			（默认当前行 |cmdline-ranges|）。
			重复 '>' 以移动多个 'shiftwidth'。
			参见 |ex-flags| 了解 [flags]。

">" 和 "<" 命令对于更改程序中的缩进很有用。使用 'shiftwidth' 选项
设置这些命令插入或删除的空白大小。通常 'shiftwidth' 选项是 8，
但您可以将其设置为，比如 3，以制作更小的缩进。向左移动在
没有缩进时停止。向右移动不影响空行。

如果 'shiftround' 选项开启，缩进会四舍五入到 'shiftwidth' 的倍数。

如果 'smartindent' 选项开启，或 'cindent' 开启且 'cinkeys' 包含值为零的 '#'，
向右移动不影响以 '#' 开头的行（这些应该是必须保持在第 1 列的 C 预处理器行）。
这可以用 'cino' 选项更改，参见 |cino-#|。

当 'expandtab' 选项关闭时（这是默认值）Vim 尽可能使用 <Tab> 来制作缩进。
您可以使用 ">><<" 将用空格制作的缩进替换为用 <Tab> 制作的相同缩进
（如果需要，还有几个空格）。如果 'expandtab' 选项开启，Vim 只使用空格。
然后您可以使用 ">><<" 将缩进中的 <Tab> 替换为空格（或使用 `:retab!`）。

要移动一行几个 'shiftwidth'，使用可视模式或 `:` 命令。
例如：>
	Vjj4>		将三行向右移动 4 个缩进
	:<<<		将当前行向左移动 3 个缩进
	:>> 5		将 5 行向右移动 2 个缩进
	:5>>		将第 5 行向右移动 2 个缩进

==============================================================================
4. 复杂更改					*complex-change*

4.1 过滤器命令					*filter*

过滤器是一个程序，它接受标准输入的文本，以某种方式更改它，
然后将其发送到标准输出。您可以使用下面的命令通过过滤器发送
一些文本，以便它被过滤器输出替换。过滤器的例子有 "sort"，
它按字母顺序排序行，和 "indent"，它格式化 C 程序文件（您需要
一个像过滤器一样工作的 indent 版本；不是所有版本都这样做）。
'shell' 选项指定 Vim 用来执行过滤器命令的 shell。您可以用 "."
重复过滤器命令。Vim 不识别 `:!` 命令后的注释（以 '"' 开头）。

							*!*
!{motion}{filter}	通过外部程序 {filter} 过滤 {motion} 文本行。

							*!!*
!!{filter}		通过外部程序 {filter} 过滤 [count] 行。

							*v_!*
{Visual}!{filter}	通过外部程序 {filter} 过滤高亮的行
			（对于 {Visual} 参见 |Visual-mode|）。

:{range}![!]{filter} [!][arg]				*:range!*
			对于执行外部命令参见 |:!|

			通过外部程序 {filter} 过滤 {range} 行。
			Vim 用最新给定的命令替换可选的感叹号并附加
			可选的 [arg]。Vim 将过滤器命令的输出保存在
			临时文件中，然后将文件读入缓冲区 |tempfile|。
			Vim 使用 'shellredir' 选项将过滤器输出重定向到
			临时文件。但是，如果 'shelltemp' 选项关闭，则在
			可能时使用管道（在 Unix 上）。
			当 'cpoptions' 中包含 'R' 标志时，过滤行中的标记
			被删除，除非使用 |:keepmarks| 命令。示例：>
				:keepmarks '<,'>!sort
<			当过滤后的行数少于之前时，缺失行中的标记无论如何
			都会被删除。

							*=*
={motion}		通过 'equalprg' 选项给定的外部程序过滤 {motion} 行。
			当 'equalprg' 选项为空时（这是默认值），使用
			内部格式化函数 |C-indenting| 和 'lisp'。
			但是当 'indentexpr' 不为空时，将使用它
			代替 |indent-expression|。

							*==*
==			像 ={motion} 一样过滤 [count] 行。

							*v_=*
{Visual}=		像 ={motion} 一样过滤高亮的行。


						*tempdir* *tempfile* *setuid*
Nvim 使用临时文件进行过滤和生成差异。插件也常用 |tempname()| 用于
自己的目的。在第一次请求临时文件时，Nvim 创建一个公共目录（"Nvim tempdir"），
作为当前会话中所有临时文件（包括 `stdpath("run")` 文件 |$XDG_RUNTIME_DIR|）
的存储。

Nvim tempdir 在第一个可用的系统 tempdir 中创建：
	Unix:    $TMPDIR, /tmp, current-dir, $HOME.
	Windows: $TMPDIR, $TMP, $TEMP, $USERPROFILE, current-dir.

在 unix 上，tempdir 以权限 0700 创建（仅当前用户可访问）以避免安全问题
（例如符号链接攻击）。退出时，Nvim 删除 tempdir 及其内容。
							*E5431*
如果您看到错误或 |log| 消息如：>
	E5431: tempdir disappeared (2 times)
这意味着您系统上的外部进程删除了 Nvim tempdir。
通常这是由"防病毒软件"或配置错误的清理服务引起的。

如果 Nvim 设置了 setuid 位，这可能会导致问题：临时文件
由 setuid 用户拥有，但过滤器命令可能以原始用户身份运行。


4.2 替换						*:substitute*
							*:s* *:su*
:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]
			对于 [range] 中的每一行，用 {string} 替换 {pattern} 的匹配。
			对于 {pattern} 参见 |pattern|。
			{string} 可以是字面字符串，或特殊的东西；
			参见 |sub-replace-special|。
			当省略 [range] 和 [count] 时，仅在当前行中替换。
			当给出 [count] 时，在 [count] 行中替换，从 [range] 中的
			最后一行开始。当省略 [range] 时从当前行开始。
							*E939* *E1510*
			[count] 必须是正数（最大 2147483647）
			另见 |cmdline-ranges|。

			参见 |:s_flags| 了解 [flags]。
			分隔符不必是 /，参见 |pattern-delimiter|。

:[range]s[ubstitute] [flags] [count]
:[range]&[&][flags] [count]					*:&*
			重复上次 :substitute，使用相同的搜索模式和
			替换字符串，但没有相同的标志。您可以添加 [flags]，
			参见 |:s_flags|。
			注意，在 `:substitute` 后不能使用 '&' 和 '#' 标志，
			它们被识别为模式分隔符。
			`:substitute` 和 'c'、'g'、'i'、'I' 和 'r' 标志之间的
			空格不是必需的，但在脚本中保持它是一个好主意，以避免混淆。
			另见下面的两字母和三字母命令来重复 :substitute |:substitute-repeat|。

:[range]~[&][flags] [count]					*:~*
			重复上次替换，使用相同的替换字符串但使用上次使用的
			搜索模式。这就像 `:&r`。参见 |:s_flags| 了解 [flags]。

								*&*
&			`:s` 的同义词（重复上次替换）。注意标志不被记住，
			因此它可能实际上工作方式不同。您可以使用 `:&&` 来保持标志。

								*&-default*
			默认映射为 ":&&<CR>"。|default-mappings|

								*g&*
g&			`:%s//~/&` 的同义词（在所有行上使用上次搜索模式重复
			上次替换，使用相同的标志）。
			例如，当您首先用 `:s/pattern/repl/flags` 进行替换，
			然后用 `/search` 搜索其他内容时，`g&` 将执行 `:%s/search/repl/flags`。
			助记符：全局替换。

						*:snomagic* *:sno*
:[range]sno[magic] ...	与 `:substitute` 相同，但始终使用 'nomagic'。

						*:smagic* *:sm*
:[range]sm[agic] ...	与 `:substitute` 相同，但始终使用 'magic'。

							*:s_flags*
您可以为替换命令使用的标志：

							*:&&*
[&]	必须是第一个：保持上次替换命令的标志。示例：>
		:&&
		:s/this/that/&
<	注意 `:s` 和 `:&` 不保持标志。

[c]	确认每次替换。Vim 高亮匹配的字符串（使用 |hl-IncSearch|）。
	您可以输入：				*:s_c*
	    'y'	    替换此匹配
	    'l'	    替换此匹配然后退出（"last"）
	    'n'	    跳过此匹配
	    <Esc>   退出替换
	    'a'	    替换此匹配和所有剩余匹配
	    'q'	    退出替换
	    CTRL-E  向上滚动屏幕
	    CTRL-Y  向下滚动屏幕

							*:s_e*
[e]     当搜索模式失败时，不发出错误消息，特别是，在映射中继续，
	就像没有发生错误一样。这对于防止 "No match" 错误破坏映射
	最有用。但是，Vim 不抑制以下错误消息：
		正则表达式不能用字母分隔
		\ 后面应该跟 /、? 或 &
		没有先前的替换正则表达式
		尾随字符
		中断

							*:s_g*
[g]	替换行中的所有出现。没有此参数时，替换仅在每行中
	的第一次出现时发生。如果 'gdefault' 选项开启，此标志
	默认开启，[g] 参数将其关闭。

							*:s_i*
[i]	忽略模式的大小写。不使用 'ignorecase' 和 'smartcase' 选项。

							*:s_I*
[I]	不忽略模式的大小写。不使用 'ignorecase' 和 'smartcase' 选项。

							*:s_n*
[n]	报告匹配数量，不实际替换。[c] 标志被忽略。匹配报告
	就像 'report' 为零一样。对于 |count-items| 有用。
	如果使用 \= |sub-replace-expression|，表达式将在 |sandbox| 中
	在每个匹配处求值。

[p]	打印包含上次替换的行。*:s_p*

[#]	像 [p] 一样并前置行号。*:s_#*

[l]	像 [p] 一样但像 |:list| 一样打印文本。*:s_l*

							*:s_r*
[r]	仅在与 `:&` 或没有参数的 `:s` 结合使用时有用。`:&r`
	工作方式与 `:~` 相同：当搜索模式为空时，使用之前使用的
	搜索模式，而不是来自上次替换或 `:global` 的搜索模式。
	如果执行搜索的最后命令是替换或 `:global`，则没有效果。
	如果最后命令是搜索命令如 "/"，使用该命令的模式。
	对于有参数的 `:s` 这已经发生：>
		:s/blue/red/
		/green
		:s//red/   or  :~   or  :&r
<	最后命令将用 "red" 替换 "green"。>
		:s/blue/red/
		/green
		:&
<	最后命令将用 "red" 替换 "blue"。

注意没有标志来更改模式的"魔法性"。使用不同的命令代替，
或者您可以使用 |/\v| 和朋友。原因是可以只能通过跳过模式
来找到标志，而为了跳过模式必须知道"魔法性"。第22条军规！

如果替换命令的 {pattern} 为空，命令使用来自上次替换或 `:global` 命令的模式。
如果没有，但有先前的搜索模式，则使用那个。使用 [r] 标志时，命令使用
来自上次替换、`:global` 或搜索命令的模式。

如果省略 {string}，替换就像它是空的一样完成。因此匹配的模式被删除。
{pattern} 后的分隔符也可以省略。示例：>
	:%s/TESTING
这从所有行中删除 "TESTING"，但每行只删除一个。

为了与 Vi 兼容，允许这两个例外：
"\/{string}/" 和 "\?{string}?" 与 "//{string}/r" 相同。
"\&{string}&" 与 "//{string}/" 相同。
						*pattern-delimiter* *E146*
您可以使用另一个单字节字符代替包围模式和替换字符串的 '/'。
如果您想在搜索模式或替换字符串中包含 '/'，这很有用。示例：>
	:s+/+//+

您可以使用大多数字符，但不能使用字母数字字符、'\'、'"' 或 '|'。

对于模式的定义，参见 |pattern|。在可视块模式中，在模式中使用 |/\%V|
以使替换仅在块中工作。否则它无论如何都在整行上工作。

					*sub-replace-special* *:s\=*
当 {string} 以 "\=" 开头时，它被解释为表达式，参见 |sub-replace-expression|。
您可以使用它进行复杂替换或特殊字符。

替换在递归中限制为 4 级。*E1290*

否则 {string} 中的这些字符有特殊含义：

magic	nomagic	  动作    ~
  &	  \&	  用整个匹配的模式替换	     *s/\&*
 \&	   &	  用 & 替换
      \0	  用整个匹配的模式替换	   *\0* *s/\0*
      \1	  用第一对 () 中匹配的模式替换	     *s/\1*
      \2	  用第二对 () 中匹配的模式替换	     *s/\2*
      ..	  ..						     *s/\3*
      \9	  用第九对 () 中匹配的模式替换	     *s/\9*
  ~	  \~	  用上次替换的 {string} 替换	     *s~*
 \~	   ~	  用 ~ 替换				     *s/\~*
      \u	  下一个字符变为大写			     *s/\u*
      \U	  以下字符变为大写，直到 \E      *s/\U*
      \l	  下一个字符变为小写			     *s/\l*
      \L	  以下字符变为小写，直到 \E      *s/\L*
      \e	  \u、\U、\l 和 \L 的结束（注意：不是 <Esc>！）     *s/\e*
      \E	  \u、\U、\l 和 \L 的结束			     *s/\E*
      <CR>	  在此点将行分成两行
		  （将 <CR> 作为 CTRL-V <Enter> 输入）     *s<CR>*
      \r	  同上						     *s/\r*
      \<CR>	  插入回车符（CTRL-M）
		  （将 <CR> 作为 CTRL-V <Enter> 输入）     *s/\<CR>*
      \n	  插入 <NL>（文件中的 <NUL>）
		  （不换行）			     *s/\n*
      \b	  插入 <BS>					     *s/\b*
      \t	  插入 <Tab>				     *s/\t*
      \\	  插入单个反斜杠			     *s/\\*
      \x	  其中 x 是上面未提到的任何字符：
		  保留供将来扩展

特殊含义也在 |substitute()| 函数的第三个参数 {sub} 中使用，
但有以下例外：
  - % 不考虑 'cpoptions' 字面插入百分号。
  - magic 总是设置，不考虑 'magic'。
  - ~ 字面插入波浪号。
  - <CR> 和 \r 插入回车符（CTRL-M）。
  - \<CR> 没有特殊含义。它只是 \x 之一。

示例：>
  :s/a\|b/xxx\0xxx/g		 将 "a b" 修改为 "xxxaxxx xxxbxxx"
  :s/\([abc]\)\([efg]\)/\2\1/g	 将 "af fa bg" 修改为 "fa fa gb"
  :s/abcde/abc^Mde/		 将 "abcde" 修改为 "abc", "de"（两行）
  :s/$/\^M/			 将 "abcde" 修改为 "abcde^M"
  :s/\w\+/\u\0/g		 将 "bla bla" 修改为 "Bla Bla"
  :s/\w\+/\L\u\0/g		 将 "BLA bla" 修改为 "Bla Bla"

注意："\L\u" 可用于将单词的第一个字母大写。这与 Vi 和较旧版本的 Vim 不兼容，
其中 "\u" 会抵消 "\L"。"\U\l" 也是如此。

注意：在以前的版本中，CTRL-V 以特殊方式处理。由于这与 Vi 不兼容，
这被移除了。使用反斜杠代替。

command		text	result ~
:s/aa/a^Ma/	aa	a<line-break>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<line-break>a

（您需要输入 CTRL-V <CR> 来获得这里的 ^M）

"\1"、"\2" 等的编号基于模式中哪个 "\(" 首先出现（从左到右）。
当括号组匹配几次时，最后一个将用于 "\1"、"\2" 等。示例：>
  :s/\(\(a[a-d] \)*\)/\2/      将 "aa ab x" 修改为 "ab x"
"\2" 用于 "\(a[a-d] \)"。首先它匹配 "aa "，其次 "ab "。

当在括号组合中使用 '|' 时，如 \([ab]\)\|\([cd]\)，
括号中的第一个或第二个模式没有匹配，所以 \1 或 \2 为空。示例：>
  :s/\([ab]\)\|\([cd]\)/\1x/g   将 "a b c d" 修改为 "ax bx x x"
<

		*:sc* *:sce* *:scg* *:sci* *:scI* *:scl* *:scp* *:sg* *:sgc*
		*:sge* *:sgi* *:sgI* *:sgl* *:sgn* *:sgp* *:sgr* *:sI* *:si*
		*:sic* *:sIc* *:sie* *:sIe* *:sIg* *:sIl* *:sin* *:sIn* *:sIp*
		*:sip* *:sIr* *:sir* *:sr* *:src* *:srg* *:sri* *:srI* *:srl*
		*:srn* *:srp* *:substitute-repeat*
两字母和三字母 :substitute 命令 ~

这些命令用给定的标志重复先前的 `:substitute` 命令。
第一个字母总是 "s"，后跟一个或两个可能的标志字符。
例如 `:sce` 工作方式像 `:s///ce`。表格列出了可能的组合，
不是所有标志都可能的，因为命令是另一个命令的缩写。

     :substitute 命令列表
     |      c    e    g    i    I    n    p    l    r
     | c  :sc  :sce :scg :sci :scI :scn :scp :scl
     | e
     | g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
     | i  :sic :sie      :si  :siI :sin :sip      :sir
     | I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
     | n
     | p
     | l
     | r  :src      :srg :sri :srI :srn :srp :srl :sr

例外：
     :scr  是  `:scriptnames`
     :se   是  `:set`
     :sig  是  `:sign`
     :sil  是  `:silent`
     :sn   是  `:snext`
     :sp   是  `:split`
     :sl   是  `:sleep`
     :sre  是  `:srewind`


用表达式替换			*sub-replace-expression*
						*sub-replace-\=* *s/\=*
当替换字符串以 "\=" 开头时，其余部分被解释为表达式。

|sub-replace-special| 中提到的字符的特殊含义不适用，除了 "<CR>"。
<NL> 字符用作换行符，您可以用双引号字符串获得一个："\n"。
前置反斜杠以获得真正的 <NL> 字符（在文件中将是 NUL）。

"\=" 符号也可以在 |substitute()| 函数的第三个参数 {sub} 中使用。在这种情况下，|sub-replace-special| 中提到的字符特殊含义完全不适用。特别是，<CR> 和
<NL> 不会被解释为换行符，而是分别被解释为回车符和换行符。

当结果为 |List| 时，各个项目之间会以换行符连接起来。因此，每个项目都成为一行，但它们本身可以包含换行符。


|submatch()| 函数可用于获取匹配的文本。整个
匹配的文本可以用 "submatch(0)" 访问。第一对 () 中
匹配的文本用 "submatch(1)" 访问。对于 () 中的进一步子匹配也是如此。

小心：分隔字符不能出现在表达式中！
考虑使用像 "@" 或 ":" 这样的字符。如果表达式结果包含分隔字符没有问题。

示例：>
	:s@\n@\="\r" .. expand("$HOME") .. "\r"@
这用包含 $HOME 值的新行替换行尾。>

	s/E/\="\<Char-0x20ac>"/g
这用欧元符号替换每个 'E' 字符。在 |<Char->| 中了解更多。


4.3 更改制表符					*change-tabs*
							*:ret* *:retab* *:retab!*
:[range]ret[ab][!] [-indentonly] [{new-tabstop}]
			用使用 {new-tabstop} 的新空白字符串替换所有包含
			<Tab> 的空白序列。如果您不指定 {new-tabstop} 或
			它为零，Vim 使用 'tabstop' 的当前值。
			'tabstop' 的当前值总是用于计算现有制表符的宽度。
			使用 !，Vim 还在适当的地方用制表符替换仅包含普通
			空格的字符串。
			当 'expandtab' 开启时，Vim 用适当数量的空格替换所有制表符。
			此命令将 'tabstop' 设置为 {new-tabstop}，如果在整个文件上执行
			（这是默认值），应该不会产生任何可见的更改。

			当指定 [-indentonly] 时，只有前导空白会被目标化。
			任何其他连续的空白不会被更改。

			警告：此命令修改 C 程序中字符串内的任何 <Tab> 字符。
			使用 "\t" 避免这种情况（这无论如何都是好习惯）。
			`:retab!` 也可能用 <Tab> 字符更改空格序列，这可能会搞乱 printf()。
			可以用逗号分隔的制表符宽度列表代替单个 tabstop。
			列表中的每个值代表一个 tabstop 的宽度，除了适用于所有后续 tabstop 的最终值。

							*retab-example*
使用自动命令和 ":retab" 编辑以 tabstop 为 8 存储但以 tabstop 设置为 4 编辑的文件的示例。
警告：字符串内的空白可能会改变！另见 'softtabstop' 选项。>

  :auto BufReadPost	*.xx	retab! 4
  :auto BufWritePre	*.xx	retab! 8
  :auto BufWritePost	*.xx	retab! 4
  :auto BufNewFile	*.xx	set ts=4

==============================================================================
5. 复制和移动文本				*copy-move*

							*quote*
"{register}		对下一个删除、复制或放置使用 {register}。使用
			大写字符以追加删除和复制。寄存器 "."、"%"、"#" 和 ":"
			仅与放置一起工作。

							*:reg* *:registers*
:reg[isters]		显示所有编号和命名寄存器的类型和内容。如果寄存器
			为 |:redir| 写入，它将不会被列出。
			类型可以是以下之一：
			"c"	用于 |characterwise| 文本
			"l"	用于 |linewise| 文本
			"b"	用于 |blockwise-visual| 文本


:reg[isters] {arg}	显示 {arg} 中提到的编号和命名寄存器的内容。
			例如：>
				:reg 1a
<			显示寄存器 '1' 和 'a'。{arg} 中允许空格。

							*:di* *:dis* *:display*
:di[splay] [arg]	与 :registers 相同。

							*y* *yank*
["x]y{motion}		复制 {motion} 文本 [到寄存器 x]。当没有
			字符要复制时（例如，在第 1 列的 "y0"），
			当 'cpoptions' 包含 'E' 标志时这是错误。

							*yy*
["x]yy			复制 [count] 行 [到寄存器 x] |linewise|。

							*Y*
["x]Y			复制 [count] 行 [到寄存器 x]（yy 的同义词，
			|linewise|）。
							*Y-default*
			默认映射为 "y$"。|default-mappings|

							*zy*
["x]zy{motion}		复制 {motion} 文本 [到寄存器 x]。仅在选择文本块时
			与 `y` 不同，参见 |v_zy|。

							*v_y*
{Visual}["x]y		复制高亮的文本 [到寄存器 x]（对于 {Visual} 参见
			|Visual-mode|）。

							*v_Y*
{Visual}["x]Y		复制高亮的行 [到寄存器 x]（对于 {Visual} 参见
			|Visual-mode|）。

							*v_zy*
{Visual}["x]zy		复制高亮的文本 [到寄存器 x]。选中块每行末尾的
			尾随空白不会被复制。特别有用的是与 `zp` 结合使用。
			（对于 {Visual} 参见 |Visual-mode|）

							*:y* *:yank* *E850*
:[range]y[ank] [x]	复制 [range] 行 [到寄存器 x]。

:[range]y[ank] [x] {count}
			复制 {count} 行，从 [range] 中的最后行号开始
			（默认：当前行 |cmdline-ranges|），[到寄存器 x]。

						*p* *put* *E353* *E1240*
["x]p			将文本 [从寄存器 x] 放在光标后 [count] 次。

							*P*
["x]P			将文本 [从寄存器 x] 放在光标前 [count] 次。

							*<MiddleMouse>*
["x]<MiddleMouse>	将文本从寄存器放在光标前 [count] 次。
			使用 "* 寄存器，除非指定了另一个。
			将光标留在新文本的末尾。
			仅当 'mouse' 包含 'n' 或 'a' 时使用鼠标才有效。
			如果您有滚轮并经常意外粘贴文本，您可以使用这些映射
			来禁用中键粘贴：>
				:map <MiddleMouse> <Nop>
				:imap <MiddleMouse> <Nop>
<			您可能还想禁用多击版本，参见 |double-click|。

							*gp*
["x]gp			就像 "p" 一样，但将光标留在新文本之后。

							*gP*
["x]gP			就像 "P" 一样，但将光标留在新文本之后。

							*:pu* *:put*
:[line]pu[t] [x]	将文本 [从寄存器 x] 放在 [line] 之后（默认
			当前行）。这总是以 |linewise| 方式工作，因此
			此命令可用于将复制的块作为新行放置。
			如果未指定寄存器，它取决于 'cb' 选项：
			如果 'cb' 包含 "unnamedplus"，从 + 寄存器粘贴 |quoteplus|。
			否则，如果 'cb' 包含 "unnamed"，从 * 寄存器粘贴 |quotestar|。
			否则，从无名寄存器粘贴 |quote_quote|。
			寄存器也可以是 '=' 后跟可选的表达式。表达式继续到
			命令结束。您需要转义 '|' 和 '"' 字符以防止它们
			终止命令。示例：>
				:put ='path' .. \",/test\"
<			如果 '=' 后没有表达式，Vim 使用先前的表达式。
			您可以用 ":dis =" 查看它。

:[line]pu[t]! [x]	将文本 [从寄存器 x] 放在 [line] 之前（默认
			当前行）。

							*:ip* *:iput*
:[line]ip[ut] [x]	像 |:put| 一样，但调整缩进到当前行

:[line]ip[ut]! [x]	像 |:put|! 一样，但调整缩进到当前行

["x]]p		    or					*]p* *]<MiddleMouse>*
["x]]<MiddleMouse>	像 "p" 一样，但调整缩进到当前行。
			仅当 'mouse' 包含 'n' 或 'a' 时使用鼠标才有效。

["x][P		    or					*[P*
["x]]P		    or					*]P*
["x][p		    or					*[p* *[<MiddleMouse>*
["x][<MiddleMouse>	像 "P" 一样，但调整缩进到当前行。
			仅当 'mouse' 包含 'n' 或 'a' 时使用鼠标才有效。

["x]zp		    or					*zp* *zP*
["x]zP			像 "p" 和 "P" 一样，但在粘贴块时不添加尾随空格。
			因此插入的文本不总是矩形。特别有用的是与 |v_zy| 结合使用。

您可以使用这些命令将文本从一个地方复制到另一个地方。通过首先使用复制、
删除或更改命令将文本放入寄存器，然后使用放置命令插入寄存器内容来做到这一点。
您也可以使用这些命令将文本从一个文件移动到另一个文件，因为 Vim 在更改缓冲区时
保留所有寄存器（CTRL-^ 命令是在两个文件之间切换的快速方法）。

				*linewise-register* *charwise-register*
您可以用 "." 重复放置命令（除了 :put）并撤销它们。如果用于将文本放入寄存器的
命令是 |linewise|，Vim 将文本插入到光标所在行之下（"p"）或之上（"P"）。
否则 Vim 将文本插入到光标之后（"p"）或之前（"P"）。使用 ":put" 命令时，
Vim 总是将文本插入到下一行。您可以用命令序列 "xp" 交换两个字符。
您可以用命令序列 "ddp" 交换两行。您可以用命令序列 "deep" 交换两个单词
（从第一个单词前的空白空间开始，光标在那里）。您可以在放置命令后使用 |']| 或 |`]|
命令将光标移动到插入文本的末尾，或使用 |'[| 或 |`[| 将光标移动到开头。

						*put-Visual-mode* *v_p* *v_P*
在可视模式中使用像 |p| 或 |P| 这样的放置命令时，Vim 将尝试用寄存器的内容
替换选中的文本。这工作得如何取决于选择的类型和寄存器中文本的类型。
对于块状选择，它还取决于块的大小以及角落是否在现有字符上。
（实现细节：它实际上是通过首先将寄存器放在选择之后然后删除选择来工作的。）
使用 |p| 时，先前选中的文本被放在无名寄存器中（可能还有选择和/或剪贴板）。
如果您想将该文本放在其他地方，这很有用。但您不能重复相同的更改。
使用 |P| 时，无名寄存器不会更改（选择和剪贴板也不会），您可以重复相同的更改。
但删除的文本不能使用。如果您确实需要它，可以使用带有另一个寄存器的 |p|。
例如，复制要复制的文本，可视选择要替换的文本并使用 "0p"。您可以重复
此操作任意多次，无名寄存器每次都会更改。
							*blockwise-put*
当寄存器包含来自一行的文本（字符方式）时，使用块状可视选择，放置该寄存器
将在每个选中的行中重复粘贴该文本，从而用寄存器文本的多个副本替换块状
选中区域。例如：
	- 用 `yw` 将单词 "TEXT" 复制到寄存器中
	- 选择可视块，在此文本中用 "v" 标记：
	    aaavvaaa
	    bbbvvbbb
	    cccvvccc
	- 按 `p`，结果：
	    aaaTEXTaaa
	    bbbTEXTbbb
	    cccTEXTccc

							*blockwise-register*
如果您使用块状可视模式命令将文本放入寄存器，文本块将被插入到当前行和下一行的
光标列之前（"P"）或之后（"p"）。Vim 使整个文本块从同一列开始。
因此插入的文本看起来与复制或删除时相同。Vim 可能会用空格替换一些 <Tab> 字符
来实现这一点。但是，如果块的宽度不是 <Tab> 宽度的倍数，并且插入块后的文本
包含 <Tab>，该文本可能会错位。

使用 |zP|/|zp| 粘贴块状复制的寄存器而不添加尾随空格。

注意，在字符方式复制命令后，Vim 将光标留在最接近缓冲区开头的第一个复制字符上。
这意味着 "yl" 不移动光标，但 "yh" 将光标向左移动一个字符。
理由：在 Vi 中，后跟向后移动的 "y" 命令有时不会将光标移动到第一个复制的字符，
因为跳过了重新显示。在 Vim 中，它总是移动到第一个字符，如 Posix 所指定的。
对于行方式复制命令，光标被放在第一行，但列未修改，因此它可能不在第一个复制的字符上。

有十种类型的寄存器：		*registers* *{register}* *E354*
1. 无名寄存器 ""
2. 10 个编号寄存器 "0 到 "9
3. 小删除寄存器 "-
4. 26 个命名寄存器 "a 到 "z 或 "A 到 "Z
5. 三个只读寄存器 ":、"."、"%
6. 备用缓冲区寄存器 "#
7. 表达式寄存器 "=
8. 选择寄存器 "* 和 "+
9. 黑洞寄存器 "_
10. 最后搜索模式寄存器 "/

1. 无名寄存器 ""				*quote_quote* *quotequote*
Vim 用 "d"、"c"、"s"、"x" 命令删除的文本或复制命令 "y" 复制的文本
填充此寄存器，无论是否使用了特定寄存器（例如 "xdd）。这就像无名寄存器
指向最后使用的寄存器。因此，当使用大写寄存器名称追加时，无名寄存器包含
与命名寄存器相同的文本。例外是 '_' 寄存器："_dd 不将删除的文本存储在任何寄存器中。
Vim 将无名寄存器的内容用于任何未指定寄存器的放置命令（p 或 P）。
此外，您可以用名称 '"' 访问它。这意味着您必须输入两个双引号。
写入 "" 寄存器就是写入寄存器 "0。

2. 编号寄存器 "0 到 "9		*quote_number* *quote0* *quote1*
					*quote2* *quote3* *quote4* *quote9*
Vim 用复制和删除命令的文本填充这些寄存器。
   编号寄存器 0 包含来自最近复制命令的文本，除非命令用 ["x] 指定了另一个寄存器。
   编号寄存器 1 包含最近删除或更改命令删除的文本（即使命令指定了另一个寄存器），
   除非文本少于一行（然后使用小删除寄存器）。对于这些移动命令的删除操作符有例外：
   |%|、|(|、|)|、|`|、|/|、|?|、|n|、|N|、|{| 和 |}|。
   然后总是使用寄存器 "1（这与 Vi 兼容）。如果删除在一行内，也使用 "- 寄存器。
   注意这些字符可能被映射。例如 |%| 被 matchit 插件映射。
   随着每次连续的删除或更改，Vim 将寄存器 1 的先前内容移到寄存器 2，
   2 移到 3，依此类推，丢失寄存器 9 的先前内容。
							*yankring*
要将复制（不仅是删除）也存储在寄存器 1-9 中，请尝试这个：>lua
    -- 复制环：将复制的文本存储在寄存器 1-9 中。
    vim.api.nvim_create_autocmd('TextYankPost', {
      callback = function()
        if vim.v.event.operator == 'y' then
          for i = 9, 1, -1 do -- 移动所有编号寄存器。
            vim.fn.setreg(tostring(i), vim.fn.getreg(tostring(i - 1)))
          end
        end
      end,
    })

3. 小删除寄存器 "-				*quote_-* *quote-*
此寄存器包含来自删除少于一行命令的文本，除非命令用 ["x] 指定了寄存器。

4. 命名寄存器 "a 到 "z 或 "A 到 "Z			*quote_alpha* *quotea*
Vim 仅在您说时才填充这些寄存器。将它们指定为小写字母以替换其先前内容，
或指定为大写字母以追加到其先前内容。当 'cpoptions' 中存在 '>' 标志时，
在追加的文本前插入换行符。

5. 只读寄存器 ":、"." 和 "%
这些是 '%'、':' 和 '.'。您只能将它们与 "p"、"P" 和 ":put" 命令以及 CTRL-R 一起使用。
						*quote_.* *quote.* *E29*
	".	包含最后插入的文本（与插入模式命令 CTRL-A 和 CTRL-@ 插入的相同）。
		注意：这在命令行上的 CTRL-R 中不起作用。它工作方式略有不同，
		就像插入文本而不是放置文本一样（'textwidth' 和其他选项影响插入的内容）。
							*quote_%* *quote%*
	"%	包含当前文件的名称。
						*quote_:* *quote:* *E30*
	":	包含最近执行的命令行。示例：使用 "@:" 重复先前的命令行命令。
		仅当至少输入了命令行的一个字符时，命令行才存储在此寄存器中。
		因此，如果命令完全来自映射，它保持不变。

							*quote_#* *quote#*
6. 备用文件寄存器 "#
包含当前窗口的备用文件名。它将改变 |CTRL-^| 命令的工作方式。
此寄存器是可写的，主要是为了允许在插件更改后恢复它。它接受缓冲区号：>
    let altbuf = bufnr(@#)
    ...
    let @# = altbuf
如果您传递缓冲区号而此缓冲区不存在，它将给出错误 |E86|。
它也可以接受与现有缓冲区名称的匹配：>
    let @# = 'buffer_name'
如果有多个缓冲区匹配给定名称，则错误 |E93|，如果没有缓冲区匹配给定名称，则错误 |E94|。

7. 表达式寄存器 "=			*quote_=* *quote=* *@=*
这不是真正存储文本的寄存器，而是在使用寄存器的命令中使用表达式的方法。
表达式寄存器是可读写的。

在 " 或 CTRL-R 后输入 '=' 时，光标移动到命令行，您可以在那里输入任何表达式
（参见 |expression|）。所有正常的命令行编辑命令都可用，包括表达式的特殊历史。
当您通过输入 <CR> 结束命令行时，Vim 计算表达式的结果。如果您用 <Esc> 结束它，
Vim 放弃表达式。如果您不输入表达式，Vim 使用先前的表达式（就像 "/" 命令一样）。

表达式必须求值为字符串。数字总是自动转换为字符串。对于 "p" 和 ":put" 命令，
如果结果是浮点数，它被转换为字符串。如果结果是列表，每个元素都被转换为字符串
并用作一行。字典被转换为字符串。函数引用导致错误消息（使用 string() 转换）。

如果 "= 寄存器用于 "p" 命令，字符串在 <NL> 字符处分割。如果字符串以 <NL> 结尾，
它被视为行方式寄存器。

8. 选择寄存器 "* 和 "+
使用这些寄存器存储和检索 GUI 的选中文本。参见 |quotestar| 和 |quoteplus|。
当剪贴板不可用或不工作时，使用无名寄存器代替。对于 Unix 系统和 Mac OS X，
参见 |primary-selection|。

9. 黑洞寄存器 "_				*quote_*
当写入此寄存器时，什么都不会发生。这可用于删除文本而不影响正常寄存器。
当从此寄存器读取时，不返回任何内容。

10. 最后搜索模式寄存器	"/		*quote_/* *quote/*
包含最近的搜索模式。这用于 "n" 和 'hlsearch'。
它可以用 `:let` 写入，您可以更改它以让 'hlsearch' 高亮其他匹配而不实际搜索。
您不能复制或删除到此寄存器。搜索方向在 |v:searchforward| 中可用。
注意，从函数返回时值会恢复 |function-search-undo|。

							*@/*
您可以用 `:let` 命令写入寄存器 |:let-@|。示例：>
	:let @/ = "the"

如果您使用放置命令而不指定寄存器，Vim 使用最后填充的寄存器
（这也是无名寄存器的内容）。如果您感到困惑，请使用 `:dis` 命令
来找出 Vim 将放置什么（此命令显示所有命名和编号寄存器；无名寄存器
标记为 '"'）。

接下来的三个命令总是对整个行工作。

:[range]co[py] {address}				*:co* *:copy*
			将 [range] 给定的行复制到 {address} 给定的行之下。

							*:t*
:t			复制的同义词。

:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			将 [range] 给定的行移动到 {address} 给定的行之下。

==============================================================================
6. 格式化文本					*formatting*

:[range]ce[nter] [width]				*:ce* *:center*
			在 [width] 列之间居中 [range] 中的行
			（默认 'textwidth' 或当 'textwidth' 为 0 时为 80）。

:[range]ri[ght] [width]					*:ri* *:right*
			在 [width] 列处右对齐 [range] 中的行
			（默认 'textwidth' 或当 'textwidth' 为 0 时为 80）。

							*:le* *:left*
:[range]le[ft] [indent]
			左对齐 [range] 中的行。将行中的缩进设置为 [indent]
			（默认 0）。

							*gq*
gq{motion}		格式化 {motion} 移动过的行。
			格式化使用三种方法之一：
			1. 如果 'formatexpr' 不为空，则求值表达式。
			   这对每个缓冲区可能不同。
			2. 如果 'formatprg' 不为空，则使用外部程序。
			3. 否则在内部进行格式化。

			在第三种情况下，'textwidth' 选项控制每个格式化行的
			长度（见下文）。
			如果 'textwidth' 选项为 0，格式化行长度是屏幕宽度
			（最大宽度为 79）。
			'formatoptions' 选项控制格式化类型 |fo-table|。
			光标留在最后格式化行的第一个非空白处。
			注意："Q" 命令以前执行此功能。如果您仍想使用 "Q" 进行
			格式化，请使用此映射：>
				:nnoremap Q gq

gqgq							*gqgq* *gqq*
gqq			格式化当前行。使用计数格式化那么多行。

							*v_gq*
{Visual}gq		格式化高亮的文本。（对于 {Visual} 参见
			|Visual-mode|）。

							*gw*
gw{motion}		格式化 {motion} 移动过的行。类似于 |gq| 但将光标
			放回文本中的相同位置。但是，不使用 'formatprg' 和 'formatexpr'。

gwgw							*gwgw* *gww*
gww			像 "gw" 一样格式化当前行。

							*v_gw*
{Visual}gw		像 "gw" 一样格式化高亮的文本。（对于 {Visual} 参见
			|Visual-mode|）。

示例：要格式化当前段落，请使用：			*gqap*  >
	gqap

"gq" 命令将光标留在移动命令将光标带到的行中。这允许您用 "." 重复格式化。
这与 "gqj"（格式化当前行和下一行）和 "gq}"（格式化直到段落末尾）配合得很好。
注意：当设置 'formatprg' 时，"gq" 将光标留在第一个格式化行上（就像使用过滤器命令一样）。

如果您想格式化当前段落并继续您所在的位置，请使用：>
	gwap
如果您总是想保持段落格式化，您可能想要将 'a' 标志添加到 'formatoptions'。
参见 |auto-format|。

如果 'autoindent' 选项开启，Vim 使用第一行的缩进作为后续行。

格式化不更改空行（但它确实更改只有空白的行！）。

当行连接在一起时使用 'joinspaces' 选项。

您可以将 'formatexpr' 选项设置为表达式或将 'formatprg' 选项设置为外部程序的名称，
供 Vim 用于文本格式化。'textwidth' 和其他选项对外部程序的格式化没有影响。

                                                        *format-formatexpr*
'formatexpr' 选项可以设置为执行缓冲区重新格式化的 Vim 脚本函数。
这通常应该在 |ftplugin| 中发生，因为格式化高度依赖于文件类型。
使用 |autoload| 脚本是有意义的，因此相应的脚本仅在真正需要时加载，
脚本应该称为 <filetype>format.vim。

例如，Vim 在 $VIMRUNTIME/ftplugin 目录中分发的 XML 文件类型插件，
将 'formatexpr' 选项设置为：>

   setlocal formatexpr=xmlformat#Format()

这意味着，您将在文件 `$VIMRUNTIME/autoload/xmlformat.vim` 中找到
定义 xmlformat#Format() 函数的相应脚本

这是一个从选中文本中删除尾随空白的示例脚本。
将其放在您的 autoload 目录中，例如 ~/.vim/autoload/format.vim：
>vim
  func! format#Format()
    " 仅在显式 gq 命令时重新格式化
    if mode() != 'n'
      " 回退到 Vim 的内部重新格式化
      return 1
    endif
    let lines = getline(v:lnum, v:lnum + v:count - 1)
    call map(lines, {key, val -> substitute(val, '\s\+$', '', 'g')})
    call setline('.', lines)

    " 不运行内部格式化器！
    return 0
  endfunc

然后您可以通过执行以下命令启用格式化：>
  setlocal formatexpr=format#Format()

注意：当从插入模式调用时，此函数明确返回非零值
（这基本上意味着，文本插入超出了 'textwidth' 限制）。
这导致 Vim 回退到使用内部格式化器重新格式化文本。

但是，如果使用 |gq| 命令重新格式化文本，函数将接收选中的行，
从这些行中修剪尾随空白并将它们放回原位。如果您要将单行分割成多行，
请小心不要覆盖任何内容。

如果您想允许从插入或替换模式重新格式化文本，必须非常小心，
因为函数可能会被递归调用。对于调试，设置 'debug' 选项会有所帮助。

							*right-justify*
Vim 中没有右对齐文本的命令。您可以使用外部命令来做到这一点，
比如 "par"（例如：`:.,}!par` 格式化直到段落末尾）或将 'formatprg' 设置为 "par"。

							*format-comments*
注释格式化的概述在用户手册的 |30.6| 节中。

Vim 可以以特殊方式自动插入和格式化注释。Vim 通过行开头的特定字符串
（忽略空白）识别注释。可以使用三种类型的注释：

- 在每行开头重复的注释字符串。一个例子是 shell 脚本中使用的注释类型，
  以 "#" 开头。
- 仅在第一行出现，不在后续行中的注释字符串。一个例子是这个带破折号的列表。
- 三部分注释，有开始字符串、结束字符串和中间的可选行。
  开始、中间和结束的字符串是不同的。一个例子是 C 风格注释：>
	/*
	 * this is a C comment
	 */

'comments' 选项是逗号分隔的部分列表。每个部分定义一种类型的注释字符串。
一个部分由以下组成：
	{flags}:{string}

{string} 是必须出现的字面文本。

{flags}:
  n	嵌套注释。允许与混合部分嵌套。如果 'comments' 是 "n:),n:>"，
	以 "> ) >" 开头的行是注释。

  b	{string} 后需要空白（<Space>、<Tab> 或 <EOL>）。

  f	只有第一行有注释字符串。不在下一行重复注释，但保留缩进
	（例如，项目符号列表）。

  s	三部分注释的开始

  m	三部分注释的中间

  e	三部分注释的结束

  l	左对齐。与 's' 或 'e' 一起使用，开始或结束的最左边字符将与
	中间的最左边字符对齐。这是默认值，可以省略。详见下文。

  r	右对齐。与上面相同，但是最右边而不是最左边。详见下文。

  O	不考虑此注释用于 "O" 命令。

  x	允许三部分注释通过在新行上作为第一个动作键入结束注释字符串的
	最后一个字符来结束，当中间注释字符串已自动插入时。详见下文。

  {digits}
	与 's' 或 'e' 一起：为自动插入的中间或结束注释前导符添加 {digit} 量的偏移。
	偏移从左对齐开始。详见下文。

  -{digits}
	像 {digits} 但减少缩进。这仅在开始或结束部分有一些可以移除的缩进时有效。

当字符串没有 'f'、's'、'm' 或 'e' 标志时，Vim 假设注释字符串在每行开头重复。
{flags} 字段可能为空。

{string} 前后文本中的任何空白都是 {string} 的一部分，所以不要包含前导或尾随空白，
除非空白是注释字符串的必需部分。

当一个注释前导符是另一个的一部分时，在整体之后指定部分。
例如，要包含 "-" 和 "->"，请使用 >
	:set comments=f:->,f:-

三部分注释必须始终作为 start,middle,end 给出，中间没有其他部分。
三部分注释的示例是 >
	sr:/*,mb:*,ex:*/
用于 C 注释。为了避免将 "*ptr" 识别为注释，中间字符串包含 'b' 标志。
对于三部分注释，Vim 检查开始和中间字符串后的文本以查找结束字符串。
如果 Vim 找到结束字符串，注释不会在下一行继续。三部分注释必须有中间字符串，
因为否则 Vim 无法识别中间行。

注意上面三部分注释定义中 "x" 标志的使用。
当您在 C 注释中按 Return 时，Vim 将为新行插入中间注释前导符：" * "。
要关闭此注释，您只需在新行上键入任何其他内容之前键入 "/"。
这将用结束注释前导符替换中间注释前导符并应用任何指定的对齐，
只留下 `" */"`。无需先按 Backspace。

当有与中间部分匹配时，但也有更长的匹配结束部分，则使用结束部分。
这使得 C 风格注释工作而不需要中间部分以空格结尾。

这是对齐标志工作的示例，使注释突出（看起来也像 1）。
考虑注释字符串：>vim
	:set comments=sr:/***,m:**,ex-2:******/
>
                                   /*** ~
                                     **<--从 "r" 标志右对齐 ~
                                     ** ~
 为 "-2" 标志偏移 2 个空格-->** ~
                                   ******/ ~
在这种情况下，首先输入第一个注释，然后按 return 4 次，
然后按 "/" 结束注释。

这里是三部分注释的一些更精细的点。有三个时候考虑对齐和偏移标志：
在开始注释后打开新行，在结束注释前打开新行，以及自动结束三部分注释。
结束对齐标志有向后的视角；结果是，与 "s" 和 "e" 一起使用的相同对齐标志
将导致开始和结束部分具有相同的缩进。每个注释部分只打算使用一个对齐，
但偏移数字将覆盖 "r" 和 "l" 标志。

启用 'cindent' 在许多情况下会覆盖对齐标志。
使用不同方法重新缩进如 |gq| 或 |=| 也不会咨询对齐标志。
相同的行为可以在那些其他格式化选项中定义。一个考虑是 'cindent' 有额外的选项
用于基于上下文的注释缩进，但无法复制许多三部分缩进对齐。
但是，'indentexpr' 有能力更好地处理三部分注释。

其他示例：>
   "b:*"	包括以 "*" 开头的行，但如果 "*" 后跟非空白则不包括。
		这避免了像 "*str" 这样的指针解引用被识别为注释。
   "n:>"	包括以 ">"、">>"、">>>" 等开头的行。
   "fb:-"	格式化以 "- " 开头的列表。

默认情况下，包含 "b:#"。这意味着以 "#include" 开头的行不被识别为注释行。
但以 "# define" 开头的行被识别。这是一个折衷。

							*fo-table*
您可以使用 'formatoptions' 选项来影响 Vim 如何格式化文本。
'formatoptions' 是一个可以包含下面任何字母的字符串。您可以用逗号分隔选项字母以提高可读性。

letter	 在 'formatoptions' 中存在时的含义    ~
							*fo-t*
t	使用 'textwidth' 自动换行文本
							*fo-c*
c	使用 'textwidth' 自动换行注释，自动插入当前注释前导符。
							*fo-r*
r	在插入模式中按 <Enter> 后自动插入当前注释前导符。
							*fo-o*
o	在普通模式中按 'o' 或 'O' 后自动插入当前注释前导符。
	在特定地方不需要注释的情况下使用 CTRL-U 快速删除它。|i_CTRL-U|
							*fo-/*
/	当包含 'o' 时：不要在语句后的 // 注释后插入注释前导符，
	仅当 // 在行开头时。
							*fo-q*
q	允许用 "gq" 格式化注释。
	注意格式化不会更改空白行或仅包含注释前导符的行。
	新段落在这样的行之后开始，或当注释前导符更改时。
							*fo-w*
w	尾随空白表示段落在下一行继续。
	以非空白字符结尾的行结束段落。
							*fo-a*
a	段落的自动格式化。每次插入或删除文本时，段落将被重新格式化。
	参见 |auto-format|。当存在 'c' 标志时，这只发生在识别的注释中。
							*fo-n*
n	格式化文本时，识别编号列表。这实际上使用 'formatlistpat' 选项，
	因此可以使用任何类型的列表。数字后文本的缩进用于下一行。
	默认是找到一个数字，可选地后跟 '.'、':'、')'、']' 或 '}'。
	注意 'autoindent' 也必须设置。与 "2" 配合不好。
	示例：>
		1. the first item
		   wraps
		2. the second item
<							*fo-2*
2	格式化文本时，使用段落第二行的缩进作为段落的其余部分，
	而不是第一行的缩进。这支持第一行缩进与其余部分不同的段落。
	注意 'autoindent' 也必须设置。示例：>
			first line of a paragraph
		second line of the same paragraph
		third line.
<	这也适用于注释内部，忽略注释前导符。
							*fo-v*
v	插入模式中的 Vi 兼容自动换行：仅在当前插入命令期间您输入的空白处换行。
	（注意：这不是 100% Vi 兼容。Vi 在这个区域有一些"意外功能"或错误。
	它使用屏幕列而不是行列。）
							*fo-b*
b	像 'v'，但仅当您在换行边距处或之前输入空白时才自动换行。
	如果当您开始插入时行比 'textwidth' 长，或者您在到达 'textwidth' 之前
	在插入中没有输入空白，Vim 不执行自动换行。
							*fo-l*
l	在插入模式中不换行长行：当插入命令开始时行比 'textwidth' 长时，
	Vim 不自动格式化它。
							*fo-m*
m	也在 255 以上的多字节字符处换行。这对每个字符都是自己单词的亚洲文本很有用。
							*fo-M*
M	连接行时，不在多字节字符前后插入空格。覆盖 'B' 标志。
							*fo-B*
B	连接行时，不在两个多字节字符之间插入空格。被 'M' 标志覆盖。
							*fo-1*
1	不要在一个字母单词后换行。而是在它之前换行（如果可能）。
							*fo-]*
]	严格遵守 'textwidth'。设置此标志后，没有行可以比 'textwidth' 长，
	除非换行禁止规则使这不可能。主要用于 CJK 脚本，仅在 'encoding' 为 "utf-8" 时工作。
							*fo-j*
j	在合理的地方，连接行时移除注释前导符。例如，连接：
		int i;   // the index ~
			 // in the list ~
	变成：
		int i;   // the index in the list ~
							*fo-p*
p	不要在句号后的单个空格处换行。这旨在补充 'joinspaces' 和 |cpo-J|，
	用于句子用两个空格分隔的散文。例如，将 'textwidth' 设置为 28：>
		Surely you're joking, Mr. Feynman!
<	变成：>
		Surely you're joking,
		Mr. Feynman!
<	而不是：>
		Surely you're joking, Mr.
		Feynman!


使用 't' 和 'c' 您可以指定 Vim 何时执行自动换行：
value	action	~
""	无自动格式化（您可以使用 "gq" 进行手动格式化）
"t"	文本的自动格式化，但不是注释
"c"	注释的自动格式化，但不是文本（对 C 代码很好）
"tc"	文本和注释的自动格式化

注意，当 'textwidth' 为 0 时，Vim 无论如何都不进行自动格式化
（但确实根据 'comments' 选项插入注释前导符）。当存在 'a' 标志时是例外。|auto-format|

注意，即使 Vim 从不执行自动换行，'textwidth' 也可以非零；
'textwidth' 对于用 "gq" 格式化仍然有用。

如果 'comments' 选项包括 "/*"、"*" 和/或 "*/"，那么 Vim 有一些内置的东西
来更聪明地处理这些类型的注释。在 "/*" 或 "*/" 前后打开新行
（在 'formatoptions' 中存在 'r' 或 'o'）会自动给出行的正确开始。
格式化和自动换行也是如此。在包含 "*/" 的以 "/*" 或 "*" 开头的行后打开行，
将导致不插入注释前导符，新行的缩进取自包含注释开始的行。
例如：>
    /*
     * Your typical comment.
     */
    The indent on this line is the same as the start of the above
    comment.

所有这些应该真的很酷，特别是与新的 :autocmd 命令结合使用，
为不同类型的文件准备不同的设置。

一些示例：
  对于 C 代码（仅格式化注释）：>
	:set fo=croq
< 对于邮件/新闻（格式化所有，不用 "o" 命令开始注释）：>
	:set fo=tcrq
<

自动格式化				*auto-format* *autoformat*

当 'formatoptions' 中存在 'a' 标志时，在插入文本或删除文本时自动格式化文本。
这对编辑文本段落很好。关于如何使用这个的一些提示：

- 您需要正确定义段落。最简单的是用空行分隔的段落。
  当没有分隔空行时，考虑使用 'w' 标志并在段落中每行末尾添加空格，
  除了最后一行。

- 您可以根据文件类型 |filetype| 或使用 |modeline| 专门为一个文件设置 'formatoptions'。

- 将 'formatoptions' 设置为 "aw2tq" 以制作像这样的缩进文本：

	    bla bla foobar bla 
	bla foobar bla foobar bla
	    bla bla foobar bla 
	bla foobar bla bla foobar

- 添加 'c' 标志以仅自动格式化注释。在源代码中很有用。

- 将 'textwidth' 设置为所需宽度。如果它为零，则使用 79，或屏幕宽度（如果这更小）。

还有一些警告：

- 当部分文本没有在段落中正确分隔时，在此文本中进行更改将导致它被格式化。
  考虑做 >

	:set fo-=a

- 当使用 'w' 标志（尾随空格表示段落继续）并用 |dd| 删除段落的最后一行时，
  段落将与下一个段落连接。

- 更改的文本保存用于撤销。格式化也是一个更改。因此每个格式化操作都保存文本用于撤销。
  这可能会消耗相当多的内存。

- 格式化长段落和/或复杂缩进可能很慢。

==============================================================================
7. 排序文本						*sorting*

Vim 有一个排序函数和一个排序命令。排序函数可以在这里找到：|sort()|、|uniq()|。
另见 |:uniq|。

							*:sor* *:sort*
:[range]sor[t][!] [b][f][i][l][n][o][r][u][x] [/{pattern}/]
			对 [range] 中的行进行排序。当没有给出范围时，所有行都被排序。

			使用 [!] 时顺序被反转。

			使用 [i] 时忽略大小写。
							*:sort-l*
			使用 [l] 时排序使用当前排序区域设置。
			实现细节：使用 strcoll() 比较字符串。参见 |:language| 检查或设置排序区域设置。
			示例：>
				:language collate en_US.UTF-8
				:%sort l
<			|v:collate| 也可以用于检查当前区域设置。
			使用区域设置排序通常忽略大小写。
			这在 Mac 上不能正常工作。

			选项 [n][f][x][o][b] 是互斥的。

			使用 [n] 时，排序基于行中的第一个十进制数字
			（在 {pattern} 匹配之后或内部）。包含一个前导 '-'。

			使用 [f] 时，排序基于行中的浮点数。
			浮点数的值类似于将文本（在 {pattern} 匹配之后或内部）
			传递给 str2float() 函数来确定。

			使用 [x] 时，排序基于行中的第一个十六进制数字
			（在 {pattern} 匹配之后或内部）。忽略前导 "0x" 或 "0X"。
			包含一个前导 '-'。

			使用 [o] 时，排序基于行中的第一个八进制数字
			（在 {pattern} 匹配之后或内部）。

			使用 [b] 时，排序基于行中的第一个二进制数字
			（在 {pattern} 匹配之后或内部）。
							*:sort-u* *:sort-uniq*
			使用 [u]（u 代表唯一）只保留相同行序列中的第一个
			（当使用 [i] 时忽略大小写）。没有此标志，相同行的序列
			将保持其原始顺序。注意前导和尾随空白可能导致行不同。
			当您只想使事物唯一时，使用 |:uniq|。

			当指定 /{pattern}/ 且没有 [r] 标志时，跳过与 {pattern} 匹配的文本，
			以便您对匹配后的内容进行排序。
			'ignorecase' 适用于模式，但不使用 'smartcase'。
			可以使用任何非字母代替斜杠。
			例如，要对第二个逗号分隔字段进行排序：>
				:sort /[^,]*,/
<			要对虚拟列 10 处的文本进行排序（因此忽略制表符和空格之间的差异）：>
				:sort /.*\%10v/
<			要对行中的第一个数字进行排序，无论前面是什么：>
				:sort /.\{-}\ze\d/
<			（解释：".\{-}" 匹配任何文本，"\ze" 设置匹配的结束，\d 匹配数字。）
			使用 [r] 时，排序基于匹配的 {pattern}，而不是像上面描述的那样跳过它。
			例如，仅对每行的前三个字母进行排序：>
				:sort /\a\a\a/ r

<			如果使用了 {pattern}，任何没有 {pattern} 匹配的行都保持其当前顺序，
			但与匹配 {pattern} 的行分开。如果您反向排序，它们将在排序行之后
			按相反顺序排列，否则它们将按原始顺序排列，就在排序行之前。

			如果 {pattern} 为空（例如指定了 //），则使用最后的搜索模式。
			这允许首先尝试模式。

注意，将 `:sort` 与 `:global` 一起使用不会对匹配的行进行排序，这完全没有用。

`:sort` 不使用当前区域设置，除非使用 l 标志。
Vim 确实进行"稳定"排序。

排序可以被中断，但如果您在过程中中断得太晚，您可能会得到重复的行。
这也取决于使用的系统库函数。

==============================================================================
8. 去重文本				*deduplicating* *unique*

Vim 有一个去重函数和一个去重命令。去重函数可以在这里找到：|uniq()|。
另见 |:sort-uniq|。

							*:uni* *:uniq*
:[range]uni[q][!] [i][l][r][u] [/{pattern}/]
			删除 [range] 中彼此相邻的重复行。当没有给出范围时，处理所有行。

			使用 [i] 时，比较行时忽略大小写。

			使用 [l] 时，比较使用当前排序区域设置。详见 |:sort-l|。

			使用 [r] 时，比较基于与 /{pattern}/ 匹配的文本而不是整行。

			使用 [u] 时，只保留不重复的行（即，不立即后跟相同行）。

			使用 [!] 时，只保留立即后跟重复的行。

			如果同时给出 [!] 和 [u]，则忽略 [u] 并生效 [!]。

			当指定 /{pattern}/ 且不使用 [r] 时，跳过与 {pattern} 匹配的文本，
			并对匹配后的内容进行比较。
			'ignorecase' 适用于模式，但不使用 'smartcase'。
			可以使用任何非字母代替斜杠。

			例如，要基于第二个逗号分隔字段删除相邻的重复行：>
				:uniq /[^,]*,/
<			或者只保留忽略前 5 个字符的唯一行：>
				:uniq u /.\{5}/
<			如果 {pattern} 为空（例如使用 //），则使用最后的搜索模式。

			注意前导和尾随空白可能导致行被认为是不同的。
			要删除所有重复项而不考虑位置，请使用 |:sort-u| 或外部工具。

 vim:tw=78:ts=8:noet:ft=help:norl:
