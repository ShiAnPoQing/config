*pattern.txt*   Nvim


		  VIM 参考手册    作者：Bram Moolenaar


模式和搜索命令				*pattern-searches*

基础内容可以在用户手册的 |03.9| 节找到。更多解释在第27章 |usr_27.txt|。

                                      输入 |gO| 查看目录。

==============================================================================
1. 搜索命令				*search-commands*

							*/*
/{pattern}[/]<CR>	向前搜索第[count]次出现的
			{pattern} |exclusive|。

/{pattern}/{offset}<CR>	向前搜索第[count]次出现的
			{pattern} 并向上或向下移动 |{offset}| 行。
			|linewise|。

							*/<CR>*
/<CR>			向前搜索第[count]次出现的最近使用的
			模式 |last-pattern| 和最近使用的 |{offset}|。

//{offset}<CR>		向前搜索第[count]次出现的最近使用的
			模式 |last-pattern| 和新的 |{offset}|。
			如果 {offset} 为空则不使用偏移。

							*?*
?{pattern}[?]<CR>	向后搜索第[count]次出现的
			{pattern} |exclusive|。

?{pattern}?{offset}<CR>	向后搜索第[count]次出现的
			{pattern} 并向上或向下移动 |{offset}| 行
			|linewise|。

							*?<CR>*
?<CR>			向后搜索第[count]次出现的最近使用的
			模式 |last-pattern| 和最近使用的 |{offset}|。

??{offset}<CR>		向后搜索第[count]次出现的最近使用的
			模式 |last-pattern| 和新的 |{offset}|。
			如果 {offset} 为空则不使用偏移。

							*n*
n			重复最近的 "/" 或 "?" [count] 次。
			如果光标没有移动，搜索会以 count + 1 重复。
			|last-pattern|

							*N*
N			以相反方向重复最近的 "/" 或 "?" [count] 次。
			|last-pattern|

							*star* *E348* *E349*
*			向前搜索第[count]次出现的离光标最近的词。
			用于搜索的词是以下第一个：
				1. 光标下的关键字 |'iskeyword'|
				2. 当前行中光标后的第一个关键字
				3. 光标下的非空白词
				4. 当前行中光标后的第一个非空白词
			只搜索完整的关键字，就像使用命令
			"/\<keyword\>"。|exclusive|
			使用 'ignorecase'，不使用 'smartcase'。
							*v_star-default*
{Visual}*		在可视模式下，向前搜索当前选择。
			|default-mappings|

							*#*
#			与 "*" 相同，但向后搜索。英镑符号
			(字符163)也有效。如果 "#" 键作为退格键工作，
			尝试在启动Vim前使用 "stty erase <BS>"
			(<BS> 是 CTRL-H 或真正的退格键)。
							*v_#-default*
{Visual}#		在可视模式下，向后搜索当前选择。
			|default-mappings|

							*gstar*
g*			与 "*" 类似，但不将 "\<" 和 "\>" 放在词周围。
			这使得搜索也能找到不是完整词的匹配。

							*g#*
g#			与 "#" 类似，但不将 "\<" 和 "\>" 放在词周围。
			这使得搜索也能找到不是完整词的匹配。

							*gd*
gd			转到局部声明。当光标在局部变量上时，
			此命令将跳转到其声明。这是为C代码设计的，
			在其他语言中可能不能很好地工作。
			首先Vim搜索当前函数的开始，就像 "[["。
			如果没找到，搜索在行1停止。如果找到了，
			Vim会向后直到找到一个空行。从这个位置，
			Vim搜索光标下的关键字，就像使用 "*"，
			但忽略看起来像注释的行(参见 'comments' 选项)。
			注意这不能保证工作，Vim并不真正检查语法，
			它只是搜索关键字的匹配。如果需要搜索包含的文件，
			使用 |include-search| 中列出的命令。
			在此命令之后 |n| 向前搜索下一个匹配(不是向后)。

							*gD*
gD			转到全局声明。当光标在文件中定义的
			全局变量上时，此命令将跳转到其声明。
			这与 "gd" 工作方式相同，只是关键字的搜索
			总是从行1开始。

							*1gd*
1gd			与 "gd" 类似，但忽略在光标位置之前结束的
			{} 块内的匹配。

							*1gD*
1gD			与 "gD" 类似，但忽略在光标位置之前结束的
			{} 块内的匹配。

							*CTRL-C*
CTRL-C			中断当前(搜索)命令。
			在普通模式下，任何待处理的命令都会被中止。

							*:noh* *:nohlsearch*
:noh[lsearch]		停止 'hlsearch' 选项的高亮显示。
			当使用搜索命令或设置 'hlsearch' 选项时，
			它会自动重新打开。
			此命令在自动命令中不起作用，因为高亮状态
			在执行自动命令时会被保存和恢复 |autocmd-searchpat|。
			调用用户函数时也是如此。

afadsfa
在输入搜索模式时，如果 'incsearch' 选项开启，当前匹配将被显示。
记住你仍然需要用 <CR> 完成搜索命令才能实际将光标定位到显示的匹配处。
或者使用 <Esc> 放弃搜索。

							*nohlsearch-auto*
如果你设置了 'hlsearch' 选项，最后一个使用的搜索模式的所有匹配
都会被高亮显示。这可以通过 |:nohlsearch| 命令暂停，或通过
nohlsearch 插件自动暂停。参见 |nohlsearch-install|。

当 'shortmess' 不包含 "S" 标志时，Vim 会自动显示一个索引，
显示光标所在位置。这看起来像这样：>

  [1/5]		光标在5个匹配中的第1个上。
  [1/>99]	光标在超过99个匹配中的第1个上。
  [>99/>99]	光标在超过99个匹配中的第99个之后。
  [?/??]	未知有多少匹配存在，因为搜索超时，
		生成统计信息被中止。

注意：计数不考虑偏移。

当没有找到匹配时，你会得到错误：*E486* 未找到模式
注意对于 `:global` 命令，你会得到一个普通消息"未找到模式"，
这是为了与Vi兼容。
对于 |:s| 命令，可以使用 "e" 标志来避免错误消息 |:s_flags|。

					*search-offset* *{offset}*
这些命令搜索指定的模式。使用 "/" 和 "?" 时可以给出额外的偏移。
有两种类型的偏移：行偏移和字符偏移。

偏移给出相对于找到的匹配的光标位置：
    [num]	向下[num]行，在第1列
    +[num]	向下[num]行，在第1列
    -[num]	向上[num]行，在第1列
    e[+num]	匹配结束处右侧[num]个字符
    e[-num]	匹配结束处左侧[num]个字符
    s[+num]	匹配开始处右侧[num]个字符
    s[-num]	匹配开始处左侧[num]个字符
    b[+num]	与上面的s[+num]相同(助记：begin)
    b[-num]	与上面的s[-num]相同(助记：begin)
    ;{pattern}  执行另一个搜索，参见 |//;|

如果给出 '-' 或 '+' 但省略了 [num]，将使用计数1。
当包含 'e' 的偏移时，搜索变为包含性的(光标所在位置的字符
包含在操作中)。

示例：

pattern			光标位置	~
/test/+1		在"test"下方一行，在第1列
/test/e			在"test"的最后一个t上
/test/s+2		在"test"的's'上
/test/b-3		"test"前三个字符

如果在操作符之后使用这些命令之一，光标位置前后的字符
会受到影响。但是，如果给出了行偏移，两个光标位置之间的
整行都会受到影响。

一个如何搜索匹配模式并用另一个词替换匹配的示例：>
	/foo<CR>	查找"foo"
	c//e<CR>	更改直到匹配结束
	bar<Esc>	输入替换内容
	//<CR>		转到下一个匹配的开始
	c//e<CR>	更改直到匹配结束
	beep<Esc>	输入另一个替换内容
			等等。
<
							*//;* *E386*
一个非常特殊的偏移是 ';' 后跟另一个搜索命令。例如：>

   /test 1/;/test
   /test.*/+1;?ing?

第一个首先找到下一个"test 1"的出现，然后找到
之后的第一个"test"。

这就像连续执行两个搜索命令，除了：
- 它可以用作操作符后的单个动作命令。
- 后续的 "n" 或 "N" 命令的方向来自第一个搜索命令。
- 当发生错误时，光标完全不会移动。

							*last-pattern*
记住最后使用的模式和偏移。它们可以用来重复搜索，
可能是在另一个方向或使用另一个计数。注意记住两个模式：
一个用于"普通"搜索命令，一个用于替换命令 ":s"。
每次给出空模式时，使用之前使用的模式。但是，
如果没有之前的搜索命令，如果可能的话，会使用之前的替换模式。

'magic' 选项与最后使用的模式绑定。如果你改变 'magic'，
这不会改变最后使用的模式将被如何解释。
'ignorecase' 选项不是这样。当 'ignorecase' 改变时，
它会导致模式匹配其他文本。

如果你设置了 'hlsearch' 选项，最后一个使用的搜索模式的所有匹配
都会被高亮显示。

要清除最后使用的搜索模式：>
	:let @/ = ""
这不会将模式设置为空字符串，因为那会匹配任何地方。
模式真的被清除了，就像启动Vim时一样。

搜索通常会跳过不移动光标的匹配。下一个匹配是在下一个字符
还是在跳过的匹配之后找到，取决于 'cpoptions' 中的 'c' 标志。
参见 |cpo-c|。
	   使用 'c' 标志：   "/..." 前进1到3个字符
	不使用 'c' 标志：   "/..." 前进1个字符
使用 'c' 标志时的不可预测性是由于从第一列开始搜索，
跳过匹配直到找到一个在光标位置之后的匹配。

当向后搜索时，搜索从行的开始处开始，使用 'cpoptions' 中的
'c' 标志，如上所述。然后使用光标位置之前的最后一个匹配。

在Vi中，":tag" 命令在搜索标签时设置最后一个搜索模式。
在Vim中不是这样，除非 'cpoptions' 中存在 't' 标志，
否则仍然记住之前的搜索模式。搜索模式总是放在搜索历史中。

如果 'wrapscan' 选项开启(这是默认值)，搜索会环绕缓冲区末尾。
如果 'wrapscan' 未设置，向后搜索在开始处停止，
向前搜索在缓冲区末尾停止。如果 'wrapscan' 设置且
未找到模式，会给出错误消息"未找到模式"，
并且光标不会移动。如果 'wrapscan' 未设置，
当向前搜索时消息变为"搜索到达底部未找到匹配"，
当向后搜索时变为"搜索到达顶部未找到匹配"。
如果 wrapscan 设置且搜索环绕文件末尾，当向后搜索时
会给出消息"搜索到达顶部，从底部继续"，
当向前搜索时给出"搜索到达底部，从顶部继续"。
这可以通过在 'shortmess' 选项中设置 's' 标志来关闭。
使用高亮方法 'w' 显示此消息(默认：standout)。

							*search-range*
你可以通过包含 \%>l 项来限制搜索命令 "/" 到特定范围的行。
例如，要匹配第199行以下和第300行以上的"limit"词：>
	/\%>199l\%<300llimit
也参见 |/\%>l|。

另一种方法是使用带有 'c' 标志的 ":substitute" 命令。示例：>
   :.,300s/Pattern//gc
此命令将从光标位置到第300行搜索"Pattern"。
在匹配处，你会被要求输入一个字符。输入 'q' 在此匹配处停止，
输入 'n' 查找下一个匹配。

"*"、"#"、"g*" 和 "g#" 命令按此顺序查找光标附近的词，
找到的第一个将被使用：
- 光标下的关键字。
- 光标右侧的第一个关键字，在同一行。
- 光标下的WORD。
- 光标右侧的第一个WORD，在同一行。
关键字只能包含字母和 'iskeyword' 中的字符。
WORD 可以包含任何非空白字符(<Tab>和/或<Space>)。
注意如果你用十个手指打字，这些字符很容易记住：
"#" 在你的左手无名指下(向左和向上搜索)，
"*" 在你的右手无名指下(向右和向下搜索)。
(这取决于你的键盘布局)。


*E956*
在极少数情况下，正则表达式会被递归使用。这可能在执行模式
需要很长时间时发生，当检查通道上的消息时，会调用也使用模式
的回调，或者触发自动命令。在大多数情况下这应该没问题，
但如果一个模式正在使用时再次使用它就会失败。通常这意味着
模式有问题。

==============================================================================
2. 模式的定义			*search-pattern* *pattern* *[pattern]*
					*regular-expression* *regexp* *Pattern*
					*E383* *E476*

初学者可以阅读用户手册的第27章 |usr_27.txt|。

						*/bar* */\bar* */pattern*
1. 模式是一个或多个分支，由 "\|" 分隔。它匹配任何
   匹配其中一个分支的内容。例如："foo\|beep" 匹配 "foo" 和
   匹配 "beep"。如果多个分支匹配，使用第一个。

   模式 ::=	    分支
		或  分支 \| 分支
		或  分支 \| 分支 \| 分支
		等等。

						*/branch* */\&*
2. 分支是一个或多个连接，由 "\&" 分隔。它匹配最后一个
   连接，但仅当所有前面的连接也在同一位置匹配时。
   示例：
	"foobeep\&..." 在 "foobeep" 中匹配 "foo"。
	".*Peter\&.*Bob" 在包含 "Peter" 和 "Bob" 的行中匹配

   分支 ::=	    连接
		或  连接 \& 连接
		或  连接 \& 连接 \& 连接
		等等。

						*/concat*
3. 连接是一个或多个片段，连接在一起。它匹配第一个片段
   的匹配，后跟第二个片段的匹配，等等。例如：
   "f[0-9]b"，首先匹配 "f"，然后是一个数字，然后是 "b"。

   连接  ::=	    片段
		或  片段 片段
		或  片段 片段 片段
		等等。

						*/piece*
4. 片段是一个原子，可能后跟一个多重指示，表示原子可以
   匹配多少次。例如："a*" 匹配任何 "a" 字符序列：
   ""、"a"、"aa" 等。参见 |/multi|。

   片段   ::=	    原子
		或  原子  多重

						*/atom*
5. 原子可以是以下长列表中的一项。许多原子匹配文本中的
   一个字符。它通常是一个普通字符或字符类。
   括号可以用来使模式成为原子。"\z(\)" 构造仅用于
   语法高亮。

   原子    ::=	    普通原子		|/ordinary-atom|
		或  \( 模式 \)		|/\(|
		或  \%( 模式 \)		|/\%(|
		或  \z( 模式 \)		|/\z(|


				*/\%#=* *two-engines* *NFA*
Vim包含两个正则表达式引擎：
1. 一个旧的、回溯引擎，支持所有功能。
2. 一个新的、NFA引擎，在某些模式上工作得更快，
   在某些模式上可能更慢。
								 *E1281*
Vim会自动为你选择正确的引擎。但是，如果你遇到问题
或想特别选择其中一个引擎，你可以在模式前加上以下之一：

	\%#=0	强制自动选择。仅在 'regexpengine' 已设置为
		非零值时有效。
	\%#=1	强制使用旧引擎。
	\%#=2	强制使用NFA引擎。

你也可以使用 'regexpengine' 选项来改变默认值。

			 *E864* *E868* *E874* *E875* *E876* *E877* *E878*
如果选择NFA引擎并遇到未实现的内容，模式将不匹配。
这仅在调试Vim时有用。

==============================================================================
3. 魔法							*/magic*

模式中的一些字符，如字母，被按字面意思处理。它们
精确匹配文本中的相同字符。但是，当在前面加上反斜杠时，
这些字符可能会获得特殊含义。例如，"a" 匹配字母 "a"，
而 "\a" 匹配任何字母字符。

其他字符没有反斜杠就有特殊含义。它们需要前面加上
反斜杠才能按字面意思匹配。例如，"." 匹配任何字符，
而 "\." 匹配一个点。

字符是否按字面意思处理取决于 'magic' 选项和模式中
提到的项目。'magic' 选项应该始终设置，但为了与Vi兼容
可以关闭。我们在这里提到 'nomagic' 的效果是为了完整性，
但我们建议不要使用它。
							*/\m* */\M*
使用 "\m" 使后面的模式被解释为好像设置了 'magic'，
忽略 'magic' 选项的实际值。
使用 "\M" 使后面的模式被解释为好像使用了 'nomagic'。
							*/\v* */\V*
使用 "\v" 意味着在它之后，除了 '0'-'9'、'a'-'z'、
'A'-'Z' 和 '_' 之外的所有ASCII字符都有特殊含义：
"非常魔法"

使用 "\V" 意味着在它之后，只有反斜杠和终止字符
(通常是 / 或 ?)有特殊含义："非常不魔法"

示例：
之后：	  \v	   \m	    \M	     \V		匹配 ~
		'magic' 'nomagic'
	  a	   a	    a	     a		字面 'a'
	  \a	   \a	    \a	     \a		任何字母字符
	  .	   .	    \.	     \.		任何字符
	  \.	   \.	    .	     .		字面点
	  $	   $	    $	     \$		行尾
	  *	   *	    \*	     \*		前一个原子的任意数量
	  ~	   ~	    \~	     \~		最近的替换字符串
	  ()	   \(\)     \(\)     \(\)	作为原子的组
	  |	   \|	    \|	     \|		无：分隔替代项
	  \\	   \\	    \\	     \\		字面反斜杠
	  \{	   {	    {	     {		字面花括号

如果你想，你可以通过在模式开始处放置 "\m" 或 "\M"
来使模式不受 'magic' 选项设置的影响。


==============================================================================
4. 模式项目概述				*pattern-overview*
						*E865* *E866* *E867* *E869*

多重项目概述。				*/multi* *E61* *E62*
更多解释和示例在下面，跟随链接。		*E64* *E871*

	  多重 ~
     'magic' 'nomagic'	前一个原子的匹配 ~
|/star|	*	\*	0或更多	尽可能多
|/\+|	\+	\+	1或更多	尽可能多
|/\=|	\=	\=	0或1	尽可能多
|/\?|	\?	\?	0或1	尽可能多

|/\{|	\{n,m}	\{n,m}	n到m	尽可能多
	\{n}	\{n}	n	精确
	\{n,}	\{n,}	至少n	尽可能多
	\{,m}	\{,m}	0到m	尽可能多
	\{}	\{}	0或更多	尽可能多(与"*"相同)

|/\{-|	\{-n,m}	\{-n,m}	n到m	尽可能少
	\{-n}	\{-n}	n	精确
	\{-n,}	\{-n,}	至少n	尽可能少
	\{-,m}	\{-,m}	0到m	尽可能少
	\{-}	\{-}	0或更多	尽可能少

							*E59*
|/\@>|	\@>	\@>	1，像匹配整个模式
|/\@=|	\@=	\@=	无，要求匹配 |/zero-width|
|/\@!|	\@!	\@!	无，要求不匹配 |/zero-width|
|/\@<=|	\@<=	\@<=	无，要求后面有匹配 |/zero-width|
|/\@<!|	\@<!	\@<!	无，要求后面不匹配 |/zero-width|


普通原子概述。				*/ordinary-atom*
更多解释和示例在下面，跟随链接。

      普通原子 ~
      magic   nomagic	匹配 ~
|/^|	^	^	行首(在模式开始处) |/zero-width|
|/\^|	\^	\^	字面 '^'
|/\_^|	\_^	\_^	行首(可在任何位置使用) |/zero-width|
|/$|	$	$	行尾(在模式结束处) |/zero-width|
|/\$|	\$	\$	字面 '$'
|/\_$|	\_$	\_$	行尾(可在任何位置使用) |/zero-width|
|/.|	.	\.	任何单个字符(不是行尾)
|/\_.|	\_.	\_.	任何单个字符或行尾
|/\<|	\<	\<	词首 |/zero-width|
|/\>|	\>	\>	词尾 |/zero-width|
|/\zs|	\zs	\zs	任何内容，设置匹配的开始
|/\ze|	\ze	\ze	任何内容，设置匹配的结束
|/\%^|	\%^	\%^	文件开始 |/zero-width|		*E71*
|/\%$|	\%$	\%$	文件结束 |/zero-width|
|/\%V|	\%V	\%V	可视区域内部 |/zero-width|
|/\%#|	\%#	\%#	光标位置 |/zero-width|
|/\%'m|	\%'m	\%'m	标记m位置 |/zero-width|
|/\%l|	\%23l	\%23l	在第23行 |/zero-width|
|/\%c|	\%23c	\%23c	在第23列 |/zero-width|
|/\%v|	\%23v	\%23v	在虚拟列23 |/zero-width|

字符类：					*/character-classes*
      magic   nomagic	匹配 ~
|/\i|	\i	\i	标识符字符(参见 'isident' 选项)
|/\I|	\I	\I	类似 "\i"，但排除数字
|/\k|	\k	\k	关键字字符(参见 'iskeyword' 选项)
|/\K|	\K	\K	类似 "\k"，但排除数字
|/\f|	\f	\f	文件名字符(参见 'isfname' 选项)
|/\F|	\F	\F	类似 "\f"，但排除数字
|/\p|	\p	\p	可打印字符(参见 'isprint' 选项)
|/\P|	\P	\P	类似 "\p"，但排除数字
|/\s|	\s	\s	空白字符：<Space> 和 <Tab>
|/\S|	\S	\S	非空白字符；\s的反面
|/\d|	\d	\d	数字：				[0-9]
|/\D|	\D	\D	非数字：			[^0-9]
|/\x|	\x	\x	十六进制数字：			[0-9A-Fa-f]
|/\X|	\X	\X	非十六进制数字：			[^0-9A-Fa-f]
|/\o|	\o	\o	八进制数字：			[0-7]
|/\O|	\O	\O	非八进制数字：		[^0-7]
|/\w|	\w	\w	词字符：			[0-9A-Za-z_]
|/\W|	\W	\W	非词字符：		[^0-9A-Za-z_]
|/\h|	\h	\h	词首字符：		[A-Za-z_]
|/\H|	\H	\H	非词首字符：	[^A-Za-z_]
|/\a|	\a	\a	字母字符：		[A-Za-z]
|/\A|	\A	\A	非字母字符：	[^A-Za-z]
|/\l|	\l	\l	小写字符：		[a-z]
|/\L|	\L	\L	非小写字符：	[^a-z]
|/\u|	\u	\u	大写字符：		[A-Z]
|/\U|	\U	\U	非大写字符		[^A-Z]
|/\_|	\_x	\_x	其中x是上述任何字符：包含行尾的
			字符类
(字符类结束)

      magic   nomagic	匹配 ~
|/\e|	\e	\e	<Esc>
|/\t|	\t	\t	<Tab>
|/\r|	\r	\r	<CR>
|/\b|	\b	\b	<BS>
|/\n|	\n	\n	行尾
|/~|	~	\~	最后给定的替换字符串
|/\1|	\1	\1	与第一个 \(\) 匹配的相同字符串
|/\2|	\2	\2	类似 "\1"，但使用第二个 \(\)
	   ...
|/\9|	\9	\9	类似 "\1"，但使用第九个 \(\)
								*E68*
|/\z1|	\z1	\z1	仅用于语法高亮，参见 |:syn-ext-match|
	   ...
|/\z1|	\z9	\z9	仅用于语法高亮，参见 |:syn-ext-match|

	x	x	没有特殊含义的字符匹配自身

|/[]|	[]	\[]	[]中指定的任何字符
|/\%[]|	\%[]	\%[]	可选匹配原子的序列

|/\c|	\c	\c	忽略大小写，不使用 'ignorecase' 选项
|/\C|	\C	\C	匹配大小写，不使用 'ignorecase' 选项
|/\Z|	\Z	\Z	忽略Unicode"组合字符"的差异。
			在搜索带元音的希伯来语或阿拉伯语文本时很有用。

      magic   nomagic	匹配 ~
|/\m|	\m	\m	对模式中后面的字符开启'magic'
|/\M|	\M	\M	对模式中后面的字符关闭'magic'
|/\v|	\v	\v	模式中后面的字符是"非常魔法"
|/\V|	\V	\V	模式中后面的字符是"非常不魔法"
|/\%#=|   \%#=1   \%#=1   选择正则表达式引擎 |/zero-width|

|/\%d|	\%d	\%d	匹配指定的十进制字符(例如 \%d123)
|/\%x|	\%x	\%x	匹配指定的十六进制字符(例如 \%x2a)
|/\%o|	\%o	\%o	匹配指定的八进制字符(例如 \%o040)
|/\%u|	\%u	\%u	匹配指定的多字节字符(例如 \%u20ac)
|/\%U|	\%U	\%U	匹配指定的大多字节字符(例如
			\%U12345678)
|/\%C|	\%C	\%C	匹配任何组合字符


示例			匹配 ~
\<\I\i*		或
\<\h\w*
\<[a-zA-Z_][a-zA-Z0-9_]*
			一个标识符(例如，在C程序中)。

\(\.$\|\. \)		一个后跟<EOL>或空格的句点。

[.!?][])"']*\($\|[ ]\)	一个查找句子结尾的搜索模式，
			与")"命令的定义几乎相同。

cat\Z			同时匹配"cat"和"càt"("a"后跟0x0300)
			不匹配"càt"(字符0x00e0)，即使
			它们看起来可能相同。


==============================================================================
5. 多重项目						*pattern-multi-items*

一个原子后面可以跟一个指示，说明原子可以匹配多少次以及
以什么方式。这被称为多重。参见 |/multi| 获取概述。

							*/star* */\star*
*	(当'magic'未设置时使用 \*)
	匹配前一个原子的0次或多次，尽可能多。
	示例  'nomagic'	匹配 ~
	a*	   a\*		""、"a"、"aa"、"aaa"等。
	.*	   \.\*		任何内容，也包括空字符串，不包括行尾
	\_.*	   \_.\*	直到缓冲区末尾的所有内容
	\_.*END	   \_.\*END	直到并包括缓冲区中最后一个"END"
				的所有内容

	例外：当"*"用在模式开始处或紧接在"^"之后时，
	它匹配星号字符。

	注意重复"\_.*"可以匹配大量文本并花费很长时间。
	例如，"\_.*END"匹配从当前位置到文件中最后一个
	"END"出现的所有文本。由于"*"会尽可能多地匹配，
	这会首先跳过所有行直到文件末尾，然后尝试匹配"END"，
	一次回退一个字符。

							*/\+*
\+	匹配前一个原子的1次或多次，尽可能多。
	示例		匹配 ~
	^.\+$		任何非空行
	\s\+		至少一个字符的空白

							*/\=*
\=	匹配前一个原子的0次或1次，尽可能多。
	示例		匹配 ~
	foo\=		"fo"和"foo"

							*/\?*
\?	与\=完全相同。不能在向后搜索时使用"?"命令。

					*/\{* *E60* *E554* *E870*
\{n,m}	匹配前一个原子的n到m次，尽可能多
\{n}	匹配前一个原子的n次
\{n,}	匹配前一个原子的至少n次，尽可能多
\{,m}	匹配前一个原子的0到m次，尽可能多
\{}	匹配前一个原子的0次或多次，尽可能多(与"*"相同)
							*/\{-*
\{-n,m}	匹配前一个原子的n到m次，尽可能少
\{-n}	匹配前一个原子的n次
\{-n,}	匹配前一个原子的至少n次，尽可能少
\{-,m}	匹配前一个原子的0到m次，尽可能少
\{-}	匹配前一个原子的0次或多次，尽可能少

	n和m是正十进制数或零
								*non-greedy*
	如果"-"紧接在"{"之后出现，则使用最短匹配优先算法
	(见下面的示例)。特别是，"\{-}"与"*"相同，
	但使用最短匹配优先算法。但是：较早开始的匹配
	优先于较短的匹配："a\{-}b"在"xaaab"中匹配"aaab"。

	示例			匹配 ~
	ab\{2,3}c		"abbc"或"abbbc"
	a\{5}			"aaaaa"
	ab\{2,}c		"abbc"、"abbbc"、"abbbbc"等。
	ab\{,3}c		"ac"、"abc"、"abbc"或"abbbc"
	a[bc]\{3}d		"abbbd"、"abbcd"、"acbcd"、"acccd"等。
	a\(bc\)\{1,2}d		"abcd"或"abcbcd"
	a[bc]\{-}[cd]		"abcd"中的"abc"
	a[bc]*[cd]		"abcd"中的"abcd"

	}可以可选地前面加一个反斜杠：\{n,m\}。

							*/\@=*
\@=	以零宽度匹配前一个原子。
	类似Perl中的"(?=pattern)"。
	示例			匹配 ~
	foo\(bar\)\@=		"foobar"中的"foo"
	foo\(bar\)\@=foo	无
							*/zero-width*
	当使用"\@="(或"^"、"$"、"\<"、"\>")时，
	没有字符包含在匹配中。这些项目仅用于检查
	是否可以匹配。这可能很棘手，因为与后续项目的
	匹配将在同一位置进行。上面的最后一个示例不会
	匹配"foobarfoo"，因为它试图在与"bar"匹配的
	同一位置匹配"foo"。

	注意使用"\&"与使用"\@="效果相同：
	"foo\&.."与"\(foo\)\@=.."相同。但使用"\&"
	更容易，你不需要括号。

afadsfa
*/\@!*
\@!	如果前一个原子在当前位置不匹配，则以零宽度匹配。
	|/zero-width|
	类似Perl中的"(?!pattern)"。
	示例			匹配 ~
	foo\(bar\)\@!		任何不后跟"bar"的"foo"
	a.\{-}p\@!		"a"、"ap"、"app"、"appp"等，不立即
				后跟"p"
	if \(\(then\)\@!.\)*$	不后跟"then"的"if "

	使用"\@!"很棘手，因为有很多地方模式不匹配。
	"a.*p\@!"将匹配从"a"到行尾的所有内容，因为".*"
	可以匹配行中的所有字符，而"p"在行尾不匹配。
	"a.\{-}p\@!"将匹配任何不后跟"p"的"a"、"ap"、"app"等，
	因为"."可以匹配"p"，而"p\@!"在那之后不匹配。

	你不能使用"\@!"来查找匹配位置之前的非匹配：
	"\(foo\)\@!bar"将在"foobar"中匹配"bar"，因为在
	"bar"匹配的位置，"foo"不匹配。要避免匹配"foobar"，
	你可以使用"\(foo\)\@!...bar"，但这不会匹配行首的
	bar。使用"\(foo\)\@<!bar"。

	有用的示例：在不包含"bar"的行中查找"foo"：>
		/^\%(.*bar\)\@!.*\zsfoo
<	这个模式首先检查行中没有任何位置"bar"匹配。
	如果".*bar"在某处匹配，\@!将拒绝该模式。
	当没有匹配时，任何"foo"都会被找到。
	"\zs"是为了让匹配正好在"foo"之前开始。

							*/\@<=*
\@<=	如果前一个原子正好在后面的内容之前匹配，则以零宽度匹配。
	|/zero-width|
	类似Perl中的"(?<=pattern)"，但Vim允许非固定宽度模式。
	示例			匹配 ~
	\(an\_s\+\)\@<=file	在"an"和空白或行尾之后的"file"
	为了速度，通常最好避免使用这个多重。
	尝试使用"\zs"代替 |/\zs|。要匹配与上面示例相同的内容：
		an\_s\+\zsfile
	至少为后向查找设置一个限制，见下文。

	"\@<="和"\@<!"检查后面的内容之前的匹配。
	理论上这些匹配可以从这个位置之前的任何地方开始。
	但为了限制所需的时间，只搜索后面的内容匹配的行，
	以及它之前的一行(如果有的话)。这应该足以匹配
	大多数内容而不会太慢。

	在旧的正则表达式引擎中，"\@<="和"\@<!"后面的
	模式部分首先检查匹配，因此像"\1"这样的东西不能
	引用前面的\(\)内部。反过来是可以的：
	错误示例			匹配 ~
	\%#=1\1\@<=,\([a-z]\+\)		",abc"在"abc,abc"中

	但是，新的正则表达式引擎工作方式不同，最好不要
	依赖这种行为，如果可以避免就不要使用\@<=：
	示例				匹配 ~
	\([a-z]\+\)\zs,\1		",abc"在"abc,abc"中

\@123<=
	类似"\@<="但只向后查找123字节。这避免了尝试许多
	已知会失败的匹配，使执行模式非常慢。例如，检查
	"span"之前是否有"<"：
		/<\@1<=span
	这将只尝试在"span"前一个字节处匹配"<"，
	这是唯一有效的位置。
	在跨越行边界后，限制是相对于行尾的。因此，
	匹配行开头的字符不被计数(这只是为了保持简单)。
	数字零与无限制相同。

							*/\@<!*
\@<!	如果前一个原子不在后面的内容之前匹配，则以零宽度匹配。
	因此，如果当前行或前一行中没有原子匹配的位置
	使其正好在后面的内容之前结束，则匹配。
	|/zero-width|
	类似Perl中的"(?<!pattern)"，但Vim允许非固定宽度模式。
	与前面的原子的匹配被设置为正好在后面的内容
	匹配之前结束，因此以".*"结尾的原子将工作。
	警告：这可能很慢(因为需要检查许多位置的匹配)。
	如果可能，使用限制，见下文。
	示例			匹配 ~
	\(foo\)\@<!bar		不在"foobar"中的任何"bar"
	\(\/\/.*\)\@<!in	不在"//"之后的"in"

\@123<!
	类似"\@<!"但只向后查找123字节。这避免了尝试许多
	已知会失败的匹配，使执行模式非常慢。

							*/\@>*
\@>	像匹配整个模式一样匹配前一个原子。
	类似Perl中的"(?>pattern)"。
	示例		匹配 ~
	\(a*\)\@>a	无("a*"占用所有"a"，不可能有
			另一个跟在后面)

	这像单独的模式一样匹配前一个原子。如果它不匹配，
	不会尝试使用更短的子匹配或任何其他方式重试。
	观察这个区别："a*b"和"a*ab"都匹配"aaab"，
	但在第二种情况下，"a*"只匹配前两个"a"。
	"\(a*\)\@>ab"不会匹配"aaab"，因为"a*"匹配
	"aaa"(尽可能多的"a")，因此"ab"不能匹配。

adfas
==============================================================================
6. 普通原子					*pattern-atoms*

普通原子可以是：

							*/^*
^	在模式开始处或"\|"、"\("、"\%("或"\n"之后：
	匹配行首；在其他位置，匹配字面'^'。|/zero-width|
	示例		匹配 ~
	^beep(		C函数"beep"的开始(可能)。

							*/\^*
\^	匹配字面'^'。可以在模式中的任何位置使用，
	但不能在[]内。

							*/\_^*
\_^	匹配行首。|/zero-width| 可以在模式中的任何位置使用，
	但不能在[]内。
	示例		匹配 ~
	\_s*\_^foo	空白和空行，然后是行首的"foo"

							*/$*
$	在模式结束处或"\|"、"\)"或"\n"之前('magic'开启)：
	匹配行尾<EOL>；在其他位置，匹配字面'$'。
	|/zero-width|

							*/\$*
\$	匹配字面'$'。可以在模式中的任何位置使用，
	但不能在[]内。

							*/\_$*
\_$	匹配行尾。|/zero-width| 可以在模式中的任何位置使用，
	但不能在[]内。注意"a\_$b"永远不会匹配，因为
	"b"不能匹配行尾。使用"a\nb"代替 |/\n|。
	示例		匹配 ~
	foo\_$\_s*	行尾的"foo"和后面的空白和空行

.	(使用'nomagic'时：\.)				*/.* */\.*
	匹配任何单个字符，但不是行尾。

							*/\_.*
\_.	匹配任何单个字符或行尾。
	注意："\_.*"匹配到缓冲区末尾的所有文本！

							*/\<*
\<	匹配词首：下一个字符是词的第一个字符。
	'iskeyword'选项指定什么是词字符。
	|/zero-width|

							*/\>*
\>	匹配词尾：前一个字符是词的最后一个字符。
	'iskeyword'选项指定什么是词字符。
	|/zero-width|

							*/\zs*
\zs	在任何位置匹配，但不能在[]内，并设置匹配的开始：
	下一个字符是整个匹配的第一个字符。
	|/zero-width|
	示例：>
		/^\s*\zsif
<	匹配行首的"if"，忽略空白。
	可以多次使用，使用匹配分支中遇到的最后一个。
	示例：>
		/\(.\{-}\zsFab\)\{3}
<	查找"Fab"的第三次出现。
	这后面不能跟多重。*E888*

							*/\ze*
\ze	在任何位置匹配，但不能在[]内，并设置匹配的结束：
	前一个字符是整个匹配的最后一个字符。
	|/zero-width|
	可以多次使用，使用匹配分支中遇到的最后一个。
	示例："end\ze\(if\|for\)"匹配"endif"和"endfor"中的"end"。
	这后面不能跟多重。|E888|

						*/\%^* *start-of-file*
\%^	匹配文件开始。当与字符串匹配时，匹配字符串的开始。
	例如，要查找文件中的第一个"VIM"：>
		/\%^\_.\{-}\zsVIM
<
						*/\%$* *end-of-file*
\%$	匹配文件结束。当与字符串匹配时，匹配字符串的结束。
	注意这不会找到文件中的最后一个"VIM"：>
		/VIM\_.\{-}\%$
<	它会找到下一个VIM，因为后面的部分总是会匹配。
	这个会找到文件中的最后一个"VIM"：>
		/VIM\ze\(\(VIM\)\@!\_.\)*\%$
<	这使用 |/\@!| 来确保"VIM"不会在第一个"VIM"之后的
	任何位置匹配。
	从文件末尾向后搜索更容易！

						*/\%V*
\%V	在可视区域内部匹配。当可视模式已经停止时，
	在|gv|会重新选择的区域中匹配。
	这是一个|/zero-width|匹配。要确保整个模式在
	可视区域内部，将其放在模式开始处和结束前，
	例如：>
		/\%Vfoo.*ba\%Vr
<	这也适用于只选择了"foo bar"的情况。这个：>
		/\%Vfoo.*bar\%V
<	如果可视选择在"r"之后继续，将匹配"foo bar"。
	仅适用于当前缓冲区。

						*/\%#* *cursor-position*
\%#	与光标位置匹配。仅当在窗口中显示的缓冲区中
	匹配时有效。
	警告：当光标移动后使用模式，结果将无效。
	Vim不会自动更新匹配。这对于语法高亮和
	'hlsearch'特别相关。换句话说：当光标移动时，
	显示不会为此更改而更新。当更改行时(整行更新)
	或使用|CTRL-L|命令(整个屏幕更新)时会进行更新。
	示例，要高亮光标下的词：>
		/\k*\%#\k*
<	当设置'hlsearch'并移动光标和进行更改时，
	这将清楚地显示匹配何时更新。

						*/\%'m* */\%<'m* */\%>'m*
\%'m	与标记m的位置匹配。
\%<'m	在标记m的位置之前匹配。
\%>'m	在标记m的位置之后匹配。
	示例，要高亮从标记's到'e的文本：>
		/.\%>'s.*\%<'e..
<	注意需要两个点来包含'e标记。这是因为
	"\%<'e"在'e标记前的字符处匹配，由于它是
	|/zero-width|匹配，它不包含该字符。
	警告：当标记移动后使用模式，结果将无效。
	Vim不会自动更新匹配。类似于移动光标时的
	"\%#" |/\%#|。

					*/\%l* */\%>l* */\%<l* *E951* *E1204*
\%23l	在特定行中匹配。
\%<23l	在特定行之上匹配(较低的行号)。
\%>23l	在特定行之下匹配(较高的行号)。
\%.l	在光标行匹配。
\%<.l	在光标行之上匹配。
\%>.l	在光标行之下匹配。
	这六个可以用来匹配缓冲区中的特定行。
	"23"可以是任何行号。第一行是1。
	警告：当插入或删除行时，Vim不会自动更新匹配。
	这意味着语法高亮很快就会出错。同样，当引用
	光标位置(".")且光标移动时，显示不会为此更改
	而更新。当使用|CTRL-L|命令(整个屏幕更新)时
	会进行更新。
	示例，要高亮光标当前所在的行：>
		:exe '/\%' .. line(".") .. 'l'
<	或者使用：>
		/\%.l
<	当设置'hlsearch'并移动光标和进行更改时，
	这将清楚地显示匹配何时更新。

						*/\%c* */\%>c* */\%<c*
\%23c	在特定列中匹配。
\%<23c	在特定列之前匹配。
\%>23c	在特定列之后匹配。
\%.c	在光标列匹配。
\%<.c	在光标列之前匹配。
\%>.c	在光标列之后匹配。
	这六个可以用来匹配缓冲区或字符串中的特定列。
	"23"可以是任何列号。第一列是1。实际上，
	列是字节号(因此对于多字节字符不完全正确)。
	警告：当插入或删除文本时，Vim不会自动更新匹配。
	这意味着语法高亮很快就会出错。同样，当引用
	光标位置(".")且光标移动时，显示不会为此更改
	而更新。当使用|CTRL-L|命令(整个屏幕更新)时
	会进行更新。
	示例，要高亮光标当前所在的列：>
		:exe '/\%' .. col(".") .. 'c'
<	或者使用：>
		/\%.c
<	当设置'hlsearch'并移动光标和进行更改时，
	这将清楚地显示匹配何时更新。
	示例，匹配第44列中的单个字节：>
		/\%>43c.\%<46c
<	注意当"."匹配第44列中的字节时，
	"\%<46c"在第45列匹配。
						*/\%v* */\%>v* */\%<v*
\%23v	在特定虚拟列中匹配。
\%<23v	在特定虚拟列之前匹配。
\%>23v	在特定虚拟列之后匹配。
\%.v	在当前虚拟列匹配。
\%<.v	在当前虚拟列之前匹配。
\%>.v	在当前虚拟列之后匹配。
	这六个可以用来匹配缓冲区或字符串中的特定虚拟列。
	当不在窗口中显示的缓冲区中匹配时，使用当前窗口的
	选项值(例如，'tabstop')。
	"23"可以是任何列号。第一列是1。
	注意某些虚拟列位置永远不会匹配，因为它们
	在制表符或其他占用多个屏幕字符的字符中间。
	警告：当插入或删除文本时，Vim不会自动更新
	高亮的匹配。这意味着语法高亮很快就会出错。
	同样，当引用光标位置(".")且光标移动时，
	显示不会为此更改而更新。当使用|CTRL-L|命令
	(整个屏幕更新)时会进行更新。
	示例，要高亮虚拟列72之后的所有字符：>
		/\%>72v.*
<	当设置'hlsearch'并移动光标和进行更改时，
	这将清楚地显示匹配何时更新。
	要匹配到第17列的文本：>
		/^.*\%17v
<	要匹配当前虚拟列(光标所在位置)之后的所有字符：>
		/\%>.v.*
<	第17列不包含在内，因为这是一个|/zero-width|匹配。
	要包含该列使用：>
		/^.*\%17v.
<	这个命令做同样的事情，但当第17列没有字符时
	也会匹配：>
		/^.*\%<18v.
<	注意没有"^"来将匹配锚定在第一列，
	这也会高亮第17列：>
		/.*\%17v
<	第17列被'hlsearch'高亮是因为有另一个匹配，
	其中".*"匹配零个字符。


字符类：
\i	标识符字符(参见'isident'选项)	*/\i*
\I	类似"\i"，但排除数字			*/\I*
\k	关键字字符(参见'iskeyword'选项)	*/\k*
\K	类似"\k"，但排除数字			*/\K*
\f	文件名字符(参见'isfname'选项)	*/\f*
\F	类似"\f"，但排除数字			*/\F*
\p	可打印字符(参见'isprint'选项)	*/\p*
\P	类似"\p"，但排除数字			*/\P*

注意：上面的也适用于多字节字符。下面的只匹配ASCII字符，
如范围所示。

						*whitespace* *white-space*
\s	空白字符：<Space>和<Tab>		*/\s*
\S	非空白字符；\s的反面	*/\S*
\d	数字：				[0-9]		*/\d*
\D	非数字：			[^0-9]		*/\D*
\x	十六进制数字：			[0-9A-Fa-f]	*/\x*
\X	非十六进制数字：			[^0-9A-Fa-f]	*/\X*
\o	八进制数字：			[0-7]		*/\o*
\O	非八进制数字：		[^0-7]		*/\O*
\w	词字符：			[0-9A-Za-z_]	*/\w*
\W	非词字符：		[^0-9A-Za-z_]	*/\W*
\h	词首字符：		[A-Za-z_]	*/\h*
\H	非词首字符：	[^A-Za-z_]	*/\H*
\a	字母字符：		[A-Za-z]	*/\a*
\A	非字母字符：	[^A-Za-z]	*/\A*
\l	小写字符：		[a-z]		*/\l*
\L	非小写字符：	[^a-z]		*/\L*
\u	大写字符：		[A-Z]		*/\u*
\U	非大写字符：	[^A-Z]		*/\U*

	注意：使用原子比[]形式更快。

	注意：字符类不使用'ignorecase'、"\c"和"\C"。

			*/\_* *E63* */\_i* */\_I* */\_k* */\_K* */\_f* */\_F*
			*/\_p* */\_P* */\_s* */\_S* */\_d* */\_D* */\_x* */\_X*
			*/\_o* */\_O* */\_w* */\_W* */\_h* */\_H* */\_a* */\_A*
			*/\_l* */\_L* */\_u* */\_U*
\_x	其中"x"是上述任何字符：添加了行尾的
	字符类
(字符类结束)

\e	匹配<Esc>					*/\e*
\t	匹配<Tab>					*/\t*
\r	匹配<CR>					*/\r*
\b	匹配<BS>					*/\b*
\n	匹配行尾				*/\n*
	当在字符串而不是缓冲区文本中匹配时，
	匹配字面换行符。

~	匹配最后给定的替换字符串	*/~* */\~*

\(\)	由转义括号括起来的模式。	*/\(* */\(\)* */\)*
	例如，"\(^a\)"匹配行首的'a'。
	这些只能有九个。你可以使用"\%("来添加更多，
	但不将其计为子表达式。
	*E51* *E54* *E55* *E872* *E873*

\1      匹配与第一个子表达式在\(和\)中匹配的	*/\1* *E65*
	相同字符串。
	示例："\([a-z]\).\1"匹配"ata"、"ehe"、"tot"等。
\2      类似"\1"，但使用第二个子表达式，	*/\2*
   ...							*/\3*
\9      类似"\1"，但使用第九个子表达式。	*/\9*
	注意：组的编号基于哪个"\("在模式中最先出现
	(从左到右)，而不是基于最先匹配的内容。

\%(\)	由转义括号括起来的模式。	*/\%(\)* */\%(* *E53*
	与\(\\)完全相同，但不将其计为子表达式。
	这允许使用更多组，而且速度稍快。

x	没有特殊含义的单个字符匹配自身

							*/\* */\\*
\x	后跟没有特殊含义的单个字符的反斜杠，
	为将来的扩展保留

[]	(使用'nomagic'时：\[])		*/[]* */\[]* */\_[]* */collection* *E76*
\_[]
	一个集合。这是由方括号括起来的字符序列。
	它匹配集合中的任何单个字符。
	示例		匹配 ~
	[xyz]		任何'x'、'y'或'z'
	[a-zA-Z]$	行尾的任何字母字符
	\c[a-z]$	相同
	[А-яЁё]		俄语字母表(使用utf-8和cp1251)

								*/[\n]*
	在前面加上"\_"时，集合也包含行尾。
	这也可以通过包含"\n"在集合中来实现。
	当集合以"^"开头时，行尾也会被匹配！
	因此"\_[^ab]"匹配行尾和除"a"和"b"之外的
	任何字符。这使其与Vi兼容：没有"\_"或"\n"时，
	集合不匹配行尾。
								*E769*
	当']'不存在时，Vim不会给出错误消息，
	但假设不使用集合。对搜索'['很有用。
	但是，对于内部搜索你会得到E769。
	要注意在`:substitute`命令中整个命令成为模式。
	例如，":s/[/x/"搜索"[/x"并将其替换为空。
	它不搜索"["并将其替换为"x"！

								*E944* *E945*
	如果序列以"^"开始，它匹配不在集合中的
	任何单个字符："[^xyz]"匹配除'x'、'y'和'z'
	之外的任何内容。
	- 如果序列中的两个字符由'-'分隔，这是
	  它们之间的完整ASCII字符列表的简写。
	  例如，"[0-9]"匹配任何十进制数字。
	  如果起始字符超过结束字符，例如[c-a]，
	  会出现E944。可以使用非ASCII字符，
	  但在旧的正则表达式引擎中，字符值
	  不能相差超过256。例如，在设置re=1后
	  搜索[\u3000-\u4000]会发出E945错误。
	  在前面加上\%#=2可以修复它。
	- 字符类表达式被计算为属于该字符类的
	  字符集。支持以下字符类：
		 名称	      函数	内容 ~
*[:alnum:]*	  [:alnum:]   isalnum	ASCII字母和数字
*[:alpha:]*	  [:alpha:]   isalpha	ASCII字母
*[:blank:]*	  [:blank:]		空格和制表符
*[:cntrl:]*	  [:cntrl:]   iscntrl	ASCII控制字符
*[:digit:]*	  [:digit:]		十进制数字'0'到'9'
*[:graph:]*	  [:graph:]   isgraph	ASCII可打印字符，不包括
					空格
*[:lower:]*	  [:lower:]   (1)	小写字母(当使用'ignorecase'时
					为所有字母)
*[:print:]*	  [:print:]   (2)	可打印字符，包括空格
*[:punct:]*	  [:punct:]   ispunct	ASCII标点字符
*[:space:]*	  [:space:]		空白字符：空格、制表符、CR、
					NL、垂直制表符、换页符
*[:upper:]*	  [:upper:]   (3)	大写字母(当使用'ignorecase'时
					为所有字母)
*[:xdigit:]*	  [:xdigit:]		十六进制数字：0-9、a-f、A-F
*[:return:]*	  [:return:]		<CR>字符
*[:tab:]*	  [:tab:]		<Tab>字符
*[:escape:]*	  [:escape:]		<Esc>字符
*[:backspace:]*	  [:backspace:]		<BS>字符
*[:ident:]*	  [:ident:]		标识符字符(与"\i"相同)
*[:keyword:]*	  [:keyword:]		关键字字符(与"\k"相同)
*[:fname:]*	  [:fname:]		文件名字符(与"\f"相同)
	  字符类表达式中的方括号是额外的，
	  用于分隔集合的方括号。例如，以下
	  是UNIX文件名的合理模式：
	  "[-./[:alnum:]_~]\+"。即，至少一个
	  字符的列表，每个字符是'-'、'.'、'/'、
	  字母、数字、'_'或'~'。
	  这些项目只适用于8位字符，除了
	  [:lower:]和[:upper:]在使用新的正则表达式
	  引擎时也适用于多字节字符。参见|two-engines|。
	  将来这些项目可能适用于多字节字符。
	  现在，要获取所有"alpha"字符，你可以使用：
	  [[:lower:][:upper:]]。

	  "函数"列显示使用什么库函数。
	  实现取决于系统。否则：
	  (1) 对ASCII使用islower()，对其他字符
	  使用Vim内置规则。
	  (2) 使用Vim内置规则
	  (3) 与(1)相同，但使用isupper()
							*/[[=* *[==]*
	- 等价类。这意味着匹配具有几乎相同含义的
	  字符，例如，忽略重音时。这只适用于Unicode、
	  latin1和latin9。形式是：
		[=a=]
							*/[[.* *[..]*
	- 排序元素。目前简单地接受单个字符，形式为：
		[.a.]
							  */\]*
	- 要在集合中包含字面']'、'^'、'-'或'\'，
	  在其前面放一个反斜杠："[xyz\]]"、
	  "[\^xyz]"、"[xy\-z]"和"[xyz\\]"。
	  (注意：POSIX不支持这种使用反斜杠的方式)。
	  对于']'，你也可以将其作为第一个字符
	  (在可能的"^"之后)："[]xyz]"或"[^]xyz]"。
	  对于'-'，你也可以将其作为第一个或最后一个
	  字符："[-xyz]"、"[^-xyz]"或"[xyz-]"。
	  对于'\'，你也可以让它后跟任何不在
	  "^]-\bdertnoUux"中的字符。"[\xyz]"匹配
	  '\'、'x'、'y'和'z"。不过最好使用"\\"，
	  将来的扩展可能使用'\'后的其他字符。
	- 省略结尾的]不被视为错误。"[]"像"[]]"
	  一样工作，它匹配']'字符。
	- 当'cpoptions'中不包含'l'标志时，
	  接受以下转换：
		\e	<Esc>
		\t	<Tab>
		\r	<CR>	(不是行尾！)
		\b	<BS>
		\n	换行，见上文 |/[\n]|
		\d123	字符的十进制数
		\o40	字符的八进制数，最多0o377
		\x20	字符的十六进制数，最多0xff
		\u20AC	多字节字符的十六进制数，最多0xffff
		\U1234	多字节字符的十六进制数，最多0xffffffff
	  注意：上面提到的其他反斜杠代码在[]内不起作用！
	- 使用集合匹配可能很慢，因为文本中的每个字符
	  都必须与集合中的每个字符比较。
	  尽可能使用上面的其他原子之一。例如：
	  "\d"比"[0-9]"快得多，并匹配相同的字符。
	  但是，新的|NFA|正则表达式引擎比旧的
	  更好地处理这个问题。

						*/\%[]* *E69* *E70* *E369*
\%[]	可选匹配原子的序列。这总是匹配。
	它尽可能多地匹配它包含的原子列表。
	因此它在第一个不匹配的原子处停止。
	例如：>
		/r\%[ead]
<	匹配"r"、"re"、"rea"或"read"。
	使用最长的匹配。
	要匹配Ex命令"function"，其中"fu"是必需的，
	"nction"是可选的，这可以工作：>
		/\<fu\%[nction]\>
<	使用词尾原子"\>"来避免匹配"full"中的"fu"。
	当原子不是普通字符时，它会变得更复杂。
	你不经常需要使用它，但这是可能的。示例：>
		/\<r\%[[eo]ad]\>
<	匹配词"r"、"re"、"ro"、"rea"、"roa"、"read"
	和"road"。
	[]内不能有\(\)、\%(\)或\z(\)项，
	且\%[]不能嵌套。
	要包含"["使用"[[]"，对于"]"使用"[]]"，
	例如：>
		/index\%[[[]0[]]]
<	匹配"index"、"index["、"index[0"和"index[0]"。

				*/\%d* */\%x* */\%o* */\%u* */\%U* *E678*

\%d123	匹配用十进制数指定的字符。必须后跟非数字。
\%o40	匹配用八进制数指定的字符，最多0o377。
	低于0o40的数字必须后跟非八进制数字或非数字。
\%x2a	匹配用最多两个十六进制字符指定的字符。
\%u20AC	匹配用最多四个十六进制字符指定的字符。
\%U1234abcd	匹配用最多八个十六进制字符指定的字符，
	最多0x7fffffff

==============================================================================
7. 在模式中忽略大小写					*/ignorecase*

如果'ignorecase'选项开启，普通字母的大小写被忽略。
可以设置'smartcase'来在模式只包含小写字母时忽略大小写。
							*/\c* */\C*
当"\c"出现在模式中的任何位置时，整个模式被处理为
好像'ignorecase'开启。忽略'ignorecase'和'smartcase'
的实际值。"\C"做相反的事：强制整个模式匹配大小写。
注意字符类不使用'ignorecase'、"\c"和"\C"。

示例：
      模式	'ignorecase'  'smartcase'	匹配 ~
	foo	  off		-		foo
	foo	  on		-		foo Foo FOO
	Foo	  on		off		foo Foo FOO
	Foo	  on		on		    Foo
	\cfoo	  -		-		foo Foo FOO
	foo\C	  -		-		foo

技术细节：				*NL-used-for-Nul*
文件中的<Nul>字符在内存中存储为<NL>。在显示中
它们显示为"^@"。这个转换在读写文件时进行。
要用搜索模式匹配<Nul>，你可以直接输入CTRL-@或
"CTRL-V 000"。这可能正是你期望的。在内部，
搜索模式中的字符被替换为<NL>。不寻常的是
输入CTRL-V CTRL-J也会插入<NL>，因此也会
搜索文件中的<Nul>。

						*CR-used-for-NL*
当'fileformat'是"mac"时，文件中的<NL>字符在内部
存储为<CR>字符。在文本中它们显示为"^J"。
否则这与<Nul>的使用类似。

当使用表达式求值时，模式中的<NL>字符匹配
字符串中的<NL>。使用"\n"(反斜杠n)来匹配<NL>
在那里不起作用，它只用于匹配缓冲区中的文本。

				*pattern-multi-byte* *pattern-multibyte*
模式也将与多字节字符一起工作，大多如你所期望的。
但无效字节可能导致问题，带有无效字节的模式
可能永远不会匹配。

==============================================================================
8. 组合字符					*patterns-composing*

							*/\Z*
当"\Z"出现在模式中的任何位置时，所有组合字符都被忽略。
因此只有基本字符需要匹配，组合字符可以不同，
组合字符的数量也可以不同。
例外：如果模式以一个或多个组合字符开始，
这些必须匹配。
							*/\%C*
使用"\%C"跳过任何组合字符。例如，模式"a"不匹配
"càt"中的"a"(其中a有组合字符0x0300)，
但"a\%C"匹配。注意这不匹配"cát"(其中á是字符
0xe1，它没有组合字符)。它匹配"cat"(其中a就是a)。

当组合字符出现在模式开始处或在不包括组合字符的
项目之后时，在任何包含此组合字符的字符处找到匹配。

当使用点和组合字符时，这与单独使用组合字符相同，
除了它不关心这之前是什么。

组合字符的顺序无关紧要。同样，文本可能有比模式
更多的组合字符，它仍然匹配。但模式中的所有组合字符
必须在文本中找到。

假设B是基本字符，x和y是组合字符：
	模式		文本		匹配 ~
	Bxy		Bxy		是(完美匹配)
	Bxy		Byx		是(忽略顺序)
	Bxy		By		否(x缺失)
	Bxy		Bx		否(y缺失)
	Bx		Bx		是(完美匹配)
	Bx		By		否(x缺失)
	Bx		Bxy		是(忽略额外的y)
	Bx		Byx		是(忽略额外的y)

==============================================================================
9. 与Perl模式比较				*perl-patterns*

Vim的正则表达式最类似于Perl的，就功能而言。
它们之间的区别主要只是表示法；这里是它们
不同的地方总结：

功能			在Vim中		在Perl中 ~
强制忽略大小写	\c		(?i)
强制匹配大小写		\C		(?-i)
无反向引用分组		\%(atom\)	(?:atom)
保守量词	\{-n,m}		`*?,` +?, ??, {}?
0宽度匹配			atom\@=		(?=atom)
0宽度非匹配		atom\@!		(?!atom)
0宽度前向匹配		atom\@<=	(?<=atom)
0宽度前向非匹配	atom\@<!	(?<!atom)
无重试匹配		atom\@>		(?>atom)

Vim和Perl处理字符串中的换行字符有点不同：

在Perl中，^和$默认只匹配文本的最开始和结束，
但你可以设置'm'标志，让它们也匹配嵌入的换行。
你还可以设置's'标志，让.也匹配换行。
(这两个标志都可以使用与上面i标志相同的语法
在模式内部更改，顺便说一下。)

另一方面，Vim的^和$总是匹配嵌入的换行，
你得到两个单独的原子，\%^和\%$，它们只匹配
文本的最开始和结束。Vim通过给你\_"修饰符"
解决第二个问题：把它放在.或字符类前面，
它们也会匹配换行。

最后，这些构造是Perl独有的：
- 在正则表达式中执行任意代码：(?{perl code})
- 条件表达式：(?(condition)true-expr|false-expr)

...而这些是Vim独有的：
- 改变模式的魔法性：\v \V \m \M
   (对于避免反斜杠过多非常有用)
- 可选匹配原子序列：\%[atoms]
- \&(对\|就像"and"对"or"；它强制几个分支
  在一个位置匹配)
- 按行号/列号匹配：\%5l \%5c \%5v
- 设置匹配的开始和结束：\zs \ze

==============================================================================
10. 高亮匹配				*match-highlight*

							*syntax-vs-match*
		注意匹配高亮机制独立于|syntax-highlighting|，
			后者(通常)是缓冲区局部的高亮，
			而匹配是窗口局部的，两种方法可以
			自由混合。匹配高亮函数给你更多
			灵活性，但通常只用于临时高亮，
			没有严格的规则。两种方法都可以
			用来隐藏文本。

			因此像|matchadd()|这样的匹配函数不会
			考虑语法规则，而像|synconcealed()|这样的
			函数也不会考虑匹配规则，反之亦然。

							*:mat* *:match*
:mat[ch] {group} /{pattern}/
			在当前窗口中定义一个要高亮的模式。
			它将用{group}高亮显示。示例：>
				:highlight MyGroup ctermbg=green guibg=green
				:match MyGroup /TODO/
<			除了//，任何字符都可以用来标记{pattern}
			的开始和结束。注意使用特殊字符，
			如'"'和'|'。

			{group}在执行此命令时必须存在。

			{group}高亮在字符要为'hlsearch'高亮时
			仍然适用，因为匹配的高亮优先级高于
			'hlsearch'。语法高亮(参见'syntax')
			也被匹配覆盖。

			注意使用'hlsearch'高亮最后使用的搜索模式
			在所有窗口中使用，而用":match"定义的
			模式只存在于当前窗口。切换到另一个
			缓冲区时它会被保留。

			'ignorecase'不适用，在模式中使用|/\c|
			来忽略大小写。否则不忽略大小写。

			'redrawtime'定义搜索模式匹配的最大时间。

			当匹配行尾且Vim只重绘部分显示时，
			你可能得到意外的结果。这是因为Vim
			在重绘开始的行中查找匹配。

			也参见|matcharg()|和|getmatches()|。
			前者返回之前|:match|命令的高亮组和模式。
			后者返回由|matchadd()|和|:match|定义的
			高亮组和模式列表。

			使用|:match|高亮匹配限制为三个匹配
			(除了|:match|，还有|:2match|和|:3match|可用)。
			|matchadd()|没有这个限制，此外还使
			优先化匹配成为可能。

			另一个示例，高亮虚拟列72及以上的所有字符：>
				:highlight rightMargin term=bold ctermfg=blue guifg=blue
				:match rightMargin /.\%>72v/
<			要高亮虚拟列7中的所有字符：>
				:highlight col8 ctermbg=grey guibg=grey
				:match col8 /\%<8v.\%>7v/
<			注意使用两个项目来也匹配占用多个虚拟列的
			字符，如TAB。

:mat[ch]
:mat[ch] none
			清除之前定义的匹配模式。


:2mat[ch] {group} /{pattern}/					*:2match*
:2mat[ch]
:2mat[ch] none
:3mat[ch] {group} /{pattern}/					*:3match*
:3mat[ch]
:3mat[ch] none
			就像上面的|:match|，但设置一个单独的匹配。
			因此可以同时有三个活动的匹配。
			如果几个匹配在同一位置，编号最低的
			匹配有优先级。它使用匹配id 3。
			":3match"命令被(较旧的Vims)|matchparen|
			插件使用。建议你使用":match"进行手动匹配，
			":2match"用于另一个插件，或者更好的是
			使用更灵活的|matchadd()|(和类似)函数。

==============================================================================
11. 模糊匹配					*fuzzy-matching*

模糊匹配指的是使用非精确搜索字符串来匹配字符串。
如果搜索字符串中的所有字符以相同顺序出现在字符串中的
任何位置，模糊匹配将匹配该字符串。忽略大小写。
在匹配的字符串中，搜索字符串中两个连续字符之间
可以存在其他字符。如果搜索字符串有多个词，则
每个词单独匹配。因此搜索字符串中的词可以以任何
顺序出现在字符串中。

模糊匹配根据以下标准为每个匹配的字符串分配分数：
    - 顺序匹配的字符数。
    - 两个连续匹配字符之间的字符数(距离)。
    - 词首的匹配
    - 驼峰大小写字符的匹配(例如CamelCase中的Case)
    - 路径分隔符或连字符后的匹配。
    - 字符串中未匹配的字符数。
    - 优先完全/精确匹配。
得分最高的匹配字符串首先返回。

例如，当你使用模糊匹配搜索"get pat"字符串时，它将
匹配"GetPattern"、"PatternGet"、"getPattern"、
"patGetter"、"getSomePattern"、"MatchpatternGet"等。

|matchfuzzy()|和|matchfuzzypos()|函数可用于在字符串
列表中模糊搜索字符串。matchfuzzy()函数返回匹配字符串
的列表。matchfuzzypos()函数返回匹配列表、匹配位置
和模糊匹配分数。

`:vimgrep`的"f"标志启用模糊匹配。

要为|ins-completion|启用模糊匹配，将"fuzzy"值添加到
'completeopt'选项。

 vim:tw=78:ts=8:noet:ft=help:norl:
