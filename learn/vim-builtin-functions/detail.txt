*builtin.txt*	Nvim


		  NVIM 参考手册


内置函数		*vimscript-functions* *builtin-functions*

按用途分组的函数列表请参见 |function-list|。

				      输入 |gO| 查看目录。
==============================================================================
1. 详细说明					*builtin-function-details*

abs({expr})                                                              *abs()*
		返回 {expr} 的绝对值。当 {expr} 求值为 |Float| 时，abs() 返回 |Float|。
		当 {expr} 可以转换为 |Number| 时，abs() 返回 |Number|。否则 abs() 
		会给出错误消息并返回 -1。
		示例：>vim
			echo abs(1.456)
<			1.456  >vim
			echo abs(-5.456)
<			5.456  >vim
			echo abs(-4)
<			4

                参数：~
                  • {expr} (`number`)

                返回值：~
                  (`number`)

acos({expr})                                                            *acos()*
		返回 {expr} 的反余弦值，以弧度为单位，作为 |Float| 在 [0, pi] 范围内。
		{expr} 必须求值为 |Float| 或 |Number|，且在 [-1, 1] 范围内。
		如果 {expr} 超出 [-1, 1] 范围，则返回 NaN。如果 {expr} 不是 |Float| 
		或 |Number|，则返回 0.0。
		示例：>vim
			echo acos(0)
<			1.570796 >vim
			echo acos(-0.5)
<			2.094395

                参数：~
                  • {expr} (`number`)

                返回值：~

                  (`number`)

add({object}, {expr})                                                    *add()*
		将项目 {expr} 追加到 |List| 或 |Blob| {object} 中。返回结果 |List| 
		或 |Blob|。示例：>vim
			let alist = add([1, 2, 3], item)
			call add(mylist, "woodstock")
<		注意，当 {expr} 是 |List| 时，它会被作为单个项目追加。使用 |extend()| 
		来连接 |Lists|。
		当 {object} 是 |Blob| 时，{expr} 必须是数字。
		使用 |insert()| 在另一个位置添加项目。
		如果 {object} 不是 |List| 或 |Blob|，则返回 1。

                参数：~
                  • {object} (`any`)
                  • {expr} (`any`)

                返回值：~
                  (`any`) 结果 |List| 或 |Blob|，如果 {object} 不是 |List| 或 |Blob|，
                  则返回 1。

and({expr}, {expr})                                                      *and()*
		对两个参数进行按位与运算。参数会被转换为数字。List、Dict 或 Float 
		参数会导致错误。另请参见 `or()` 和 `xor()`。
		示例：>vim
			let flag = and(bits, 0x80)
<

                参数：~
                  • {expr} (`number`)
                  • {expr1} (`number`)

                返回值：~
                  (`integer`)

api_info()                                                          *api_info()*
		返回 |api-metadata| 的 Dictionary。

		以人类可读的格式查看：>vim
		       lua vim.print(vim.fn.api_info())
<

                返回值：~
                  (`table`)

append({lnum}, {text})                                                *append()*
		当 {text} 是 |List| 时：将 |List| 的每个项目作为文本行追加到当前缓冲区
		的第 {lnum} 行下方。否则将 {text} 作为一行文本追加到当前缓冲区的第 
		{lnum} 行下方。

		当前缓冲区。
		接受任何类型的项目并将其转换为字符串。
		{lnum} 可以是 0，表示在第一行之前插入一行。
		{lnum} 的使用方式与 |getline()| 相同。
		失败时返回 1（{lnum} 超出范围或内存不足），成功时返回 0。
		当 {text} 是空列表时，无论 {lnum} 的值如何，都返回 0。
		示例：>vim
			let failed = append(line('$'), "# THE END")
			let failed = append(0, ["Chapter 1", "the beginning"])
<

                参数：~
                  • {lnum} (`integer|string`)
                  • {text} (`string|string[]`)

                返回值：~
                  (`0|1`)

appendbufline({buf}, {lnum}, {text})                           *appendbufline()*
		类似于 |append()|，但在缓冲区 {expr} 中追加文本。

		此函数仅适用于已加载的缓冲区。如果需要，请先调用 |bufload()|。

		关于 {buf} 的使用，请参见 |bufname()|。

		{lnum} 是要在其下方追加的行号。请注意，使用 |line()| 会使用当前缓冲区，
		而不是要追加的缓冲区。使用 "$" 在缓冲区末尾追加。不支持其他字符串值。

		成功时返回 0，失败时返回 1。

		如果 {buf} 不是有效的缓冲区或 {lnum} 无效，则会给出错误消息。
		示例：>vim
			let failed = appendbufline(13, 0, "# THE START")
<		但是，当 {text} 是空列表时，对于无效的 {lnum} 不会给出错误，
		因为 {lnum} 实际上并未使用。

                参数：~
                  • {buf} (`integer|string`)
                  • {lnum} (`integer`)
                  • {text} (`string`)

                返回值：~
                  (`0|1`)

argc([{winid}])                                                         *argc()*
		结果是参数列表中的文件数量。参见 |arglist|。

		如果未提供 {winid}，则使用当前窗口的参数列表。
		如果 {winid} 是 -1，则使用全局参数列表。
		否则 {winid} 指定要使用其参数列表的窗口：可以是窗口编号或窗口 ID。
		如果 {winid} 参数无效，则返回 -1。

                参数：~
                  • {winid} (`integer?`)

                返回值：~
                  (`integer`)

argidx()                                                              *argidx()*
		结果是参数列表中的当前索引。0 是第一个文件。argc() - 1 是最后一个。
		参见 |arglist|。

                返回值：~
                  (`integer`)

arglistid([{winnr} [, {tabnr}]])                                   *arglistid()*
		返回参数列表 ID。这是一个标识正在使用的参数列表的数字。
		零用于全局参数列表。参见 |arglist|。
		如果参数无效，则返回 -1。

		不带参数时使用当前窗口。
		仅使用 {winnr} 时，在当前标签页中使用此窗口。
		使用 {winnr} 和 {tabnr} 时，在指定的标签页中使用窗口。
		{winnr} 可以是窗口编号或 |window-ID|。

                参数：~
                  • {winnr} (`integer?`)
                  • {tabnr} (`integer?`)

                返回值：~
                  (`integer`)

argv([{nr} [, {winid}]])                                                *argv()*
		结果是参数列表中的第 {nr} 个文件。参见 |arglist|。
		"argv(0)" 是第一个。示例：>vim
			let i = 0
			while i < argc()
			  let f = escape(fnameescape(argv(i)), '.')
			  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'
			  let i = i + 1
			endwhile
<		没有 {nr} 参数时，或当 {nr} 是 -1 时，返回包含整个 |arglist| 的 |List|。

		{winid} 参数指定窗口 ID，参见 |argc()|。
		关于 Vim 命令行参数，请参见 |v:argv|。

		如果参数列表中没有第 {nr} 个参数，则返回空字符串。
		如果 {winid} 参数无效，则返回空列表。

                参数：~
                  • {nr} (`integer?`)
                  • {winid} (`integer?`)

                返回值：~
                  (`string|string[]`)

asin({expr})                                                            *asin()*
		返回 {expr} 的反正弦值，以弧度为单位，作为 |Float| 在 [-pi/2, pi/2] 
		范围内。
		{expr} 必须求值为 |Float| 或 |Number|，且在 [-1, 1] 范围内。
		如果 {expr} 超出 [-1, 1] 范围，则返回 NaN。如果 {expr} 不是 |Float| 
		或 |Number|，则返回 0.0。
		示例：>vim
			echo asin(0.8)
<			0.927295 >vim
			echo asin(-0.5)
<			-0.523599

                参数：~
                  • {expr} (`any`)

                返回值：~
                  (`number`)

assert_beeps({cmd})                                             *assert_beeps()*
		运行 {cmd}，如果它没有产生蜂鸣声或视觉铃声，则向 |v:errors| 
		添加错误消息。
		另请参见 |assert_fails()|、|assert_nobeep()| 和 |assert-return|。

                参数：~
                  • {cmd} (`string`)

                返回值：~
                  (`0|1`)

assert_equal({expected}, {actual} [, {msg}])                    *assert_equal()*
		当 {expected} 和 {actual} 不相等时，向 |v:errors| 添加错误消息并返回 1。
		否则返回 0。|assert-return|

		错误消息的形式为"Expected {expected} but got {actual}"。
		当存在 {msg} 时，它会作为前缀添加到该消息中，同时添加从脚本运行时
		assert 的位置。

		没有自动转换，字符串 "4" 与数字 4 不同。数字 4 与浮点数 4.0 不同。
		这里不使用 'ignorecase' 的值，大小写总是有区别的。
		示例：>vim
			call assert_equal('foo', 'bar', 'baz')
<		将向 |v:errors| 添加以下内容：
			test.vim line 12: baz: Expected 'foo' but got 'bar' ~

                参数：~
                  • {expected} (`any`)
                  • {actual} (`any`)
                  • {msg} (`any?`)

                返回值：~
                  (`0|1`)

assert_equalfile({fname_one}, {fname_two})                  *assert_equalfile()*
		当文件 {fname_one} 和 {fname_two} 不包含完全相同的文本时，向 
		|v:errors| 添加错误消息。另请参见 |assert-return|。
		当 {fname_one} 或 {fname_two} 不存在时，错误消息会提到这一点。

                参数：~
                  • {fname_one} (`string`)
                  • {fname_two} (`string`)

                返回值：~
                  (`0|1`)

assert_exception({error} [, {msg}])                         *assert_exception()*
		当 v:exception 不包含字符串 {error} 时，向 |v:errors| 添加错误消息。
		另请参见 |assert-return|。
		这可用于断言命令会抛出异常。
		使用错误号，后跟冒号，可以避免翻译问题：>vim
			try
			  commandthatfails
			  call assert_false(1, 'command should have failed')
			catch
			  call assert_exception('E492:')
			endtry
<

                参数：~
                  • {error} (`any`)
                  • {msg} (`any?`)

                返回值：~
                  (`0|1`)

                                                                *assert_fails()*
assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])
		运行 {cmd}，如果它没有产生错误或错误消息中没有找到 {error}，
		则向 |v:errors| 添加错误消息。另请参见 |assert-return|。

		当 {error} 是字符串时，它必须字面出现在第一个报告的错误中。
		最常见的是错误代码，包括冒号，例如 "E123:"。>vim
			call assert_fails('bad cmd', 'E987:')
<
		当 {error} 是包含一个或两个字符串的 |List| 时，这些字符串用作模式。
		第一个模式与第一个报告的错误匹配：>vim
			call assert_fails('cmd', ['E987:.*expected bool'])
<		如果存在第二个模式，则与最后一个报告的错误匹配。
		要只匹配最后一个错误，对第一个错误使用空字符串：>vim
			call assert_fails('cmd', ['', 'E987:'])
<
		如果 {msg} 为空，则不使用它。这样做是为了在传递 {lnum} 参数时
		获得默认消息。
							*E1115*
		当 {lnum} 存在且不为负数，且 {error} 参数存在且匹配时，
		则将其与报告错误的行号进行比较。这可以是函数或脚本中的行号。
							*E1116*
		当 {context} 存在时，它被用作模式并与 {lnum} 所在位置的上下文
		（脚本名称或函数名称）进行匹配。

		请注意，蜂鸣声不被视为错误，一些失败的命令只会发出蜂鸣声。
		对于这些情况，请使用 |assert_beeps()|。

                参数：~
                  • {cmd} (`string`)
                  • {error} (`any?`)
                  • {msg} (`any?`)
                  • {lnum} (`integer?`)
                  • {context} (`any?`)

                返回值：~
                  (`0|1`)


assert_false({actual} [, {msg}])                                *assert_false()*
		当 {actual} 不为假时，向 |v:errors| 添加错误消息，类似于 |assert_equal()|。
		错误消息的形式为"Expected False but got {actual}"。
		当 {msg} 存在时，它会作为前缀添加到该消息中，同时添加从脚本运行时
		assert 的位置。另请参见 |assert-return|。

		当值为零时，它被认为是假。当 {actual} 不是数字时，断言失败。

                参数：~
                  • {actual} (`any`)
                  • {msg} (`any?`)

                返回值：~
                  (`0|1`)

assert_inrange({lower}, {upper}, {actual} [, {msg}])          *assert_inrange()*
		这个断言用于数字和 |Float| 值。当 {actual} 低于 {lower} 或高于 {upper} 
		时，向 |v:errors| 添加错误消息。另请参见 |assert-return|。
		错误消息的形式为"Expected range {lower} - {upper}, but got {actual}"。
		当 {msg} 存在时，它会作为前缀添加到该消息中。

                参数：~
                  • {lower} (`number`)
                  • {upper} (`number`)
                  • {actual} (`number`)
                  • {msg} (`string?`)

                返回值：~
                  (`0|1`)

assert_match({pattern}, {actual} [, {msg}])                     *assert_match()*
		当 {pattern} 不匹配 {actual} 时，向 |v:errors| 添加错误消息。
		另请参见 |assert-return|。
		错误消息的形式为"Pattern {pattern} does not match {actual}"。
		当 {msg} 存在时，它会作为前缀添加到该消息中，同时添加从脚本运行时
		assert 的位置。

		{pattern} 的使用方式与 |expr-=~| 相同：匹配总是像设置了 'magic' 
		且 'cpoptions' 为空一样进行，无论 'magic' 或 'cpoptions' 的实际值如何。

		{actual} 被用作字符串，应用自动转换。
		使用 "^" 和 "$" 来匹配文本的开头和结尾。
		同时使用两者来匹配整个文本。

		示例：>vim
			call assert_match('^f.*o$', 'foobar')
<		将导致向 |v:errors| 添加字符串：
			test.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~

                参数：~
                  • {pattern} (`string`)
                  • {actual} (`string`)
                  • {msg} (`string?`)

                返回值：~
                  (`0|1`)

assert_nobeep({cmd})                                           *assert_nobeep()*
		运行 {cmd}，如果它产生蜂鸣声或视觉铃声，则向 |v:errors| 添加错误消息。
		另请参见 |assert_beeps()|。

                参数：~
                  • {cmd} (`string`)

                返回值：~
                  (`0|1`)

assert_notequal({expected}, {actual} [, {msg}])              *assert_notequal()*
		`assert_equal()` 的反向操作：当 {expected} 和 {actual} 相等时，
		向 |v:errors| 添加错误消息。另请参见 |assert-return|。

                参数：~
                  • {expected} (`any`)
                  • {actual} (`any`)
                  • {msg} (`any?`)

                返回值：~
                  (`0|1`)

assert_notmatch({pattern}, {actual} [, {msg}])               *assert_notmatch()*
		`assert_match()` 的反向操作：当 {pattern} 匹配 {actual} 时，
		向 |v:errors| 添加错误消息。另请参见 |assert-return|。

                参数：~
                  • {pattern} (`string`)
                  • {actual} (`string`)
                  • {msg} (`string?`)

                返回值：~
                  (`0|1`)

assert_report({msg})                                           *assert_report()*
		直接使用字符串 {msg} 报告测试失败。
		总是返回 1。

                参数：~
                  • {msg} (`string`)

                返回值：~
                  (`0|1`)

assert_true({actual} [, {msg}])                                  *assert_true()*
		当 {actual} 不为真时，向 |v:errors| 添加错误消息，类似于 |assert_equal()|。
		另请参见 |assert-return|。
		当值为非零数字或 |v:true| 时，它被认为是 |TRUE|。
		当 {actual} 不是数字或 |v:true| 时，断言失败。
		当给出 {msg} 时，它会作为前缀添加到默认消息中，同时添加从脚本运行时
		assert 的位置。

                参数：~
                  • {actual} (`any`)
                  • {msg} (`string?`)

                返回值：~
                  (`0|1`)

atan({expr})                                                            *atan()*
		返回 {expr} 的反正切主值，以弧度为单位，作为 |Float| 在 [-pi/2, +pi/2] 
		范围内。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：>vim
			echo atan(100)
<			1.560797 >vim
			echo atan(-4.01)
<			-1.326405

                参数：~
                  • {expr} (`number`)

                返回值：~
                  (`number`)

atan2({expr1}, {expr2})                                                *atan2()*
		返回 {expr1} / {expr2} 的反正切值，以弧度为单位，作为 |Float| 在 
		[-pi, pi] 范围内。
		{expr1} 和 {expr2} 必须求值为 |Float| 或 |Number|。
		如果 {expr1} 或 {expr2} 不是 |Float| 或 |Number|，则返回 0.0。

		示例：>vim
			echo atan2(-1, 1)
<			-0.785398 >vim
			echo atan2(1, -1)
<			2.356194

                参数：~
                  • {expr1} (`number`)
                  • {expr2} (`number`)

                返回值：~
                  (`number`)

blob2list({blob})                                                  *blob2list()*
		返回一个 List，包含 Blob {blob} 中每个字节的数值。
		示例：>vim
			blob2list(0z0102.0304)	" 返回 [1, 2, 3, 4]
			blob2list(0z)		" 返回 []
<		错误时返回空列表。|list2blob()| 执行相反的操作。

                参数：~
                  • {blob} (`any`)

                返回值：~
                  (`any[]`)

browse({save}, {title}, {initdir}, {default})                         *browse()*
		显示文件选择器。这仅在 "has("browse")" 返回 |TRUE| 时有效
		（仅在某些 GUI 版本中）。
		输入字段为：
		    {save}	当为 |TRUE| 时，选择要写入的文件
		    {title}	选择器的标题
		    {initdir}	开始浏览的目录
		    {default}	默认文件名
		当点击"取消"按钮、出现错误或无法浏览时，返回空字符串。

                参数：~
                  • {save} (`any`)
                  • {title} (`string`)
                  • {initdir} (`string`)
                  • {default} (`string`)

                返回值：~
                  (`0|1`)

browsedir({title}, {initdir})                                      *browsedir()*
		显示目录选择器。这仅在 "has("browse")" 返回 |TRUE| 时有效
		（仅在某些 GUI 版本中）。

		在不支持目录浏览器的系统上，使用文件浏览器。在这种情况下：
		选择要使用的目录中的文件。
		输入字段为：
		    {title}	选择器的标题
		    {initdir}	开始浏览的目录
		当点击"取消"按钮、出现错误或无法浏览时，返回空字符串。

                参数：~
                  • {title} (`string`)
                  • {initdir} (`string`)

                返回值：~
                  (`0|1`)

bufadd({name})                                                        *bufadd()*
		将名为 {name} 的缓冲区添加到缓冲区列表（必须是字符串）。
		如果文件 {name} 的缓冲区已存在，则返回该缓冲区编号。
		否则返回新创建的缓冲区的编号。当 {name} 是空字符串时，
		总是创建新缓冲区。
		缓冲区不会设置 'buflisted' 且尚未加载。
		要向缓冲区添加一些文本，请使用以下方法：>vim
			let bufnr = bufadd('someName')
			call bufload(bufnr)
			call setbufline(bufnr, 1, ['some', 'text'])
<		错误时返回 0。

                参数：~
                  • {name} (`string`)

                返回值：~
                  (`integer`)

bufexists({buf})                                                   *bufexists()*
		结果是一个数字，如果名为 {buf} 的缓冲区存在，则为 |TRUE|。
		如果 {buf} 参数是数字，则使用缓冲区编号。
		数字零是当前窗口的备用缓冲区。

		如果 {buf} 参数是字符串，它必须完全匹配缓冲区名称。
		名称可以是：
		- 相对于当前目录。
		- 完整路径。
		- 设置了 'buftype' 为 "nofile" 的缓冲区名称。
		- URL 名称。
		未列出的缓冲区也会被找到。
		请注意，帮助文件按其短名称列出在
		|:buffers| 的输出中，但 bufexists() 需要使用其长名称才能找到它们。
		bufexists() 可能报告缓冲区存在，但要使用 |:buffer| 命令，
		您可能需要使用 |expand()|。特别是对于 MS-Windows 8.3 格式的
		名称，如 "c:\DOCUME~1"。
		使用 "bufexists(0)" 来测试备用文件名的存在。

                参数：~
                  • {buf} (`any`)

                返回值：~
                  (`0|1`)

buflisted({buf})                                                   *buflisted()*
		结果是一个数字，如果名为 {buf} 的缓冲区存在且已列出
		（设置了 'buflisted' 选项），则为 |TRUE|。
		{buf} 参数的使用方式与 |bufexists()| 相同。

                参数：~
                  • {buf} (`any`)

                返回值：~
                  (`0|1`)

bufload({buf})                                                       *bufload()*
		确保缓冲区 {buf} 已加载。当缓冲区名称引用现有文件时，
		将读取该文件。否则缓冲区将为空。如果缓冲区已经加载，
		则不会有变化。如果缓冲区与文件无关，则不会读取文件
		（例如，当 'buftype' 为 "nofile" 时）。
		如果缓冲区的文件存在交换文件，将不会有对话框，
		缓冲区无论如何都会被加载。
		{buf} 参数的使用方式与 |bufexists()| 相同。

                参数：~
                  • {buf} (`any`)

bufloaded({buf})                                                   *bufloaded()*
		结果是一个数字，如果名为 {buf} 的缓冲区存在且已加载
		（显示在窗口中或隐藏），则为 |TRUE|。
		{buf} 参数的使用方式与 |bufexists()| 相同。

                参数：~
                  • {buf} (`any`)

                返回值：~
                  (`0|1`)

bufname([{buf}])                                                     *bufname()*
		结果是缓冲区的名称。主要是由 `:ls` 命令显示的名称，
		但不使用特殊名称，如 "[No Name]"。
		如果省略 {buf}，则使用当前缓冲区。
		如果 {buf} 是数字，则给出该缓冲区编号的名称。
		数字零是当前窗口的备用缓冲区。
		如果 {buf} 是字符串，它被用作 |file-pattern| 来匹配缓冲区名称。
		这总是像设置了 'magic' 且 'cpoptions' 为空一样进行。
		当有多个匹配时，返回空字符串。
		"" 或 "%" 可用于当前缓冲区，"#" 用于备用缓冲区。
		优先完全匹配，否则接受缓冲区名称开头、结尾或中间的匹配。
		如果只想要完全匹配，则在模式的开头加上 "^"，在结尾加上 "$"。
		首先查找列出的缓冲区。如果有一个列出的缓冲区匹配，则返回该缓冲区。
		接下来搜索未列出的缓冲区。
		如果 {buf} 是字符串，但您想将其用作缓冲区编号，则通过加零强制其为数字：>vim
			echo bufname("3" + 0)
<		如果缓冲区不存在，或没有名称，则返回空字符串。>vim
			echo bufname("#")	" 备用缓冲区名称
			echo bufname(3)		" 缓冲区 3 的名称
			echo bufname("%")	" 当前缓冲区的名称
			echo bufname("file2")	" 匹配 "file2" 的缓冲区名称。
<

                参数：~
                  • {buf} (`integer|string?`)

                返回值：~
                  (`string`)

bufnr([{buf} [, {create}]])                                            *bufnr()*
		结果是缓冲区的编号，如 `:ls` 命令显示的那样。
		关于 {buf} 的使用，请参见上面的 |bufname()|。
		如果缓冲区不存在，则返回 -1。或者，如果存在 {create} 参数且为 TRUE，
		则创建新的未列出的缓冲区并返回其编号。
		bufnr("$") 是最后一个缓冲区：>vim
			let last_buffer = bufnr("$")
<		结果是一个数字，它是现有缓冲区的最高编号。
		请注意，并非所有编号较小的缓冲区都一定存在，因为 ":bwipeout" 
		可能已经删除了它们。使用 bufexists() 来测试缓冲区的存在。

                参数：~
                  • {buf} (`integer|string?`)
                  • {create} (`any?`)

                返回值：~
                  (`integer`)

bufwinid({buf})                                                     *bufwinid()*
		结果是一个数字，它是与缓冲区 {buf} 关联的第一个窗口的 |window-ID|。
		关于 {buf} 的使用，请参见上面的 |bufname()|。
		如果缓冲区 {buf} 不存在或没有这样的窗口，则返回 -1。
		示例：>vim

			echo "A window containing buffer 1 is " .. (bufwinid(1))
<
		仅处理当前标签页。要查找更多，请参见 |win_findbuf()|。

                参数：~
                  • {buf} (`any`)

                返回值：~
                  (`integer`)

bufwinnr({buf})                                                     *bufwinnr()*
		类似于 |bufwinid()|，但返回窗口编号而不是 |window-ID|。
		如果缓冲区 {buf} 不存在或没有这样的窗口，则返回 -1。
		示例：>vim

			echo "A window containing buffer 1 is " .. (bufwinnr(1))

<		该编号可用于 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。

                参数：~
                  • {buf} (`any`)

                返回值：~
                  (`integer`)

byte2line({byte})                                                  *byte2line()*
		返回当前缓冲区中字节计数 {byte} 处的字符所在的行号。
		这包括行尾字符，取决于当前缓冲区的 'fileformat' 选项。
		第一个字符的字节计数为一。
		另请参见 |line2byte()|、|go| 和 |:goto|。

		如果 {byte} 值无效，则返回 -1。


                参数：~
                  • {byte} (`any`)

                返回值：~
                  (`integer`)

byteidx({expr}, {nr} [, {utf16}])                                    *byteidx()*
		返回字符串 {expr} 中第 {nr} 个字符的字节索引。
		对第一个字符使用零，然后返回零。
		如果没有多字节字符，返回值等于 {nr}。
		组合字符不单独计数，它们的字节长度被添加到前面的基础字符中。
		有关单独计数组合字符，请参见下面的 |byteidxcomp()|。
		当存在 {utf16} 且为 TRUE 时，{nr} 被用作字符串 {expr} 中的
		UTF-16 索引，而不是字符索引。
		UTF-16 索引是字符串以 16 位字编码时的索引。
		如果指定的 UTF-16 索引在字符的中间（例如在 4 字节字符中），
		则返回字符中第一个字节的字节索引。
		有关更多信息，请参见 |string-offset-encoding|。
		示例：>vim
			echo matchstr(str, ".", byteidx(str, 3))
<		将显示第四个字符。另一种做同样事情的方法：>vim
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		另请参见 |strgetchar()| 和 |strcharpart()|。

		如果字符少于 {nr} 个，则返回 -1。
		如果正好有 {nr} 个字符，则返回字符串的字节长度。
		有关从字节索引获取字符和 UTF-16 索引，请参见 |charidx()| 和 |utf16idx()|。
		示例：>vim
			echo byteidx('a😊😊', 2)	" 返回 5
			echo byteidx('a😊😊', 2, 1)	" 返回 1
			echo byteidx('a😊😊', 3, 1)	" 返回 5
<

                参数：~
                  • {expr} (`any`)
                  • {nr} (`integer`)
                  • {utf16} (`any?`)

                返回值：~
                  (`integer`)

byteidxcomp({expr}, {nr} [, {utf16}])                            *byteidxcomp()*
		类似于 byteidx()，但组合字符被单独计数。
		示例：>vim
			let s = 'e' .. nr2char(0x301)
			echo byteidx(s, 1)
			echo byteidxcomp(s, 1)
			echo byteidxcomp(s, 2)
<		第一个和第三个 echo 结果为 3（'e' 加上组合字符是 3 字节），
		第二个 echo 结果为 1（'e' 是一个字节）。

                参数：~
                  • {expr} (`any`)
                  • {nr} (`integer`)
                  • {utf16} (`any?`)

                返回值：~
                  (`integer`)

call({func}, {arglist} [, {dict}])                                 *call()* *E699*
		使用 |List| {arglist} 中的项目作为参数调用函数 {func}。
		{func} 可以是 |Funcref| 或函数名称。
		a:firstline 和 a:lastline 被设置为光标行。
		返回被调用函数的返回值。
		{dict} 用于具有 "dict" 属性的函数。它将用于设置局部变量 "self"。
		|Dictionary-function|

                参数：~
                  • {func} (`any`)
                  • {arglist} (`any`)
                  • {dict} (`any?`)

                返回值：~
                  (`any`)

ceil({expr})                                                            *ceil()*
		返回大于或等于 {expr} 的最小整数值，作为 |Float|（向上取整）。
		{expr} 必须求值为 |Float| 或 |Number|。
		示例：>vim
			echo ceil(1.456)
<			2.0  >vim
			echo ceil(-5.456)
<			-5.0  >vim
			echo ceil(4.0)
<			4.0

		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。

                参数：~
                  • {expr} (`number`)

                返回值：~
                  (`number`)

chanclose({id} [, {stream}])                                       *chanclose()*
		关闭通道或与其关联的特定流。
		对于作业，{stream} 可以是 "stdin"、"stdout"、"stderr" 或 "rpc" 
		（关闭使用 `"rpc":v:true` 启动的作业的 stdin/stdout）。
		如果省略 {stream}，则关闭所有流。
		如果通道是 pty，这将关闭 pty 主设备，向作业进程发送 SIGHUP。
		对于套接字，只有一个流，应省略 {stream}。

                参数：~
                  • {id} (`integer`)
                  • {stream} (`string?`)

                返回值：~
                  (`0|1`)

changenr()                                                          *changenr()*
		返回最近更改的编号。这与 |:undolist| 显示的数字相同，
		可用于 |:undo| 命令。
		当进行更改时，它是该更改的编号。重做后，它是重做更改的编号。
		撤销后，它是被撤销更改的编号减一。
		如果撤销列表为空，则返回 0。

                返回值：~
                  (`integer`)

chansend({id}, {data})                                              *chansend()*
		向通道 {id} 发送数据。对于作业，它将其写入进程的 stdin。
		对于 stdio 通道 |channel-stdio|，它写入 Nvim 的 stdout。
		如果写入成功，则返回写入的字节数，否则返回 0。
		有关更多信息，请参见 |channel-bytes|。

		{data} 可以是字符串、可转换为字符串、|Blob| 或列表。
		如果 {data} 是列表，项目将由换行符连接；项目中的任何换行符
		将作为 NUL 发送。要发送最终的换行符，请包含一个最终的空字符串。
		示例：>vim
			call chansend(id, ["abc", "123\n456", ""])
<		将发送 "abc<NL>123<NUL>456<NL>"。
		chansend() 写入原始数据，而不是 RPC 消息。
		如果通道是使用 `"rpc":v:true` 创建的，则通道期望 RPC 消息，
		请改用 |rpcnotify()| 和 |rpcrequest()|。

                参数：~
                  • {id} (`number`)
                  • {data} (`string|string[]`)

                返回值：~
                  (`0|1`)

char2nr({string} [, {utf8}])                                         *char2nr()*
		返回 {string} 中第一个字符的数字值。
		示例：>vim
			echo char2nr(" ")	" 返回 32
			echo char2nr("ABC")	" 返回 65
			echo char2nr("á")	" 返回 225
			echo char2nr("á"[0])	" 返回 195
			echo char2nr("\<M-x>")	" 返回 128
<		非 ASCII 字符始终被视为 UTF-8 字符。
		{utf8} 被忽略，它仅用于向后兼容。
		组合字符是单独的字符。
		|nr2char()| 执行相反的操作。

		如果 {string} 不是 |String|，则返回 0。

                参数：~
                  • {string} (`string`)
                  • {utf8} (`any?`)

                返回值：~
                  (`0|1`)

charclass({string})                                                *charclass()*
		返回 {string} 中第一个字符的字符类。
		字符类是以下之一：
			0	空白
			1	标点符号
			2	单词字符（取决于 'iskeyword'）
			3	表情符号
			other	特定 Unicode 类
		该类用于模式和单词移动。
		如果 {string} 不是 |String|，则返回 0。

                参数：~
                  • {string} (`string`)

                返回值：~
                  (`0|1|2|3|'other'`)
charcol({expr} [, {winid}])                                          *charcol()*
		与 |col()| 相同，但返回给定 {expr} 列位置的字符索引，
		而不是字节位置。

		示例：
		光标在第 5 行的 '세' 上，文本为 "여보세요"：>vim
			echo charcol('.')	" 返回 3
			echo col('.')		" 返回 7
<

                参数：~
                  • {expr} (`string|any[]`)
                  • {winid} (`integer?`)

                返回值：~
                  (`integer`)

charidx({string}, {idx} [, {countcc} [, {utf16}]])                   *charidx()*
		返回 {string} 中 {idx} 字节处的字符索引。
		第一个字符的索引为零。
		如果没有多字节字符，返回值等于 {idx}。

		当 {countcc} 被省略或为 |FALSE| 时，组合字符不单独计数，
		它们的字节长度被添加到前面的基础字符中。
		当 {countcc} 为 |TRUE| 时，组合字符被单独计数。

		当 {utf16} 存在且为 TRUE 时，{idx} 被用作字符串 {expr} 中的
		UTF-16 索引，而不是字节索引。

		如果参数无效或字节少于 {idx}，则返回 -1。
		如果正好有 {idx} 字节，则返回字符串的字符长度。

		如果第一个参数不是字符串，第二个参数不是数字，或者第三个参数存在
		且不是零或一，则给出错误并返回 -1。

		有关从字符索引获取字节索引，请参见 |byteidx()| 和 |byteidxcomp()|，
		有关从字符索引获取 UTF-16 索引，请参见 |utf16idx()|。
		有关更多信息，请参见 |string-offset-encoding|。
		示例：>vim
			echo charidx('áb́ć', 3)		" 返回 1
			echo charidx('áb́ć', 6, 1)	" 返回 4
			echo charidx('áb́ć', 16)		" 返回 -1
			echo charidx('a😊��', 4, 0, 1)	" 返回 2
<

                参数：~
                  • {string} (`string`)
                  • {idx} (`integer`)
                  • {countcc} (`boolean?`)
                  • {utf16} (`boolean?`)

                返回值：~
                  (`integer`)

chdir({dir})                                                           *chdir()*
		将当前工作目录更改为 {dir}。目录更改的范围取决于当前窗口的目录：
			- 如果当前窗口有窗口本地目录 (|:lcd|)，则更改窗口本地目录。
			- 否则，如果当前标签页有本地目录 (|:tcd|)，则更改标签页本地目录。
			- 否则，更改全局目录。
		{dir} 必须是字符串。
		如果成功，返回之前的工作目录。将此传递给另一个 chdir() 以恢复目录。
		失败时，返回空字符串。

		示例：>vim
			let save_dir = chdir(newdir)
			if save_dir != ""
			   " ... 做一些工作
			   call chdir(save_dir)
			endif
<

                参数：~
                  • {dir} (`string`)

                返回值：~
                  (`string`)

cindent({lnum})                                                      *cindent()*
		根据 |C-indenting| 规则获取行 {lnum} 的缩进量，与 'cindent' 相同。
		缩进以空格计数，'tabstop' 的值相关。{lnum} 的使用方式与 |getline()| 相同。
		当 {lnum} 无效时返回 -1。

		要获取或设置字符串中行的缩进，请参见 |vim.text.indent()|。

                参数：~
                  • {lnum} (`integer|string`)

                返回值：~
                  (`integer`)

clearmatches([{win}])                                           *clearmatches()*
		清除之前由 |matchadd()| 和 |:match| 命令为当前窗口定义的所有匹配。
		如果指定了 {win}，则使用具有此编号或窗口 ID 的窗口，而不是当前窗口。

                参数：~
                  • {win} (`integer?`)

col({expr} [, {winid}])                                                  *col()*
		结果是一个数字，它是给定 {expr} 列位置的字节索引。
		有关可接受的位置，请参见 |getpos()|。
		当 {expr} 是 "$" 时，它表示光标行的末尾，因此结果是光标行的字节数加一。
		此外，{expr} 可以是 [lnum, col]：一个包含行号和列号的 |List|。
		当列是 "$" 时最有用，以获取特定行的最后一列。
		当 "lnum" 或 "col" 超出范围时，col() 返回零。

		使用可选的 {winid} 参数，可以从该窗口而不是当前窗口获取值。

		要获取行号，请使用 |line()|。要同时获取两者，请使用 |getpos()|。

		对于屏幕列位置，请使用 |virtcol()|。对于字符位置，请使用 |charcol()|。

		请注意，只能使用当前文件中的标记。

		示例：>vim
			echo col(".")			" 光标的列
			echo col("$")			" 光标行的长度加一
			echo col("'t")			" 标记 t 的列
			echo col("'" .. markname)	" 标记 markname 的列
<
		第一列是 1。如果 {expr} 无效或找不到 ID 为 {winid} 的窗口，则返回 0。
		对于大写标记，列实际上可能在另一个缓冲区中。
		对于光标位置，当 'virtualedit' 激活时，如果光标在行尾之后，则列加一。
		此外，当使用 <Cmd> 映射时，光标不会移动，这可用于在插入模式下获取列：>vim
			imap <F2> <Cmd>echo col(".").."\n"<CR>
<

                参数：~
                  • {expr} (`string|any[]`)
                  • {winid} (`integer?`)

                返回值：~
                  (`integer`)

complete({startcol}, {matches})                                *complete()* *E785*
		设置插入模式补全的匹配项。
		只能在插入模式下使用。您需要使用带有 CTRL-R = 的映射（参见 |i_CTRL-R|）。
		它在 CTRL-O 之后或使用表达式映射时不起作用。
		{startcol} 是行中补全文本开始的字节偏移量。
		光标之前的文本是将被匹配项替换的原始文本。
		对于空字符串，使用 col('.')。"col('.') - 1" 将用一个匹配项替换一个字符。
		{matches} 必须是 |List|。每个 |List| 项目是一个匹配项。
		有关可能的项目类型，请参见 |complete-items|。
		'completeopt' 中的 "longest" 被忽略。
		请注意，在调用此函数后，您需要避免插入任何会导致补全停止的内容。
		可以使用 CTRL-N 和 CTRL-P 像通常的插入模式补全一样选择匹配项。
		如果指定，将显示弹出菜单，请参见 |ins-completion-menu|。
		示例：>vim
			inoremap <F5> <C-R>=ListMonths()<CR>

			func ListMonths()
			  call complete(col('.'), ['January', 'February', 'March',
			    \ 'April', 'May', 'June', 'July', 'August', 'September',
			    \ 'October', 'November', 'December'])
			  return ''
			endfunc
<		这不是很有用，但它展示了它是如何工作的。请注意，返回空字符串以避免插入零。

                参数：~
                  • {startcol} (`integer`)
                  • {matches} (`any[]`)

complete_add({expr})                                            *complete_add()*
		将 {expr} 添加到匹配列表中。仅用于 'completefunc' 选项指定的函数。
		失败时返回 0（空字符串或内存不足），添加匹配项时返回 1，
		匹配项已在列表中时返回 2。
		有关 {expr} 的解释，请参见 |complete-functions|。它是
		与 'omnifunc' 将返回的列表中的一个项目相同。

                参数：~
                  • {expr} (`any`)

                返回值：~
                  (`0|1|2`)

complete_check()                                              *complete_check()*
		检查在查找补全匹配项时是否按下了键。
		这用于查找匹配项需要一些时间时。
		当搜索匹配项被中止时返回 |TRUE|，否则返回零。
		仅用于 'completefunc' 选项指定的函数。

                返回值：~
                  (`0|1`)

complete_info([{what}])                                        *complete_info()*
		返回一个包含插入模式补全信息的 |Dictionary|。参见 |ins-completion|。
		项目包括：
		   mode		当前补全模式名称字符串。
				参见 |complete_info_mode| 了解值。
		   pum_visible	如果弹出菜单可见，则为 |TRUE|。
				参见 |pumvisible()|。
		   items	所有补全候选项的列表。每个项目
				是一个包含 "word"、"abbr"、"menu"、"kind"、
				"info" 和 "user_data" 条目的字典。
				参见 |complete-items|。
		   matches	与 "items" 相同，但只返回与当前查询
				匹配的项目。如果 "matches" 和 "items" 都在
				"what" 中，返回的列表仍将命名为 "items"，
				但每个项目将有一个额外的 "match" 字段。
		   selected	选中的项目索引。第一个索引为零。
				如果没有项目被选中，则索引为 -1
				（仅显示键入的文本，或在使用 <Up> 或
				<Down> 键后没有项目被选中时的最后一个补全）
		   completed	返回一个包含当前选中索引项目
				条目的字典。
		   preview_winid     信息浮动预览窗口 ID。
		   preview_bufnr     信息浮动预览缓冲区 ID。

							*complete_info_mode*
		mode 值为：
		   ""		     不在补全模式
		   "keyword"	     关键字补全 |i_CTRL-X_CTRL-N|
		   "ctrl_x"	     刚刚按下 CTRL-X |i_CTRL-X|
		   "scroll"	     使用 |i_CTRL-X_CTRL-E| 或
				     |i_CTRL-X_CTRL-Y| 滚动
		   "whole_line"	     整行 |i_CTRL-X_CTRL-L|
		   "files"	     文件名 |i_CTRL-X_CTRL-F|
		   "tags"	     标签 |i_CTRL-X_CTRL-]|
		   "path_defines"    定义补全 |i_CTRL-X_CTRL-D|
		   "path_patterns"   包含补全 |i_CTRL-X_CTRL-I|
		   "dictionary"	     字典 |i_CTRL-X_CTRL-K|
		   "thesaurus"	     同义词 |i_CTRL-X_CTRL-T|
		   "cmdline"	     Vim 命令行 |i_CTRL-X_CTRL-V|
		   "function"	     用户定义补全 |i_CTRL-X_CTRL-U|
		   "omni"	     全能补全 |i_CTRL-X_CTRL-O|
		   "spell"	     拼写建议 |i_CTRL-X_s|
		   "eval"	     |complete()| 补全
		   "unknown"	     其他内部模式

		如果提供了可选的 {what} 列表参数，则只返回 {what} 中列出的项目。
		{what} 中不支持的项目会被静默忽略。

		要获取弹出菜单的位置和大小，请参见 |pum_getpos()|。
		在 |CompleteChanged| 事件期间，它也可以在 |v:event| 中使用。

		错误时返回空 |Dictionary|。

		示例：>vim
			" 获取所有项目
			call complete_info()
			" 只获取 'mode'
			call complete_info(['mode'])
			" 只获取 'mode' 和 'pum_visible'
			call complete_info(['mode', 'pum_visible'])
<

                参数：~
                  • {what} (`any[]?`)

                返回值：~
                  (`table`)

confirm({msg} [, {choices} [, {default} [, {type}]]])                *confirm()*
		confirm() 向用户提供一个对话框，从中可以选择。
		它返回选择的编号。对于第一个选择，这是 1。

		{msg} 显示在对话框中，{choices} 作为选项。
		当 {choices} 缺失或为空时，使用 "&OK"（并翻译）。
		{msg} 是一个字符串，使用 '\n' 来包含换行符。
		只有在某些系统上，当字符串不适合时才会换行。

		{choices} 是一个字符串，各个选择用 '\n' 分隔，例如：>vim
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		'&' 后面的字母是该选择的快捷键。
		因此您可以输入 'c' 来选择 "Cancel"。快捷键不需要是第一个字母：>vim
			confirm("file has been modified", "&Save\nSave &All")
<		对于控制台，每个选择的第一个字母用作默认快捷键。大小写被忽略。

		可选的 {type} 字符串参数给出对话框的类型。
		它可以是以下值之一："Error"、"Question"、"Info"、"Warning" 或 "Generic"。
		只有第一个字符是相关的。当省略 {type} 时，使用 "Generic"。

		可选的 {type} 参数给出对话框的类型。这仅用于 Win32 GUI 的图标。
		它可以是以下值之一："Error"、"Question"、"Info"、"Warning" 或 "Generic"。
		只有第一个字符是相关的。当省略 {type} 时，使用 "Generic"。

		如果用户通过按 <Esc>、CTRL-C 或其他有效中断键中止对话框，
		confirm() 返回 0。

		示例：>vim
		   let choice = confirm("What do you want?",
					\ "&Apples\n&Oranges\n&Bananas", 2)
		   if choice == 0
			echo "make up your mind!"
		   elseif choice == 3
			echo "tasteful"
		   else
			echo "I prefer bananas myself."
		   endif
<		在 GUI 对话框中，使用按钮。按钮的布局取决于 'guioptions' 中的 'v' 标志。
		如果包含它，按钮总是垂直放置。否则，confirm() 尝试将按钮放在一条水平线上。
		如果它们不适合，无论如何都会使用垂直布局。对于某些系统，总是使用水平布局。

                参数：~
                  • {msg} (`string`)
                  • {choices} (`string?`)
                  • {default} (`integer?`)
                  • {type} (`string?`)
                返回值：~
                  (`integer`)

copy({expr})                                                            *copy()*
		创建 {expr} 的副本。对于数字和字符串，这与直接使用 {expr} 没有区别。
		当 {expr} 是 |List| 时，创建浅拷贝。这意味着原始 |List| 可以更改而不影响副本，
		反之亦然。但项目是相同的，因此更改项目会更改两个 |Lists| 的内容。
		|Dictionary| 的复制方式与 |List| 类似。
		另请参见 |deepcopy()|。

                参数：~
                  • {expr} (`T`)

                返回值：~
                  (`T`)

cos({expr})                                                              *cos()*
		返回 {expr} 的余弦值，以弧度为单位，作为 |Float|。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：>vim
			echo cos(100)
<			0.862319 >vim
			echo cos(-4.01)
<			-0.646043

                参数：~
                  • {expr} (`number`)

                返回值：~
                  (`number`)

cosh({expr})                                                            *cosh()*
		返回 {expr} 的双曲余弦值，作为 |Float| 在 [1, inf] 范围内。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：>vim
			echo cosh(0.5)
<			1.127626 >vim
			echo cosh(-0.5)
<			-1.127626

                参数：~
                  • {expr} (`number`)

                返回值：~
                  (`number`)

count({comp}, {expr} [, {ic} [, {start}]])                        *count()* *E706*
		返回值 {expr} 的项目在 |String|、|List| 或 |Dictionary| {comp} 中出现的次数。

		如果给出 {start}，则从具有此索引的项目开始。
		{start} 只能与 |List| 一起使用。

		当给出 {ic} 且为 |TRUE| 时，忽略大小写。

		当 {comp} 是字符串时，返回 {expr} 的不重叠出现次数。
		当 {expr} 是空字符串时返回零。

                参数：~
                  • {comp} (`string|table|any[]`)
                  • {expr} (`any`)
                  • {ic} (`boolean?`)
                  • {start} (`integer?`)

                返回值：~
                  (`integer`)

ctxget([{index}])                                                     *ctxget()*
		返回一个 |Dictionary|，表示 |context-stack| 顶部 {index} 处的 |context|
		（参见 |context-dict|）。
		如果未给出 {index}，则假定为 0（即：顶部）。

                参数：~
                  • {index} (`integer?`)

                返回值：~
                  (`table`)

ctxpop()                                                              *ctxpop()*
		弹出并恢复 |context-stack| 顶部的 |context|。

                返回值：~
                  (`any`)

ctxpush([{types}])                                                   *ctxpush()*
		将当前编辑器状态（|context|）推入 |context-stack|。
		如果给出 {types} 且是 |String|s 的 |List|，它指定要包含在推入的上下文中的
		|context-types|。否则，包含所有上下文类型。

                参数：~
                  • {types} (`string[]?`)

                返回值：~
                  (`any`)

ctxset({context} [, {index}])                                         *ctxset()*
		将 |context-stack| 顶部 {index} 处的 |context| 设置为 {context} 表示的上下文。
		{context} 是一个包含上下文数据的字典（|context-dict|）。
		如果未给出 {index}，则假定为 0（即：顶部）。

                参数：~
                  • {context} (`table`)
                  • {index} (`integer?`)

                返回值：~
                  (`integer`)

ctxsize()                                                            *ctxsize()*
		返回 |context-stack| 的大小。

                返回值：~
                  (`any`)

cursor({lnum}, {col} [, {off}])                                       *cursor()*
cursor({list})
		将光标定位在行 {lnum} 的列（字节计数）{col} 处。第一列为一。

		当有一个参数 {list} 时，它被用作包含两个、三个或四个项目的 |List|：
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		这类似于 |getpos()| 或 |getcurpos()| 的返回值，但没有第一个项目。

		要使用 {col} 作为字符计数来定位光标，请使用 |setcursorcharpos()|。

		不更改跳转列表。
		{lnum} 的使用方式与 |getline()| 相同，但如果 {lnum} 为零，
		光标将保持在当前行。
		如果 {lnum} 大于缓冲区中的行数，光标将定位在缓冲区的最后一行。
		如果 {col} 大于行中的字节数，光标将定位在行的最后一个字符。
		如果 {col} 为零，光标将保持在当前列。
		如果给出 {curswant}，它用于设置首选列
		用于垂直移动。否则使用 {col}。

		当使用 'virtualedit' 时，{off} 指定从字符开始的屏幕列偏移量。
		例如，<Tab> 内的位置或最后一个字符之后的位置。
		当位置可以设置时返回 0，否则返回 -1。

                参数：~
                  • {list} (`integer[]`)

                返回值：~
                  (`any`)

debugbreak({pid})                                                 *debugbreak()*
		专门用于中断正在调试的程序。它会使进程 {pid} 收到 SIGTRAP。
		其他进程的行为未定义。参见 |terminal-debug|。
		（向非 MS-Windows 的进程 {pid} 发送 SIGINT）

		如果成功中断程序，则返回 |TRUE|。否则返回 |FALSE|。

                参数：~
                  • {pid} (`integer`)

                返回值：~
                  (`any`)

deepcopy({expr} [, {noref}])                                   *deepcopy()* *E698*
		创建 {expr} 的副本。对于数字和字符串，这与直接使用 {expr} 没有区别。
		当 {expr} 是 |List| 时，创建完整副本。这意味着原始 |List| 可以更改而不影响副本，
		反之亦然。当项目是 |List| 时，递归地为其创建副本。因此更改副本中的项目不会
		更改原始 |List| 的内容。

		当 {noref} 被省略或为零时，包含的 |List| 或 |Dictionary| 只复制一次。
		所有引用都指向这个单一副本。当 {noref} 设置为 1 时，每次出现的 |List| 或
		|Dictionary| 都会产生一个新副本。这也意味着循环引用会导致 deepcopy() 失败。
								*E724*
		嵌套最多可达 100 层。当有项目引用回更高层级时，使用 {noref} 设置为 1 进行
		深拷贝将失败。
		另请参见 |copy()|。

                参数：~
                  • {expr} (`T`)
                  • {noref} (`boolean?`)

                返回值：~
                  (`T`)

delete({fname} [, {flags}])                                           *delete()*
		没有 {flags} 或 {flags} 为空时：删除名为 {fname} 的文件。

		这也适用于 {fname} 是符号链接的情况。删除的是符号链接本身，而不是它指向的内容。

		当 {flags} 为 "d" 时：删除名为 {fname} 的目录。当目录 {fname} 不为空时，此操作将失败。

		当 {flags} 为 "rf" 时：递归删除名为 {fname} 的目录及其中的所有内容。请小心！
		注意：在 MS-Windows 上，无法删除正在使用的目录。

		结果是一个数字，如果删除操作成功则为 0/false，当删除失败或部分失败时为 -1/true。

                参数：~
                  • {fname} (`string`)
                  • {flags} (`string?`)

                返回值：~
                  (`integer`)

deletebufline({buf}, {first} [, {last}])                       *deletebufline()*
		从缓冲区 {buf} 中删除第 {first} 到 {last} 行（包括两端）。
		如果省略 {last}，则只删除第 {first} 行。
		成功时返回 0，失败时返回 1。

		此函数仅适用于已加载的缓冲区。如果需要，请先调用 |bufload()|。

		关于 {buf} 的使用，请参见上面的 |bufname()|。

		{first} 和 {last} 的使用方式与 |getline()| 相同。请注意，
		当使用 |line()| 时，这指的是当前缓冲区。使用 "$" 来引用缓冲区 {buf} 的最后一行。

                参数：~
                  • {buf} (`integer|string`)
                  • {first} (`integer|string`)
                  • {last} (`integer|string?`)
dictwatcheradd({dict}, {pattern}, {callback})                 *dictwatcheradd()*
		向字典添加一个监视器。字典监视器由三个组件标识：

		- 一个字典({dict})；
		- 一个键模式({pattern})；
		- 一个函数({callback})。

		调用此函数后，{dict} 上以及匹配 {pattern} 的键上的每个更改都会导致调用 {callback}。

		例如，要监视所有全局变量：>vim
			silent! call dictwatcherdel(g:, '*', 'OnDictChanged')
			function! OnDictChanged(d,k,z)
			  echomsg string(a:k) string(a:z)
			endfunction
			call dictwatcheradd(g:, '*', 'OnDictChanged')
<
		目前 {pattern} 只接受非常简单的模式，可以在字符串末尾包含 "*"，在这种情况下，它将匹配所有以 "*" 之前的子字符串开头的键。
		这意味着如果 "*" 不是 {pattern} 的最后一个字符，则只有与 {pattern} 完全相等的键才会被匹配。

		{callback} 接收三个参数：

		- 被监视的字典。
		- 发生变化的键。
		- 一个包含键的新值和旧值的字典。

		可以通过检查第三个参数上存在的键来确定更改的类型：

		- 如果同时包含 `old` 和 `new`，则表示键被更新。
		- 如果只包含 `new`，则表示键被添加。
		- 如果只包含 `old`，则表示键被删除。

		此函数可用于插件实现具有验证和解析逻辑的选项。

                参数：~
                  • {dict} (`table`)
                  • {pattern} (`string`)
                  • {callback} (`function`)

                返回值：~
                  (`any`)
dictwatcherdel({dict}, {pattern}, {callback})                 *dictwatcherdel()*
		删除由 |dictwatcheradd()| 添加的监视器。所有三个参数必须与传递给 |dictwatcheradd()| 的参数匹配，才能成功删除监视器。

                参数：~
                  • {dict} (`any`)
                  • {pattern} (`string`)
                  • {callback} (`function`)

                返回值：~
                  (`any`)

did_filetype()                                                  *did_filetype()*
		当正在执行自动命令且 FileType 事件至少触发一次时返回 |TRUE|。可用于避免在检测文件类型的脚本中再次触发 FileType 事件。|FileType|
		当使用 `:setf FALLBACK` 时返回 |FALSE|。
		当编辑另一个文件时，计数器会重置，因此这实际上检查的是当前缓冲区的 FileType 事件是否已触发。这允许一个自动命令开始编辑另一个缓冲区时设置 'filetype' 并加载语法文件。

                返回值：~
                  (`integer`)

diff_filler({lnum})                                              *diff_filler()*
		返回行 {lnum} 上方的填充行数。
		这些是在另一个差异窗口中在此点插入的行。这些填充行在显示中显示，但在缓冲区中不存在。
		{lnum} 的使用方式与 |getline()| 相同。因此 "." 是当前行，"'m" 是标记 m，等等。
		如果当前窗口不在差异模式下，则返回 0。

                参数：~
                  • {lnum} (`integer|string`)

                返回值：~
                  (`integer`)

diff_hlID({lnum}, {col})                                           *diff_hlID()*
		返回行 {lnum} 列 {col}（字节索引）处差异模式的高亮 ID。当当前行没有差异更改时返回零。
		{lnum} 的使用方式与 |getline()| 相同。因此 "." 是当前行，"'m" 是标记 m，等等。
		{col} 从 1 开始表示最左边的列，{lnum} 从 1 开始表示第一行。
		高亮 ID 可以与 |synIDattr()| 一起使用，以获取有关高亮的语法信息。

                参数：~
                  • {lnum} (`integer|string`)
                  • {col} (`integer`)

                返回值：~
                  (`any`)

digraph_get({chars})                                       *digraph_get()* *E1214*
		返回 {chars} 的双字符组合。这应该是一个恰好包含两个字符的字符串。如果 {chars} 不是恰好两个字符，或者 {chars} 的双字符组合不存在，则会给出错误并返回空字符串。

		另请参阅 |digraph_getlist()|。

		示例：>vim
		" 获取内置双字符组合
		echo digraph_get('00')		" 返回 '∞'

		" 获取用户定义的双字符组合
		call digraph_set('aa', 'あ')
		echo digraph_get('aa')		" 返回 'あ'
<

                参数：~
                  • {chars} (`string`)

                返回值：~
                  (`string`)

digraph_getlist([{listall}])                                 *digraph_getlist()*
		返回双字符组合列表。如果给出了 {listall} 参数且为 TRUE，则返回所有双字符组合，包括默认双字符组合。否则，仅返回用户定义的双字符组合。

		另请参阅 |digraph_get()|。

		示例：>vim
		" 获取用户定义的双字符组合
		echo digraph_getlist()

		" 获取所有双字符组合，包括默认双字符组合
		echo digraph_getlist(1)
<
                参数：~
                  • {listall} (`boolean?`)

                返回值：~
                  (`string[][]`)

digraph_set({chars}, {digraph})                                  *digraph_set()*
		将双字符组合 {chars} 添加到列表中。{chars} 必须是一个包含两个字符的字符串。{digraph} 是一个包含一个 UTF-8 编码字符的字符串。*E1215*
		请注意，组合字符不会被忽略。此函数类似于 |:digraphs| 命令，但可用于添加以空格开头的双字符组合。

		如果成功注册了双字符组合，函数返回 v:true。如果失败，会给出错误消息并返回 v:false。

		如果要一次定义多个双字符组合，可以使用 |digraph_setlist()|。

		示例：>vim
			call digraph_set('  ', 'あ')
<

                参数：~
                  • {chars} (`string`)
                  • {digraph} (`string`)

                返回值：~
                  (`any`)

digraph_setlist({digraphlist})                               *digraph_setlist()*
		类似于 |digraph_set()|，但此函数可以一次添加多个双字符组合。{digraphlist} 是一个由列表组成的列表，其中每个列表包含两个字符串，分别是 {chars} 和 {digraph}，与 |digraph_set()| 中的相同。*E1216*
		示例：>vim
		    call digraph_setlist([['aa', 'あ'], ['ii', 'い']])
<
		这类似于以下代码：>vim
		    for [chars, digraph] in [['aa', 'あ'], ['ii', 'い']]
			  call digraph_set(chars, digraph)
		    endfor
<		不同之处在于，函数在第一个错误后返回，后续的双字符组合将不会被添加。

                参数：~
                  • {digraphlist} (`table<integer,string[]>`)

                返回值：~
                  (`any`)

empty({expr})                                                          *empty()*
		如果 {expr} 为空，则返回数字 1，否则返回 0。
		- 当 |List| 或 |Dictionary| 没有任何项目时为空。
		- 当 |String| 的长度为零时为空。
		- 当 |Number| 和 |Float| 的值为零时为空。
		- |v:false| 和 |v:null| 为空，|v:true| 不为空。
		- 当 |Blob| 的长度为零时为空。

                参数：~
                  • {expr} (`any`)

                返回值：~
                  (`integer`)

environ()                                                            *environ()*
		以字典形式返回所有环境变量。您可以这样检查环境变量是否存在：>vim
			echo has_key(environ(), 'HOME')
<		注意变量名可能是驼峰命名；要忽略大小写，请使用：>vim
			echo index(keys(environ()), 'HOME', 0, 1) != -1
<

                返回值：~
                  (`any`)

escape({string}, {chars})                                             *escape()*
		用反斜杠转义 {string} 中出现的 {chars} 字符。例如：>vim
			echo escape('c:\program files\vim', ' \')
<		结果为：>
			c:\\program\ files\\vim
<		另请参阅 |shellescape()| 和 |fnameescape()|。

                参数：~
                  • {string} (`string`)
                  • {chars} (`string`)

                返回值：~
                  (`string`)

eval({string})                                                          *eval()*
		评估 {string} 并返回结果。特别适用于将 |string()| 的结果转换回原始值。
		这适用于数字、浮点数、字符串、二进制数据及其组合。也适用于引用现有函数的 |Funcref|。

eventhandler()                                                  *eventhandler()*
		当在事件处理程序内部时返回 1。这意味着 Vim 在等待用户输入字符时被中断，
		例如，当在 Vim 上拖放文件时。这表示不能使用交互式命令。否则返回 0。

                返回值：~
                  (`any`)

executable({expr})                                                *executable()*
		此函数检查名为 {expr} 的可执行文件是否存在。{expr} 必须是程序名称，不包含任何参数。

		executable() 使用 $PATH 的值和/或程序的正常搜索路径。
							*PATHEXT*
		在 MS-Windows 上，可以可选地包含 ".exe"、".bat" 等扩展名。
		然后会尝试 $PATHEXT 中的扩展名。因此如果 "foo.exe" 不存在，
		可能会找到 "foo.exe.bat"。如果 $PATHEXT 未设置，则使用 ".com;.exe;.bat;.cmd"。
		在 $PATHEXT 中可以使用单个点来尝试使用不带扩展名的名称。
		当 'shell' 看起来像 Unix shell 时，也会尝试不添加扩展名的名称。
		在 MS-Windows 上，它只检查文件是否存在且不是目录，而不检查它是否真的可执行。
		在 MS-Windows 上，与 Vim 可执行文件在同一目录中的可执行文件总是可以找到
		（它在 |startup| 时被添加到 $PATH 中）。
					*NoDefaultCurrentDirectoryInExePath*
		在 MS-Windows 上，Vim 当前工作目录中的可执行文件通常也可以找到，
		但可以通过设置 $NoDefaultCurrentDirectoryInExePath 环境变量来禁用此功能。

		返回值为数字：
			1	存在
			0	不存在
		|exepath()| 可用于获取可执行文件的完整路径。

                参数：~
                  • {expr} (`string`)

                返回值：~
                  (`0|1`)
execute({command} [, {silent}])                                      *execute()*
		执行 {command} 并捕获其输出。
		如果 {command} 是 |String|，返回 {command} 的输出。
		如果 {command} 是 |List|，返回连接后的输出。
		{command} 中的行继续符不会被识别。
		示例：>vim
			echo execute('echon "foo"')
<			foo >vim
			echo execute(['echon "foo"', 'echon "bar"'])
<			foobar

		可选的 {silent} 参数可以有以下值：
			""		不使用 `:silent`
			"silent"	使用 `:silent`
			"silent!"	使用 `:silent!`
		默认为 "silent"。注意，与 `:redir` 不同，使用 "silent!" 时会丢弃错误消息。

		要获取行列表，可以在结果上使用 `split()`：>vim
			execute('args')->split("\n")

<		此函数在 |sandbox| 中不可用。
		注意：如果嵌套使用，外部 execute() 将不会观察到内部调用的输出。
		注意：文本属性（高亮）不会被捕获。
		要在当前窗口以外的窗口执行命令，请使用 `win_execute()`。

                参数：~
                  • {command} (`string|string[]`)
                  • {silent} (`''|'silent'|'silent!'?`)

                返回值：~
                  (`string`)

exepath({expr})                                                      *exepath()*
		如果 {expr} 是可执行文件且作为（部分或完整）路径给出或在 $PATH 中找到，
		则返回 {expr} 的完整路径。否则返回空字符串。
		如果 {expr} 以 "./" 开头，则使用 |current-directory|。

                参数：~
                  • {expr} (`string`)

                返回值：~
                  (`string`)

exists({expr})                                                        *exists()*
		如果 {expr} 存在，则返回 |TRUE| 的数字结果。
		{expr} 参数是一个字符串，可以包含以下内容之一：
			varname		内部变量（参见 |internal-variables|）。
			dict.key	也适用于 |curly-braces-names|、|Dictionary|
				条目、|List| 项等。
					注意，评估索引可能会导致无效表达式的错误消息。
					例如：>vim
					   let l = [1, 2, 3]
					   echo exists("l[5]")
<					   0 >vim
					   echo exists("l[xx]")
<					   E121: 未定义的变量：xx
					   0
			&option-name	Vim 选项（仅检查是否存在，不检查是否真的有效）
			+option-name	有效的 Vim 选项。
			$ENVNAME	环境变量（也可以通过与空字符串比较来完成）
			`*funcname`	内置函数（参见 |functions|）或用户定义函数（参见
					|user-function|）。也适用于作为 Funcref 的变量。
			:cmdname	Ex 命令：内置命令、用户命令或命令修饰符 |:command|。
					返回值：
					1  匹配命令的开头
					2  完全匹配命令
					3  匹配多个用户命令
					要检查是否支持某个命令，始终检查返回值是否为 2。
			:2match		|:2match| 命令。
			:3match		|:3match| 命令（但你可能不应该使用它，它保留用于内部使用）
			#event		为此事件定义的自动命令
			#event#pattern	为此事件和模式定义的自动命令（模式被字面理解并与自动命令模式逐字符比较）
			#group		自动命令组存在
			#group#event	为此组和事件定义的自动命令。
			#group#event#pattern
					为此组、事件和模式定义的自动命令。
			##event		支持此事件的自动命令。

		示例：>vim
			echo exists("&mouse")
			echo exists("$HOSTNAME")
			echo exists("*strftime")
			echo exists("*s:MyFunc")
			echo exists("*MyFunc")
			echo exists("*v:lua.Func")
			echo exists("bufcount")
			echo exists(":Make")
			echo exists("#CursorHold")
			echo exists("#BufReadPre#*.gz")
			echo exists("#filetypeindent")
			echo exists("#filetypeindent#FileType")
			echo exists("#filetypeindent#FileType#*")
			echo exists("##ColorScheme")
<		符号（&/$/*/#）和名称之间不能有空格。
		名称后面不能有多余的字符，尽管在某些情况下会被忽略。这在未来可能会变得更严格，所以不要依赖它！
		工作示例：>vim
			echo exists(":make")
<		不工作示例：>vim
			echo exists(":make install")

<		注意，参数必须是字符串，而不是变量本身的名称。例如：>vim
			echo exists(bufcount)
<		这不会检查 "bufcount" 变量是否存在，而是获取 "bufcount" 的值，并检查该值是否存在。

                参数：~
                  • {expr} (`string`)

                返回值：~
                  (`0|1`)

exp({expr})                                                              *exp()*
		返回 {expr} 的指数值，作为 [0, inf] 范围内的 |Float|。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：>vim
			echo exp(2)

expand({string} [, {nosuf} [, {list}]])                               *expand()*
		在 {string} 中展开通配符和以下特殊关键字。'wildignorecase' 选项适用。

		如果给出 {list} 且为 |TRUE|，将返回一个 List。
		否则结果是一个 String，当有多个匹配项时，它们用 <NL> 字符分隔。

		如果展开失败，结果是一个空字符串。除非 {string} 不以 '%'、'#' 或 '<' 开头（见下文），否则不会包含不存在的文件的名称。

		当 {string} 以 '%'、'#' 或 '<' 开头时，展开方式类似于 |cmdline-special| 变量及其关联的修饰符。以下是简要概述：

			%		当前文件名
			#		备用文件名
			#n		第 n 个备用文件名
			<cfile>		光标下的文件名
			<afile>		自动命令文件名
			<abuf>		自动命令缓冲区号（作为字符串！）
			<amatch>	自动命令匹配的名称
			<cexpr>		光标下的 C 表达式
			<sfile>		源脚本文件或函数名
			<slnum>		源脚本行号或函数行号
			<sflnum>	脚本文件行号，即使在函数中也是如此
			<SID>		"<SNR>123_" 其中 "123" 是当前脚本 ID |<SID>|
			<script>	源脚本文件，或定义当前函数的脚本文件
			<stack>		调用栈
			<cword>		光标下的单词
			<cWORD>		光标下的 WORD
			<client>	最后接收到的消息的 {clientid}
		修饰符：
			:p		展开为完整路径
			:h		头部（移除最后一个路径组件）
			:t		尾部（仅保留最后一个路径组件）
			:r		根（移除一个扩展名）
			:e		仅扩展名

		示例：>vim
			let &tags = expand("%:p:h") .. "/tags"
<		注意，当展开以 '%'、'#' 或 '<' 开头的字符串时，任何后续文本都会被忽略。这不起作用：>vim
			let doesntwork = expand("%:h.bak")
<		应该这样使用：>vim
			let doeswork = expand("%:h") .. ".bak"
<		还要注意，展开 "<cfile>" 和其他类似项时，只返回引用的文件名而不进行进一步展开。如果 "<cfile>" 是 "~/.cshrc"，你需要再次使用 expand() 来将 "~/" 展开为家目录的路径：>vim
			echo expand(expand("<cfile>"))
<
		变量和后续修饰符之间不能有空格。|fnamemodify()| 函数可用于修改普通文件名。

		当使用 '%' 或 '#' 时，如果当前或备用文件名未定义，则使用空字符串。在未命名的缓冲区中使用 "%:p" 会返回当前目录，并添加一个 '/'。
		当设置了 'verbose' 时，如果无法展开 '%'、'#' 和 <> 项，将显示错误消息。

		当 {string} 不以 '%'、'#' 或 '<' 开头时，它会像命令行上的文件名一样展开。
		除非给出可选的 {nosuf} 参数且为 |TRUE|，否则会使用 'suffixes' 和 'wildignore'。
		包含不存在的文件的名称。"**" 项可用于在目录树中搜索。例如，查找当前目录及其子目录中的所有 "README" 文件：>vim
			echo expand("**/README")
<
		expand() 也可用于展开仅在 shell 中已知的变量和环境变量。但这可能很慢，因为可能需要使用 shell 来执行展开。参见 |expr-env-expand|。
		展开后的变量仍然像文件名列表一样处理。当环境变量无法展开时，它保持不变。因此 ":echo expand('$FOOBAR')" 的结果是 "$FOOBAR"。

		参见 |glob()| 用于查找现有文件。参见 |system()| 用于获取外部命令的原始输出。
参数：
  • {string} (字符串类型)
  • {nosuf} (布尔类型，可选)
  • {list} (nil|false，可选)

返回值：
  (字符串类型)

expandcmd({string} [, {options}])                                  *expandcmd()*
		展开 {string} 中的特殊项，就像在 Ex 命令（如 `:edit`）中那样。这会展开特殊关键字（类似 |expand()|）和环境变量，可以在 {string} 的任何位置展开。"~user" 和 "~/path" 只在开头处展开。

		{options} 字典参数支持以下项：
		    errmsg	如果设置为 TRUE，在展开过程中遇到错误时会显示错误消息。
				默认情况下不显示错误消息。

		返回展开后的字符串。如果在展开过程中遇到错误，则返回未修改的 {string}。

		示例：>vim
			echo expandcmd('make %<.o')
<		 >
			make /path/runtime/doc/builtin.o
<		 >vim
			echo expandcmd('make %<.o', {'errmsg': v:true})
<

参数：
  • {string} (字符串类型)
  • {options} (表类型，可选)

返回值：
  (任意类型)

extend({expr1}, {expr2} [, {expr3}])                                  *extend()*
		{expr1} 和 {expr2} 必须都是 |Lists| 或都是 |Dictionaries|。

		如果它们是 |Lists|：将 {expr2} 追加到 {expr1}。
		如果提供了 {expr3}，则将 {expr2} 的项目插入到 {expr1} 中索引为 {expr3} 的项目之前。
		当 {expr3} 为零时，插入到第一项之前。
		当 {expr3} 等于 len({expr1}) 时，{expr2} 将被追加到末尾。
		示例：>vim
			echo sort(extend(mylist, [7, 5]))
			call extend(mylist, [2, 3], 1)
<		当 {expr1} 和 {expr2} 是同一个 List 时，复制的项目数等于 List 的原始长度。
		例如，当 {expr3} 为 1 时，你会得到 N 个第一项的新副本（N 是 List 的原始长度）。
		使用 |add()| 可以将一个项目连接到列表。要将两个列表连接成一个新列表，请使用 + 运算符：>vim
			let newlist = [1, 2, 3] + [4, 5]
<
		如果它们是 |Dictionaries|（字典）：
		将 {expr2} 中的所有条目添加到 {expr1} 中。
		如果某个键在 {expr1} 和 {expr2} 中都存在，则使用 {expr3} 来决定如何处理：
		{expr3} = "keep"：保留 {expr1} 的值
		{expr3} = "force"：使用 {expr2} 的值
		{expr3} = "error"：给出错误消息		*E737*
		当省略 {expr3} 时，默认为 "force"。

		当 {expr2} 不为空时，{expr1} 会被改变。如果需要，请先复制 {expr1} 或使用 |extendnew()| 返回一个新的 List/Dictionary。
		{expr2} 保持不变。
		当 {expr1} 被锁定且 {expr2} 不为空时，操作会失败。
		返回 {expr1}。出错时返回 0。

参数：
  • {expr1} (表类型)
  • {expr2} (表类型)
  • {expr3} (表类型，可选)

返回值：
  (任意类型)

extendnew({expr1}, {expr2} [, {expr3}])                            *extendnew()*
		类似于 |extend()|，但不是将项目添加到 {expr1}，而是创建并返回一个新的 List 或 Dictionary。{expr1} 保持不变。

参数：
  • {expr1} (表类型)
  • {expr2} (表类型)
  • {expr3} (表类型，可选)

返回值：
  (任意类型)

feedkeys({string} [, {mode}])                                       *feedkeys()*
		将 {string} 中的字符排队处理，就像它们来自映射或由用户输入一样。

		默认情况下，字符串被添加到预输入缓冲区的末尾，因此如果映射仍在执行，这些字符会出现在它们之后。使用 'i' 标志可以在其他字符之前插入，它们将在任何来自映射的字符之前立即执行。

		该函数不会等待处理 {string} 中包含的键。

		要在 {string} 中包含特殊键，请使用双引号和 "\..." 表示法 |expr-quote|。例如，
		feedkeys("\<CR>") 模拟按下 <Enter> 键。但是
		feedkeys('\<CR>') 会推入 5 个字符。
		可以使用 |<Ignore>| 键码来退出等待字符而不做任何事情。

		{mode} 是一个字符串，可以包含这些字符标志：
		'm'	重映射键。这是默认值。如果 {mode} 不存在，键会被重映射。
		'n'	不重映射键。
		't'	将键视为输入；否则它们会被视为来自映射。这对撤销、打开折叠等很重要。
		'L'	低级输入。不使用其他标志。
		'i'	插入字符串而不是追加（见上文）。
		'x'	执行命令直到预输入为空。
			这类似于使用 ":normal!"。
			你可以多次调用 feedkeys() 而不使用 'x'，然后使用一次带 'x' 的调用（可能带有空 {string}）来执行所有预输入。
			注意，当 Vim 在插入模式下结束时，它会表现得像按下了 <Esc>，以避免在脚本继续之前等待输入字符而卡住。
			注意，如果你在执行命令时设法调用 feedkeys()，即递归调用它，那么所有预输入将被最后一次调用消耗。
		'!'	当与 'x' 一起使用时不会结束插入模式。可以在测试中使用，当定时器设置为稍后退出插入模式时。对测试 CursorHoldI 很有用。

		返回值始终为 0。

参数：
  • {string} (字符串类型)
  • {mode} (字符串类型，可选)

返回值：
  (任意类型)

filecopy({from}, {to})                                              *filecopy()*
		将名为 {from} 的文件复制到 {to}。
		结果是一个数字，如果文件复制成功则为 |TRUE|，失败则为 |FALSE|。
		如果已存在名为 {to} 的文件，则会失败。
		注意它（目前）不处理目录。

		此函数在 |sandbox| 中不可用。

参数：
  • {from} (字符串类型)
  • {to} (字符串类型)

返回值：
  (0|1)

filereadable({file})                                            *filereadable()*
		结果是一个数字，当名为 {file} 的文件存在且可读时为 |TRUE|。如果 {file} 不存在或是目录，结果为 |FALSE|。{file} 可以是任何表达式，它会被用作字符串。
		如果你不关心文件是否可读，可以使用 |glob()|。
		{file} 按原样使用，你可能想先展开通配符：>vim
			echo filereadable('~/.vimrc')
<		 >
			0
<		 >vim
			echo filereadable(expand('~/.vimrc'))
<		 >
			1
<

参数：
  • {file} (字符串类型)

返回值：
  (0|1)

filewritable({file})                                            *filewritable()*
		结果是一个数字，当名为 {file} 的文件存在且可写时为 1。如果 {file} 不存在或不可写，结果为 0。如果 {file} 是一个目录且我们可以写入，结果为 2。

参数：
  • {file} (字符串类型)

返回值：
  (0|1)

filter({expr1}, {expr2})                                              *filter()*
		{expr1} 必须是 |List|、|String|、|Blob| 或 |Dictionary|。
		对 {expr1} 中的每个项目求值 {expr2}，当结果为零或假时从 |List| 或 |Dictionary| 中移除该项目。
		对于 |Blob| 中的每个字节和 |String| 中的每个字符也是如此。

		{expr2} 必须是 |string| 或 |Funcref|。

		如果 {expr2} 是 |string|，在 {expr2} 内部 |v:val| 具有当前项目的值。对于 |Dictionary|，|v:key| 具有当前项目的键，对于 |List|，|v:key| 具有当前项目的索引。对于 |Blob|，|v:key| 具有当前字节的索引。对于 |String|，|v:key| 具有当前字符的索引。
		示例：>vim
			call filter(mylist, 'v:val !~ "OLD"')
<		移除包含 "OLD" 的项目。>vim
			call filter(mydict, 'v:key >= 8')
<		移除键小于 8 的项目。>vim
			call filter(var, 0)
<		移除所有项目，从而清空 |List| 或 |Dictionary|。

		注意 {expr2} 是表达式的结果，然后再次用作表达式。通常使用 |literal-string| 来避免必须双写反斜杠是个好主意。

		如果 {expr2} 是 |Funcref|，它必须接受两个参数：
			1. 当前项目的键或索引。
			2. 当前项目的值。
		函数必须返回 |TRUE| 以保留该项目。
		保留列表中奇数项的示例：>vim
			func Odd(idx, val)
			  return a:idx % 2 == 1
			endfunc
			call filter(mylist, function('Odd'))
<		使用 |lambda| 时会更简短：>vim
			call filter(myList, {idx, val -> idx * val <= 42})
<		如果你不使用 "val"，可以省略它：>vim
			call filter(myList, {idx -> idx % 2 == 1})
<
		对于 |List| 和 |Dictionary|，操作是就地进行的。如果你希望它保持不变，请先复制：>vim
			let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		返回 {expr1}，即被过滤的 |List| 或 |Dictionary|，或者一个新的 |Blob| 或 |String|。
		当在评估 {expr2} 时遇到错误，{expr1} 中的其余项目不会被处理。
		当 {expr2} 是 Funcref 时，函数内的错误会被忽略，除非它是用 "abort" 标志定义的。

参数：
  • {expr1} (字符串|表类型)
  • {expr2} (字符串|函数类型)

返回值：
  (任意类型)

finddir({name} [, {path} [, {count}]])                               *finddir()*
		在 {path} 中查找目录 {name}。支持向下和向上的递归目录搜索。有关 {path} 的语法，请参见 |file-searching|。

		返回第一个找到的匹配项的路径。当找到的目录在当前目录下时，返回相对路径。否则返回完整路径。
		如果省略或为空 {path}，则使用 'path'。

		如果提供了可选的 {count}，则在 {path} 中查找 {name} 的第 {count} 次出现，而不是第一次。
		当 {count} 为负数时，返回所有匹配项的 |List|。

		如果未找到目录，则返回空字符串。

		这与 ex 命令 `:find` 非常相似。

参数：
  • {name} (字符串类型)
  • {path} (字符串类型，可选)
  • {count} (整数类型，可选)

返回值：
  (任意类型)

findfile({name} [, {path} [, {count}]])                             *findfile()*
		与 |finddir()| 完全相同，但查找文件而不是目录。
		使用 'suffixesadd'。
		示例：>vim
			echo findfile("tags.vim", ".;")
<		从当前文件的目录向上搜索，直到找到文件 "tags.vim"。

参数：
  • {name} (字符串类型)
  • {path} (字符串类型，可选)
  • {count} (任意类型，可选)
返回值：
  (任意类型)

flatten({list} [, {maxdepth}])                                       *flatten()*
		将 {list} 展平到 {maxdepth} 层。如果没有 {maxdepth}，结果是一个没有嵌套的 |List|，就像 {maxdepth} 是一个很大的数字一样。
		{list} 会被就地修改，如果你不想这样，请使用 |flattennew()|。
								*E900*
		{maxdepth} 表示在嵌套列表中进行更改的深度。
		当 {maxdepth} 为 0 时，{list} 不会被修改。
		{maxdepth} 必须是正数。

		如果出现错误，返回数字零。

		示例：>vim
			echo flatten([1, [2, [3, 4]], 5])
<			[1, 2, 3, 4, 5] >vim
			echo flatten([1, [2, [3, 4]], 5], 1)
<			[1, 2, [3, 4], 5]

参数：
  • {list} (任意类型数组)
  • {maxdepth} (整数类型，可选)

返回值：
  (任意类型数组|0)

flattennew({list} [, {maxdepth}])                                 *flattennew()*
		与 |flatten()| 类似，但首先复制 {list}。

参数：
  • {list} (任意类型数组)
  • {maxdepth} (整数类型，可选)

返回值：
  (任意类型数组|0)

float2nr({expr})                                                    *float2nr()*
		通过省略小数点后的部分将 {expr} 转换为数字。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0。
		当 {expr} 的值超出 |Number| 的范围时，结果会被截断为 0x7fffffff 或 -0x7fffffff（或者当启用 64 位数字支持时，为 0x7fffffffffffffff 或 -0x7fffffffffffffff）。NaN 结果为 -0x80000000（或者当启用 64 位数字支持时，为 -0x8000000000000000）。
		示例：>vim
			echo float2nr(3.95)
<			3  >vim
			echo float2nr(-23.45)
<			-23  >vim
			echo float2nr(1.0e100)
<			2147483647  (或 9223372036854775807) >vim
			echo float2nr(-1.0e150)
<			-2147483647 (或 -9223372036854775807) >vim
			echo float2nr(1.0e-100)
<			0

参数：
  • {expr} (数字类型)

返回值：
  (任意类型)

floor({expr})                                                          *floor()*
		返回小于或等于 {expr} 的最大整数值，作为 |Float| 类型（向下取整）。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：>vim
			echo floor(1.856)
<			1.0  >vim
			echo floor(-5.456)
<			-6.0  >vim
			echo floor(4.0)
<			4.0

参数：
  • {expr} (数字类型)

返回值：
  (任意类型)

fmod({expr1}, {expr2})                                                  *fmod()*
		返回 {expr1} / {expr2} 的余数，即使除法不能表示。返回 {expr1} - i * {expr2}，
		其中 i 是某个整数，使得如果 {expr2} 非零，结果的符号与 {expr1} 相同，且绝对值小于 {expr2} 的绝对值。
		如果 {expr2} 为零，则返回零。返回值是 |Float| 类型。
		{expr1} 和 {expr2} 必须计算为 |Float| 或 |Number|。
		如果 {expr1} 或 {expr2} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：>vim
			echo fmod(12.33, 1.22)
<			0.13 >vim
			echo fmod(-12.33, 1.22)
<			-0.13

参数：
  • {expr1} (数字类型)
  • {expr2} (数字类型)

返回值：
  (任意类型)

fnameescape({string})                                            *fnameescape()*
		转义 {string} 以用作文件名命令参数。所有具有特殊含义的字符，如 `'%'` 和 `'|'` 都会用反斜杠转义。
		对于大多数系统，被转义的字符是 " \t\n*?[{`$\\%#'\"|!<"。
		对于文件名中可能出现反斜杠的系统，它取决于 'isfname' 的值。
		开头的 '+' 和 '>' 也会被转义（在 |:edit| 和 |:write| 之后有特殊含义）。
		单独的 "-" 也会被转义（在 |:cd| 之后有特殊含义）。
		出错时返回空字符串。
		示例：>vim
			let fname = '+some str%nge|name'
			exe "edit " .. fnameescape(fname)
<		结果执行：>vim
			edit \+some\ str\%nge\|name
<

参数：
  • {string} (字符串类型)

返回值：
  (字符串类型)

fnamemodify({fname}, {mods})                                     *fnamemodify()*
		根据 {mods} 修改文件名 {fname}。{mods} 是一个字符串，类似于命令行上用于文件名的字符串。
		参见 |filename-modifiers|。
		示例：>vim
			echo fnamemodify("main.c", ":p:h")
<		结果为：>
			/home/user/vim/vim/src
<		如果 {mods} 为空或使用了不支持的修饰符，则返回 {fname}。
		当 {fname} 为空时，使用 {mods} ":h" 返回 "."，这样就可以用 `:cd` 来使用它。
		这与没有缓冲区名称时的 expand('%:h') 不同，后者返回空字符串。
		注意：环境变量在 {fname} 中不起作用，请先使用 |expand()|。
参数：
  • {fname} (字符串类型)
  • {mods} (字符串类型)

返回值：
  (字符串类型)

foldclosed({lnum})                                                *foldclosed()*
		结果是一个数字。如果行 {lnum} 在一个关闭的折叠中，结果是该折叠中第一行的行号。
		如果行 {lnum} 不在关闭的折叠中，返回 -1。
		{lnum} 的使用方式与 |getline()| 相同。因此 "." 是当前行，"'m" 是标记 m，等等。

参数：
  • {lnum} (整数|字符串类型)

返回值：
  (整数类型)

foldclosedend({lnum})                                          *foldclosedend()*
		结果是一个数字。如果行 {lnum} 在一个关闭的折叠中，结果是该折叠中最后一行的行号。
		如果行 {lnum} 不在关闭的折叠中，返回 -1。
		{lnum} 的使用方式与 |getline()| 相同。因此 "." 是当前行，"'m" 是标记 m，等等。

参数：
  • {lnum} (整数|字符串类型)

返回值：
  (整数类型)

foldlevel({lnum})                                                  *foldlevel()*
		结果是一个数字，是当前缓冲区中行 {lnum} 的折叠级别。对于嵌套折叠，返回最深的级别。
		如果行 {lnum} 没有折叠，返回零。折叠是打开还是关闭都无关紧要。
		当在更新折叠时使用（从 'foldexpr'），对于尚待更新且折叠级别未知的行返回 -1。
		作为特殊情况，通常可以获得前一行的级别。
		{lnum} 的使用方式与 |getline()| 相同。因此 "." 是当前行，"'m" 是标记 m，等等。

参数：
  • {lnum} (整数|字符串类型)

返回值：
  (整数类型)
foldtext()                                                          *foldtext()*
		返回一个字符串，用于显示关闭的折叠。这是用于 'foldtext' 选项的默认函数，
		只应在计算 'foldtext' 时调用。它使用 |v:foldstart|、|v:foldend| 和 |v:folddashes| 变量。
		返回的字符串看起来像这样：>
			+-- 45 lines: abcdef
<		开头的破折号数量取决于折叠级别。"45" 是折叠中的行数。"abcdef" 是折叠中第一个非空行的文本。
		会移除开头的空白、"//" 或 "/*" 以及来自 'foldmarker' 和 'commentstring' 选项的文本。
		当用于绘制实际的折叠文本时，行的其余部分将用 'fillchars' 设置中的折叠字符填充。
		当没有折叠时返回空字符串。

返回值：
  (字符串类型)

foldtextresult({lnum})                                        *foldtextresult()*
		返回在行 {lnum} 处显示的关闭折叠的文本。在适当的上下文中计算 'foldtext'。
		当 {lnum} 处没有关闭的折叠时，返回空字符串。
		{lnum} 的使用方式与 |getline()| 相同。因此 "." 是当前行，"'m" 是标记 m，等等。
		在导出折叠文本时很有用，例如导出到 HTML。

参数：
  • {lnum} (整数|字符串类型)

返回值：
  (字符串类型)

foreach({expr1}, {expr2})                                            *foreach()*
		{expr1} 必须是 |List|、|String|、|Blob| 或 |Dictionary|。
		对 {expr1} 中的每个项目执行 {expr2}。{expr1} 不会被修改；其值可能会被修改，就像使用 |:lockvar| 1 一样。|E741|
		参见 |map()| 和 |filter()| 来修改 {expr1}。

		{expr2} 必须是 |string| 或 |Funcref|。

		如果 {expr2} 是 |string|，在 {expr2} 内部 |v:val| 具有当前项目的值。
		对于 |Dictionary|，|v:key| 具有当前项目的键，对于 |List|，|v:key| 具有当前项目的索引。
		对于 |Blob|，|v:key| 具有当前字节的索引。对于 |String|，|v:key| 具有当前字符的索引。
		示例：>vim
			call foreach(mylist, 'let used[v:val] = v:true')
<		这会记录 {expr1} 列表中的项目。

		注意 {expr2} 是表达式的结果，然后用作命令。通常使用 |literal-string| 来避免必须双写反斜杠是个好主意。

		如果 {expr2} 是 |Funcref|，它必须接受两个参数：
			1. 当前项目的键或索引。
			2. 当前项目的值。
		使用 lambda 时，如果它只接受一个参数，不会收到错误。
		如果函数返回值，它会被忽略。

		在所有情况下都返回 {expr1}。
		当在执行 {expr2} 时遇到错误，{expr1} 中的其余项目不会被处理。
		当 {expr2} 是 Funcref 时，函数内的错误会被忽略，除非它是用 "abort" 标志定义的。

参数：
  • {expr1} (字符串|表类型)
  • {expr2} (字符串|函数类型)

返回值：
  (字符串|表类型)

fullcommand({name})                                              *fullcommand()*
		从简短的缩写命令名获取完整的命令名；有关命令缩写的详细信息，请参见 |20.2|。

		字符串参数 {name} 可以以 `:` 开头，并且可以包含 [range]，这些会被跳过且不会返回。
		如果命令不存在或者它是模糊的（对于用户定义的命令），则返回空字符串。

		例如 `fullcommand('s')`、`fullcommand('sub')`、`fullcommand(':%substitute')` 都返回 "substitute"。

参数：
  • {name} (字符串类型)

返回值：
  (字符串类型)

funcref({name} [, {arglist}] [, {dict}])                             *funcref()*
		与 |function()| 完全相同，但返回的 Funcref 将通过引用查找函数，而不是通过名称。
		这在函数 {name} 稍后被重新定义时很重要。
		与 |function()| 不同，{name} 必须是一个已存在的用户函数。
		它只对已经加载的自动加载函数有效（为避免在只打算使用函数名时错误地加载自动加载脚本，请使用 |function()| 代替）。
		{name} 不能是内置函数。
		出错时返回 0。

参数：
  • {name} (字符串类型)
  • {arglist} (任意类型，可选)
  • {dict} (任意类型，可选)

返回值：
  (任意类型)

function({name} [, {arglist}] [, {dict}])         *function()* *partial* *E700* *E923*
		返回一个引用函数 {name} 的 |Funcref| 变量。
		{name} 可以是用户定义函数或内部函数的名称。

		{name} 也可以是 Funcref 或 partial。当它是 partial 时，将使用其中存储的字典，且不允许使用 {dict} 参数。
		例如：>vim
			let FuncWithArg = function(dict.Func, [arg])
			let Broken = function(dict.Func, [arg], dict)
<
		使用 Funcref 时，将通过 {name} 找到函数，即使它后来被重新定义。使用 |funcref()| 可以保持相同的函数。

		当存在 {arglist} 或 {dict} 时，这会创建一个 partial。
		这意味着参数列表和/或字典会存储在 Funcref 中，并在调用 Funcref 时使用。

		这些参数会在其他参数之前传递给函数，但在 |method| 的任何参数之后。
		示例：>vim
			func Callback(arg1, arg2, name)
			"...
			endfunc
			let Partial = function('Callback', ['one', 'two'])
			"...
			call Partial('name')
<		调用函数的方式如下：>vim
			call Callback('one', 'two', 'name')

<		使用 |method|：>vim
			func Callback(one, two, three)
			"...
			endfunc
			let Partial = function('Callback', ['two'])
			"...
			eval 'one'->Partial('three')
<		调用函数的方式如下：>vim
			call Callback('one', 'two', 'three')

<		function() 调用可以嵌套，以向 Funcref 添加更多参数。额外的参数会被追加到参数列表中。
		示例：>vim
			func Callback(arg1, arg2, name)
			"...
			endfunc
			let Func = function('Callback', ['one'])
			let Func2 = function(Func, ['two'])
			"...
			call Func2('name')
<		调用函数的方式如下：>vim
			call Callback('one', 'two', 'name')

<		字典只在调用 "dict" 函数时有用。在这种情况下，{dict} 作为 "self" 传入。
		示例：>vim
			function Callback() dict
			   echo "called for " .. self.name
			endfunction
			"...
			let context = {"name": "example"}
			let Func = function('Callback', context)
			"...
			call Func()	" 将输出：called for example
<		当没有额外参数时，不需要使用 function()，如果 Callback() 被定义为 context.Callback()，
		以下两种方式是等价的：>vim
			let Func = function('Callback', context)
			let Func = context.Callback

<		参数列表和字典可以组合使用：>vim
			function Callback(arg1, count) dict
			"...
			endfunction
			let context = {"name": "example"}
			let Func = function('Callback', ['one'], context)
			"...
			call Func(500)
<		调用函数的方式如下：>vim
			call context.Callback('one', 500)
<
		出错时返回 0。

参数：
  • {name} (字符串类型)
                  • {arglist} (任意类型，可选)
                  • {dict} (任意类型，可选)

返回值：
  (任意类型)

garbagecollect([{atexit}])                                    *garbagecollect()*
		清理未使用的具有循环引用的 |Lists| 和 |Dictionaries|。

		几乎不需要调用这个函数，因为当 Vim 内存不足或在 'updatetime' 后等待用户按键时，
		它会自动执行。没有循环引用的项目在不再使用时总是会被释放。
		如果你在长时间运行的脚本中删除了一个具有循环引用的非常大的 |List| 和/或 |Dictionary|，
		这个函数会很有用。

		当可选参数 {atexit} 为 1 时，如果之前没有进行过垃圾收集，
		在退出 Vim 时也会进行垃圾收集。这在检查内存泄漏时很有用。

		垃圾收集不会立即执行，而是在安全的时候才执行。
		这通常是在等待用户输入字符时。

参数：
  • {atexit} (布尔类型，可选)

返回值：
  (任意类型)

get({list}, {idx} [, {default}])                              *get()* *get()-list*
		从 |List| {list} 中获取项目 {idx}。当该项目不可用时返回 {default}。
		如果省略 {default}，则返回零。

参数：
  • {list} (任意类型数组)
  • {idx} (整数类型)
  • {default} (任意类型，可选)

返回值：
  (任意类型)

get({blob}, {idx} [, {default}])                                    *get()-blob*
		从 |Blob| {blob} 中获取字节 {idx}。当该字节不可用时返回 {default}。
		如果省略 {default}，则返回 -1。
参数：
  • {blob} (字符串类型)
  • {idx} (整数类型)
  • {default} (任意类型，可选)

返回值：
  (任意类型)

get({dict}, {key} [, {default}])                                    *get()-dict*
		从 |Dictionary| {dict} 中获取键为 {key} 的项目。当该项目不可用时返回 {default}。
		如果省略 {default}，则返回零。有用的示例：>vim
			let val = get(g:, 'var_name', 'default')
<		这会获取 g:var_name 的值（如果它存在），如果不存在则使用 "default"。

参数：
  • {dict} (字符串到任意类型的表)
  • {key} (字符串类型)
  • {default} (任意类型，可选)

返回值：
  (任意类型)

get({func}, {what})                                                 *get()-func*
		从 |Funcref| {func} 中获取项目 {what}。{what} 的可能值为：
		  "name"    函数名
		  "func"    函数本身
		  "dict"    字典
		  "args"    参数列表
		  "arity"   一个包含函数接受的参数数量信息的字典（减去 {arglist}），
			    包含以下字段：
				required    必需的位置参数数量
				optional    可选参数的数量（除了必需的参数）
				varargs     如果函数接受可变数量的参数 |...|，则为 |TRUE|

				注意：如果 Funcref 的 {arglist} 包含的参数比 Funcref 期望的多，
				不会报错，它不会被验证。

		出错时返回零。

参数：
  • {func} (函数类型)
  • {what} (字符串类型)
返回值：
  (任意类型)

getbufinfo([{buf}])                                               *getbufinfo()*
getbufinfo([{dict}])
		获取有关缓冲区的信息，返回一个字典列表。

		如果没有参数，则返回所有缓冲区的信息。

		当参数是一个 |Dictionary| 时，只返回符合指定条件的缓冲区。
		在 {dict} 中可以指定以下键：
			buflisted	仅包含已列出的缓冲区。
			bufloaded	仅包含已加载的缓冲区。
			bufmodified	仅包含已修改的缓冲区。

		否则，{buf} 指定要返回信息的特定缓冲区。关于 {buf} 的使用，
		请参见上面的 |bufname()|。如果找到缓冲区，返回的列表有一个项目。
		否则结果是一个空列表。

		每个返回的列表项是一个包含以下条目的字典：
			bufnr		缓冲区编号。
			changed		如果缓冲区已修改则为 TRUE。
			changedtick	对缓冲区所做更改的次数。
			command		如果缓冲区属于命令行窗口 |cmdwin| 则为 TRUE。
			hidden		如果缓冲区被隐藏则为 TRUE。
			lastused	缓冲区最后使用的时间戳（以秒为单位，类似于 |localtime()|）。
			listed		如果缓冲区已列出则为 TRUE。
			lnum		当在当前窗口打开缓冲区时使用的行号。
					仅在缓冲区过去已在窗口中显示过时有效。
					如果你想获取给定窗口中最后已知光标位置的行号，
					请使用 |line()|：>vim
						echo line('.', {winid})
<
			linecount	缓冲区中的行数（仅在加载时有效）
			loaded		如果缓冲区已加载则为 TRUE。
			name		缓冲区中文件的完整路径。
			signs		放置在缓冲区中的标记列表。
					每个列表项是一个包含以下字段的字典：
					    id	  标记标识符
					    lnum  行号
					    name  标记名称
			variables	指向缓冲区局部变量字典的引用。
			windows		显示此缓冲区的 |window-ID| 列表

		示例：>vim
			for buf in getbufinfo()
			    echo buf.name
			endfor
			for buf in getbufinfo({'buflisted':1})
			    if buf.changed
				" ....
			    endif
			endfor
<
		要获取缓冲区局部选项，请使用：>vim
			getbufvar({bufnr}, '&option_name')
<

参数：
  • {dict} (vim.fn.getbufinfo.dict，可选)

返回值：
  (vim.fn.getbufinfo.ret.item 数组)

getbufline({buf}, {lnum} [, {end}])                               *getbufline()*
		返回一个 |List|，包含缓冲区 {buf} 中从 {lnum} 到 {end}（包含）的行。
		如果省略 {end}，则返回只包含行 {lnum} 的 |List|。
		要只获取一行，请参见 `getbufoneline()`。

		关于 {buf} 的使用，请参见上面的 |bufname()|。

		对于 {lnum} 和 {end}，可以使用 "$" 表示缓冲区的最后一行。
		否则必须使用数字。

		当 {lnum} 小于 1 或大于缓冲区的行数时，返回空 |List|。

		当 {end} 大于缓冲区的行数时，它会被视为 {end} 设置为缓冲区的行数。
		当 {end} 在 {lnum} 之前时，返回空 |List|。

		此函数仅适用于已加载的缓冲区。对于未加载和不存在的缓冲区，返回空 |List|。
		示例：>vim
			let lines = getbufline(bufnr("myfile"), 1, "$")
<

参数：
  • {buf} (整数|字符串类型)
  • {lnum} (整数类型)
  • {end} (整数类型，可选)

返回值：
  (字符串数组)

getbufoneline({buf}, {lnum})                                   *getbufoneline()*
		与 `getbufline()` 类似，但只获取一行并将其作为字符串返回。

参数：
  • {buf} (整数|字符串类型)
  • {lnum} (整数类型)

返回值：
  (字符串类型)

getbufvar({buf}, {varname} [, {def}])                              *getbufvar()*
		结果是缓冲区 {buf} 中选项或局部缓冲区变量 {varname} 的值。
		注意必须使用不带 "b:" 的名称。
		{varname} 参数是一个字符串。
		当 {varname} 为空时，返回包含所有缓冲区局部变量的 |Dictionary|。
		当 {varname} 等于 "&" 时，返回包含所有缓冲区局部选项的 |Dictionary|。
		否则，当 {varname} 以 "&" 开头时，返回缓冲区局部选项的值。
		这也适用于全局或缓冲区局部选项，但不适用于全局变量、窗口局部变量或窗口局部选项。
		关于 {buf} 的使用，请参见上面的 |bufname()|。
		当缓冲区或变量不存在时，返回 {def} 或空字符串，不会有错误消息。
		示例：>vim
			let bufmodified = getbufvar(1, "&mod")
			echo "todo myvar = " .. getbufvar("todo", "myvar")

参数：
  • {buf} (整数|字符串类型)
  • {varname} (字符串类型)
  • {def} (任意类型，可选)

返回值：
getcellwidths()                                                *getcellwidths()*
		返回一个 |List|，包含由 |setcellwidths()| 覆盖的字符范围的单元格宽度。
		格式与 |setcellwidths()| 的参数相同。如果没有字符范围的单元格宽度被覆盖，
		则返回空列表。

返回值：
  (任意类型)

getchangelist([{buf}])                                         *getchangelist()*
		返回缓冲区 {buf} 的 |changelist|（更改列表）。关于 {buf} 的使用，
		请参见上面的 |bufname()|。如果缓冲区 {buf} 不存在，则返回空列表。

		返回的列表包含两个条目：一个包含更改位置的列表和列表中的当前位置。
		更改列表中的每个条目都是一个包含以下条目的字典：
			col		列号
			coladd		'virtualedit' 的列偏移
			lnum		行号
		如果缓冲区 {buf} 是当前缓冲区，则当前位置指的是列表中的位置。
		对于其他缓冲区，它被设置为列表的长度。

参数：
  • {buf} (整数|字符串类型，可选)

返回值：
  (表类型数组)

getchar([{expr} [, {opts}]])                                         *getchar()*
		从用户或输入流获取单个字符。
		如果省略 {expr} 或为 -1，等待直到有字符可用。
		如果 {expr} 为 0，仅在有字符可用时获取字符。
			否则返回零。
		如果 {expr} 为 1，仅检查是否有字符可用，不消耗它。
			如果没有字符可用，返回零。
		如果你更喜欢总是获取字符串，请使用 |getcharstr()|，
		或在 {opts} 中指定 |FALSE| 作为 "number"。

		在没有 {expr} 和当 {expr} 为 0 时，返回一个完整的字符或特殊键。
		如果是单个字符，结果是一个数字。使用 |nr2char()| 将其转换为字符串。
		否则返回一个包含编码字符的字符串。
		对于特殊键，它是一个以 0x80（十进制：128）开头的字节序列字符串。
		这与以下值相同：
		如果你更喜欢总是获取字符串，请使用 |getcharstr()|，
		或在 {opts} 中指定 |FALSE| 作为 "number"。

		当没有 {expr} 和当 {expr} 为 0 时，返回一个完整的字符或特殊键。
		如果是单个字符，结果是一个数字。使用 |nr2char()| 将其转换为字符串。
		否则返回一个包含编码字符的字符串。
		对于特殊键，它是一个以 0x80（十进制：128）开头的字节序列字符串。
		这与字符串 "\<Key>" 的值相同，例如 "\<Left>"。
		当使用了未包含在字符中的修饰符（shift、control、alt）时，
		返回值也是一个字符串。|keytrans()| 也可以用来将返回的字符串转换为可读形式。

		当 {expr} 为 0 且按下 Esc 键时，会有短暂延迟，
		因为 Vim 需要等待以确定这是否是转义序列的开始。

		当 {expr} 为 1 时，只返回第一个字节。对于单字节字符，
		它是作为数字的字符本身。使用 nr2char() 将其转换为字符串。

		使用 getcharmod() 获取任何额外的修饰符。

		可选参数 {opts} 是一个字典，支持以下项目：

			cursor		一个指定等待字符时光标行为的字符串。
					"hide"：隐藏光标。
					"keep"：保持当前光标不变。
					"msg"：将光标移动到消息区域。
					（默认：自动决定使用 "keep" 或 "msg"）

			number		如果为 |TRUE|，在获取单个字符时返回数字。
					如果为 |FALSE|，返回值总是转换为字符串，
					当没有可用字符时返回空字符串（而不是 0）。
					（默认：|TRUE|）

			simplify	如果为 |TRUE|，尽可能在字符中包含修饰符。
					例如，对于 CTRL-I 和 <Tab> 返回相同的值。
					如果为 |FALSE|，不在字符中包含修饰符。
					（默认：|TRUE|）

		当用户点击鼠标按钮时，将返回鼠标事件。然后可以在 |v:mouse_col|、
		|v:mouse_lnum|、|v:mouse_winid| 和 |v:mouse_win| 中找到位置。
		也可以使用 |getmousepos()|。鼠标移动事件将被忽略。
		这个例子演示了如何正常定位鼠标：
		>vim
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win .. "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " .. v:mouse_col .. "|"
			endif
<
		没有提示，你需要以某种方式让用户明白需要输入一个字符。
		屏幕不会重绘，例如当调整窗口大小时。

		对字符不进行映射。
		按键码会被替换，因此当用户按下 <Del> 键时，
		你获得的是 <Del> 键的代码，而不是原始的字符序列。例如：
>vim
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<
		这个例子重新定义了 "f" 命令以忽略大小写：
>vim
			nmap f :call FindChar()<CR>
			function FindChar()
			  let c = nr2char(getchar())
			  while col('.') < col('$') - 1
			    normal l
			    if getline('.')[col('.') - 1] ==? c
			      break
			    endif
			  endwhile
			endfunction
<

getcharmod()                                                      *getcharmod()*
		返回一个数字，表示最后通过 getchar() 或其他方式获取的字符的修饰符状态。
		这些值会相加：
			2	shift（上档键）
			4	control（控制键）
			8	alt（替代键/元键）
			16	meta（当它与 ALT 不同时）
			32	鼠标双击
			64	鼠标三击
			96	鼠标四击（== 32 + 64）
			128	command（Mac）或 super 键
		只返回那些未包含在字符本身中的修饰符。
		因此 Shift-a 会得到 "A" 而没有修饰符。
		如果没有使用修饰符则返回 0。
getcellwidths()                                                *getcellwidths()*
		返回一个 |List|（列表），包含由 |setcellwidths()| 覆盖的字符范围的单元格宽度。
		返回格式与 |setcellwidths()| 的参数格式相同。
		如果没有字符范围的单元格宽度被覆盖，则返回空列表。

getchangelist([{buf}])                                         *getchangelist()*
		返回缓冲区 {buf} 的 |changelist|（改变列表）。关于 {buf} 的使用，
		请参见上面的 |bufname()|。如果缓冲区 {buf} 不存在，则返回空列表。

		返回的列表包含两个条目：一个包含改变位置的列表和当前在列表中的位置。
		改变列表中的每个条目都是一个包含以下内容的字典：
			col		列号
			coladd		'virtualedit' 的列偏移
			lnum		行号
		如果缓冲区 {buf} 是当前缓冲区，则当前位置指向列表中的位置。
		对于其他缓冲区，它被设置为列表的长度。

getcharstr([{expr}])                                              *getcharstr()*
		与 |getchar()| 功能相同，但此函数总是返回一个字符串，
		并且在 {opts} 中不允许使用 "number" 选项。

getcharpos({expr})                                                *getcharpos()*
		获取字符串 {expr} 的位置。与 |getpos()| 相同，但返回的列表中的列号
		是字符索引而不是字节索引。
		如果 |getpos()| 返回一个非常大的列号（等于 |v:maxcol|），
		则 getcharpos() 将返回最后一个字符的字符索引。

		示例：
		当光标位于第5行文本"여보세요"中的'세'字符上时：
>vim
			getcharpos('.')		返回 [0, 5, 3, 0]
			getpos('.')		返回 [0, 5, 7, 0]
<

getcharsearch()                                                *getcharsearch()*
		返回当前字符搜索信息，以字典形式返回，包含以下条目：

		    char	之前用于字符搜索的字符（|t|、|f|、|T| 或 |F|）；
				如果没有执行过字符搜索，则为空字符串
		    forward	字符搜索的方向；1 表示向前，0 表示向后
		    until	字符搜索的类型；1 表示 |t| 或 |T| 字符搜索，
				0 表示 |f| 或 |F| 字符搜索

		这对于确保 |;| 和 |,| 始终按照特定方向搜索很有用，
		而不受之前字符搜索方向的影响：
>vim
			nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		另请参见 |setcharsearch()|。
getchar([{expr} [, {opts}]])                                          *getchar()*
		获取一个字符输入。当 {expr} 为 0 或省略时，等待用户输入一个字符。
		如果输入的是一个特殊键，返回的是字符串 "\<Key>"，例如 "\<Left>"。
		当使用了一个未包含在字符中的修饰符（shift、control、alt）时，
		返回值也是一个字符串。|keytrans()| 也可以用来将返回的字符串转换为可读形式。

		当 {expr} 为 0 且按下 Esc 键时，会有一个短暂的延迟，
		因为 Vim 需要等待以确定这是否是转义序列的开始。

		当 {expr} 为 1 时，只返回第一个字节。对于单字节字符，
		返回的是字符本身的数值。使用 nr2char() 可以将其转换为字符串。

		使用 getcharmod() 可以获取任何额外的修饰符。

		可选参数 {opts} 是一个字典，支持以下项目：

			cursor		指定等待字符输入时光标行为的字符串。
					"hide"：隐藏光标
					"keep"：保持当前光标不变
					"msg"：将光标移动到消息区域
					（默认：自动在"keep"和"msg"之间决定）

			number		如果为 |TRUE|，在获取单个字符时返回数值。
					如果为 |FALSE|，返回值总是转换为字符串，
					当没有可用字符时返回空字符串（而不是0）。
					（默认：|TRUE|）

			simplify	如果为 |TRUE|，尽可能在字符中包含修饰符。
					例如，CTRL-I 和 <Tab> 返回相同的值。
					如果为 |FALSE|，不在字符中包含修饰符。
					（默认：|TRUE|）

		当用户点击鼠标按钮时，将返回鼠标事件。然后可以在 |v:mouse_col|、
		|v:mouse_lnum|、|v:mouse_winid| 和 |v:mouse_win| 中找到位置。
		也可以使用 |getmousepos()|。鼠标移动事件将被忽略。

		这个示例将鼠标定位到正常情况下的位置：
>vim
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win .. "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " .. v:mouse_col .. "|"
			endif
<
		没有提示，你需要以某种方式让用户明白需要输入一个字符。
		屏幕不会重绘，例如在调整窗口大小时。

		对字符没有映射。
		按键码会被替换，因此当用户按下 <Del> 键时，
		你得到的是 <Del> 键的代码，而不是原始的字符序列。示例：
>vim
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<
		这个示例重新定义了 "f" 命令以忽略大小写：
>vim
			nmap f :call FindChar()<CR>
			function FindChar()
			  let c = nr2char(getchar())
			  while col('.') < col('$') - 1
			    normal l
			    if getline('.')[col('.') - 1] ==? c
			      break
			    endif
			  endwhile
			endfunction
<
getcharmod()                                                      *getcharmod()*
		返回一个数字，表示最后通过 getchar() 或其他方式获取的字符的修饰符状态。
		这些值会被相加：
			2	shift（上档键）
			4	control（控制键）
			8	alt（替代键/元键）
			16	meta（当它与 ALT 不同时）
			32	鼠标双击
			64	鼠标三击
			96	鼠标四击（== 32 + 64）
			128	command（Mac）或 super 键
		只返回未包含在字符本身中的修饰符。
		因此 Shift-a 会返回 "A" 而没有修饰符。
		如果没有使用修饰符，返回 0。

getcmdcomplpat()                                              *getcmdcomplpat()*
		返回当前命令行的补全模式。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、
		|getcmdprompt()|、|getcmdcompltype()| 和 |setcmdline()|。
		当未定义补全时返回空字符串。

getcmdcompltype()                                            *getcmdcompltype()*
		返回当前命令行补全的类型。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		返回值见 |:command-completion|。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、
		|getcmdprompt()|、|getcmdcomplpat()| 和 |setcmdline()|。
		当未定义补全时返回空字符串。

getcmdline()                                                      *getcmdline()*
		返回当前命令行输入。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		示例：
>vim
			cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<
		另见 |getcmdtype()|、|getcmdpos()|、|setcmdpos()|、
		|getcmdprompt()| 和 |setcmdline()|。
		在输入密码或使用 |inputsecret()| 时返回空字符串。

getcmdpos()                                                        *getcmdpos()*
		返回光标在命令行中的位置（以字节计）。第一列是 1。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|
		或表达式映射。否则返回 0。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、
		|getcmdprompt()| 和 |setcmdline()|。

getcmdprompt()                                                  *getcmdprompt()*
		在使用 |input()| 或 |confirm()| 等函数时，返回当前命令行提示。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		另见 |getcmdtype()|、|getcmdline()|、|getcmdpos()|、
		|setcmdpos()| 和 |setcmdline()|。

getcmdscreenpos()                                            *getcmdscreenpos()*
		返回光标在命令行中的屏幕位置（以字节计）。第一列是 1。
		与 |getcmdpos()| 不同，它会加上提示的位置。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|
		或表达式映射。否则返回 0。
		另见 |getcmdpos()|、|setcmdpos()|、|getcmdline()| 和 |setcmdline()|。

getcmdtype()                                                      *getcmdtype()*
		返回当前命令行类型。可能的返回值有：
		    :	普通 Ex 命令
		    >	调试模式命令 |debug-mode|
		    /	向前搜索命令
		    ?	向后搜索命令
		    @	|input()| 命令
		    `-`	|:insert| 或 |:append| 命令
		    =	|i_CTRL-R_=|
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|
		或表达式映射。否则返回空字符串。
		另见 |getcmdpos()|、|setcmdpos()| 和 |getcmdline()|。

getcmdwintype()                                                *getcmdwintype()*
		返回当前命令行窗口类型。

让我继续查看并翻译下一部分内容：
getcharpos({expr})                                                *getcharpos()*
		获取字符串 {expr} 的位置。与 |getpos()| 类似，但返回的 List 中的列号是
		字符索引而不是字节索引。
		如果 |getpos()| 返回一个非常大的列号（等于 |v:maxcol|），则 getcharpos() 
		将返回最后一个字符的字符索引。

		示例：
		在第5行包含文本 "여보세요" 时，光标位于 '세' 上：
>vim
			getcharpos('.')		返回 [0, 5, 3, 0]
			getpos('.')		返回 [0, 5, 7, 0]
<

getcharsearch()                                                *getcharsearch()*
		返回当前字符搜索信息，以字典形式返回，包含以下条目：

		    char	之前用于字符搜索的字符（|t|、|f|、|T| 或 |F|）；
				如果没有执行过字符搜索则为空字符串
		    forward	字符搜索的方向；1 表示向前，0 表示向后
		    until	字符搜索的类型；1 表示 |t| 或 |T| 字符搜索，
				0 表示 |f| 或 |F| 字符搜索

		这对于让 |;| 和 |,| 始终按照特定方向搜索很有用，不受之前字符搜索方向的影响：
>vim
			nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		另见 |setcharsearch()|。

getcharstr([{expr}])                                              *getcharstr()*
		与 |getchar()| 相同，但总是返回一个字符串，并且在 {opts} 中不允许使用
		"number" 选项。

getcompletion({pat}, {type} [, {filtered}])                    *getcompletion()*
		返回命令行补全匹配的列表。字符串参数 {type} 指定补全类型。
		支持以下补全类型：

		arglist		参数列表中的文件名
		augroup		自动命令组
		buffer		缓冲区名称
		breakpoint	|:breakadd| 和 |:breakdel| 子选项
		cmdline		|cmdline-completion| 结果
		color		配色方案
		command		Ex 命令
		compiler	编译器
		custom,{func}	通过 {func} 定义的自定义补全
		customlist,{func} 通过 {func} 定义的自定义补全
		diff_buffer	|:diffget| 和 |:diffput| 补全
		dir		目录名称
		dir_in_path	|'cdpath'| 中的目录名称
		environment	环境变量名称
		event		自动命令事件
		expression	Vim 表达式
		file		文件和目录名称
		file_in_path	|'path'| 中的文件和目录名称
		filetype	文件类型名称 |'filetype'|
		function	函数名称
		help		帮助主题
		highlight	高亮组
		history		|:history| 子选项
		keymap		键盘映射
		locale		区域设置名称（与 locale -a 输出相同）
		mapclear	缓冲区参数
		mapping		映射名称
		menu		菜单
		messages	|:messages| 子选项
		option		选项
		packadd		可选包 |pack-add| 名称
		runtime		|:runtime| 补全
		scriptnames	已加载脚本名称 |:scriptnames|
		shellcmd	Shell 命令
		shellcmdline	带文件名参数的 Shell 命令行
		sign		|:sign| 子选项
		syntax		语法文件名称 |'syntax'|
		syntime		|:syntime| 子选项
		tag		标签

让我继续查看并翻译下一部分内容：

??????????????

getreg([{regname} [, 1 [, {list}]]])                                  *getreg()*
		结果是一个字符串，即寄存器 {regname} 的内容。示例：
>vim
			let cliptext = getreg('*')
<		当寄存器 {regname} 未设置时，结果是一个空字符串。
		{regname} 参数必须是一个字符串。

		getreg('=') 返回表达式寄存器的最后求值结果。（用于映射中。）
		getreg('=', 1) 返回表达式本身，以便可以用 |setreg()| 恢复。
		对于其他寄存器，额外的参数会被忽略，因此你可以始终提供它。

		如果存在 {list} 且为 |TRUE|，则结果类型更改为 |List|。
		每个列表项是一行文本。如果你关心寄存器中可能存在的零字节，
		请使用它：没有第三个参数时，NL 和零字节都表示为 NL
		（参见 |NL-used-for-Nul|）。
		当寄存器未设置时，返回一个空列表。

		如果未指定 {regname}，则使用 |v:register|。

getreginfo([{regname}])                                           *getreginfo()*
		返回关于寄存器 {regname} 的详细信息，作为一个包含以下条目的字典：
			regcontents	寄存器 {regname} 中包含的行列表，类似于
					getreg({regname}, 1, 1)。
			regtype		寄存器 {regname} 的类型，如 |getregtype()|。
			isunnamed	布尔标志，如果此寄存器当前由未命名寄存器
					指向，则为 v:true。
			points_to	对于未命名寄存器，给出当前指向的寄存器的
					单个字母名称（参见 |quotequote|）。
					例如，使用 `dd` 删除一行后，此字段将为 "1"，
					这是获得删除文本的寄存器。

		{regname} 参数是一个字符串。如果 {regname} 无效或未设置，
		将返回一个空字典。
		如果未指定 {regname}，则使用 |v:register|。
		返回的字典可以传递给 |setreg()|。

getregion({pos1}, {pos2} [, {opts}])                               *getregion()*
		返回从 {pos1} 到 {pos2} 的缓冲区中的字符串列表。

		{pos1} 和 {pos2} 都必须是包含四个数字的 |List|。
		有关列表格式，请参见 |getpos()|。可以指定来自不同缓冲区的
		位置，但请注意 |getregion-notes| 中的限制。

		可选参数 {opts} 是一个 Dict，支持以下项目：

			type		指定区域的选择类型。
					有关可能的值，请参见 |getregtype()|，
					但可以省略宽度且不能使用空字符串。
					（默认值："v"）

			exclusive	如果为 |TRUE|，对结束位置使用独占选择。
					（默认值：遵循 'selection'）

		你可以通过 |visualmode()| 获取最后的选择类型。
		如果可视模式处于活动状态，使用 |mode()| 获取可视模式
		（例如，在 |:vmap| 中）。
		此函数对于获取在不同列开始和结束的文本很有用，例如
		|charwise-visual| 选择。

							*getregion-notes*
		注意：
		- {pos1} 和 {pos2} 的顺序无关紧要，它总是返回从左上角位置
		  到右下角位置的内容。
		- 如果启用了 'virtualedit' 且区域在行尾之后，结果行会用空格填充。
		- 如果区域是块状的且它开始或结束于多单元格字符的中间，
		  则不包含该字符，但其选中的部分会被空格替换。
		- 如果 {pos1} 和 {pos2} 不在同一个缓冲区中，则返回空列表。
		- {pos1} 和 {pos2} 必须属于 |bufloaded()| 缓冲区。
		- 它在当前窗口上下文中评估，如果缓冲区显示在具有不同
		  'virtualedit' 或 'list' 值的窗口中，这会产生差异。

		示例：
>vim
			xnoremap <CR>
			\ <Cmd>echom getregion(
			\ getpos('v'), getpos('.'), #{ type: mode() })<CR>
getregionpos({pos1}, {pos2} [, {opts}])                         *getregionpos()*
		与 |getregion()| 相同，但返回一个描述由 {pos1} 和 {pos2} 
		界定的缓冲区文本段的位置列表。
		每个段是每行的一对位置：
>			[[{start_pos}, {end_pos}], ...]
<
		位置是一个包含四个数字的 |List|：
		    [bufnum, lnum, col, off]
		"bufnum" 是缓冲区编号。
		"lnum" 和 "col" 是缓冲区中的位置。第一列是 1。
		如果起始位置的 "off" 数字不为零，它是从字符开始处的屏幕列偏移量。
		例如，<Tab> 内的位置或最后一个字符之后的位置。
		如果结束位置的 "off" 数字不为零，它是未包含在选择中的字符的
		第一个单元格的偏移量，否则包含其所有单元格。

		除了 |getregion()| 支持的选项外，{opts} 还支持以下内容：

			eol		如果为 |TRUE|，使用比行长多 1 的 "col" 值
					表示行尾之后的位置。
					如果为 |FALSE|，位置被限制在其行内，如果一行
					为空或选择完全在行尾之后，则对两个位置都使用
					0 的 "col" 值。
					（默认值：|FALSE|）

getregtype([{regname}])                                           *getregtype()*
		结果是一个字符串，表示寄存器 {regname} 的类型。
		值将是以下之一：
		    "v"			用于 |charwise| 文本
		    "V"			用于 |linewise| 文本
		    "<CTRL-V>{width}"	用于 |blockwise-visual| 文本
		    ""			用于空或未知寄存器
		<CTRL-V> 是一个值为 0x16 的字符。
		{regname} 参数是一个字符串。如果未指定 {regname}，则使用
		|v:register|。

getscriptinfo([{opts}])                                        *getscriptinfo()*
		返回一个 |List|，包含所有已加载的 Vim 脚本的信息，按照它们
		被加载的顺序，类似于 `:scriptnames` 显示的内容。

		可选的 Dict 参数 {opts} 支持以下可选项目：
		    name	脚本名称匹配模式。如果指定，且未指定 "sid"，
				则返回名称匹配模式 "name" 的脚本的信息。
		    sid		脚本 ID |<SID>|。如果指定，则只返回 ID 为 "sid"
				的脚本的信息，并忽略 "name"。

		返回的 List 中的每个项目都是一个包含以下项目的 |Dict|：
		    autoload	始终设置为 FALSE。
		    functions	脚本中定义的脚本局部函数名称列表。仅当使用
				{opts} 中的 "sid" 项目指定特定脚本时存在。
		    name	Vim 脚本文件名。
		    sid		脚本 ID |<SID>|。
		    variables	包含脚本局部变量的字典。仅当使用 {opts} 中的
				"sid" 项目指定特定脚本时存在。请注意这是一个
				副本，不能使用此字典更改脚本局部变量的值。
		    version	Vim 脚本版本，始终为 1

		示例：
			echo getscriptinfo({'name': 'myscript'})
			echo getscriptinfo({'sid': 15})[0].variables
<

getstacktrace()                                                *getstacktrace()*
		返回 Vim 脚本的当前堆栈跟踪。
		堆栈跟踪是一个 |List|，其中每个项目都是一个包含以下项目的
		|Dictionary|：
		    funcref	如果堆栈在函数处，则为函数引用，否则省略此项目。
		    event	如果堆栈在自动命令事件处，则为事件描述的字符串，
				否则省略此项目。
		    lnum	堆栈上脚本的行号。
		    filepath	堆栈上脚本的文件路径。

gettabinfo([{tabnr}])                                             *gettabinfo()*
		如果未指定 {tabnr}，则返回所有标签页的信息作为 |List|。
		每个 List 项目都是一个 |Dictionary|。否则，{tabnr} 指定标签页
		编号，并返回该标签页的信息。如果标签页不存在，则返回空 List。

		每个 List 项目都是一个包含以下条目的 |Dictionary|：
			tabnr		标签页编号。
			variables	对包含标签页局部变量的字典的引用
			windows		标签页中的 |window-ID| 列表。

gettabvar({tabnr}, {varname} [, {def}])                            *gettabvar()*
		获取标签页 {tabnr} 中标签页局部变量 {varname} 的值。|t:var|
		标签页从 1 开始编号。
		{varname} 参数是一个字符串。当 {varname} 为空时，返回包含所有
		标签页局部变量的字典。
		注意必须使用不带 "t:" 的名称。
		当标签页或变量不存在时，返回 {def} 或空字符串，没有错误消息。

gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])             *gettabwinvar()*
		获取标签页 {tabnr} 中窗口 {winnr} 的窗口局部变量 {varname} 的值。
		{varname} 参数是一个字符串。当 {varname} 为空时，返回包含所有
		窗口局部变量的字典。
		当 {varname} 等于 "&" 时，获取所有窗口局部选项的值作为 |Dictionary|。
		否则，当 {varname} 以 "&" 开头时，获取窗口局部选项的值。
		注意 {varname} 必须是不带 "w:" 的名称。
		标签页从 1 开始编号。对于当前标签页，使用 |getwinvar()|。
		{winnr} 可以是窗口编号或 |window-ID|。
		当 {winnr} 为零时，使用当前窗口。
		这也适用于全局选项、缓冲区局部选项和窗口局部选项，但不适用于
		全局变量或缓冲区局部变量。
		当标签页、窗口或变量不存在时，返回 {def} 或空字符串，没有错误消息。
		示例：
>vim
			let list_is_on = gettabwinvar(1, 2, '&list')
			echo "myvar = " .. gettabwinvar(3, 1, 'myvar')
<
		要获取所有窗口局部变量，请使用：
>vim
			gettabwinvar({tabnr}, {winnr}, '&')
<

gettagstack([{winnr}])                                           *gettagstack()*
		结果是一个 Dict，它是窗口 {winnr} 的标签堆栈。
		{winnr} 可以是窗口编号或 |window-ID|。
		当未指定 {winnr} 时，使用当前窗口。
		当窗口 {winnr} 不存在时，返回空 Dict。

		返回的字典包含以下条目：
			curidx		堆栈中的当前索引。当在堆栈顶部时，设置为
					(长度 + 1)。堆栈底部的索引是 1。
			items		堆栈中的项目列表。每个项目都是一个包含
					下面描述的条目的字典。
			length		堆栈中的条目数。

		堆栈中的每个项目都是一个包含以下条目的字典：
			bufnr		当前跳转的缓冲区编号
			from		标签跳转前的光标位置。有关返回列表的
					格式，请参见 |getpos()|。
			matchnr		当前匹配的标签编号。当为一个名称找到多个
					匹配标签时使用。
			tagname		标签的名称

		有关标签堆栈的更多信息，请参见 |tagstack|。

gettext({text})                                                      *gettext()*
		如果可能，翻译字符串 {text}。
		这主要用于分发的 Vim 脚本。当生成消息翻译时，{text} 由
		xgettext 提取，翻译者可以在 .po 文件中添加翻译后的消息，
		当调用 gettext() 时，Vim 将查找翻译。
		对于 {text}，优先使用双引号字符串，因为 xgettext 不理解
		单引号字符串中的转义。

getwininfo([{winid}])                                             *getwininfo()*
		返回关于窗口的信息作为包含字典的 |List|。

		如果给出了 {winid}，则返回具有该 ID 的窗口的信息，作为包含一个
		项目的 |List|。如果窗口不存在，则结果为空列表。

		没有 {winid} 时，返回所有标签页中所有窗口的信息。

		每个 List 项目都是一个包含以下条目的 |Dictionary|：
			botline		最后完整显示的缓冲区行
			bufnr		窗口中缓冲区的编号
			height		窗口高度（不包括工具栏）
			leftcol		显示的第一列；仅在 'wrap' 关闭时使用
			loclist		如果显示位置列表则为 1
			quickfix	如果是快速修复或位置列表窗口则为 1
			terminal	如果是终端窗口则为 1
			tabnr		标签页编号
			topline		显示的第一行缓冲区行
			variables	对包含窗口局部变量的字典的引用
			width		窗口宽度
			winbar		如果窗口有工具栏则为 1，否则为 0
			wincol		窗口最左侧的屏幕列；来自 |win_screenpos()| 的
					"col"
			textoff		文本前任何 'foldcolumn'、'signcolumn' 和行号
					占用的列数
			winid		|window-ID|
			winnr		窗口编号
			winrow		窗口最顶部的屏幕行；来自 |win_screenpos()| 的
					"row"

getwinpos([{timeout}])                                             *getwinpos()*
		结果是一个包含两个数字的 |List|，|getwinposx()| 和 |getwinposy()| 
		的组合：
			[x-pos, y-pos]
		{timeout} 可用于指定等待终端响应的毫秒数。省略时使用 100 毫秒。

		对于远程终端使用更长的时间。
		当使用小于 10 的值且未收到响应时
		在该时间内，如果可用，则返回之前报告的位置。
		这可用于轮询位置并在此期间执行一些工作：
>vim
			while 1
			  let res = getwinpos(1)
			  if res[0] >= 0
			    break
			  endif
			  " 在这里执行一些工作
			endwhile
<

getwinposx()                                                      *getwinposx()*
		结果是一个数字，它是 GUI Vim 窗口左侧的 X 坐标（以像素为单位）。
		如果信息不可用，结果将为 -1。
		该值可用于 `:winpos`。

getwinposy()                                                      *getwinposy()*
		结果是一个数字，它是 GUI Vim 窗口顶部的 Y 坐标（以像素为单位）。
		如果信息不可用，结果将为 -1。
		该值可用于 `:winpos`。

getwinvar({winnr}, {varname} [, {def}])                            *getwinvar()*
		类似于当前标签页的 |gettabwinvar()|。
		示例：
>vim
			let list_is_on = getwinvar(2, '&list')
			echo "myvar = " .. getwinvar(1, 'myvar')
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])                      *glob()*
		展开 {expr} 中的文件通配符。有关特殊字符的使用，请参见 |wildcards|。

		除非给出了可选的 {nosuf} 参数且为 |TRUE|，否则 'suffixes' 和
		'wildignore' 选项适用：匹配 'wildignore' 中任一模式的名字将被
		跳过，'suffixes' 影响匹配的顺序。
		'wildignorecase' 始终适用。

		当存在 {list} 且为 |TRUE| 时，结果是一个包含所有匹配文件的 |List|。
		使用 List 的优势是，你还可以正确获取包含换行符的文件名。
		否则结果是字符串，当有多个匹配时，它们由 <NL> 字符分隔。

		如果展开失败，结果是一个空字符串或空列表。

		如果你需要做复杂的事情，比如限制匹配数量，你也可以使用 |readdir()|。

		不存在的文件名不包括在内。符号链接只有在指向现有文件时才包括在内。
		但是，当存在 {alllinks} 参数且为 |TRUE| 时，所有符号链接都包括在内。

		对于大多数系统，可以使用反引号从任何外部命令获取文件名。示例：
>vim
			let tagfiles = glob("`find . -name tags -print`")
			let &tags = substitute(tagfiles, "\n", ",", "g")
<		反引号内程序的结果应该是每行一个项目。项目内的空格是允许的。

		有关展开特殊 Vim 变量，请参见 |expand()|。有关获取外部命令的原始
		输出，请参见 |system()|。

glob2regpat({string})                                            *glob2regpat()*
		将 glob() 使用的文件模式转换为搜索模式。结果可用于匹配作为文件名的
		字符串。例如：
>vim
			if filename =~ glob2regpat('Make*.mak')
			  " ...
			endif
<		这等同于：
>vim
			if filename =~ '^Make.*\.mak$'
			  " ...
			endif
<		当 {string} 是空字符串时，结果是 "^$"，匹配空字符串。
		注意结果取决于系统。在 MS-Windows 上，反斜杠通常表示路径分隔符。

globpath({path}, {expr} [, {nosuf} [, {list} [, {allinks}]]])       *globpath()*
		对 {path} 中的所有目录执行 {expr} 的 glob() 并连接结果。示例：
>vim
			echo globpath(&rtp, "syntax/c.vim")
<
		{path} 是逗号分隔的目录名列表。每个目录名都添加到 {expr} 前面，
		并像 |glob()| 一样展开。在需要时插入路径分隔符。
		要在目录名中添加逗号，请用反斜杠转义它。注意在 MS-Windows 上，
		目录可能有尾随反斜杠，如果在它后面放逗号，请删除它。
		如果其中一个目录的展开失败，不会有错误消息。

		除非给出了可选的 {nosuf} 参数且为 |TRUE|，否则 'suffixes' 和
		'wildignore' 选项适用：匹配 'wildignore' 中任一模式的名字将被
		跳过，'suffixes' 影响匹配的顺序。

		当存在 {list} 且为 |TRUE| 时，结果是一个包含所有匹配文件的 |List|。
		使用 List 的优势是，你还可以正确获取包含换行符的文件名。否则
		结果是字符串，当有多个匹配时，它们由 <NL> 字符分隔。示例：
>vim
			echo globpath(&rtp, "syntax/c.vim", 0, 1)
<
		{allinks} 的使用方式与 |glob()| 相同。

		"**" 项可用于在目录树中搜索。例如，要在 'runtimepath' 中的目录
		及其子目录中查找所有 "README.txt" 文件：
>vim
			echo globpath(&rtp, "**/README.txt")
<		向上搜索和限制 "**" 的深度不是
		支持的，因此使用 'path' 并不总是能正常工作。

has({feature})                                                           *has()*
		如果支持 {feature} 则返回 1，否则返回 0。{feature} 参数是特性名称，
		如 "nvim-0.2.1" 或 "win32"，见下文。另见 |exists()|。

		要获取系统名称，在 Lua 中使用 |vim.uv|.os_uname()：
>lua
			print(vim.uv.os_uname().sysname)

<		如果代码有语法错误，Vimscript 可能会跳过该行的其余部分。将 |:if| 
		和 |:endif| 放在单独的行上以避免语法错误：
>vim
			if has('feature')
			  let x = this_breaks_without_the_feature()
			endif
<
		Vim 的编译时特性名称（以 "+" 为前缀）不被识别，因为 Nvim 总是
		使用所有可能的特性编译。|feature-compile|

		特性名称可以是：
		1.  Nvim 版本。例如，"nvim-0.2.1" 特性表示 Nvim 是 0.2.1 或
		    更高版本：
>vim
			if has("nvim-0.2.1")
			  " ...
			endif

<		2.  运行时条件或其他伪特性。例如，"win32" 特性检查当前系统是否
		    是 Windows：
>vim
			if has("win32")
			  " ...
			endif
<							*feature-list*
		支持的伪特性名称列表：
			acl		|ACL| 支持。
			bsd		BSD 系统（不是 macOS，使用 "mac" 表示）。
			clipboard	|clipboard| 提供程序可用。
			fname_case	文件名大小写敏感（对于 Darwin 和 MS-Windows，
					这不适用）。
			gui_running	Nvim 有 GUI。
			hurd		GNU/Hurd 系统。
			iconv		可以使用 |iconv()| 进行转换。
			linux		Linux 系统。
			mac		MacOS 系统。
			nvim		这是 Nvim。
			python3		传统 Vim |python3| 接口。|has-python|
			pythonx		传统 Vim |python_x| 接口。|has-pythonx|
			sun		SunOS 系统。
			ttyin		输入是终端（tty）。
			ttyout		输出是终端（tty）。
			unix		Unix 系统。
			*vim_starting*	在 |startup| 期间为真。
			win32		Windows 系统（32 或 64 位）。
			win64		Windows 系统（64 位）。
			wsl		WSL（Windows Subsystem for Linux）系统。

							*has-patch*
		3.  Vim 补丁。例如，"patch123" 特性表示在当前 |v:version| 
		    包含了 Vim 补丁 123：
>vim
			if v:version > 602 || v:version == 602 && has("patch148")
			  " ...
			endif

<		4.  Vim 版本。例如，"patch-7.4.237" 特性表示 Nvim 与 Vim 
		    7.4.237 或更高版本兼容。
>vim
			if has("patch-7.4.237")
			  " ...
			endif
<

has_key({dict}, {key})                                               *has_key()*
		结果是一个数字，如果 |Dictionary| {dict} 有一个键为 {key} 的条目，
		则为 TRUE。否则为 FALSE。{key} 参数是一个字符串。

haslocaldir([{winnr} [, {tabnr}]])                               *haslocaldir()*
		结果是一个数字，当窗口通过 |:lcd| 设置了本地路径，或者当 {winnr} 
		为 -1 且标签页通过 |:tcd| 设置了本地路径时，为 1，否则为 0。

		标签和窗口由其各自的编号标识，0 表示当前标签或窗口。缺少参数意味着 0。
		因此以下内容是等价的：
>vim
			echo haslocaldir()
			echo haslocaldir(0)
			echo haslocaldir(0, 0)
<		使用 {winnr} 在当前标签页中使用该窗口。
		使用 {winnr} 和 {tabnr} 在该标签页中使用该窗口。
		{winnr} 可以是窗口编号或 |window-ID|。
		如果 {winnr} 为 -1，则忽略它，只解析标签。
		如果参数无效，则抛出错误。|E5000| |E5001| |E5002|

hasmapto({what} [, {mode} [, {abbr}]])                              *hasmapto()*
		结果是一个数字，如果在 rhs（映射到的内容）中的某处包含 {what} 
		的映射存在，并且此映射存在于 {mode} 指示的模式之一中，则为 TRUE。
		{what} 和 {mode} 参数是字符串。
		当存在 {abbr} 且为 |TRUE| 时，使用缩写而不是映射。不要忘记指定
		Insert 和/或 Command-line 模式。
		检查全局映射和当前缓冲区的局部映射以查找匹配。
		如果未找到匹配的映射，则返回 FALSE。
		{mode} 中识别以下字符：
			n	普通模式
			v	可视和选择模式
			x	可视模式
			s	选择模式
			o	操作符待决模式
			i	插入模式
			l	语言参数（"r"、"f"、"t" 等）
			c	命令行模式
		当省略 {mode} 时，使用 "nvo"。

		此函数对于检查 Vim 脚本中的函数是否已存在映射很有用。示例：
>vim
			if !hasmapto('\ABCdoit')
			   map <Leader>d \ABCdoit
			endif
<		这仅在还没有映射到 "\ABCdoit" 时安装该映射。

histadd({history}, {item})                                           *histadd()*
		将字符串 {item} 添加到历史 {history} 中，{history} 可以是以下之一：
			"cmd"	或 ":"	 命令行历史
			"search"或 "/"   搜索模式历史
			"expr"	或 "="   键入的表达式历史
			"input" 或 "@"	 输入行历史
			"debug" 或 ">"   调试命令历史
			空		 当前或最后使用的历史
		{history} 字符串不需要是完整的名称，一个字符就足够了。
		如果 {item} 已经存在于历史中，它将被移动成为最新的条目。
		结果是一个数字：如果操作成功，则为 TRUE，否则返回 FALSE。

		示例：
>vim
			call histadd("input", strftime("%Y %b %d"))
			let date=input("Enter date: ")
<		此函数在 |sandbox| 中不可用。

histdel({history} [, {item}])                                        *histdel()*
		清除 {history}，即删除其所有条目。有关 {history} 的可能值，
		请参见 |hist-names|。

		如果参数 {item} 求值为字符串，则它被用作正则表达式。所有匹配该
		表达式的条目将从历史中删除（如果有的话）。
		大小写必须匹配，除非使用 "\c" |/\c|。
		如果 {item} 求值为数字，它将被解释为索引，参见 |:history-indexing|。
		相应的条目将
		被删除（如果存在）。

		对于成功的操作，结果为 TRUE，否则返回 FALSE。

		示例：
		清除表达式寄存器历史：
>vim
			call histdel("expr")
<
		从搜索历史中删除所有以 "*" 开头的条目：
>vim
			call histdel("/", '^\*')
<
		以下三个是等价的：
>vim
			call histdel("search", histnr("search"))
			call histdel("search", -1)
			call histdel("search", '^' .. histget("search", -1) .. '$')
<
		要删除最后一个搜索模式并使用倒数第二个用于 "n" 命令和 'hlsearch'：
>vim
			call histdel("search", -1)
			let @/ = histget("search", -1)
<

histget({history} [, {index}])                                       *histget()*
		结果是一个字符串，是 {history} 中编号为 {index} 的条目。
		有关 {history} 的可能值，请参见 |hist-names|，有关 {index}，
		请参见 |:history-indexing|。如果没有这样的条目，则返回空字符串。
		当省略 {index} 时，使用历史中最新的项目。

		示例：
		从历史中重做倒数第二个搜索。
>vim
			execute '/' .. histget("search", -2)

<		定义一个 Ex 命令 ":H {num}"，支持重新执行 |:history| 输出中的
		第 {num} 个条目。
>vim
			command -nargs=1 H execute histget("cmd", 0+<args>)
<
histnr({history})                                                     *histnr()*
		结果是 {history} 中当前条目的编号。
		有关 {history} 的可能值，请参见 |hist-names|。
		如果发生错误，则返回 -1。

		示例：
>vim
			let inp_index = histnr("expr")
<

hlID({name})                                                            *hlID()*
		结果是一个数字，它是名称为 {name} 的高亮组的 ID。
		当高亮组不存在时，返回零。
		这可用于检索有关高亮组的信息。例如，获取 "Comment" 组的
		背景颜色：
>vim
			echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<

hlexists({name})                                                    *hlexists()*
		结果是一个数字，如果存在名为 {name} 的高亮组，则为 TRUE。
		这是当组以某种方式定义时。不一定是当为其定义了高亮时，它也可能
		已用于语法项目。

hostname()                                                          *hostname()*
		结果是一个字符串，它是 Vim 当前运行的机器的名称。机器名称大于
		256 个字符的长度会被截断。

iconv({string}, {from}, {to})                                          *iconv()*
		结果是一个字符串，它是文本 {string} 从编码 {from} 转换为编码 {to}。
		当转换完全失败时，返回空字符串。当某些字符无法转换时，它们被替换为 "?"。
		编码名称是 iconv() 库函数可以接受的任何名称，参见 ":!man 3 iconv"。
		注意 Vim 对所有 Unicode 编码使用 UTF-8，从/到 UCS-2 的转换会自动
		更改为使用 UTF-8。由于 NUL 字节，你无法在字符串中使用 UCS-2。

id({expr})                                                                *id()*
		返回一个 |String|，它是容器类型（|List|、|Dict|、|Blob| 和 |Partial|）
		的唯一标识符。保证对于提到的类型，`id(v1) ==# id(v2)` 返回 true
		当且仅当 `type(v1) == type(v2) && v1 is v2`。
		注意 `v:_null_string`、`v:_null_list`、`v:_null_dict` 和
		`v:_null_blob` 具有相同的 `id()`，但类型不同，因为它们内部表示为
		NULL 指针。
		`id()` 返回指向容器的指针的十六进制表示（即像 `0x994a40`），
		与 `printf("%p", {expr})` 相同，但建议不要依赖返回值的确切格式。

		不保证 `id(no_longer_existing_container)` 不会等于其他 `id()`：
		新容器可能会重用垃圾回收的容器的标识符。

indent({lnum})                                                        *indent()*
		结果是一个数字，它是当前缓冲区中行 {lnum} 的缩进。
		缩进以空格计数，'tabstop' 的值相关。{lnum} 的使用方式与 |getline()| 
		相同。
		当 {lnum} 无效时返回 -1。

		要获取或设置字符串中行的缩进，请参见 |vim.text.indent()|。

index({object}, {expr} [, {start} [, {ic}]])                           *index()*
		在 {object} 中查找 {expr} 并返回其索引。有关使用 lambda 选择项目，
		请参见 |indexof()|。

		如果 {object} 是 |List|，返回项目值等于 {expr} 的最低索引。
		没有自动转换，因此字符串 "4" 与数字 4 不同。数字 4 与浮点数 4.0 
		不同。'ignorecase' 的值在这里不使用，大小写由 {ic} 参数指示。

		如果 {object} 是 |Blob|，返回字节值等于 {expr} 的最低索引。

		如果给出了 {start}，则从索引为 {start} 的项目开始查找（对于相对于
		末尾的项目可以为负数）。

		当给出 {ic} 且为 |TRUE| 时，忽略大小写。否则大小写必须匹配。

		当在 {object} 中找不到 {expr} 时返回 -1。
		示例：
>vim
			let idx = index(words, "the")
			if index(numbers, 123) >= 0
			  " ...
			endif
<
indexof({object}, {expr} [, {opts}])                                 *indexof()*
		返回 {object} 中 {expr} 为 v:true 的项目的索引。{object} 必须是
		|List| 或 |Blob|。

		如果 {object} 是 |List|，对 List 中的每个项目评估 {expr}，直到
		表达式为 v:true 并返回此项目的索引。

		如果 {object} 是 |Blob|，对 Blob 中的每个字节评估 {expr}，直到
		表达式为 v:true 并返回此字节的索引。

		{expr} 必须是 |string| 或 |Funcref|。

		如果 {expr} 是 |string|：如果 {object} 是 |List|，在 {expr} 中
		|v:key| 具有当前 List 项目的索引，|v:val| 具有项目的值。如果
		{object} 是 |Blob|，在 {expr} 中 |v:key| 具有当前字节的索引，
		|v:val| 具有字节值。

		如果 {expr} 是 |Funcref|，它必须接受两个参数：
			1. 当前项目的键或索引。
			2. 当前项目的值。
		如果找到项目且搜索应停止，函数必须返回 |TRUE|。

		可选参数 {opts} 是一个 Dict，支持以下项目：
		    startidx	从具有此索引的项目开始评估 {expr}；对于相对于
				末尾的项目可以为负数
		当 {expr} 对所有项目评估为 v:false 时返回 -1。
		示例：
>vim
			let l = [#{n: 10}, #{n: 20}, #{n: 30}]
			echo indexof(l, "v:val.n == 20")
			echo indexof(l, {i, v -> v.n == 30})
			echo indexof(l, "v:val.n == 20", #{startidx: 1})
<

input({prompt} [, {text} [, {completion}]])                            *input()*
input({opts})
		结果是一个字符串，它是用户在命令行上输入的任何内容。{prompt} 参数
		要么是一个提示字符串，要么是一个空字符串（表示没有提示）。可以在
		提示中使用 '\n' 来开始新行。

		在第二种形式中，它接受一个包含以下键的单个字典，其中任何一个都可以
		省略：

		键           默认值   描述 ~
		prompt        ""      与第一种形式中的 {prompt} 相同。
		default       ""      与第一种形式中的 {text} 相同。
		completion    无      与第一种形式中的 {completion} 相同。
		cancelreturn  ""      对话框取消时返回的值。
		highlight     无      高亮处理程序：|Funcref|。

		使用 |:echohl| 设置的高亮用于提示。
		输入就像命令行一样输入，使用相同的编辑命令和映射。为 input() 输入
		的行有单独的历史记录。
		示例：
>vim
			if input("Coffee or beer? ") == "beer"
			  echo "Cheers!"
			endif
<
		如果存在可选的 {text} 参数且不为空，则将其用作默认回复，就像用户
		输入了它一样。
		示例：
>vim
			let color = input("Color? ", "white")

<		可选的 {completion} 参数指定输入支持的完成类型。没有它则不执行完成。
		支持的完成类型与可以使用 "-complete=" 参数提供给用户定义命令的类型
		相同。有关更多信息，请参阅 |:command-completion|。示例：
>vim
			let fname = input("File: ", "", "file")

<					*input()-highlight* *E5400* *E5402*
		可选的 `highlight` 键允许指定用于高亮用户输入的函数。此函数接收
		用户输入作为其唯一参数，并且必须返回
		一个 3 元组列表 [hl_start_col, hl_end_col + 1, hl_group]，其中
			hl_start_col 是第一个高亮的列，
			hl_end_col 是最后一个高亮的列（+ 1！），
			hl_group 是用于高亮的 |:hi| 组。
					      *E5403* *E5404* *E5405* *E5406*
		hl_start_col 和 hl_end_col + 1 都必须指向多字节字符的开始
		（高亮不能破坏多字节字符），hl_end_col + 1 可以等于输入长度。
		起始列必须在范围 [0, len(input)) 内，结束列必须在范围
		(hl_start_col, len(input)] 内，部分必须排序，使得下一个
		hl_start_col 大于或等于前一个 hl_end_col。

		示例（尝试一些带括号的输入）：
>vim
			highlight RBP1 guibg=Red ctermbg=red
			highlight RBP2 guibg=Yellow ctermbg=yellow
			highlight RBP3 guibg=Green ctermbg=green
			highlight RBP4 guibg=Blue ctermbg=blue
			let g:rainbow_levels = 4
			function! RainbowParens(cmdline)
			  let ret = []
			  let i = 0
			  let lvl = 0
			  while i < len(a:cmdline)
			    if a:cmdline[i] is# '('
			      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])
			      let lvl += 1
			    elseif a:cmdline[i] is# ')'
			      let lvl -= 1
			      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])
			    endif
			    let i += 1
			  endwhile
			  return ret
			endfunction
			call input({'prompt':'>','highlight':'RainbowParens'})
<
		高亮函数在每次显示新的输入字符串时至少调用一次，在命令行重绘之前。
		期望函数在一个 input() 调用期间是纯的，即对于相同的输入产生相同的
		输出，因此输出可以被记忆。函数像在 |:silent| 修饰符下运行。如果
		函数导致任何错误，它将在当前 input() 调用期间被跳过。

		如果命令行包含阿拉伯字符，则禁用高亮。

		注意：此函数不得在启动文件中使用，因为
		仅运行在 GUI 模式下的版本（例如，Win32 GUI）。
		注意：当从映射中调用 input() 时，它将消耗该映射中的剩余字符，因为
		映射的处理方式就像字符被键入一样。
		在 input() 之前使用 |inputsave()| 并在 input() 之后使用
		|inputrestore()| 以避免这种情况。另一种解决方案是避免映射中
		有更多字符跟随，例如通过使用 |:execute| 或 |:normal|。

		使用映射的示例：
>vim
			nmap \x :call GetFoo()<CR>:exe "/" .. Foo<CR>
			function GetFoo()
			  call inputsave()
			  let g:Foo = input("enter search pattern: ")
			  call inputrestore()
			endfunction
<

inputlist({textlist})                                              *inputlist()*
		{textlist} 必须是字符串的 |List|。此 |List| 被显示，每行一个字符串。
		用户将被提示输入一个数字，该数字被返回。
		如果命令行中启用了鼠标（'mouse' 是 "a" 或包含 "c"），用户也可以
		通过用鼠标点击项目来选择它。对于第一个字符串返回 0。当点击第一个
		项目上方时返回负数。当点击提示时返回比 {textlist} 长度多 1 的数字。
		确保 {textlist} 的条目数少于 'lines'，否则它将不起作用。最好在
		字符串的开头放置条目编号。并在第一个项目中放置提示。
		示例：
>vim
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])

inputrestore()                                                  *inputrestore()*
		恢复之前用 |inputsave()| 保存的预输入。
		应该调用与 inputsave() 相同的次数
		调用次数过多是无害的。
		当没有内容可恢复时返回 TRUE，否则返回 FALSE。

inputsave()                                                        *inputsave()*
		保存预输入（包括来自映射的）并清除它，以便后续提示从用户获取输入。
		应该在提示后跟一个匹配的 inputrestore()。可以多次使用，在这种情况下
		必须有相同次数的 inputrestore() 调用。
		当内存不足时返回 TRUE，否则返回 FALSE。

inputsecret({prompt} [, {text}])                                 *inputsecret()*
		此函数的行为与 |input()| 函数非常相似，但有两个例外：
		a) 用户的响应将显示为星号序列（"*"），从而保持输入的秘密性
		b) 用户的响应不会被记录在输入 |history| 堆栈中
		结果是一个字符串，即用户在命令行上实际输入的内容。
		注意：不支持命令行补全。

insert({object}, {item} [, {idx}])                                    *insert()*
		当 {object} 是 |List| 或 |Blob| 时，在开头插入 {item}。

		如果指定了 {idx}，则在索引为 {idx} 的项目之前插入 {item}。
		如果 {idx} 为零，它会在第一个项目之前插入，就像省略 {idx} 一样。
		也可以使用负的 {idx}，参见 |list-index|。-1 在最后一个项目之前插入。

		返回结果 |List| 或 |Blob|。示例：
>vim
			let mylist = insert([2, 3, 5], 1)
			call insert(mylist, 4, -1)
			call insert(mylist, 6, len(mylist))
<		最后一个示例可以用 |add()| 更简单地完成。
		注意，当 {item} 是 |List| 时，它作为单个项目插入
		作为单个项目插入。要连接列表，请使用 |extend()|。

		参数：
		  • {object} (`any`) - 要插入的列表或二进制对象
		  • {item} (`any`) - 要插入的项目
		  • {idx} (`integer?`) - 可选的插入位置索引

		返回值：
		  (`any`) - 修改后的列表或二进制对象

interrupt()                                                        *interrupt()*
		中断脚本执行。它的工作方式类似于用户输入 CTRL-C，大多数命令不会执行，
		控制权返回给用户。这对于从较低层（例如自动命令）中止执行很有用。
		示例：
>vim
		function s:check_typoname(file)
		   if fnamemodify(a:file, ':t') == '['
		       echomsg 'Maybe typo'
		       call interrupt()
		   endif
		endfunction
		au BufWritePre * call s:check_typoname(expand('<amatch>'))
<

		返回值：
		  (`any`)

invert({expr})                                                        *invert()*
		按位取反。参数被转换为数字。列表、字典或浮点数参数会导致错误。
		示例：
>vim
			let bits = invert(bits)
<

		参数：
		  • {expr} (`integer`) - 要取反的整数

		返回值：
		  (`integer`) - 取反后的整数

isabsolutepath({path})                                        *isabsolutepath()*
		返回一个数字，当 {path} 是绝对路径时为 |TRUE|。
		在 Unix 上，当路径以 '/' 开头时被视为绝对路径。
		在 MS-Windows 上，当路径以可选的驱动器前缀开头，后跟 '\' 或 '/' 时被视为绝对路径。
		UNC 路径始终是绝对路径。
		示例：
>vim
			echo isabsolutepath('/usr/share/')	" 1
			echo isabsolutepath('./foobar')		" 0
			echo isabsolutepath('C:\Windows')	" 1
			echo isabsolutepath('foobar')		" 0
			echo isabsolutepath('\\remote\file')	" 1

		参数：
		  • {path} (`string`) - 要检查的路径

		返回值：
		  (`0|1`) - 如果是绝对路径返回1，否则返回0

isdirectory({directory})                                         *isdirectory()*
		返回一个数字，当名为 {directory} 的目录存在时为 |TRUE|。
		如果 {directory} 不存在，或者不是一个目录，则结果为 |FALSE|。
		{directory} 可以是任何表达式，会被用作字符串。

		参数：
		  • {directory} (`string`) - 要检查的目录路径

		返回值：
		  (`0|1`) - 如果是目录返回1，否则返回0

isinf({expr})                                                          *isinf()*
		如果 {expr} 是正无穷大则返回1，如果是负无穷大则返回-1，否则返回0。
		示例：
>vim
			echo isinf(1.0 / 0.0)	" 1
			echo isinf(-1.0 / 0.0)	" -1

		参数：
		  • {expr} (`number`) - 要检查的数字

		返回值：
		  (`1|0|-1`) - 正无穷大返回1，负无穷大返回-1，否则返回0

islocked({expr})                                               *islocked()* *E786*
		返回一个数字，当 {expr} 是一个被锁定的变量名时为 |TRUE|。
		字符串参数 {expr} 必须是变量、|List| 项或 |Dictionary| 条目的名称，而不是变量本身！
		示例：
>vim
			let alist = [0, ['a', 'b'], 2, 3]
			lockvar 1 alist
			echo islocked('alist')		" 1
			echo islocked('alist[1]')	" 0

		当 {expr} 是一个不存在的变量时，你会得到一个错误消息。
		使用 |exists()| 来检查变量是否存在。
		参数：
		  • {expr} (`any`) - 要检查的变量名

		返回值：
		  (`0|1`) - 如果变量被锁定返回1，否则返回0

isnan({expr})                                                          *isnan()*
		如果 {expr} 是一个值为 NaN 的浮点数则返回 |TRUE|。
		示例：
>vim
			echo isnan(0.0 / 0.0)	" 1

		参数：
		  • {expr} (`number`) - 要检查的数字

		返回值：
		  (`0|1`) - 如果是 NaN 返回1，否则返回0

items({dict})                                                          *items()*
		返回一个包含 {dict} 所有键值对的 |List|。每个 |List| 项都是一个包含两个项目的列表：
		字典条目的键和该条目的值。|List| 的顺序是任意的。另请参见 |keys()| 和 |values()|。
		示例：
>vim
			for [key, value] in items(mydict)
			   echo key .. ': ' .. value
			endfor

		也支持 List 或 String 参数。在这些情况下，items() 返回一个包含索引和该索引处值的 List。

		参数：
		  • {dict} (`table`) - 要获取键值对的字典

		返回值：
		  (`any`) - 包含键值对的列表

jobpid({job})                                                         *jobpid()*
		返回 |job-id| {job} 的 PID（进程 ID）。

		参数：
		  • {job} (`integer`) - 作业 ID

		返回值：
		  (`integer`) - 进程 ID

jobresize({job}, {width}, {height})                                *jobresize()*
		将 |job-id| {job} 的伪终端窗口大小调整为 {width} 列和 {height} 行。
		如果作业不是以 `"pty":v:true` 启动的，则操作会失败。
		参数：
		  • {job} (`integer`) - 作业 ID
		  • {width} (`integer`) - 新的宽度（列数）
		  • {height} (`integer`) - 新的高度（行数）

		返回值：
		  (`any`) - 操作结果

jobstart({cmd} [, {opts}])                                          *jobstart()*
		注意：在 Lua 中优先使用 |vim.system()|（除非使用 `rpc`、`pty` 或 `term`）。

		将 {cmd} 作为作业启动。
		如果 {cmd} 是 List，则直接运行（不使用 'shell'）。
		如果 {cmd} 是 String，则在 'shell' 中运行，如下所示：
>vim
		  call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])
		（详情请参见 |shell-unquoting|。）

		示例：启动一个作业并处理其输出：
>vim
		  call jobstart(['nvim', '-h'], {'on_stdout':{j,d,e->append(line('.'),d)}})

		示例：启动一个连接到当前缓冲区的 |terminal| 作业：
>vim
		  call jobstart(['nvim', '-h'], {'term':v:true})

		成功时返回 |job-id|，参数无效时返回 0（或作业表已满），
		如果 {cmd}[0] 或 'shell' 不可执行则返回 -1。
		返回的 job-id 是一个有效的 |channel-id|，代表作业的 stdio 流。
		使用 |chansend()|（如果启用了 "rpc"，则使用 |rpcnotify()| 和 |rpcrequest()|）
		向 stdin 发送数据，使用 |chanclose()| 关闭流而不停止作业。

		参见 |job-control| 和 |RPC|。

		注意：在 Windows 上，如果 {cmd} 是 List：
		  - cmd[0] 必须是可执行文件（不是"内置命令"）。如果在 $PATH 中，
		    可以通过名称调用，无需扩展名：
>vim
		      call jobstart(['ping', 'neovim.io'])
		    如果是完整或部分路径，则需要扩展名：
>vim
		      call jobstart(['System32\ping.exe', 'neovim.io'])
		  - {cmd} 会被折叠为 CommandLineToArgvW 期望的带引号的参数字符串
		    https://msdn.microsoft.com/bb776391
		    除非 cmd[0] 是某种形式的 "cmd.exe"。

							*jobstart-env*
		作业环境的初始化如下：
		  $NVIM                设置为父 Nvim 的 |v:servername|
		  $NVIM_LISTEN_ADDRESS 未设置
		  $NVIM_LOG_FILE       未设置
		  $VIM                 未设置
		  $VIMRUNTIME          未设置
		你可以使用 `env` 选项设置这些环境变量。

							*jobstart-options*
		{opts} 是一个包含以下键的字典：
		  clear_env:  (boolean) `env` 精确定义作业环境，而不是合并当前环境。
		  cwd:	      (string, 默认=|current-directory|) 作业的工作目录。
		  detach:     (boolean) 分离作业进程：当 Nvim 退出时不会杀死它。
			      如果进程在 Nvim 之前退出，将调用 `on_exit`。
		  env:	      (dict) 环境变量名:值对的映射，扩展（或使用 "clear_env" 替换）
			      当前环境。|jobstart-env|
		  height:     (number) `pty` 终端的高度。
		  |on_exit|:    (function) 作业退出时调用的回调函数。
		  |on_stdout|:  (function) 作业输出 stdout 数据时调用的回调函数。
		  |on_stderr|:  (function) 作业输出 stderr 数据时调用的回调函数。
		  overlapped: (boolean) 为传递给子进程的 stdio 设置 FILE_FLAG_OVERLAPPED。
			      仅在 MS-Windows 上有效；在其他平台上被忽略。
		  pty:	      (boolean) 将作业连接到新的伪终端，并将其流连接到主文件描述符。
			      `on_stdout` 接收所有输出，`on_stderr` 被忽略。|terminal-start|
		  rpc:	      (boolean) 使用 |msgpack-rpc| 通过 stdio 与作业通信。
			      此时 `on_stdout` 被忽略，但 `on_stderr` 仍可使用。
		  stderr_buffered: (boolean) 在调用 `on_stderr` 之前收集数据直到 EOF（流关闭）。
			      |channel-buffered|
		  stdout_buffered: (boolean) 在调用 `on_stdout` 之前收集数据直到 EOF（流关闭）。
			      |channel-buffered|
		  stdin:      (string) 可以是 "pipe"（默认）将作业的 stdin 连接到通道，
			      或 "null" 断开 stdin 连接。
		  term:	    (boolean) 在新的伪终端会话中启动 {cmd}，连接到当前（未修改的）缓冲区。
		          隐含 "pty"。默认的 "height" 和 "width" 设置为当前窗口尺寸。
		          |jobstart()|。默认将 $TERM 设置为 "xterm-256color"。
		  width:      (number) `pty` 终端的宽度。

		{opts} 作为 |self| 字典传递给回调函数；调用者可以设置其他键来传递应用特定的数据。

		返回值：
		  - 成功时返回 |channel-id|
		  - 参数无效时返回 0
		  - 如果 {cmd}[0] 不可执行则返回 -1
		另请参见 |job-control|、|channel|、|msgpack-rpc|。

		参数：
		  • {cmd} (`string|string[]`) - 要执行的命令
		  • {opts} (`table?`) - 可选的作业选项

		返回值：
		  (`integer`) - 作业 ID 或错误代码

jobstop({id})                                                        *jobstop()*
		通过向作业进程发送 SIGTERM 来停止 |job-id| {id}。
		如果进程在超时后仍未终止，则会发送 SIGKILL。
		当作业终止时，将调用其 |on_exit| 处理程序（如果有）。
		参见 |job-control|。

		对于有效的作业 ID 返回 1，对于无效的 ID（包括已退出或停止的作业）返回 0。

		参数：
		  • {id} (`integer`) - 要停止的作业 ID

		返回值：
		  (`integer`) - 操作结果

jobwait({jobs} [, {timeout}])                                        *jobwait()*
		等待作业及其 |on_exit| 处理程序完成。

		{jobs} 是要等待的 |job-id| 列表。
		{timeout} 是最大等待时间（毫秒）。如果省略或为 -1，则无限等待。

		超时值为 0 可用于检查作业状态：
>vim
			let running = jobwait([{job-id}], 0)[0] == -1

		在 jobwait() 调用期间，可能会调用不在 {jobs} 列表中的作业的回调。
		除非回调调用 |:redraw|，否则屏幕不会重绘。

		返回一个长度为 len({jobs}) 的整数列表，其中每个整数是对应作业的状态：
			退出代码，如果作业已退出
			-1 如果超时
			-2 如果作业被中断（通过 |CTRL-C|）
			-3 如果 job-id 无效

		参数：
		  • {jobs} (`integer[]`) - 要等待的作业 ID 列表
		  • {timeout} (`integer?`) - 可选的超时时间（毫秒）
		返回值：
		  (`integer[]`) - 作业状态列表

join({list} [, {sep}])                                                  *join()*
		将 {list} 中的项目连接成一个字符串。
		当指定 {sep} 时，它会被放在项目之间。如果省略 {sep}，则使用单个空格。
		注意 {sep} 不会添加在末尾。你可能也想在那里添加它：
>vim
			let lines = join(mylist, "\n") .. "\n"

		字符串项目按原样使用。|Lists| 和 |Dictionaries| 会像 |string()| 一样转换为字符串。
		相反的函数是 |split()|。

		参数：
		  • {list} (`any[]`) - 要连接的列表
		  • {sep} (`string?`) - 可选的连接分隔符

		返回值：
		  (`string`) - 连接后的字符串

json_decode({expr})                                              *json_decode()*
		将 {expr} 从 JSON 对象转换。接受 |readfile()| 风格的列表作为输入，也接受常规字符串。
		可能输出任何 Vim 值。在以下情况下会输出 |msgpack-special-dict|：
		1. 字典包含重复键。
		2. 字符串包含 NUL 字节。如果包含 NUL 字节的字符串是字典键，
		   将输出两个特殊字典：一个用于字典，一个用于字符串。

		注意：函数始终将其输入视为 UTF-8。JSON 标准只允许少数几种编码，
		其中 UTF-8 是推荐的，也是唯一要求支持的编码。非 UTF-8 字符是错误的。

		参数：
		  • {expr} (`any`) - 要解码的 JSON 数据

		返回值：
		  (`any`) - 解码后的 Vim 值

json_encode({expr})                                              *json_encode()*
		将 {expr} 转换为 JSON 字符串。接受 |msgpack-special-dict| 作为输入。
		不会转换 |Funcref|s、具有非字符串键的映射（可以作为 |msgpack-special-dict| 创建）、
		具有自引用容器的值、包含非 UTF-8 字符的字符串、
		包含为代理对保留的码点的伪 UTF-8 字符串（这样的字符串不是有效的 UTF-8 字符串）。
		不可打印字符被转换为 "\u1234" 转义或特殊转义如 "\t"，其他字符按原样转储。
		|Blob|s 被转换为单个字节的数组。

		参数：
		  • {expr} (`any`) - 要编码的 Vim 值

		返回值：
		  (`string`) - JSON 编码的字符串

keys({dict})                                                            *keys()*
		返回一个包含 {dict} 所有键的 |List|。|List| 的顺序是任意的。
		另请参见 |items()| 和 |values()|。

		参数：
		  • {dict} (`table`) - 要获取键的字典

		返回值：
		  (`string[]`) - 键的列表

keytrans({string})                                                  *keytrans()*
		将键的内部字节表示转换为可用于 |:map| 的形式。
		例如：
>vim
			let xx = "\<C-Home>"
			echo keytrans(xx)
			<C-Home>

		参数：
		  • {string} (`string`) - 要转换的字符串

		返回值：
		  (`string`) - 转换后的字符串

len({expr})                                                         *len()* *E701*
		结果是一个数字，表示参数的长度。
		当 {expr} 是字符串或数字时，使用字节长度，如 |strlen()|。
		当 {expr} 是 |List| 时，返回 |List| 中的项目数。
		当 {expr} 是 |Blob| 时，返回字节数。
		当 {expr} 是 |Dictionary| 时，返回 |Dictionary| 中的条目数。
		否则会给出错误并返回零。

		参数：
		  • {expr} (`any[]`) - 要计算长度的表达式

		返回值：
		  (`integer`) - 长度值
libcall({libname}, {funcname}, {argument})                 *libcall()* *E364* *E368*
		使用单个参数 {argument} 调用运行时库 {libname} 中的函数 {funcname}。
		这对于调用你专门为 Vim 制作的库中的函数很有用。
		由于只能使用一个参数，调用标准库函数相当受限。
		结果是函数返回的字符串。如果函数返回 NULL，这将在 Vim 中显示为空字符串 ""。
		如果函数返回数字，请使用 libcallnr()！
		如果 {argument} 是数字，它作为 int 传递给函数；
		如果 {argument} 是字符串，它作为以 null 结尾的字符串传递。

		libcall() 允许你编写自己的 Vim '插件'扩展，而无需重新编译程序。
		它不是调用系统函数的手段！如果你尝试这样做，Vim 很可能会崩溃。

		对于 Win32，你编写的函数必须放在 DLL 中，并使用正常的 C 调用约定
		（不是 Windows 系统 DLL 中使用的 Pascal）。
		函数必须只接受一个参数，可以是字符指针或长整数，并且必须返回字符指针或 NULL。
		返回的字符指针必须指向在函数返回后仍然有效的内存
		（例如，在 DLL 的静态数据中）。
		如果它指向分配的内存，该内存将会泄漏。
		在函数中使用静态缓冲区应该可以工作，它会在 DLL 卸载时释放。

		警告：如果函数返回无效指针，Vim 可能会崩溃！
		如果函数返回数字，也会发生这种情况，因为 Vim 认为它是一个指针。
		对于 Win32 系统，{libname} 应该是 DLL 的文件名，不带 ".DLL" 后缀。
		只有当 DLL 不在通常的位置时才需要完整路径。
		对于 Unix：在编译自己的插件时，请记住目标代码必须编译为位置无关（'PIC'）。
		示例：
>vim
			echo libcall("libc.so", "getenv", "HOME")

		参数：
		  • {libname} (`string`) - 库名称
		  • {funcname} (`string`) - 函数名称
		  • {argument} (`any`) - 函数参数

		返回值：
		  (`any`) - 函数返回的结果
libcallnr({libname}, {funcname}, {argument})                       *libcallnr()*
		与 |libcall()| 类似，但用于返回 int 而不是字符串的函数。
		示例：
>vim
			echo libcallnr("/usr/lib/libc.so", "getpid", "")
			call libcallnr("libc.so", "printf", "Hello World!\n")
			call libcallnr("libc.so", "sleep", 10)

		参数：
		  • {libname} (`string`) - 库名称
		  • {funcname} (`string`) - 函数名称
		  • {argument} (`any`) - 函数参数

		返回值：
		  (`any`) - 函数返回的结果

line({expr} [, {winid}])                                                *line()*
		参见 |getpos()| 了解接受的位置。

		要获取列号，请使用 |col()|。要同时获取两者，请使用 |getpos()|。

		使用可选的 {winid} 参数，可以从该窗口而不是当前窗口获取值。

		对于无效的 {expr} 和 {winid} 值返回 0。

		示例：
>vim
			echo line(".")			" 光标所在行的行号
			echo line(".", winid)		" 同上，在窗口 "winid" 中
			echo line("'t")			" 标记 t 的行号
			echo line("'" .. marker)	" 标记 marker 的行号

		要在打开文件时跳转到最后已知位置，请参见 |last-position-jump|。

		参数：
		  • {expr} (`string|integer[]`) - 位置表达式
		  • {winid} (`integer?`) - 可选的窗口 ID

		返回值：
		  (`integer`) - 行号

line2byte({lnum})                                                  *line2byte()*
		返回从缓冲区开始到行 {lnum} 的字节计数。
		这包括行尾字符，取决于当前缓冲区的 'fileformat' 选项。
		第一行返回 1。使用 UTF-8 编码，忽略 'fileencoding'。
		这也可以用于获取缓冲区的字节计数。
		行：
>vim
			echo line2byte(line("$") + 1)
		这是缓冲区大小加一。如果 'fileencoding' 为空，则是文件大小加一。
		{lnum} 的使用方式与 |getline()| 相同。当 {lnum} 无效时返回 -1。
		另请参见 |byte2line()|、|go| 和 |:goto|。

		参数：
		  • {lnum} (`integer|string`) - 行号

		返回值：
		  (`integer`) - 字节位置

lispindent({lnum})                                                *lispindent()*
		根据 lisp 缩进规则获取行 {lnum} 的缩进量，如 'lisp' 选项所示。
		缩进以空格计数，'tabstop' 的值很重要。{lnum} 的使用方式与 |getline()| 相同。
		当 {lnum} 无效时返回 -1。

		参数：
		  • {lnum} (`integer|string`) - 行号

		返回值：
		  (`integer`) - 缩进量

list2blob({list})                                                  *list2blob()*
		返回一个连接 {list} 中所有数字值的 Blob。
		示例：
>vim
			echo list2blob([1, 2, 3, 4])	" 返回 0z01020304
			echo list2blob([])		" 返回 0z
		出错时返回空 Blob。如果其中一个数字为负数或大于 255，则给出错误 *E1239*。

		|blob2list()| 执行相反的操作。

		参数：
		  • {list} (`any[]`) - 数字列表

		返回值：
		  (`string`) - Blob 字符串

list2str({list} [, {utf8}])                                         *list2str()*
		将 {list} 中的每个数字转换为字符字符串并连接它们。
		示例：
>vim
			echo list2str([32])		" 返回 " "
			echo list2str([65, 66, 67])	" 返回 "ABC"
		同样可以（较慢地）通过以下方式完成：
>vim
			echo join(map(list, {nr, val -> nr2char(val)}), '')
		|str2list()| 执行相反的操作。
		始终使用 UTF-8 编码，{utf8} 选项没有效果，仅用于向后兼容。
		使用 UTF-8 时，组合字符按预期工作：
>vim
			echo list2str([97, 769])	" 返回 "á"
		出错时返回空字符串。

		参数：
		  • {list} (`any[]`) - 数字列表
		  • {utf8} (`boolean?`) - 可选的 UTF-8 标志（已弃用）

		返回值：
		  (`string`) - 转换后的字符串

localtime()                                                        *localtime()*
		返回当前时间，以自 1970 年 1 月 1 日以来的秒数计算。
		另请参见 |strftime()|、|strptime()| 和 |getftime()|。

		返回值：
		  (`integer`) - 当前时间戳

log({expr})                                                              *log()*
		返回 {expr} 的自然对数（以 e 为底）作为 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|，范围在 (0, inf] 内。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：
>vim
			echo log(10)
			2.302585
			echo log(exp(5))
			5.0

		参数：
		  • {expr} (`number`) - 要计算对数的数字

		返回值：
		  (`number`) - 自然对数

log10({expr})                                                          *log10()*
		返回浮点数 {expr} 以 10 为底的对数作为 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：
>vim
			echo log10(1000)
			3.0
			echo log10(0.01)
			-2.0

		参数：
		  • {expr} (`number`) - 要计算对数的数字

		返回值：
		  (`number`) - 以 10 为底的对数

luaeval({expr} [, {expr}])                                           *luaeval()*
		评估 Lua 表达式 {expr} 并返回其结果转换为 Vim 数据结构。
		详情请参见 |lua-eval|。

		另请参见 |v:lua-call|。

		参数：
		  • {expr} (`string`) - Lua 表达式
		  • {expr1} (`any[]?`) - 可选的参数列表

		返回值：
		  (`any`) - 评估结果

map({expr1}, {expr2})                                                    *map()*
		{expr1} 必须是 |List|、|String|、|Blob| 或 |Dictionary|。
		当 {expr1} 是 |List| 或 |Dictionary| 时，用评估 {expr2} 的结果替换 {expr1} 中的每个项目。
		对于 |Blob|，每个字节都被替换。
		对于 |String|，每个字符（包括组合字符）都被替换。
		如果项目类型发生变化，你可能想使用 |mapnew()| 创建一个新的 List 或 Dictionary。

		{expr2} 必须是 |String| 或 |Funcref|。

		如果 {expr2} 是 |String|，在 {expr2} 内部 |v:val| 具有当前项目的值。
		对于 |Dictionary|，|v:key| 具有当前项目的键；
		对于 |List|，|v:key| 具有当前项目的索引。
		对于 |Blob|，|v:key| 具有当前字节的索引。
		对于 |String|，|v:key| 具有当前字符的索引。
		示例：
>vim
			call map(mylist, '"> " .. v:val .. " <"')
		这会在 "mylist" 中的每个项目前后加上 "> " 和 " <"。

		注意 {expr2} 是表达式的结果，然后再次用作表达式。
		通常最好使用 |literal-string| 以避免必须双写反斜杠。
		你仍然需要双写单引号。

		如果 {expr2} 是 |Funcref|，它会被调用两个参数：
			1. 当前项目的键或索引。
			2. 当前项目的值。
		函数必须返回项目的新值。示例，将每个值更改为 "key-value"：
			func KeyValue(key, val)
			  return a:key .. '-' .. a:val
			endfunc
			call map(myDict, function('KeyValue'))
		使用 |lambda| 时更短：
>vim
			call map(myDict, {key, val -> key .. '-' .. val})
		如果不使用 "val"，可以省略它：
>vim
			call map(myDict, {key -> 'item: ' .. key})
		如果不使用 "key"，可以使用短名称：
>vim
			call map(myDict, {_, val -> 'item: ' .. val})

		对于 |List| 和 |Dictionary|，操作是原地进行的。
		如果你希望它保持未修改，请先制作一个副本：
>vim
			let tlist = map(copy(mylist), ' v:val .. "\t"')

		返回 {expr1}，即被过滤的 |List| 或 |Dictionary|，或新的 |Blob| 或 |String|。
		在评估 {expr2} 时遇到错误时，不会处理 {expr1} 中的其他项目。
		当 {expr2} 是 Funcref 时，函数内部的错误会被忽略，除非它被定义为 "abort" 标志。

		参数：
		  • {expr1} (`string|table|any[]`) - 要映射的集合
		  • {expr2} (`string|function`) - 映射函数或表达式

		返回值：
		  (`any`) - 映射后的结果

maparg({name} [, {mode} [, {abbr} [, {dict}]]])                       *maparg()*
		当 {dict} 被省略或为零时：返回模式 {mode} 中映射 {name} 的 rhs。
		返回的字符串中的特殊字符会被转换，就像 ":map" 命令列表的输出一样。
		当 {dict} 为 TRUE 时，返回一个字典，见下文。要获取所有映射的列表，请参见 |maplist()|。

		当 {name} 没有映射时，如果 {dict} 为 FALSE，则返回空字符串，否则返回空字典。
		当 {name} 的映射为空时，返回 "<Nop>"。

		{name} 可以包含特殊键名，就像 ":map" 命令中一样。

		{mode} 可以是以下字符串之一：
			"n"	普通模式
			"v"	可视模式（包括选择模式）
			"o"	操作符待决模式
			"i"	插入模式
			"c"	命令行模式
			"s"	选择模式
			"x"	可视模式
			"l"	语言映射 |language-mapping|
			"t"	终端模式
			""	普通、可视和操作符待决模式
		当 {mode} 被省略时，使用 "" 的模式。

		当 {abbr} 存在且为 |TRUE| 时，使用缩写而不是映射。

		当 {dict} 为 |TRUE| 时，返回一个描述映射的字典，包含以下项目：		*mapping-dict*
		  "lhs"	     映射的 {lhs}，就像输入时一样
		  "lhsraw"   映射的 {lhs}，原始字节
		  "lhsrawalt" 映射的 {lhs}，原始字节，替代形式，仅在不同于 "lhsraw" 时存在
		  "rhs"	     映射的 {rhs}，就像输入时一样
		  "callback" Lua 函数，如果 RHS 被定义为这样的函数
		  "silent"    1 表示 |:map-silent| 映射，否则为 0
		  "noremap"   1 如果映射的 {rhs} 不可重映射
		  "script"    1 如果映射是用 <script> 定义的
		  "expr"      1 表示表达式映射 (|:map-<expr>|)
		  "buffer"    1 表示缓冲区本地映射 (|:map-local|)
		  "mode"     定义映射的模式。除了上述模式外，还会使用这些字符：
			     " "     普通、可视和操作符待决模式
			     "!"     插入和命令行模式 (|mapmode-ic|)
		  "sid"	     脚本本地 ID，用于 <sid> 映射 (|<SID>|)。特殊上下文为负值
		  "scriptversion"  脚本版本，始终为 1
		  "lnum"     在 "sid" 中的行号，未知时为 0
		  "nowait"   不等待其他更长的映射 (|:map-<nowait>|)
		  "abbr"     如果这是 |abbreviation| 则为 True
		  "mode_bits" Nvim 内部对 "mode" 的二进制表示
			     |mapset()| 忽略这一点；只使用 "mode"
			     参见 |maplist()| 获取使用示例。值来自 src/nvim/state_defs.h，
			     将来可能会更改

		该字典可用于通过 |mapset()| 恢复映射。

		首先检查当前缓冲区的本地映射，然后是全局映射。
		这个函数可以用来映射一个键，即使它已经被映射，并让它也执行原始映射。示例：
>vim
			exe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')
		参数：
		  • {name} (`string`) - 映射名称
		  • {mode} (`string?`) - 可选的模式
		  • {abbr} (`boolean?`) - 可选的缩写标志
		  • {dict} (`false?`) - 可选的字典标志

		返回值：
		  (`string`) - 映射的 rhs 或空字符串

mapcheck({name} [, {mode} [, {abbr}]])                              *mapcheck()*
		检查在模式 {mode} 中是否有与 {name} 匹配的映射。
		关于 {mode} 和 {name} 中的特殊名称，请参见 |maparg()|。
		当 {abbr} 存在且非零时，使用缩写而不是映射。
		当映射以 {name} 开头或 {name} 以映射开头时，就会发生匹配。

			匹配映射 "a"	"ab"	"abc" ~
		   mapcheck("a")	是	是	 是
		   mapcheck("abc")	是	是	 是
		   mapcheck("ax")	是	否	 否
		   mapcheck("b")	否	否	 否

		与 maparg() 的区别在于，mapcheck() 查找与 {name} 匹配的映射，
		而 maparg() 只查找完全匹配 {name} 的映射。
		当没有以 {name} 开头的映射时，返回空字符串。
		如果有一个，则返回该映射的 RHS。
		如果有多个以 {name} 开头的映射，则返回其中一个的 RHS。
		如果 RHS 为空，则返回 "<Nop>"。
		首先检查当前缓冲区的本地映射，然后是全局映射。
		这个函数可以用来检查是否可以添加映射而不产生歧义。示例：
>vim
			if mapcheck("_vv") == ""
			   map _vv :set guifont=7x13<CR>
			endif
		这避免了在已经有 "_v" 或 "_vvv" 的映射时添加 "_vv" 映射。

		参数：
		  • {name} (`string`) - 要检查的映射名称
		  • {mode} (`string?`) - 可选的模式
		  • {abbr} (`boolean?`) - 可选的缩写标志

		返回值：
		  (`any`) - 匹配的映射 rhs 或空字符串

maplist([{abbr}])                                                    *maplist()*
		返回所有映射的 |List|。每个 List 项都是一个 |Dict|，
		与 |maparg()| 返回的相同，参见 |mapping-dict|。
		当 {abbr} 存在且为 |TRUE| 时，使用缩写而不是映射。

		示例，显示所有 rhs 中包含 "MultiMatch" 的映射：
>vim
			echo maplist()->filter({_, m ->
				\ match(get(m, 'rhs', ''), 'MultiMatch') >= 0
				\ })
		找到特定 |:map-modes| 的映射可能很棘手。
		|mapping-dict| 的 "mode_bits" 可以简化这一点。
		例如，普通、插入或命令行模式的 mode_bits 是 0x19。
		要找到这些模式中可用的所有映射，你可以这样做：
>vim
			let saved_maps = []
			for m in maplist()
			    if and(m.mode_bits, 0x19) != 0
				eval saved_maps->add(m)
			    endif
			endfor
			echo saved_maps->mapnew({_, m -> m.lhs})
		mode_bits 的值在 Nvim 的 src/nvim/state_defs.h 文件中定义，
		它们可以在运行时使用 |:map-commands| 和 "maplist()" 发现。示例：
>vim
			omap xyzzy <Nop>
			let op_bit = maplist()->filter(
			    \ {_, m -> m.lhs == 'xyzzy'})[0].mode_bits
			ounmap xyzzy
			echo printf("Operator-pending mode bit: 0x%x", op_bit)

		参数：
		  • {abbr} (`0|1?`) - 可选的缩写标志

		返回值：
		  (`table[]`) - 映射列表

mapnew({expr1}, {expr2})                                              *mapnew()*
		类似于 |map()|，但不是替换 {expr1} 中的项目，而是创建一个新的
		List 或 Dictionary 并返回。{expr1} 保持不变。
		如果你不希望 {expr2} 更改项目，请先使用 |deepcopy()|。

		参数：
		  • {expr1} (`any`) - 要映射的集合
		  • {expr2} (`any`) - 映射函数或表达式
		返回值：
		  (`any`) - 新的映射结果

mapset({mode}, {abbr}, {dict})                                        *mapset()*
mapset({dict})
		从字典中恢复映射，可能是由 |maparg()| 或 |maplist()| 返回的。
		当 dict.buffer 为 true 时，在当前缓冲区上设置缓冲区映射；
		由调用者确保目标缓冲区是当前缓冲区。
		这个特性允许将映射从一个缓冲区复制到另一个缓冲区。
		dict.mode 值可以恢复覆盖多个模式的单个映射，如模式值为 '!'、' '、"nox" 或 'v'。*E1276*

		在第一种形式中，{mode} 和 {abbr} 应该与调用 |maparg()| 时相同。*E460*
		{mode} 用于定义设置映射的模式，而不是 {dict} 中的 "mode" 条目。
		保存和恢复映射的示例：
>vim
			let save_map = maparg('K', 'n', 0, 1)
			nnoremap K somethingelse
			" ...
			call mapset('n', 0, save_map)
		注意，如果你要替换多个模式中的映射，例如使用 `:map!`，
		当它们可能不同时，你需要保存/恢复所有模式的映射。

		在第二种形式中，{dict} 作为唯一参数，模式和缩写取自字典。
		示例：
>vim
			let save_maps = maplist()->filter(
						\ {_, m -> m.lhs == 'K'})
			nnoremap K somethingelse
			cnoremap K somethingelse2
			" ...
			unmap K
			for d in save_maps
			    call mapset(d)
			endfor

		参数：
		  • {dict} (`table<string,any>`) - 映射字典

		返回值：
		  (`any`) - 操作结果

match({expr}, {pat} [, {start} [, {count}]])                           *match()*
		当 {expr} 是 |List| 时，返回第一个匹配 {pat} 的项目的索引。
		每个项目都用作字符串。
		|Lists| 和 |Dictionaries| 按回显方式使用。

		否则，{expr} 被用作字符串。结果是一个数字，表示 {expr} 中匹配 {pat} 的索引（字节偏移量）。

		在第一个字符或 |List| 项处匹配返回零。如果没有匹配，返回 -1。

		要获取子匹配，请参见 |matchlist()|。
		示例：
>vim
			echo match("testing", "ing")	" 结果为 4
			echo match([1, 'x'], '\a')	" 结果为 1
		参见 |string-match| 了解如何使用 {pat}。
								*strpbrk()*
		Vim 没有 strpbrk() 函数。但你可以这样做：
>vim
			let sepidx = match(line, '[.,;: \t]')
								*strcasestr()*
		Vim 没有 strcasestr() 函数。但你可以添加 "\c" 到模式中以忽略大小写：
>vim
			let idx = match(haystack, '\cneedle')

		如果给出 {start}，搜索从字符串中的字节索引 {start} 或 |List| 中的项 {start} 开始。
		但是，结果仍然是从第一个字符/项开始计数的索引。
		示例：
>vim
			echo match("testing", "ing", 2)
		结果仍然是 "4"。
>vim
			echo match("testing", "ing", 4)
		结果仍然是 "4"。
>vim
			echo match("testing", "t", 2)
		结果是 "3"。
		对于字符串，如果 {start} > 0，则就像字符串从 {start} 字节后开始，
		因此 "^" 将在 {start} 处匹配。除非给出 {count}，那么就像忽略 {start} 字节之前的匹配
		（这有点复杂，以保持向后兼容）。
		对于字符串，如果 {start} < 0，它将被设置为 0。对于列表，索引从末尾开始计数。
		如果 {start} 超出范围（对于字符串 {start} > strlen({expr}) 或对于 |List| {start} > len({expr})），
		则返回 -1。

		当给出 {count} 时，使用第 {count} 个匹配。当在字符串中找到匹配时，
		下一个匹配的搜索从下一个字符开始。因此这个示例的结果是 1：
>vim
			echo match("testing", "..", 0, 2)
		在 |List| 中，搜索继续在下一个项中进行。
		注意，当添加 {count} 时，{start} 的工作方式会改变，见上文。
						*match-pattern*
		参见 |pattern| 了解接受哪些模式。
		'ignorecase' 选项用于设置模式的忽略大小写。不使用 'smartcase'。
		匹配总是像设置了 'magic' 且 'cpoptions' 为空一样进行。
		注意，优先匹配开头，因此当模式使用 "*"（任意数量的匹配）时，
		它倾向于在开头找到零匹配，而不是在文本中更靠后的多个匹配。

		参数：
		  • {expr} (`string|any[]`) - 要搜索的字符串或列表
		  • {pat} (`string`) - 搜索模式
		  • {start} (`integer?`) - 可选的起始位置
		  • {count} (`integer?`) - 可选的匹配次数

		返回值：
		  (`any`) - 匹配的索引或 -1

                                                *matchadd()* *E798* *E799* *E801* *E957*
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
		在当前窗口中定义一个要高亮显示的模式（"匹配"）。
		它将用 {group} 高亮显示。返回一个标识号（ID），
		可用于使用 |matchdelete()| 删除匹配。ID 绑定到窗口。
		匹配是区分大小写和魔法的，除非在 {pattern} 中明确覆盖了大小写敏感性或魔法性。
		不使用 'magic'、'smartcase' 和 'ignorecase' 选项。
		"Conceal" 值是特殊的，它会导致匹配被隐藏。

		可选的 {priority} 参数为匹配分配优先级。
		高优先级的匹配将覆盖低优先级匹配的高亮显示。
		优先级指定为整数（负数也不例外）。
		如果未指定 {priority} 参数，则默认优先级为 10。
		'hlsearch' 的优先级为零，因此所有优先级大于零的匹配都将覆盖它。
		语法高亮（参见 'syntax'）是一个单独的机制，无论选择的优先级如何，
		匹配总是会覆盖语法高亮。

		可选的 {id} 参数允许请求特定的匹配 ID。
		如果指定的 ID 已被占用，将显示错误消息并且不会添加匹配。
		ID 指定为正整数（不包括零）。ID 1、2 和 3 分别保留给 |:match|、|:2match| 和 |:3match|。
		3 保留给 |matchparen| 插件使用。
		如果 {id} 参数未指定或为 -1，|matchadd()|
		自动选择一个空闲的 ID，该 ID 至少为 1000。

		可选的 {dict} 参数允许进一步的自定义值。
		目前这用于指定一个匹配特定的隐藏字符，该字符将显示给 |hl-Conceal| 高亮的匹配。
		字典可以有以下成员：

			conceal	    显示在匹配位置的特殊字符（仅用于 |hl-Conceal| 高亮的匹配，参见 |:syn-cchar|）
			window	    使用此编号或窗口 ID 的窗口，而不是当前窗口。

		匹配的数量不受限制，这与 |:match| 命令不同。

		出错时返回 -1。

		示例：
>vim
			highlight MyGroup ctermbg=green guibg=green
			let m = matchadd("MyGroup", "TODO")
		删除模式：
>vim
			call matchdelete(m)

		|matchadd()| 和 |:match| 定义的匹配列表可从 |getmatches()| 获取。
		所有匹配可以通过 |clearmatches()| 一次性删除。

		参数：
		  • {group} (`integer|string`) - 高亮组
		  • {pattern} (`string`) - 匹配模式
		  • {priority} (`integer?`) - 可选的优先级
		  • {id} (`integer?`) - 可选的匹配 ID
		  • {dict} (`string?`) - 可选的字典参数

		返回值：
		  (`any`) - 匹配 ID 或 -1

matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])   *matchaddpos()*
		与 |matchadd()| 相同，但需要一个位置列表 {pos} 而不是模式。
		这个命令比 |matchadd()| 更快，因为它不处理正则表达式，
		并且它设置缓冲区行边界以重绘屏幕。
		它应该在需要快速添加和删除匹配时使用，例如高亮匹配的括号。
							*E5030* *E5031*
		{pos} 是一个位置列表。每个位置可以是以下之一：
		- 一个数字。整行将被高亮。第一行的编号为 1。
		- 一个包含一个数字的列表，例如 [23]。具有此编号的整行将被高亮。
		- 一个包含两个数字的列表，例如 [23, 11]。第一个数字是行号，
		  第二个是列号（第一列是 1，值必须对应于 |col()| 返回的字节索引）。
		  此位置的字符将被高亮。
		- 一个包含三个数字的列表，例如 [23, 11, 3]。如上所述，
		  但第三个数字给出高亮的字节长度。

		具有零和负行号的条目会被静默忽略，具有负列号和长度的条目也是如此。

		出错时返回 -1。

		示例：
>vim
			highlight MyGroup ctermbg=green guibg=green
			let m = matchaddpos("MyGroup", [[23, 24], 34])
		删除模式：
>vim
			call matchdelete(m)

		|matchaddpos()| 添加的匹配由 |getmatches()| 返回。

		参数：
		  • {group} (`integer|string`) - 高亮组
		  • {pos} (`any[]`) - 位置列表
		  • {priority} (`integer?`) - 可选的优先级
		  • {id} (`integer?`) - 可选的匹配 ID
		  • {dict} (`string?`) - 可选的字典参数

		返回值：
		  (`any`) - 匹配 ID 或 -1

matcharg({nr})                                                      *matcharg()*
		选择第 {nr} 个匹配项，如通过 |:match|、|:2match| 或 |:3match| 命令设置。
		返回一个包含两个元素的 |List|：
			使用的高亮组名称
			使用的模式。
		当 {nr} 不是 1、2 或 3 时返回空 |List|。
		当没有设置匹配项时返回 ['', '']。
		这对于保存和恢复 |:match| 很有用。
		使用 |:match| 命令的高亮匹配限制为三个匹配。|matchadd()| 没有这个限制。

		参数：
		  • {nr} (`integer`) - 匹配编号
		返回值：
		  (`any`) - 匹配信息列表

matchbufline({buf}, {pat}, {lnum}, {end}, [, {dict}])           *matchbufline()*
		返回缓冲区 {buf} 中从 {lnum} 到 {end} 的行中匹配 {pat} 的 |List|。

		{lnum} 和 {end} 可以是行号，也可以是字符串 "$" 来引用 {buf} 中的最后一行。

		{dict} 参数支持以下项目：
		    submatches	包含子匹配信息 (|/\(|)

		对于每个匹配，返回一个包含以下项目的 |Dict|：
		    byteidx	匹配的起始字节索引
		    lnum	匹配所在的行号
		    text	匹配的字符串
		注意，一行中可以有多个匹配。

		此函数仅适用于已加载的缓冲区。如果需要，首先调用 |bufload()|。

		参见 |match-pattern| 了解一些选项设置对模式的影响。

		当 {buf} 不是有效的缓冲区，缓冲区未加载，或 {lnum} 或 {end} 无效时，
		会给出错误并返回空 |List|。

		示例：
>vim
		    " 假设缓冲区 5 的第 3 行包含 "a"
		    echo matchbufline(5, '\<\k\+\>', 3, 3)
		    `[{'lnum': 3, 'byteidx': 0, 'text': 'a'}]`
>vim
		    " 假设缓冲区 10 的第 4 行包含 "tik tok"
		    echo matchbufline(10, '\<\k\+\>', 1, 4)
		    `[{'lnum': 4, 'byteidx': 0, 'text': 'tik'}, {'lnum': 4, 'byteidx': 4, 'text': 'tok'}]`

		如果存在 {submatch} 且为 v:true，则还会返回 "\1"、"\2" 等子匹配。
		示例：
>vim
		    " 假设缓冲区 2 的第 2 行包含 "acd"
		    echo matchbufline(2, '\(a\)\?\(b\)\?\(c\)\?\(.*\)', 2, 2
						\ {'submatches': v:true})
		    `[{'lnum': 2, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]`
		"submatches" 列表始终包含 9 个项目。如果未找到子匹配，则返回空字符串。

		参数：
		  • {buf} (`string|integer`) - 缓冲区编号或名称
		  • {pat} (`string`) - 匹配模式
		  • {lnum} (`string|integer`) - 起始行号或 "$"
		  • {end} (`string|integer`) - 结束行号或 "$"
		  • {dict} (`table?`) - 可选的字典参数

		返回值：
		  (`any`) - 匹配信息列表

matchdelete({id} [, {win}])                            *matchdelete()* *E802* *E803*
		删除之前由 |matchadd()| 或 |:match| 命令之一定义的 ID 为 {id} 的匹配。
		如果成功返回 0，否则返回 -1。参见 |matchadd()| 的示例。
		所有匹配可以通过 |clearmatches()| 一次性删除。
		如果指定了 {win}，则使用此编号或窗口 ID 的窗口，而不是当前窗口。

		参数：
		  • {id} (`integer`) - 匹配 ID
		  • {win} (`integer?`) - 可选的窗口 ID

		返回值：
		  (`any`) - 操作结果

matchend({expr}, {pat} [, {start} [, {count}]])                     *matchend()*
		与 |match()| 相同，但返回匹配后的第一个字符的索引。
		示例：
>vim
			echo matchend("testing", "ing")
		结果为 "7"。
							*strspn()* *strcspn()*
		Vim 没有 strspn() 或 strcspn() 函数，但你可以用 matchend() 实现：
>vim
			let span = matchend(line, '[a-zA-Z]')
			let span = matchend(line, '[^a-zA-Z]')
		除了在没有匹配时返回 -1。

		如果给出 {start}，其含义与 |match()| 相同。
>vim
			echo matchend("testing", "ing", 2)
		结果为 "7"。
>vim
			echo matchend("testing", "ing", 5)
		结果为 "-1"。
		当 {expr} 是 |List| 时，结果与 |match()| 相同。

		参数：
		  • {expr} (`any`) - 要搜索的字符串或列表
		  • {pat} (`string`) - 搜索模式
		  • {start} (`integer?`) - 可选的起始位置
		  • {count} (`integer?`) - 可选的匹配次数

		返回值：
		  (`any`) - 匹配结束位置或 -1
matchfuzzy({list}, {str} [, {dict}])                              *matchfuzzy()*
		如果 {list} 是字符串列表，则返回一个 |List|，包含 {list} 中所有模糊匹配 {str} 的字符串。
		返回列表中的字符串根据匹配分数排序。

		可选的 {dict} 参数始终支持以下项目：
		    matchseq	当存在此项目时，只返回包含 {str} 中字符的匹配，且按给定顺序。
		    limit	{list} 中要返回的最大匹配数。零表示无限制。

		如果 {list} 是字典列表，则可选的 {dict} 参数支持以下附加项目：
		    key		要针对 {str} 进行模糊匹配的项目的键。此项目的值应为字符串。
		    text_cb	|Funcref|，将为 {list} 中的每个项目调用以获取用于模糊匹配的文本。
				这应该接受一个字典项目作为参数，并返回用于模糊匹配的文本。

		{str} 被视为字面字符串，不支持正则表达式匹配。支持的最大 {str} 长度为 256。

		当 {str} 有多个由空格分隔的单词时，返回包含所有单词的字符串列表。

		如果没有匹配的字符串或发生错误，则返回空列表。
		如果 {str} 的长度大于 256，则返回空列表。

		当给出 {limit} 时，matchfuzzy() 将在 {list} 中查找最多此数量的匹配并按排序顺序返回它们。

		有关模糊匹配字符串的更多信息，请参见 |fuzzy-matching|。

		示例：
>vim
		   echo matchfuzzy(["clay", "crow"], "cay")
		结果为 ["clay"]。
>vim
		   echo getbufinfo()->map({_, v -> v.name})->matchfuzzy("ndl")
		结果为模糊匹配 "ndl" 的缓冲区名称列表。
>vim
		   echo getbufinfo()->matchfuzzy("ndl", {'key' : 'name'})
		结果为缓冲区名称模糊匹配 "ndl" 的缓冲区信息字典列表。
>vim
		   echo getbufinfo()->matchfuzzy("spl",
						\ {'text_cb' : {v -> v.name}})
		结果为缓冲区名称模糊匹配 "spl" 的缓冲区信息字典列表。
>vim
		   echo v:oldfiles->matchfuzzy("test")
		结果为模糊匹配 "test" 的文件名列表。
>vim
		   let l = readfile("buffer.c")->matchfuzzy("str")
		结果为 "buffer.c" 中模糊匹配 "str" 的行列表。
>vim
		   echo ['one two', 'two one']->matchfuzzy('two one')
		结果为 `['two one', 'one two']`。
>vim
		   echo ['one two', 'two one']->matchfuzzy('two one',
						\ {'matchseq': 1})
		结果为 `['two one']`。

		参数：
		  • {list} (`any[]`) - 要搜索的列表
		  • {str} (`string`) - 搜索字符串
		  • {dict} (`table?`) - 可选的字典参数

		返回值：
		  (`any`) - 匹配的列表

matchfuzzypos({list}, {str} [, {dict}])                        *matchfuzzypos()*
		与 |matchfuzzy()| 相同，但返回匹配的字符串列表、
		{str} 中字符匹配的字符位置列表和匹配分数列表。
		你可以使用 |byteidx()| 将字符位置转换为字节位置。

		如果 {str} 在字符串中多次匹配，则只返回最佳匹配的位置。

		如果没有匹配的字符串或发生错误，则返回一个包含三个空列表项的列表。

		示例：
>vim
			echo matchfuzzypos(['testing'], 'tsg')
		结果为 [["testing"], [[0, 2, 6]], [99]]
>vim
			echo matchfuzzypos(['clay', 'lacy'], 'la')
		结果为 [["lacy", "clay"], [[0, 1], [1, 2]], [153, 133]]
>vim
			echo [{'text': 'hello', 'id' : 10}]
				\ ->matchfuzzypos('ll', {'key' : 'text'})
		结果为 `[[{"id": 10, "text": "hello"}], [[2, 3]], [127]]`

		参数：
		  • {list} (`any[]`) - 要搜索的列表
		  • {str} (`string`) - 搜索字符串
		  • {dict} (`table?`) - 可选的字典参数

		返回值：
		  (`any`) - 匹配信息列表
matchlist({expr}, {pat} [, {start} [, {count}]])                   *matchlist()*
		与 |match()| 相同，但返回一个 |List|。
		列表中的第一项是匹配的字符串，与 matchstr() 返回的相同。
		后面的项是子匹配，如 |:substitute| 中的 "\1"、"\2" 等。
		当可选的子匹配未匹配时，使用空字符串。
		示例：
>vim
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
		结果为：['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		当没有匹配时返回空列表。

		你可以传入一个 List，但这不太有用。

		参数：
		  • {expr} (`any`) - 要搜索的表达式
		  • {pat} (`string`) - 搜索模式
		  • {start} (`integer?`) - 可选的起始位置
		  • {count} (`integer?`) - 可选的匹配次数

		返回值：
		  (`any`) - 匹配列表

matchstr({expr}, {pat} [, {start} [, {count}]])                     *matchstr()*
		与 |match()| 相同，但返回匹配的字符串。
		示例：
>vim
			echo matchstr("testing", "ing")
		结果为 "ing"。
		当没有匹配时返回 ""。
		如果给出 {start}，其含义与 |match()| 相同。
>vim
			echo matchstr("testing", "ing", 2)
		结果为 "ing"。
>vim
			echo matchstr("testing", "ing", 5)
		结果为 ""。
		当 {expr} 是 |List| 时，返回匹配的项目。
		类型不会改变，不一定是字符串。

		参数：
		  • {expr} (`any`) - 要搜索的表达式
		  • {pat} (`string`) - 搜索模式
		  • {start} (`integer?`) - 可选的起始位置
		  • {count} (`integer?`) - 可选的匹配次数

		返回值：
		  (`any`) - 匹配的字符串或项目

matchstrlist({list}, {pat} [, {dict}])                          *matchstrlist()*
		返回 {list} 中匹配 {pat} 的 |List|。
		{list} 是字符串的 |List|。{pat} 与 {list} 中的每个字符串匹配。

		{dict} 参数支持以下项目：
		    submatch	包含子匹配信息 (|/\(|)

		对于每个匹配，返回一个包含以下项目的 |Dict|：
		    byteidx	匹配的起始字节索引
		    idx		匹配在 {list} 中的索引
		    text	匹配的字符串
		    submatches	子匹配的列表。仅在 {dict} 中设置 "submatches" 为 v:true 时存在

		关于某些选项设置对模式的影响，请参阅 |match-pattern|。

		示例：
>vim
		    echo matchstrlist(['tik tok'], '\<\k\+\>')
<		    `[{'idx': 0, 'byteidx': 0, 'text': 'tik'}, {'idx': 0, 'byteidx': 4, 'text': 'tok'}]` >vim
		    echo matchstrlist(['a', 'b'], '\<\k\+\>')
<		    `[{'idx': 0, 'byteidx': 0, 'text': 'a'}, {'idx': 1, 'byteidx': 0, 'text': 'b'}]`

		如果存在 "submatches" 且为 v:true，则还会返回 "\1"、"\2" 等子匹配。
		示例：
>vim
		    echo matchstrlist(['acd'], '\(a\)\?\(b\)\?\(c\)\?\(.*\)',
						\ #{submatches: v:true})
<		    `[{'idx': 0, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]`
		子匹配列表总是包含 9 个项目。如果未找到子匹配，则返回空字符串。

		参数：
		  • {list} (`string[]`) - 字符串列表
		  • {pat} (`string`) - 搜索模式
		  • {dict} (`table?`) - 可选的字典参数

		返回值：
		  (`any`) - 匹配结果

matchstrpos({expr}, {pat} [, {start} [, {count}]])               *matchstrpos()*
		与 |matchstr()| 相同，但返回匹配的字符串、匹配的起始位置和结束位置。
		示例：
>vim
			echo matchstrpos("testing", "ing")
<		结果为 ["ing", 4, 7]。
		当没有匹配时返回 ["", -1, -1]。
		如果给出 {start}，其含义与 |match()| 相同。
>vim
			echo matchstrpos("testing", "ing", 2)
<		结果为 ["ing", 4, 7]。
>vim
			echo matchstrpos("testing", "ing", 5)
<		结果为 ["", -1, -1]。
		当 {expr} 是 |List| 时，返回匹配的项目、{pat} 匹配的第一个项目的索引、匹配的起始位置和结束位置。
>vim
			echo matchstrpos([1, '__x'], '\a')
<		结果为 ["x", 1, 2, 3]。
		类型不会改变，不一定是字符串。

		参数：
		  • {expr} (`any`) - 要搜索的表达式
		  • {pat} (`string`) - 搜索模式
		  • {start} (`integer?`) - 可选的起始位置
		  • {count} (`integer?`) - 可选的匹配次数

		返回值：
		  (`any`) - 匹配结果

max({expr})                                                              *max()*
		返回 {expr} 中所有项目的最大值。
		示例：
>vim
			echo max([apples, pears, oranges])

<		{expr} 可以是 |List| 或 |Dictionary|。对于 Dictionary，
		它返回 Dictionary 中所有值的最大值。
		如果 {expr} 既不是 List 也不是 Dictionary，或者 {expr} 中的某个项目
		不能用作数字，则会导致错误。空的 |List| 或 |Dictionary| 返回零。

		参数：
		  • {expr} (`any`) - 要计算最大值的表达式

		返回值：
		  (`number`) - 最大值

menu_get({path} [, {modes}])                                        *menu_get()*
		返回一个 |List|，其中包含描述 |menus| 的 |Dictionaries|（由 |:menu|、|:amenu| 等定义），
		包括 |hidden-menus|。

		{path} 通过名称匹配菜单，如果 {path} 为空字符串则匹配所有菜单。
		示例：
>vim
			echo menu_get('File','')
			echo menu_get('')
<
		{modes} 是零个或多个模式的字符串（有关模式列表，请参阅 |maparg()| 或
		|creating-menus|）。"a" 表示"全部"。

		示例：
>vim
			nnoremenu &Test.Test inormal
			inoremenu Test.Test insert
			vnoremenu Test.Test x
			echo menu_get("")

<		返回类似这样的内容：>

			[ {
			  "hidden": 0,
			  "name": "Test",
			  "priority": 500,
			  "shortcut": 84,
			  "submenus": [ {
			    "hidden": 0,
			    "mappings": {
			      i": {
				"enabled": 1,
				"noremap": 1,
				"rhs": "insert",
				"sid": 1,
				"silent": 0
			      },
			      n": { ... },
			      s": { ... },
			      v": { ... }
			    },
			    "name": "Test",
			    "priority": 500,
			    "shortcut": 0
			  } ]
			} ]
<

		参数：
		  • {path} (`string`) - 菜单路径
		  • {modes} (`string?`) - 可选的模式字符串

		返回值：
		  (`any`) - 菜单信息列表

menu_info({name} [, {mode}])                                       *menu_info()*
		返回指定菜单 {name} 在模式 {mode} 中的信息。
		菜单名称应指定时不带快捷键字符（'&'）。
		如果 {name} 为 ""，则返回顶层菜单名称。

		{mode} 可以是以下字符串之一：
			"n"	普通模式
			"v"	可视模式（包括选择模式）
			"o"	操作符待决模式
			"i"	插入模式
			"c"	命令行模式
			"s"	选择模式
			"x"	可视模式
			"t"	终端作业模式
			""	普通、可视和操作符待决模式
			"!"	插入和命令行模式
		当省略 {mode} 时，使用 "" 的模式。
		返回一个包含以下项目的 |Dictionary|：
		  accel		菜单项加速键文本 |menu-text|
		  display	显示名称（不带 '&' 的名称）
		  enabled	如果此菜单项已启用则为 v:true
				参考 |:menu-enable|
		  icon		图标文件名（用于工具栏）
				|toolbar-icon|
		  iconidx	内置图标的索引
		  modes		定义菜单的模式。除了上述模式外，
				还会使用以下字符：
				" "	普通、可视和操作符待决模式
		  name		菜单项名称
		  noremenu	如果菜单项的 {rhs} 不可重映射则为 v:true，
				否则为 v:false
		  priority	菜单顺序优先级 |menu-priority|
		  rhs		菜单项的右侧。返回的字符串中的特殊字符
				已转换，类似于 ":menu" 命令列表的输出。
				当菜单项的 {rhs} 为空时，返回 "<Nop>"。
		  script	如果允许 {rhs} 的脚本局部重映射则为 v:true，
				否则为 v:false。参见 |:menu-script|。
		  shortcut	快捷键（菜单名称中 '&' 后面的字符）
				|menu-shortcut|
		  silent	如果菜单项是使用 <silent> 参数创建的则为 v:true
				|:menu-silent|
		  submenus	包含所有子菜单名称的 |List|。
				仅当菜单项有子菜单时存在。

		如果未找到菜单项，则返回空字典。

		示例：
>vim
			echo menu_info('Edit.Cut')
			echo menu_info('File.Save', 'n')

			" 在缓冲区中显示整个菜单层次结构
			func ShowMenu(name, pfx)
			  let m = menu_info(a:name)
			  call append(line('$'), a:pfx .. m.display)
			  for child in m->get('submenus', [])
			    call ShowMenu(a:name .. '.' .. escape(child, '.'),
							\ a:pfx .. '    ')
			  endfor
			endfunc
			new
			for topmenu in menu_info('').submenus
			  call ShowMenu(topmenu, '')
			endfor
		参数：
		  • {name} (`string`) - 菜单名称
		  • {mode} (`string?`) - 可选的模式字符串

		返回值：
		  (`any`) - 菜单信息字典

min({expr})                                                              *min()*
		返回 {expr} 中所有项目的最小值。
		示例：
>vim
			echo min([apples, pears, oranges])

<		{expr} 可以是 |List| 或 |Dictionary|。对于 Dictionary，
		它返回 Dictionary 中所有值的最小值。
		如果 {expr} 既不是 List 也不是 Dictionary，或者 {expr} 中的某个项目
		不能用作数字，则会导致错误。空的 |List| 或 |Dictionary| 返回零。

		参数：
		  • {expr} (`any`) - 要计算最小值的表达式

		返回值：
		  (`number`) - 最小值

mkdir({name} [, {flags} [, {prot}]])                              *mkdir()* *E739*
		创建目录 {name}。

		当 {flags} 存在时，它必须是一个字符串。空字符串没有效果。

		{flags} 可以包含以下字符标志：
		 "p"	必要时创建中间目录
		 "D"	{name} 将在当前函数结束时删除，但不递归 |:defer|
		 "R"	{name} 将在当前函数结束时递归删除 |:defer|

		注意，当 {name} 有多个部分且使用 "p" 时，某些目录可能已经存在。
		只有第一个创建的目录及其内容会被安排删除。
		例如，当使用：
>vim
			call mkdir('subdir/tmp/autoload', 'pR')
<		且 "subdir" 已存在时，"subdir/tmp" 将被安排删除，就像：
>vim
			defer delete('subdir/tmp', 'rf')
<
		如果给出 {prot}，它用于设置新目录的保护位。
		默认为 0o755（rwxr-xr-x：用户可读/写，其他人可读）。
		使用 0o700 使其...
		对其他人不可读。这用于新创建的目录。
		注意：umask 应用于 {prot}（在 Unix 上）。
		示例：
>vim
			call mkdir($HOME .. "/tmp/foo/bar", "p", 0o700)

<		此函数在 |sandbox| 中不可用。

		如果尝试使用 {flags} 设置为 "p" 创建已存在的目录，
		mkdir() 将静默退出。

		函数结果是一个数字，如果调用成功则为 TRUE，如果目录创建失败或部分失败则为 FALSE。

		参数：
		  • {name} (`string`) - 目录名称
		  • {flags} (`string?`) - 可选的标志字符串
		  • {prot} (`string?`) - 可选的保护位

		返回值：
		  (`integer`) - 成功状态

mode([{expr}])                                                          *mode()*
		返回一个表示当前模式的字符串。
		如果提供了 {expr} 且其计算结果为非零数字或非空字符串（|non-zero-arg|），
		则返回完整模式，否则只返回第一个字母。
		另请参阅 |state()|。

		   n	    普通模式
		   no	    操作符待决模式
		   nov	    操作符待决模式（强制字符方式 |o_v|）
		   noV	    操作符待决模式（强制行方式 |o_V|）
		   noCTRL-V 操作符待决模式（强制块方式 |o_CTRL-V|）
				CTRL-V 是一个字符
		   niI	    在 |Insert-mode| 中使用 |i_CTRL-O| 的普通模式
		   niR	    在 |Replace-mode| 中使用 |i_CTRL-O| 的普通模式
		   niV	    在 |Virtual-Replace-mode| 中使用 |i_CTRL-O| 的普通模式
		   nt	    在 |terminal-emulator| 中的普通模式（插入进入终端模式）
		   ntT	    在 |Terminal-mode| 中使用 |t_CTRL-\_CTRL-O| 的普通模式
		   v	    字符方式的可视模式
		   vs	    在 Select 模式中使用 |v_CTRL-O| 的字符方式可视模式
		   V	    行方式的可视模式
		   Vs	    在 Select 模式中使用 |v_CTRL-O| 的行方式可视模式
		   CTRL-V   块方式的可视模式
		   CTRL-Vs  在 Select 模式中使用 |v_CTRL-O| 的块方式可视模式
		   s	    字符方式的选择模式
		   S	    行方式的选择模式
		   CTRL-S   块方式的选择模式
		   i	    插入模式
		   ic	    插入模式补全 |compl-generic|
		   ix	    插入模式 |i_CTRL-X| 补全
		   R	    替换模式 |R|
		   Rc	    替换模式补全 |compl-generic|
		   Rx	    替换模式 |i_CTRL-X| 补全
		   Rv	    虚拟替换模式 |gR|
		   Rvc	    虚拟替换模式补全 |compl-generic|
		   Rvx	    虚拟替换模式 |i_CTRL-X| 补全
		   c	    命令行编辑模式
		   cr	    命令行编辑覆盖模式 |c_<Insert>|
		   cv	    Vim Ex 模式 |gQ|
		   cvr	    Vim Ex 模式中的覆盖模式 |c_<Insert>|
		   r	    回车提示
		   rm	    -- more -- 提示
		   r?	    某种 |:confirm| 查询
		   !	    正在执行 shell 或外部命令
		   t	    终端模式：按键发送到作业

		这在 'statusline' 选项或 RPC 调用中很有用。
		在大多数其他地方，它总是返回 "c" 或 "n"。
		注意，将来可能会添加更多模式和更具体的模式。
		最好不要比较整个字符串，而只比较前导字符。
		另请参阅 |visualmode()|。

		参数：
		  • {expr} (`any?`) - 可选的表达式

		返回值：
		  (`any`) - 模式字符串

msgpackdump({list} [, {type}])                                   *msgpackdump()*
		将 Vimscript 对象列表转换为 msgpack。
		返回值是一个 |readfile()| 风格的列表。
		当 {type} 包含 "B" 时，返回 |Blob|。
		示例：
>vim
			call writefile(msgpackdump([{}]), 'fname.mpack', 'b')
<		或者，使用 |Blob|：
>vim
			call writefile(msgpackdump([{}], 'B'), 'fname.mpack')
<
		这将向 `fname.mpack` 文件写入单个 0x80 字节
		（在 messagepack 中，零项字典由 0x80 字节表示）。

		限制：				*E5004* *E5005*
		1. 无法转储 |Funcref|。
		2. 无法转储引用自身的容器。
		3. 字典键总是作为 STR 字符串转储。
		4. 其他字符串和 |Blob| 总是作为 BIN 字符串转储。
		5. 第 3 点和第 4 点不适用于 |msgpack-special-dict|。
		参数：
		  • {list} (`any`) - 要转换的列表
		  • {type} (`any?`) - 可选的类型参数

		返回值：
		  (`any`) - 转换后的数据

msgpackparse({data})                                            *msgpackparse()*
		将 |readfile()| 风格的列表或 |Blob| 转换为 Vimscript 对象列表。
		示例：
>vim
			let fname = expand('~/.config/nvim/shada/main.shada')
			let mpack = readfile(fname, 'b')
			let shada_objects = msgpackparse(mpack)
<		这将把 ~/.config/nvim/shada/main.shada 文件读取到 `shada_objects` 列表中。

		限制：
		1. 除非使用通用映射（|msgpack-special-map|）转储消息包映射，
		   否则不保留映射顺序。
		2. 由于解析器旨在保留所有数据不变（除了第 1 点），
		   一些字符串被解析为 |msgpack-special-dict| 格式，这不太方便使用。
							*msgpack-special-dict*
		一些消息包字符串可能被解析为特殊字典。
		特殊字典是满足以下条件的字典：

		1. 恰好包含两个键：`_TYPE` 和 `_VAL`。
		2. `_TYPE` 键是 |v:msgpack_types| 变量中找到的类型之一。
		3. `_VAL` 的值具有以下格式（Key 列包含 |v:msgpack_types| 中的键名）：

		Key	值 ~
		nil	零，转储时忽略。自引入 |v:null| 后，
			|msgpackparse()| 不再返回。
		boolean	一或零。转储时只检查值是否为 |Number|。
			自引入 |v:true| 和 |v:false| 后，
			|msgpackparse()| 不再返回。
		integer	包含四个数字的 |List|：符号（-1 或 1）、最高两位、
			第 62 位到第 31 位的数字、最低 31 位。
			即，要获取实际数字，需要使用如下代码：
>				_VAL[0] * ((_VAL[1] << 62)
				           & (_VAL[2] << 31)
				           & _VAL[3])
<			具有此类型的特殊字典将出现在...
			|msgpackparse()| 输出中，在以下情况之一出现：
			1. |Number| 是 32 位且值高于 INT32_MAX 或低于 INT32_MIN。
			2. |Number| 是 64 位且值高于 INT64_MAX。
			   它不可能低于 INT64_MIN，因为 msgpack C 解析器不支持这样的值。
		float	|Float|。这个值不可能出现在 |msgpackparse()| 输出中。
		string	|String|，如果二进制字符串包含零字节则为 |Blob|。
			   这个值自引入 blob 后不可能出现在 |msgpackparse()| 输出中。
		array	|List|。这个值不可能出现在 |msgpackparse()| 输出中。
							*msgpack-special-map*
		map	包含两个项目（键和值）的 |List| 的 |List|。
			   如果解析的映射包含以下键之一，这个值将出现在 |msgpackparse()| 输出中：
			1. 任何不是字符串的键（包括二进制字符串的键）。
			2. 内部包含 NUL 字节的字符串。
			3. 重复的键。
		ext	包含两个值的 |List|：第一个是表示扩展类型的有符号整数。
			   第二个是 |readfile()| 风格的字符串列表。

		参数：
		  • {data} (`any`) - 要解析的数据

		返回值：
		  (`any`) - 解析后的对象列表

nextnonblank({lnum})                                            *nextnonblank()*
		返回在 {lnum} 处或以下的第一个非空行的行号。
		示例：
>vim
			if getline(nextnonblank(1)) =~ "Java" | endif
<		当 {lnum} 无效或在其处或以下没有非空行时，返回零。
		{lnum} 的使用方式与 |getline()| 相同。
		另请参阅 |prevnonblank()|。

		参数：
		  • {lnum} (`integer|string`) - 起始行号

		返回值：
		  (`integer`) - 非空行的行号

nr2char({expr} [, {utf8}])                                           *nr2char()*
		返回一个包含单个字符的字符串，该字符具有数字值 {expr}。
		示例：
			echo nr2char(64)		" 返回 '@'
			echo nr2char(32)		" 返回 ' '
<		示例（"utf-8"）：
>vim
			echo nr2char(300)		" 返回带弓的 I 字符
<
		始终使用 UTF-8 编码，{utf8} 选项没有效果，仅用于向后兼容。
		注意，文件中的 NUL 字符用 nr2char(10) 指定，因为 NUL 用换行符表示。
		nr2char(0) 是真正的 NUL 并终止字符串，因此导致空字符串。

		参数：
		  • {expr} (`integer`) - 字符编码值
		  • {utf8} (`boolean?`) - 可选的 UTF-8 标志

		返回值：
		  (`string`) - 对应的字符

nvim_...({...})                                      *nvim_...()* *E5555* *eval-api*
		调用 nvim |api| 函数。参数的类型检查将比大多数其他内置函数更严格。
		例如，如果期望 Integer，则必须传入 |Number|，|String| 不会自动转换。
		由 |bufnr()| 返回的缓冲区编号可以用作 nvim_buf_... 函数的第一个参数。
		所有期望对象（缓冲区、窗口或标签页）的函数也可以接受数值 0 来表示当前（聚焦的）对象。

		参数：
		  • {...} (`any`) - API 函数参数

		返回值：
		  (`any`) - API 函数返回值

or({expr}, {expr})                                                        *or()*
		对两个参数进行按位 OR 运算。参数被转换为数字。
		List、Dict 或 Float 参数会导致错误。
		另请参阅 `and()` 和 `xor()`。
		示例：
>vim
			let bits = or(bits, 0x80)

<		原理：这是一个函数而不是像许多语言那样使用 "|" 字符的原因是，
		Vi 一直使用 "|" 来分隔命令。在许多地方，不清楚 "|" 是运算符还是命令分隔符。

		参数：
		  • {expr} (`number`) - 第一个操作数
		  • {expr1} (`number`) - 第二个操作数

		返回值：
		  (`any`) - 按位 OR 的结果

pathshorten({path} [, {len}])                                    *pathshorten()*
		缩短路径 {path} 中的目录名称并返回结果。
		尾部，即文件名，保持不变。
		路径中的其他组件被缩短为 {len} 个字母的长度。
		如果省略 {len} 或小于 1，则使用 1（单个字母）。
		保留前导的 '~' 和 '.' 字符。
		示例：
>vim
			echo pathshorten('~/.config/nvim/autoload/file1.vim')
<			~/.c/n/a/file1.vim ~
>vim
			echo pathshorten('~/.config/nvim/autoload/file2.vim', 2)
<			~/.co/nv/au/file2.vim ~
		路径是否存在并不重要。
		出错时返回空字符串。

		参数：
		  • {path} (`string`) - 要缩短的路径
		  • {len} (`integer?`) - 可选的目录名长度

		返回值：
		  (`string`) - 缩短后的路径

perleval({expr})                                                    *perleval()*
		计算 |perl| 表达式 {expr} 并返回其转换为 Vim 数据结构的结果。
		数字和字符串按原样返回（字符串会被复制）。
		列表表示为 Vim |List| 类型。
		字典表示为 Vim |Dictionary| 类型，非字符串键会导致错误。

		注意：如果你想要数组或哈希，{expr} 必须返回对它的引用。
		示例：
>vim
			echo perleval('[1 .. 4]')
<			[1, 2, 3, 4]

		参数：
		  • {expr} (`any`) - Perl 表达式

		返回值：
		  (`any`) - 转换后的 Vim 数据结构

pow({x}, {y})                                                            *pow()*
		返回 {x} 的 {y} 次幂作为 |Float|。
		{x} 和 {y} 必须计算为 |Float| 或 |Number|。
		如果 {x} 或 {y} 不是 |Float| 或 |Number|，则返回 0.0。
		示例：
>vim
			echo pow(3, 3)
<			27.0
>vim
			echo pow(2, 16)
<			65536.0
>vim
			echo pow(32, 0.20)
<			2.0

		参数：
		  • {x} (`number`) - 底数
		  • {y} (`number`) - 指数

		返回值：
		  (`number`) - 幂运算结果

prevnonblank({lnum})                                            *prevnonblank()*
		返回在 {lnum} 处或以上的第一个非空行的行号。
		示例：
>vim
			let ind = indent(prevnonblank(v:lnum - 1))
<		当 {lnum} 无效或在其处或以上没有非空行时，返回零。
		{lnum} 的使用方式与 |getline()| 相同。
		另请参阅 |nextnonblank()|。

		参数：
		  • {lnum} (`integer|string`) - 起始行号

		返回值：
		  (`integer`) - 非空行的行号

printf({fmt}, {expr1} ...)                                            *printf()*
		返回一个字符串，其中 {fmt} 中的 "%" 项被其各自参数的格式化形式替换。
		示例：
>vim
			echo printf("%4d: E%d %.30s", lnum, errno, msg)
<		可能结果：
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		当用作 |method| 时，基作为第二个参数传递：
>vim
			Compute()->printf("result: %d")
<
		你可以使用 `call()` 将项目作为列表传递。

		常用项：
		  %s	字符串
		  %6S	在 6 个显示单元格中右对齐的字符串
		  %6s	在 6 个字节中右对齐的字符串
		  %.9s	截断为 9 个字节的字符串
		  %c	单个字节
		  %d	十进制数
		  %5d	用空格填充到 5 个字符的十进制数
		  %b	二进制数
		  %08b	用零填充到至少 8 个字符的二进制数
		  %B	使用大写字母的二进制数
		  %x	十六进制数
		  %04x	用零填充到至少 4 个字符的十六进制数
		  %X	使用大写字母的十六进制数
		  %o	八进制数
		  %f	浮点数，如 12.23、inf、-inf 或 nan
		  %F	浮点数，如 12.23、INF、-INF 或 NAN
		  %e	浮点数，如 1.23e3、inf、-inf 或 nan
		  %E	浮点数，如 1.23E3、INF、-INF 或 NAN
		  %g	浮点数，根据值使用 %f 或 %e
		  %G	浮点数，根据值使用 %F 或 %E
		  %%	% 字符本身
		  %p	容器指针的表示

		转换说明以 '%' 开始，以转换类型结束。
		所有其他字符都原样复制到结果中。

		"%" 开始一个转换说明。以下参数按顺序出现：

			% [pos-argument] [flags] [field-width] [.precision] type

		pos-argument
			最多一个位置参数说明符。这些采用 {n$} 的形式，其中 n >= 1。

		flags
			零个或多个以下标志：

		    #	      值应转换为"替代形式"。
			      对于 c、d 和 s 转换，此选项没有效果。
			      对于 o 转换，数字的精度增加以强制输出字符串的第一个字符为零
			      （除非零值以显式精度零打印）。
			      对于 x 和 X 转换，非零结果前面加上字符串 "0x"
			      （对于 X 转换则为 "0X"）。

		    0 (零)  零填充。对于所有转换，转换后的值在左侧用零而不是空格填充。
			      如果使用数字转换（d、o、x 和 X）给出精度，则忽略 0 标志。
		    -	       负字段宽度标志；转换后的值应在字段边界左对齐。
			       转换后的值在右侧用空格填充，而不是在左侧用空格或零填充。
			       如果同时给出 - 和 0，则 - 覆盖 0。

		    ' ' (空格)  在由有符号转换（d）产生的正数前应留一个空格。

		    +	       在有符号转换产生的数字前必须始终放置一个符号。
			       + 覆盖空格，如果两者都使用。

		field-width
			一个可选的十进制数字字符串，指定最小字段宽度。
			如果转换后的值的字节数少于字段宽度，它将在左侧（或右侧，如果给出了左对齐标志）
			用空格填充以填满字段宽度。对于 S 转换，计数以单元格为单位。

		.precision
			一个可选的精度，以句点 '.' 后跟一个可选的数字字符串的形式。
			如果省略数字字符串，则精度视为零。
			这给出了 d、o、x 和 X 转换要显示的最小数字数，
			对于 s 转换，给出了要从字符串打印的最大字节数，
			对于 S 转换，给出了要从字符串打印的最大单元格数。
			对于浮点数，它是小数点后的数字数。

		type
			指定要应用的转换类型的字符，见下文。

		字段宽度或精度，或两者，可以用星号 "*" 而不是数字字符串表示。
		在这种情况下，一个数字参数提供字段宽度或精度。
		负字段宽度被视为左对齐标志后跟正字段宽度；负精度被视为缺失。
		示例：
>vim
			echo printf("%d: %.*s", nr, width, line)
<		这将限制从 "line" 使用的文本长度为 "width" 字节。

		如果要格式化的参数使用位置参数说明符指定，并且使用 '*' 来指示...
		字段宽度或精度，则要使用的参数也必须使用 {n$} 位置参数说明符指定。
		参见 |printf-$|。

		转换说明符及其含义：

				*printf-d* *printf-b* *printf-B* *printf-o* *printf-x* *printf-X*
		dbBoxX	数字参数转换为有符号十进制（d）、
			无符号二进制（b 和 B）、无符号八进制（o）或
			无符号十六进制（x 和 X）表示法。
			字母 "abcdef" 用于 x 转换；字母 "ABCDEF" 用于 X 转换。
			精度（如果有）给出必须出现的最小数字数；
			如果转换后的值需要更少的数字，则在左侧用零填充。
			在任何情况下，不存在或小的字段宽度都不会导致数字字段的截断；
			如果转换结果比字段宽度宽，则字段会扩展以包含转换结果。
			'h' 修饰符表示参数是 16 位。
			'l' 修饰符表示参数是长整数。大小将是 32 位或 64 位，
			取决于你的平台。
			"ll" 修饰符表示参数是 64 位。
			b 和 B 转换说明符从不接受宽度修饰符，
			并且总是假设它们的参数是 64 位整数。
			通常，这些修饰符没有用。当从参数中知道类型时，它们被忽略。

		i	d 的别名
		D	ld 的别名
		U	lu 的别名
		O	lo 的别名

							*printf-c*
		c	数字参数转换为字节，并写入结果字符。

							*printf-s*
		s	使用字符串参数的文本。如果指定了精度，
			则使用的字节数不超过指定的数量。
			如果参数不是字符串类型，它会自动转换为文本，
			格式与 ":echo" 相同。
							*printf-S*
		S	使用字符串参数的文本。如果指定了精度，
			则使用的显示单元格数不超过指定的数量。
							*printf-f* *E807*
		f F	浮点参数转换为 123.456 形式的字符串。
			精度指定小数点后的数字数。
			当精度为零时，省略小数点。
			当未指定精度时，使用 6。
			一个非常大的数字（超出范围或除以零）会导致 "inf" 或 "-inf"（使用 %f）
			或 "INF" 或 "-INF"（使用 %F）。
			"0.0 / 0.0" 会导致 "nan"（使用 %f）或 "NAN"（使用 %F）。
			示例：
>vim
				echo printf("%.2f", 12.115)
<				12.12
			注意，舍入取决于系统库。有疑问时使用 |round()|。

							*printf-e* *printf-E*
		e E	浮点参数转换为 1.234e+03 或 1.234E+03 形式的字符串（使用 'E' 时）。
			精度指定小数点后的数字数，与 'f' 相同。

							*printf-g* *printf-G*
		g G	如果值在 0.001（含）和 10000000.0（不含）之间，
			则浮点参数像 'f' 一样转换。
			否则，'g' 使用 'e'，'G' 使用 'E'。
			当未指定精度时，会删除多余的零和 '+' 号，
			除了小数点后立即出现的零。
			因此 10000000.0 结果为 1.0e7。

							*printf-%*
		%	写入一个 '%'。不转换任何参数。
			完整的转换说明是 "%%"。

		当期望数字参数时，也接受字符串参数并自动转换。
		当期望浮点或字符串参数时，也接受数字参数并自动转换。
		任何其他参数类型都会导致错误消息。

							*E766* *E767*
		{exprN} 参数的数量必须与 "%" 项的数量完全匹配。
		如果参数不足或过多，则给出错误。
		最多可以使用 18 个参数。

							*printf-$*
		在某些语言中，当单词顺序与英语中相应的消息不同时，
		错误和信息性消息更容易阅读。为了适应翻译...
		具有不同的单词顺序，可以使用位置参数来指示这一点。
		例如：
>vim
		    #, c-format
		    msgid "%s returning %s"
		    msgstr "waarde %2$s komt terug van %1$s"
<		在这个例子中，句子在输出中颠倒了它的 2 个字符串参数。
>vim
		    echo printf(
			"In The Netherlands, vim's creator's name is: %1$s %2$s",
			"Bram", "Moolenaar")
<		    In The Netherlands, vim's creator's name is: Bram Moolenaar
>vim
		    echo printf(
			"In Belgium, vim's creator's name is: %2$s %1$s",
			"Bram", "Moolenaar")
<		    In Belgium, vim's creator's name is: Moolenaar Bram

		可以使用 '*' 说明符指定宽度（和精度）。
		在这种情况下，你必须在参数列表中指定字段宽度位置。
>vim
		    echo printf("%1$*2$.*3$d", 1, 2, 3)
<		    001
>vim
		    echo printf("%2$*3$.*1$d", 1, 2, 3)
<		      2
>vim
		    echo printf("%3$*1$.*2$d", 1, 2, 3)
<		    03
>vim
		    echo printf("%1$*2$.*3$g", 1.4142, 2, 3)
<		    1.414

		你可以混合直接指定宽度和/或精度以及通过位置参数指定：
>vim
		    echo printf("%1$4.*2$f", 1.4142135, 6)
<		    1.414214
>vim
		    echo printf("%1$*2$.4f", 1.4142135, 6)
<		    1.4142
>vim
		    echo printf("%1$*2$.*3$f", 1.4142135, 6, 2)
<		      1.41

		当字段宽度或精度导致字符串长度超过 1 MB
		(1024*1024 = 1048576) 字符时，你将收到溢出错误 |E1510|。

							*E1500*
		你不能混合使用位置参数和非位置参数：
>vim
		    echo printf("%s%1$s", "One", "Two")
<		    E1500: 不能混合使用位置参数和非位置参数：
		    %s%1$s

							*E1501*
		你不能在格式字符串中跳过位置参数：
>vim
		    echo printf("%3$s%1$s", "One", "Two", "Three")
<		    E1501: 格式参数 2 在 $-style 格式中未使用：
		    %3$s%1$s

							*E1502*
		你可以重复使用 [字段宽度]（或 [精度]）参数：
>vim
		    echo printf("%1$d at width %2$d is: %01$*2$d", 1, 2)
<		    1 at width 2 is: 01

		但是，你不能将其用作不同的类型：
>vim
		    echo printf("%1$d at width %2$ld is: %01$*2$d", 1, 2)
<		    E1502: 位置参数 2 用作字段宽度时被重复用作不同的类型：
		    long int/int

							*E1503*
		当使用位置参数，但未给出正确数量的参数时，会引发错误：
>vim
		    echo printf("%1$d at width %2$d is: %01$*2$.*3$d", 1, 2)
<		    E1503: 位置参数 3 超出范围：%1$d at width
		    %2$d is: %01$*2$.*3$d

		只报告第一个错误：
>vim
		    echo printf("%01$*2$.*3$d %4$d", 1, 2)
<		    E1503: 位置参数 3 超出范围：%01$*2$.*3$d
		    %4$d

							*E1504*
		位置参数可以多次使用：
>vim
		    echo printf("%1$s %2$s %1$s", "One", "Two")
<		    One Two One

		但是，你不能在第二次使用时使用不同的类型：
>vim
		    echo printf("%1$s %2$s %1$d", "One", "Two")
<		    E1504: 位置参数 1 类型使用不一致：
		    int/string

							*E1505*
		各种其他导致格式字符串格式错误的错误会导致：
>vim
		    echo printf("%1$d at width %2$d is: %01$*2$.3$d", 1, 2)
<		    E1505: 无效的格式说明符：%1$d at width %2$d is:
		    %01$*2$.3$d

							*E1507*
		这个内部错误表明解析...
		位置格式参数时遇到了无法以其他方式报告的问题。
		如果你遇到这个问题，请向 Vim 提交一个 bug，
		复制使用的确切格式字符串和参数。

		参数：
		  • {fmt} (`string`) - 格式字符串
		  • {expr1} (`any?`) - 可选的第一个参数

		返回值：
		  (`string`) - 格式化后的字符串

prompt_getprompt({buf})                                     *prompt_getprompt()*
		返回缓冲区 {buf} 的有效提示文本。
		{buf} 可以是缓冲区名称或编号。参见 |prompt-buffer|。

		如果缓冲区不存在或不是提示缓冲区，则返回空字符串。

		参数：
		  • {buf} (`integer|string`) - 缓冲区标识符

		返回值：
		  (`any`) - 提示文本

prompt_setcallback({buf}, {expr})                         *prompt_setcallback()*
		将缓冲区 {buf} 的提示回调设置为 {expr}。
		当 {expr} 为空字符串时，回调被移除。
		这仅在 {buf} 的 'buftype' 设置为 "prompt" 时有效。

		当按下 Enter 时调用回调。
		当前缓冲区将始终是提示缓冲区。
		在调用回调之前会添加一个新的提示行，
		因此调用回调的提示将在倒数第二行。
		如果回调想要向缓冲区添加文本，
		它必须将其插入到最后一行之前，因为那是当前提示所在的位置。
		这也可以异步完成。
		回调使用一个参数调用，该参数是在提示处输入的文本。
		如果用户只按了 Enter，这可以是空字符串。
		示例：
>vim
		   func s:TextEntered(text)
		     if a:text == 'exit' || a:text == 'quit'
		       stopinsert
		       " 重置 'modified' 以允许关闭缓冲区。
		       " 我们假设没有有用的内容需要保存。
		       set nomodified
		       close
		     else
		       " 用 "a:text" 做一些有用的事情。在这个例子中
		       " 我们只是重复它。
		       call append(line('$') - 1, 'Entered: "' .. a:text .. '"')
		     endif
		   endfunc
		   call prompt_setcallback(bufnr(), function('s:TextEntered'))
<

		参数：
		  • {buf} (`integer|string`) - 缓冲区标识符
		  • {expr} (`string|function`) - 回调函数或表达式

		返回值：
		  (`any`) - 无

prompt_setinterrupt({buf}, {expr})                       *prompt_setinterrupt()*
		为缓冲区 {buf} 设置回调为 {expr}。
		当 {expr} 为空字符串时，回调被移除。
		这仅在 {buf} 的 'buftype' 设置为 "prompt" 时有效。

		当在插入模式下按 CTRL-C 时调用此回调。
		如果不设置回调，Vim 将退出插入模式，就像在任何缓冲区中一样。

		参数：
		  • {buf} (`integer|string`) - 缓冲区标识符
		  • {expr} (`string|function`) - 回调函数或表达式

		返回值：
		  (`any`) - 无

prompt_setprompt({buf}, {text})                             *prompt_setprompt()*
		将缓冲区 {buf} 的提示设置为 {text}。
		你很可能希望 {text} 以空格结尾。
		只有当 {buf} 的 'buftype' 设置为 "prompt" 时，结果才可见。
		示例：
>vim
			call prompt_setprompt(bufnr(''), 'command: ')
<

		参数：
		  • {buf} (`integer|string`) - 缓冲区标识符
		  • {text} (`string`) - 提示文本

		返回值：
		  (`any`) - 无

pum_getpos()                                                      *pum_getpos()*
		如果弹出菜单（参见 |ins-completion-menu|）不可见，
		返回空 |Dictionary|，否则返回包含以下键的 |Dictionary|：
			height		可见项目数
			width		屏幕单元格数
			row		顶部屏幕行（0 为第一行）
			col		最左侧屏幕列（0 为第一列）
			size		项目总数
			scrollbar	如果滚动条可见则为 |TRUE|

		这些值与 |CompleteChanged| 期间的 |v:event| 中的值相同。

		返回值：
		  (`any`) - 弹出菜单位置信息

pumvisible()                                                      *pumvisible()*
		当弹出菜单可见时返回非零值，否则返回零。
		参见 |ins-completion-menu|。
		这可用于避免一些会移除弹出菜单的操作。

		返回值：
		  (`any`) - 弹出菜单可见性

py3eval({expr})                                                      *py3eval()*
		计算 Python 表达式 {expr} 并返回其转换为 Vim 数据结构的结果。
		数字和字符串按原样返回（字符串会被复制，
		Unicode 字符串会额外转换为 UTF-8）。
		列表表示为 Vim |List| 类型。
		字典表示为 Vim |Dictionary| 类型，键转换为字符串。

		参数：
		  • {expr} (`any`) - Python 表达式

		返回值：
		  (`any`) - 转换后的 Vim 数据结构

pyeval({expr})                                              *pyeval()* *E858* *E859*
		计算 Python 表达式 {expr} 并返回其转换为 Vim 数据结构的结果。
		数字和字符串按原样返回（字符串会被复制）。
		列表表示为 Vim |List| 类型。
		字典表示为 Vim |Dictionary| 类型，非字符串键会导致错误。

		参数：
		  • {expr} (`any`) - Python 表达式

		返回值：
		  (`any`) - 转换后的 Vim 数据结构

pyxeval({expr})                                                      *pyxeval()*
		计算 Python 表达式 {expr} 并返回其转换为 Vim 数据结构的结果。
		使用 Python 2 或 3，参见 |python_x| 和 'pyxversion'。
		另请参阅：|pyeval()|、|py3eval()|

		参数：
		  • {expr} (`any`) - Python 表达式

		返回值：
		  (`any`) - 转换后的 Vim 数据结构

rand([{expr}])                                                          *rand()*
		返回使用 xoshiro128** 算法和种子 {expr} 生成的伪随机数。
		返回的数字是 32 位，在 64 位系统上也是如此，以保持一致性。
		{expr} 可以由 |srand()| 初始化，并将由 rand() 更新。
		如果省略 {expr}，则使用并更新内部种子值。
		如果 {expr} 无效，则返回 -1。

		示例：
>vim
			echo rand()
			let seed = srand()
			echo rand(seed)
			echo rand(seed) % 16  " 随机数 0 - 15
<

		参数：
		  • {expr} (`number?`) - 可选的种子值

		返回值：
		  (`any`) - 随机数

range({expr} [, {max} [, {stride}]])                         *range()* *E726* *E727*
		返回一个包含数字的 |List|：
		- 如果只指定 {expr}：[0, 1, ..., {expr} - 1]
		- 如果指定 {max}：[{expr}, {expr} + 1, ..., {max}]
		- 如果指定 {stride}：[{expr}, {expr} + {stride}, ...,
		  {max}]（每次将 {expr} 增加 {stride}，不产生超过 {max} 的值）。
		当最大值比起始值小 1 时，结果为空列表。
		当最大值比起始值小超过 1 时，这是一个错误。
		示例：
>vim
			echo range(4)		" [0, 1, 2, 3]
			echo range(2, 4)	" [2, 3, 4]
			echo range(2, 9, 3)	" [2, 5, 8]
			echo range(2, -2, -1)	" [2, 1, 0, -1, -2]
			echo range(0)		" []
			echo range(2, 0)	" 错误！
<

		参数：
		  • {expr} (`any`) - 起始值
		  • {max} (`integer?`) - 可选的结束值
		  • {stride} (`integer?`) - 可选的步长

		返回值：
		  (`any`) - 数字列表

readblob({fname} [, {offset} [, {size}]])                           *readblob()*
		以二进制模式读取文件 {fname} 并返回 |Blob|。
		如果指定 {offset}，则从指定偏移量开始读取文件。
		如果它是负值，则用作文件末尾的偏移量。
		例如，读取最后 12 个字节：
>vim
			echo readblob('file.bin', -12)
<		如果指定 {size}，则只读取指定大小。
		例如，读取文件的前 100 个字节：
>vim
			echo readblob('file.bin', 0, 100)
<		如果 {size} 为 -1 或省略，则读取从 {offset} 开始的所有数据。
		当 {size} 明确设置时，这也可以用于在 Unix 上从字符设备读取数据。
		只有当设备支持寻址时才能使用 {offset}。否则应该为零。
		例如，从串行控制台读取 10 个字节：
>vim
			echo readblob('/dev/ttyS0', 0, 10)
<		当无法打开文件时，会给出错误消息，结果为空 |Blob|。
		当偏移量超出文件末尾时，结果为空 blob。
		当尝试读取比可用字节更多的字节时，结果会被截断。
		另请参阅 |readfile()| 和 |writefile()|。

		参数：
		  • {fname} (`string`) - 文件名
		  • {offset} (`integer?`) - 可选的偏移量
		  • {size} (`integer?`) - 可选的大小

		返回值：
		  (`any`) - 二进制数据

readdir({directory} [, {expr}])                                      *readdir()*
		返回 {directory} 中的文件和目录名称列表。
		如果你不需要做复杂的事情，比如限制匹配数量，你也可以使用 |glob()|。
		当省略 {expr} 时，包含所有条目。
		当给出 {expr} 时，会对其进行评估以检查要做什么：
			如果 {expr} 结果为 -1，则不再处理更多条目。
			如果 {expr} 结果为 0，则此条目不会添加到列表中。
			如果 {expr} 结果为 1，则此条目会添加到列表中。
		每次评估 {expr} 时，|v:val| 被设置为条目名称。
		当 {expr} 是函数时，名称作为参数传递。
		例如，获取以 ".txt" 结尾的文件列表：
>vim
		  echo readdir(dirname, {n -> n =~ '.txt$'})
<		跳过隐藏文件和备份文件：
>vim
		  echo readdir(dirname, {n -> n !~ '^\.\|\~$'})

<		如果你想获取目录树：
>vim
		  function! s:tree(dir)
		      return {a:dir : map(readdir(a:dir),
		      \ {_, x -> isdirectory(x) ?
		      \          {x : s:tree(a:dir .. '/' .. x)} : x})}
		  endfunction
		  echo s:tree(".")
<
		出错时返回空列表。

		参数：
		  • {directory} (`string`) - 目录路径
		  • {expr} (`integer?`) - 可选的过滤表达式

		返回值：
		  (`any`) - 文件和目录名称列表

readfile({fname} [, {type} [, {max}]])                              *readfile()*
		读取文件 {fname} 并返回 |List|，文件的每一行作为一个项目。
		行在 NL 字符处断开。
		用 CR 分隔的 Macintosh 文件将导致单个长行
		（除非某处出现 NL）。
		所有 NUL 字符都被替换为 NL 字符。
		当 {type} 包含 "b" 时使用二进制模式：
		- 当最后一行以 NL 结尾时，添加一个额外的空列表项。
		- 不删除 CR 字符。
		否则：
		- 删除出现在 NL 之前的 CR 字符。
		- 最后一行是否以 NL 结尾并不重要。
		- 从文本中删除任何 UTF-8 字节顺序标记。
		当给出 {max} 时，这指定要读取的最大行数。
		如果你只想检查文件的前十行，这很有用：
>vim
			for line in readfile(fname, '', 10)
			  if line =~ 'Date' | echo line | endif
			endfor
<		当 {max} 为负数时，返回文件末尾的 -{max} 行，或尽可能多的行。
		当 {max} 为零时，结果为空列表。
		注意，如果没有 {max}，整个文件会被读入内存。
		还要注意，没有编码识别。如果需要，请将文件读入缓冲区。
		已弃用（使用 |readblob()| 代替）：当 {type} 包含
		"B" 时，返回一个包含文件二进制数据的 |Blob|，不做修改。
		当无法打开文件时，会给出错误消息，结果为空列表。
		另请参阅 |writefile()|。

		参数：
		  • {fname} (`string`) - 文件名
		  • {type} (`string?`) - 可选的类型
		  • {max} (`integer?`) - 可选的最大行数

		返回值：
		  (`any`) - 文件内容列表

reduce({object}, {func} [, {initial}])                           *reduce()* *E998*
		{func} 为 {object} 中的每个项目调用，{object} 可以是
		|String|、|List| 或 |Blob|。{func} 使用两个参数调用：
		目前为止的结果和当前项目。处理完所有项目后返回结果。

		{initial} 是初始结果。当省略时，使用 {object} 中的第一个项目，
		并且 {func} 首先为第二个项目调用。如果未给出 {initial} 且
		{object} 为空，则无法计算结果，会给出 E998 错误。

		示例：
>vim
			echo reduce([1, 3, 5], { acc, val -> acc + val })
			echo reduce(['x', 'y'], { acc, val -> acc .. val }, 'a')
			echo reduce(0z1122, { acc, val -> 2 * acc + val })
			echo reduce('xyz', { acc, val -> acc .. ',' .. val })
<

		参数：
		  • {object} (`any`) - 要处理的对象
		  • {func} (`fun(accumulator: T, current: any): any`) - 处理函数
		  • {initial} (`any?`) - 可选的初始值

		返回值：
		  (`T`) - 处理结果

reg_executing()                                                *reg_executing()*
reg_executing()                                                *reg_executing()*
		返回正在执行的寄存器的单字母名称。
		当没有寄存器正在执行时返回空字符串。
		参见 |@|。

		返回值：
		  (`any`)

reg_recorded()                                                  *reg_recorded()*
		返回最后记录的寄存器的单字母名称。
		当还没有记录任何内容时返回空字符串。
		参见 |q| 和 |Q|。

		返回值：
		  (`any`)

reg_recording()                                                *reg_recording()*
		返回正在记录的寄存器的单字母名称。
		当不在记录时返回空字符串。参见 |q|。

		返回值：
		  (`any`)

reltime()                                                            *reltime()*
reltime({start})
reltime({start}, {end})
		返回一个表示时间值的项目。该项目是一个列表，
		其内容取决于系统。
		该项目可以传递给 |reltimestr()| 转换为字符串，
		或传递给 |reltimefloat()| 转换为浮点数。

		不带参数时返回当前的"相对时间"，这是一个实现定义的值，
		仅当用作 |reltime()|、|reltimestr()| 和 |reltimefloat()| 的参数时才有意义。

		带一个参数时返回自参数指定的时间以来经过的时间。
		带两个参数时返回 {start} 和 {end} 之间经过的时间。

		{start} 和 {end} 参数必须是 reltime() 返回的值。
		出错时返回零。

		注意：|localtime()| 返回当前（非相对）时间。

		参数：
		  • {start} (`any?`)
		  • {end} (`any?`)

		返回值：
		  (`any`)
reltimefloat({time})                                            *reltimefloat()*
		返回一个表示 {time} 时间值的浮点数。
		时间单位为秒。
		示例：
			let start = reltime()
			call MyFunction()
			let seconds = reltimefloat(reltime(start))
		参见 reltimestr() 关于开销的说明。
		另见 |profiling|。
		如果出错则返回空字符串。

		参数：
		  • {time} (`any`)

		返回值：
		  (`any`)

reltimestr({time})                                                *reltimestr()*
		返回一个表示 {time} 时间值的字符串。
		这是秒数、一个小数点和微秒数。
		示例：
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
		注意命令的开销会被添加到时间中。
		使用前导空格使字符串对齐。可以使用 split() 移除它：
			echo split(reltimestr(reltime(start)))[0]
		另见 |profiling|。
		如果出错则返回空字符串。

		参数：
		  • {time} (`any`)

		返回值：
		  (`any`)

remove({list}, {idx})                                                 *remove()*
remove({list}, {idx}, {end})
		不带 {end}：从列表 {list} 中移除索引 {idx} 处的项目并返回该项目。
		带 {end}：移除从 {idx} 到 {end}（含）的项目并返回包含这些项目的列表。
		当 {idx} 指向与 {end} 相同的项目时，返回包含一个项目的列表。
		当 {end} 指向 {idx} 之前的项目时，这是一个错误。
		参见 |list-index| 了解 {idx} 和 {end} 的可能值。
		出错时返回零。
		示例：
			echo "last item: " .. remove(mylist, -1)
remove({blob}, {idx})
remove({blob}, {idx}, {end})
		不带 {end}：从 Blob {blob} 中移除索引 {idx} 处的字节并返回该字节。
		带 {end}：移除从 {idx} 到 {end}（含）的字节并返回包含这些字节的 Blob。
		当 {idx} 指向与 {end} 相同的字节时，返回包含一个字节的 Blob。
		当 {end} 指向 {idx} 之前的字节时，这是一个错误。
		出错时返回零。
		示例：
			echo "last byte: " .. remove(myblob, -1)
			call remove(mylist, 0, 9)

		参数：
		  • {blob} (`any`)
		  • {idx} (`integer`)
		  • {end} (`integer?`)

		返回值：
		  (`any`)

remove({dict}, {key})
		从字典 {dict} 中移除键为 {key} 的条目并返回它。
		示例：
			echo "removed " .. remove(dict, "one")
		如果 {dict} 中没有 {key}，这是一个错误。
		出错时返回零。

		参数：
		  • {dict} (`any`)
		  • {key} (`string`)

		返回值：
		  (`any`)

rename({from}, {to})                                                  *rename()*
		将名为 {from} 的文件重命名为 {to}。
		这应该也能用于跨文件系统移动文件。
		结果是一个数字，如果文件重命名成功则为 0，重命名失败则为非零。
		注意：如果 {to} 已存在，它会被覆盖而不发出警告。
		此函数在 |sandbox| 中不可用。

		参数：
		  • {from} (`string`)
		  • {to} (`string`)

		返回值：
		  (`integer`)

repeat({expr}, {count})                                               *repeat()*
		将 {expr} 重复 {count} 次并返回连接的结果。
		示例：
			let separator = repeat('-', 80)
		当 {count} 为零或负数时，结果为空。
		当 {expr} 是列表或 Blob 时，结果是 {expr} 连接 {count} 次。
		示例：
			let longlist = repeat(['a', 'b'], 3)
		结果为 ['a', 'b', 'a', 'b', 'a', 'b']。

		参数：
		  • {expr} (`any`)
		  • {count} (`integer`)

		返回值：
		  (`any`)

resolve({filename})                                             *resolve()* *E655*
		在 MS-Windows 上，当 {filename} 是快捷方式（.lnk 文件）时，
		返回快捷方式指向的路径的简化形式。
		在 Unix 上，重复解析 {filename} 所有路径组件中的符号链接，
		并返回简化结果。
		为了处理链接循环，符号链接的解析在 100 次迭代后停止。
		在其他系统上，返回简化的 {filename}。
		简化步骤与 |simplify()| 相同。
		resolve() 保留指定当前目录的前导路径组件
		（前提是结果仍然是相对路径名），
		并保留尾随路径分隔符。

		参数：
		  • {filename} (`string`)

		返回值：
		  (`string`)

reverse({object})                                                    *reverse()*
		反转 {object} 中项目的顺序。{object} 可以是列表、Blob 或字符串。
		对于列表和 Blob，项目在原地反转并返回 {object}。
		对于字符串，返回一个新的字符串。
		如果 {object} 不是列表、Blob 或字符串，则返回零。
		如果你希望列表或 Blob 保持不变，请先制作一个副本：
			let revlist = reverse(copy(mylist))

		参数：
		  • {object} (`T[]`)

		返回值：
		  (`T[]`)

round({expr})                                                          *round()*
		将 {expr} 四舍五入到最接近的整数值，并作为浮点数返回。
		如果 {expr} 位于两个整数值的中间，则使用较大的一个（远离零）。
		{expr} 必须求值为浮点数或数字。
		如果 {expr} 不是浮点数或数字，则返回 0.0。
		示例：
			echo round(0.456)
			0.0
			echo round(4.5)
			5.0
			echo round(-4.5)
			-5.0

		参数：
		  • {expr} (`number`)

		返回值：
		  (`number`)

rpcnotify({channel}, {event} [, {args}...])                        *rpcnotify()*
		通过 |RPC| 将 {event} 发送到 {channel} 并立即返回。
		如果 {channel} 为 0，则事件将广播到所有通道。
		示例：
			au VimLeave call rpcnotify(0, "leaving")

		参数：
		  • {channel} (`integer`)
		  • {event} (`string`)
		  • {...} (`any`)

		返回值：
		  (`integer`)
rpcrequest({channel}, {method} [, {args}...])                     *rpcrequest()*
		向 {channel} 发送请求以通过 |RPC| 调用 {method}，
		并阻塞直到收到响应。
		示例：
			let result = rpcrequest(rpc_chan, "func", 1, 2, 3)

		参数：
		  • {channel} (`integer`)
		  • {method} (`string`)
		  • {...} (`any`)

		返回值：
		  (`any`)

rubyeval({expr})                                                    *rubyeval()*
		评估 Ruby 表达式 {expr} 并返回其转换为 Vim 数据结构的结果。
		数字、浮点数和字符串按原样返回（字符串会被复制）。
		数组表示为 Vim 列表类型。
		哈希表示为 Vim 字典类型。
		其他对象表示为它们的 "Object#to_s" 方法产生的字符串。

		参数：
		  • {expr} (`any`)

		返回值：
		  (`any`)

screenattr({row}, {col})                                          *screenattr()*
		类似于 |screenchar()|，但返回属性。
		这是一个相当任意的数字，只能用于与其他位置的属性进行比较。
		当行或列超出范围时返回 -1。

		参数：
		  • {row} (`integer`)
		  • {col} (`integer`)

		返回值：
		  (`integer`)

screenchar({row}, {col})                                          *screenchar()*
		结果是一个数字，表示屏幕上位置 [row, col] 处的字符。
		这适用于每个可能的屏幕位置，包括状态行、窗口分隔符和命令行。
		左上角位置是第 1 行，第 1 列。
		字符不包括组合字符。对于双字节编码，它可能只是第一个字节。
		这主要用于测试。
		当行或列超出范围时返回 -1。

		参数：
		  • {row} (`integer`)
		  • {col} (`integer`)

		返回值：
		  (`integer`)

screenchars({row}, {col})                                        *screenchars()*
		结果是一个数字列表。第一个数字与 |screenchar()| 返回的相同。
		后续数字是基本字符上的组合字符。
		这主要用于测试。
		当行或列超出范围时返回空列表。

		参数：
		  • {row} (`integer`)
		  • {col} (`integer`)

		返回值：
		  (`integer[]`)

screencol()                                                        *screencol()*
		结果是一个数字，表示光标当前的屏幕列。最左边的列编号为 1。
		此函数主要用于测试。

		注意：始终返回当前的屏幕列，因此如果在命令中使用
		（例如 ":echo screencol()"），它将返回命令行内的列，
		当命令执行时为 1。要获取文件中光标的位置，请使用以下映射之一：
			nnoremap <expr> GG ":echom " .. screencol() .. "\n"
			nnoremap <silent> GG :echom screencol()<CR>
			noremap GG <Cmd>echom screencol()<CR>

		返回值：
		  (`integer[]`)

screenpos({winid}, {lnum}, {col})                                  *screenpos()*
		结果是一个字典，包含窗口 {winid} 中缓冲区行 {lnum} 和列 {col} 处
		文本字符的屏幕位置。{col} 是基于 1 的字节索引。
		字典包含以下成员：
			row	屏幕行
			col	第一个屏幕列
			endcol	最后一个屏幕列
			curscol	光标屏幕列
		如果指定的位置不可见，所有值都为零。
		当字符占据多个屏幕单元格时，"endcol" 值不同于 "col"。
		例如，对于制表符，"col" 可以是 1，"endcol" 可以是 8。
		"curscol" 值是光标将被放置的位置。对于制表符，
		它与 "endcol" 相同，而对于双宽度字符，它与 "col" 相同。
		这里忽略 |conceal| 特性，列号就像 'conceallevel' 为零一样。
		你可以将光标放在正确的位置并使用 |screencol()| 来获取考虑 |conceal| 的值。
		如果位置在关闭的折叠中，则返回第一个字符的屏幕位置，不使用 {col}。
		如果 {winid} 无效，则返回空字典。

		参数：
		  • {winid} (`integer`)
		  • {lnum} (`integer`)
		  • {col} (`integer`)

		返回值：
		  (`any`)

screenrow()                                                        *screenrow()*
		结果是一个数字，表示光标当前的屏幕行。顶部行编号为 1。
		此函数主要用于测试。
		或者你可以使用 |winline()|。

		注意：与 |screencol()| 相同的限制。

		返回值：
		  (`integer`)

screenstring({row}, {col})                                      *screenstring()*
		结果是一个字符串，包含屏幕上位置 [row, col] 处的基本字符和任何组合字符。
		这类似于 |screenchars()|，但返回包含字符的字符串。
		这主要用于测试。
		当行或列超出范围时返回空字符串。

		参数：
		  • {row} (`integer`)
		  • {col} (`integer`)

		返回值：
		  (`string`)

search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]]) *search()*
		搜索正则表达式模式 {pattern}。搜索从光标位置开始
		（你可以使用 |cursor()| 来设置它）。

		当找到匹配时，返回其行号。
		如果没有匹配，则返回 0 且光标不移动。不会给出错误消息。
		要获取匹配的字符串，请使用 |matchbufline()|。

		{flags} 是一个字符串，可以包含以下字符标志：
		'b'	向后搜索而不是向前
		'c'	接受光标位置的匹配
		'e'	移动到匹配的末尾
		'n'	不移动光标
		'p'	返回匹配的子模式数量（见下文）
		's'	在光标之前的位置设置 ' 标记
		'w'	在文件末尾环绕
		'W'	不在文件末尾环绕
		'z'	从光标列开始搜索而不是从零列开始
		如果既没有给出 'w' 也没有给出 'W'，则应用 'wrapscan' 选项。

		如果提供了 's' 标志，则只有在移动光标时才会设置 ' 标记。
		's' 标志不能与 'n' 标志组合使用。

		使用 'ignorecase'、'smartcase' 和 'magic'。

		当没有给出 'z' 标志时，向前搜索总是从第零列开始，
		然后跳过光标之前的匹配。当 'cpo' 中存在 'c' 标志时，
		下一次搜索从匹配之后开始。没有 'c' 标志时，
		下一次搜索从匹配开始后一列开始。这对于重叠匹配很重要。
		参见 |cpo-c|。你也可以插入 "\ze" 来改变匹配结束的位置，
		参见 |/\ze|。

		当向后搜索并给出 'z' 标志时，搜索从第零列开始，
		因此不会在当前行找到匹配（除非环绕到文件末尾）。

		当给出 {stopline} 参数时，搜索在搜索完该行后停止。
		这对于将搜索限制在行范围内很有用。示例：
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
		当使用 {stopline} 且它不为零时，这也意味着搜索不会环绕到文件末尾。
		零值等同于不给出参数。
		当给出 {timeout} 参数时，搜索在超过这么多毫秒后停止。
		因此，当 {timeout} 为 500 时，搜索在半秒后停止。
		该值不能为负数。零值等同于不给出参数。

		注意：超时仅在搜索时考虑，而不是在评估 {skip} 表达式时。

		如果给出 {skip} 表达式，则在光标位于匹配开始时评估它。
		如果评估为非零，则跳过此匹配。这可以用于，例如，
		跳过注释或字符串中的匹配。
		{skip} 可以是字符串（作为表达式评估）、函数引用或 lambda。
		当 {skip} 被省略或为空时，接受每个匹配。
		当评估 {skip} 导致错误时，搜索中止并返回 -1。

		使用 'p' 标志时，返回值比 \(\\) 中的第一个子匹配多 1。
		如果它们都没有匹配但整个模式匹配，则为 1。
		要同时获取列号，请使用 |searchpos()|。

		光标将定位在匹配处，除非使用 'n' 标志。

		示例（遍历参数列表中的所有文件）：
		    let n = 1
		    while n <= argc()	    " 遍历 arglist 中的所有文件
		      exe "argument " .. n
		      " 从文件的最后一个字符开始，并在第一次搜索时环绕
		      " 以找到文件开头的匹配
		      normal G$
		      let flags = "w"
		      while search("foo", flags) > 0
		        s/foo/bar/g
		        let flags = "W"
		      endwhile
		      update		    " 如果修改则写入文件
		      let n = n + 1
		    endwhile

		使用一些标志的示例：
		    echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
		这将搜索光标下或之后的 "if"、"else" 和 "endif" 关键字。
		由于 'p' 标志，它返回 1、2 或 3，取决于找到哪个关键字，
		如果搜索失败则返回 0。当光标在第一个单词上时。
		行：
		    if (foo == 0) | let foo = foo + 1 | endif ~
		函数返回 1。没有 'c' 标志时，函数找到 "endif" 并返回 3。
		如果没有 'e' 标志且光标在 "if" 的 "f" 上，也会发生同样的事情。
		'n' 标志告诉函数不要移动光标。

		参数：
		  • {pattern} (`string`)
		  • {flags} (`string?`)
		  • {stopline} (`integer?`)
		  • {timeout} (`integer?`)
		  • {skip} (`string|function?`)

		返回值：
		  (`integer`)

searchcount([{options}])                                         *searchcount()*
		获取或更新最后的搜索计数，就像在 'shortmess' 中没有 "S" 标志时显示的那样。
		即使 'shortmess' 包含 "S" 标志，这也有效。

		这返回一个字典。如果之前的模式未设置且未指定 "pattern"，则字典为空。

		  key		type		含义 ~
		  current	数字		匹配的当前位置；
						如果光标位置在第一个匹配之前则为 0
		  exact_match	布尔值		如果 "current" 在 "pos" 上匹配则为 1，否则为 0
		  total		数字		找到的匹配总数
		  incomplete	数字		0：搜索完全完成
						1：重新计算超时
						2：超过最大计数

		对于 {options} 见下文。

		要在按下 |n| 或 |N| 时获取最后的搜索计数，使用 `recompute: 0` 调用此函数。
		这有时会返回错误信息，因为 |n| 和 |N| 的最大计数是 99。
		如果超过 99，结果必须是最大计数 + 1（100）。
		如果你想获取正确信息，指定 `recompute: 1`：
			" 当有很多匹配时，result == maxcount + 1 (100)
			let result = searchcount(#{recompute: 0})

			" 下面返回正确结果（recompute 默认为 1）
			let result = searchcount()
		该函数对于将计数添加到 'statusline' 很有用：
			function! LastSearchCount() abort
			  let result = searchcount(#{recompute: 0})
			  if empty(result)
			    return ''
			  endif
			  if result.incomplete ==# 1     " 超时
			    return printf(' /%s [?/??]', @/)
			  elseif result.incomplete ==# 2 " 超过最大计数
			    if result.total > result.maxcount &&
			    \  result.current > result.maxcount
			      return printf(' /%s [>%d/>%d]', @/,
			      \             result.current, result.total)
			    elseif result.total > result.maxcount
			      return printf(' /%s [%d/>%d]', @/,
			      \             result.current, result.total)
			    endif
			  endif
			  return printf(' /%s [%d/%d]', @/,
			  \             result.current, result.total)
			endfunction
			let &statusline ..= '%{LastSearchCount()}'

			" 或者如果你只想在 'hlsearch' 开启时显示计数
			" let &statusline ..=
			" \   '%{v:hlsearch ? LastSearchCount() : ""}'

		你也可以更新搜索计数，这在 |CursorMoved| 或 |CursorMovedI| 自动命令中很有用：
			autocmd CursorMoved,CursorMovedI *
			  \ let s:searchcount_timer = timer_start(
			  \   200, function('s:update_searchcount'))
			function! s:update_searchcount(timer) abort
			  if a:timer ==# s:searchcount_timer
			    call searchcount(#{
			    \ recompute: 1, maxcount: 0, timeout: 100})
			    redrawstatus
			  endif
			endfunction

		这也可以用于使用 "pattern" 计算当前缓冲区中指定模式的匹配文本：
			" 计算此缓冲区中的 '\<foo\>'
			" （注意它也会更新搜索计数）
			let result = searchcount(#{pattern: '\<foo\>'})
			" 通过旧模式恢复旧的搜索计数，
			" 再次搜索
			call searchcount()

		{options} 必须是一个字典。它可以包含：
		  key		type		含义 ~
		  recompute	布尔值		如果为 |TRUE|，重新计算计数
						就像执行了 |n| 或 |N|。
						否则返回最后计算的结果
						（当 |n| 或 |N| 被使用且 'shortmess'
						中不包含 "S"，或调用此函数时）。
						（默认：|TRUE|）
		  pattern	字符串		如果给出且与 |@/| 不同，则重新计算。
						这等同于在执行此函数之前执行以下命令：
						  let @/ = pattern
						（默认：|@/|）
		  timeout	数字		0 或负数表示无超时。
						重新计算结果时的超时毫秒数
						（默认：0）
		  maxcount	数字		0 或负数表示无限制。
						重新计算结果时的最大匹配文本计数。
						如果搜索超过总计数，
						"total" 值变为 `maxcount + 1`
						（默认：0）
		  pos		列表		`[lnum, col, off]` 值
						重新计算结果时。
						这会改变 "current" 结果值。
						参见 |cursor()|、|getpos()|
						（默认：光标位置）

		参数：
		  • {options} (`table?`)

		返回值：
		  (`any`)

searchdecl({name} [, {global} [, {thisblock}]])                   *searchdecl()*
		搜索 {name} 的声明。

		使用非零的 {global} 参数时，它像 |gD| 一样工作，
		在文件中查找第一个匹配。否则它像 |gd| 一样工作，
		在函数中查找第一个匹配。
		使用非零的 {thisblock} 参数时，忽略在光标位置之前结束的 {} 块中的匹配。
		避免找到仅在另一个作用域中有效的变量声明。

		将光标移动到找到的匹配处。
		成功返回零，失败返回非零。
		示例：
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif

		参数：
		  • {name} (`string`)
		  • {global} (`boolean?`)
		  • {thisblock} (`boolean?`)

		返回值：
		  (`any`)

searchpair({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline} [, {timeout}]]]])
		搜索嵌套的开始-结束对的匹配。这可以用于查找与 "if" 匹配的 "endif"，
		同时忽略中间的其他 if/endif 对。
		搜索从光标开始。默认是向前搜索，在 {flags} 中包含 'b' 以向后搜索。
		如果找到匹配，光标定位在匹配处并返回行号。
		如果没有找到匹配，返回 0 或 -1 且光标不移动。不会给出错误消息。

		{start}、{middle} 和 {end} 是模式，参见 |pattern|。
		它们不能包含 \( \) 对。允许使用 \%( \)。
		当 {middle} 不为空时，从任一方向搜索时都会找到它，
		但只有在不在嵌套的开始-结束对中时。
		典型用法：
			echo searchpair('\<if\>', '\<else\>', '\<endif\>')
		通过将 {middle} 留空，跳过 "else"。

		{flags} 中的 'b'、'c'、'n'、's'、'w' 和 'W' 与 |search()| 相同。
		此外：
		'r'	重复直到找不到更多匹配；将找到最外层的对。隐含 'W' 标志。
		'm'	返回匹配数量而不是匹配的行号；当使用 'r' 时，将 > 1。
		注意：几乎总是使用 'W' 标志是个好主意，以避免环绕到文件末尾。
		当找到 {start}、{middle} 或 {end} 的匹配时，
		将光标定位在匹配的开始处评估 {skip} 表达式。
		如果此匹配应被跳过，它应返回非零。例如，因为它在注释或字符串内。
		当 {skip} 被省略或为空时，接受每个匹配。
		当评估 {skip} 导致错误时，搜索中止并返回 -1。
		{skip} 可以是字符串、lambda、函数引用或部分函数。
		其他任何内容都会使函数失败。

		对于 {stopline} 和 {timeout}，参见 |search()|。

		使用 'ignorecase' 的值。'magic' 被忽略，模式按原样使用。

		搜索从光标处开始。在搜索方向上，下一个字符处的
		{start}、{middle} 或 {end} 的匹配是找到的第一个匹配。
		示例：
			if 1
			  if 2
			  endif 2
			endif 1
		当从 "if 2" 开始，光标在 "i" 上，向前搜索时，找到 "endif 2"。
		当从 "if 2" 之前的字符开始时，将找到 "endif 1"。
		这是因为 "if 2" 会首先被找到，然后这被视为从 "if 2" 到 "endif 2" 的嵌套 if/endif。
		当向后搜索且 {end} 多于一个字符时，在模式末尾放置 "\zs" 可能有用，
		这样当光标在匹配的末尾内时，它会找到匹配的开始。

		示例，在 Vim 脚本中查找 "endif" 命令：
			echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

		光标必须位于要找到匹配的 "if" 处或之后。
		注意使用单引号字符串以避免必须加倍反斜杠。
		skip 表达式只捕获行首的注释，而不是命令后的注释。
		此外，行中间的单词 "en" 或 "if" 被视为匹配。
		另一个示例，搜索 "}" 的匹配 "{"：
			echo searchpair('{', '', '}', 'bW')

		这适用于光标位于要找到匹配的 "}" 处或之前时。
		要找到匹配。要拒绝语法高亮识别为字符串的匹配：
			echo searchpair('{', '', '}', 'bW',
			     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')

		参数：
		  • {start} (`string`)
		  • {middle} (`string`)
		  • {end} (`string`)
		  • {flags} (`string?`)
		  • {skip} (`string|function?`)
		  • {stopline} (`integer?`)
		  • {timeout} (`integer?`)

		返回值：
		  (`integer`)

searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline} [, {timeout}]]]])
		与 |searchpair()| 相同，但返回一个包含匹配的行和列位置的列表。
		列表的第一个元素是行号，第二个元素是匹配的列位置的字节索引。
		如果没有找到匹配，返回 [0, 0]：
			let [lnum,col] = searchpairpos('{', '', '}', 'n')

		参见 |match-parens| 获取更大且更有用的示例。

		参数：
		  • {start} (`string`)
		  • {middle} (`string`)
		  • {end} (`string`)
		  • {flags} (`string?`)
		  • {skip} (`string|function?`)
		  • {stopline} (`integer?`)
		  • {timeout} (`integer?`)

		返回值：
		  (`[integer, integer]`)

searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		与 |search()| 相同，但返回一个包含匹配的行和列位置的列表。
		列表的第一个元素是行号，第二个元素是匹配的列位置的字节索引。
		如果没有找到匹配，返回 [0, 0]。
		示例：
			let [lnum, col] = searchpos('mypattern', 'n')

		当给出 'p' 标志时，还有一个额外的项目包含子模式匹配号 |search()-sub-match|。
		示例：
			let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
		在这个示例中，当找到小写字母时 "submatch" 为 2 |/\l|，
		当找到大写字母时 "submatch" 为 3 |/\u|。

		参数：
		  • {pattern} (`string`)
		  • {flags} (`string?`)
		  • {stopline} (`integer?`)
		  • {timeout} (`integer?`)
		  • {skip} (`string|function?`)

		返回值：
		  (`any`)

serverlist()                                                      *serverlist()*
		返回服务器地址列表，如果所有服务器都已停止则返回空列表。
		|serverstart()| |serverstop()|
		示例：
			echo serverlist()

		返回值：
		  (`string[]`)

serverstart([{address}])                                         *serverstart()*
		在 {address} 打开一个套接字或命名管道并监听 |RPC| 消息。
		客户端可以向返回的地址发送 |API| 命令来控制 Nvim。

		返回地址字符串（可能与 {address} 参数不同，见下文）。

		- 如果 {address} 包含冒号（":"），它是一个 TCP/IPv4/IPv6 地址，
		  其中最后一个 ":" 分隔主机和端口（空或零分配随机端口）。
		- 否则 {address} 是命名管道的路径（Windows 除外）。
		  - 如果 {address} 没有斜杠（"/"），它被视为生成路径的 "name" 部分，
		    格式如下：
			stdpath("run").."/{name}.{pid}.{counter}"
		  - 如果 {address} 被省略，名称为 "nvim"：
			echo serverstart()
			=> /tmp/nvim.bram/oknANW/nvim.15430.5

		列出所有 Nvim 服务器的示例 bash 命令：
			ls ${XDG_RUNTIME_DIR:-${TMPDIR}nvim.${USER}}/*/nvim.*.0

		命名管道示例：
			if has('win32')
			  echo serverstart('\\.\pipe\nvim-pipe-1234')
			else
			  echo serverstart('nvim.sock')
			endif

		TCP/IP 地址示例：
			echo serverstart('::1:12345')

		参数：
		  • {address} (`string?`)

		返回值：
		  (`string`)

serverstop({address})                                             *serverstop()*
		关闭 {address} 处的管道或套接字。
		如果 {address} 有效则返回 TRUE，否则返回 FALSE。
		如果 |v:servername| 被停止，它被设置为 |serverlist()| 中的下一个可用地址。

		参数：
		  • {address} (`string`)

		返回值：
		  (`integer`)

setbufline({buf}, {lnum}, {text})                                 *setbufline()*
		在缓冲区 {buf} 中将行 {lnum} 设置为 {text}。
		这类似于对指定缓冲区使用 |setline()|。

		此函数仅适用于已加载的缓冲区。如果需要，首先调用 |bufload()|。

		要插入行，请使用 |appendbufline()|。

		{text} 可以是一个字符串来设置一行，或一个字符串列表来设置多行。
		如果列表延伸到最后一行之后，则添加这些行。
		如果列表为空，则不进行任何更改并返回零。

		对于 {buf} 的使用，请参见上面的 |bufname()|。

		{lnum} 的使用方式与 |setline()| 相同。
		使用 "$" 来引用缓冲区 {buf} 中的最后一行。
		当 {lnum} 刚好在最后一行之后时，{text} 将被
		添加到最后一行之后。
		成功返回 0，失败返回 1。

		如果 {buf} 不是有效的缓冲区或 {lnum} 无效，将给出错误消息。

		参数：
		  • {buf} (`integer|string`)
		  • {lnum} (`integer`)
		  • {text} (`string|string[]`)

		返回值：
		  (`integer`)

setbufvar({buf}, {varname}, {val})                                 *setbufvar()*
		在缓冲区 {buf} 中将选项或局部变量 {varname} 设置为 {val}。
		这也适用于全局或局部窗口选项，但不适用于全局或局部窗口变量。
		对于局部窗口选项，全局值不变。
		对于 {buf} 的使用，请参见上面的 |bufname()|。
		{varname} 参数是一个字符串。
		注意必须使用不带 "b:" 的变量名。
		示例：
			call setbufvar(1, "&mod", 1)
			call setbufvar("todo", "myvar", "foobar")
		此函数在 |sandbox| 中不可用。

		参数：
		  • {buf} (`integer|string`)
		  • {varname} (`string`)
		  • {val} (`any`)

		返回值：
		  (`any`)

setcellwidths({list})                                          *setcellwidths()*
		指定字符范围的单元格宽度覆盖。这告诉 Vim 在终端中显示时字符有多宽，
		以屏幕单元格计数。这些值覆盖 'ambiwidth'。
		示例：
		   call setcellwidths([
				\ [0x111, 0x111, 1],
				\ [0x2194, 0x2199, 2],
				\ ])

		{list} 参数是一个包含三个数字的列表的列表：[{low}, {high}, {width}]。
		{low} 和 {high} 可以相同，在这种情况下这指的是一个字符。
		否则它是从
		{low} 到 {high}（含）的字符范围。
		只能使用值 0x80 及以上的字符。

		{width} 必须是 1 或 2，表示屏幕单元格中的字符宽度。
		如果参数无效，或者范围与另一个重叠，将给出错误。

		如果新值导致 'fillchars' 或 'listchars' 变得无效，
		它将被拒绝并给出错误。

		要清除覆盖，传递一个空的 {list}：
		   call setcellwidths([])

		你可以使用脚本 $VIMRUNTIME/scripts/emoji_list.lua 来查看
		已知表情符号字符的效果。移动光标通过文本来检查
		你的终端的单元格宽度是否与 Vim 对每个表情符号的了解匹配。
		如果看起来不对，你需要调整 {list} 参数。

		参数：
		  • {list} (`any[]`)

		返回值：
		  (`any`)

setcharpos({expr}, {list})                                        *setcharpos()*
		与 |setpos()| 相同，但使用指定的列号作为字符索引，
		而不是行中的字节索引。

		示例：
		在第 8 行有文本 "여보세요"：
			call setcharpos('.', [0, 8, 4, 0])
		将光标定位在第四个字符 '요' 上。
			call setpos('.', [0, 8, 4, 0])
		将光标定位在第二个字符 '보' 上。

		参数：
		  • {expr} (`string`)
		  • {list} (`integer[]`)

		返回值：
		  (`any`)

setcharsearch({dict})                                          *setcharsearch()*
		将当前字符搜索信息设置为 {dict}，它包含以下一个或多个条目：

		    char	将用于后续 |,| 或 |;| 命令的字符；
				空字符串清除
			字符搜索
		    forward	字符搜索的方向；1 表示向前，0 表示向后
		    until	字符搜索的类型；1 表示 |t| 或 |T| 字符搜索，
				0 表示 |f| 或 |F| 字符搜索

		这对于从脚本中保存/恢复用户的字符搜索很有用：
			let prevsearch = getcharsearch()
			" 执行一个会破坏用户搜索的命令
			call setcharsearch(prevsearch)
		另见 |getcharsearch()|。

		参数：
		  • {dict} (`string`)

		返回值：
		  (`any`)

setcmdline({str} [, {pos}])                                       *setcmdline()*
		将命令行设置为 {str} 并将光标位置设置为 {pos}。
		如果 {pos} 被省略，光标定位在文本之后。
		成功时返回 0，不在编辑命令行时返回 1。

		参数：
		  • {str} (`string`)
		  • {pos} (`integer?`)

		返回值：
		  (`integer`)

setcmdpos({pos})                                                   *setcmdpos()*
		将命令行中的光标位置设置为字节位置 {pos}。第一个位置是 1。
		使用 |getcmdpos()| 获取当前位置。
		仅在编辑命令行时有效，因此你必须使用 |c_CTRL-\_e|、
		|c_CTRL-R_=| 或 |c_CTRL-R_CTRL-R| 与 '='。
		对于 |c_CTRL-\_e| 和 |c_CTRL-R_CTRL-R| 与 '='，
		位置在命令行设置为表达式后设置。
		对于 |c_CTRL-R_=|，它在评估表达式后但在插入结果文本之前设置。
		当数字太大时，光标放在行尾。小于 1 的数字有未定义的结果。
		成功时返回 0，不在编辑命令行时返回 1。

		参数：
		  • {pos} (`integer`)

		返回值：
		  (`any`)

setcursorcharpos({lnum}, {col} [, {off}])                   *setcursorcharpos()*
setcursorcharpos({list})
		与 |cursor()| 相同，但使用指定的列号作为字符索引，
		而不是行中的字节索引。

		示例：
		在第 4 行有文本 "여보세요"：
			call setcursorcharpos(4, 3)
		将光标定位在第三个字符 '세' 上。
			call cursor(4, 3)
		将光标定位在第一个字符 '여' 上。

		参数：
		  • {list} (`integer[]`)

		返回值：
		  (`any`)

setenv({name}, {val})                                                 *setenv()*
		将环境变量 {name} 设置为 {val}。
		示例：
			call setenv('HOME', '/home/myhome')

		当 {val} 为 |v:null| 时，环境变量被删除。
		另见 |expr-env|。

		参数：
		  • {name} (`string`)
		  • {val} (`string`)

		返回值：
		  (`any`)

setfperm({fname}, {mode})                                     *setfperm()* *chmod*
		将文件 {fname} 的权限设置为 {mode}。
		{mode} 必须是一个包含 9 个字符的字符串。
		它的形式为 "rwxrwxrwx"，其中每组 "rwx" 标志依次表示
		文件所有者、文件所属组和其他用户的权限。
		'-' 字符表示权限关闭，任何其他字符表示开启。
		不支持多字节字符。

		例如 "rw-r-----" 表示用户可读写，组可读，其他人不可访问。
		"xx-x-----" 会做同样的事情。
		成功返回非零，失败返回零。

		要读取权限，请参见 |getfperm()|。

		参数：
		  • {fname} (`string`)
		  • {mode} (`string`)

		返回值：
		  (`any`)

setline({lnum}, {text})                                              *setline()*
		将当前缓冲区的第 {lnum} 行设置为 {text}。
		要插入行，请使用 |append()|。
		要在另一个缓冲区中设置行，请使用 |setbufline()|。

		{lnum} 的使用方式与 |getline()| 相同。
		当 {lnum} 刚好在最后一行之后时，{text} 将被添加到最后一行之后。
		{text} 可以是任何类型或任何类型的列表，每个项目都被转换为字符串。
		当 {text} 是空列表时，不进行任何更改并返回 FALSE。

		如果成功，返回 FALSE。如果失败（很可能是因为 {lnum} 无效），返回 TRUE。

		示例：
			call setline(5, strftime("%c"))

		当 {text} 是列表时，第 {lnum} 行及后续行将被设置为列表中的项目。
		示例：
			call setline(5, ['aaa', 'bbb', 'ccc'])
		这等同于：
			for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			  call setline(n, l)
			endfor

		注意：'[ 和 '] 标记不会被设置。

		参数：
		  • {lnum} (`integer|string`)
		  • {text} (`any`)

		返回值：
		  (`any`)

setloclist({nr}, {list} [, {action} [, {what}]])                  *setloclist()*
		为窗口 {nr} 创建、替换或添加到位置列表。
		{nr} 可以是窗口编号或 |window-ID|。
		当 {nr} 为零时使用当前窗口。
		对于位置列表窗口，修改显示的位置列表。
		对于无效的窗口编号 {nr}，返回 -1。
		否则，与 |setqflist()| 相同。
		另见 |location-list|。

		对于 {action}，参见 |setqflist-action|。

		如果提供了可选的 {what} 字典参数，则只设置 {what} 中列出的项目。
		有关 {what} 中支持的键的列表，请参见 |setqflist()|。

		参数：
		  • {nr} (`integer`)
		  • {list} (`any`)
		  • {action} (`string?`)
		  • {what} (`table?`)

		返回值：
		  (`any`)

setmatches({list} [, {win}])                                      *setmatches()*
		为当前窗口恢复由 |getmatches()| 保存的匹配列表。
		如果成功返回 0，否则返回 -1。
		在恢复列表之前清除所有当前匹配。
		参见 |getmatches()| 的示例。
		如果指定了 {win}，则使用具有此编号或窗口 ID 的窗口，
		而不是当前窗口。

		参数：
		  • {list} (`any`)
		  • {win} (`integer?`)

		返回值：
		  (`any`)

setpos({expr}, {list})                                                *setpos()*
		设置字符串 {expr} 的位置。可能的值：
			.	光标
			'x	标记 x

		{list} 必须是一个包含四个或五个数字的列表：
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		"bufnum" 是缓冲区编号。零可用于当前缓冲区。
		当设置大写标记时，"bufnum" 用于标记位置。
		对于其他标记，它指定要设置标记的缓冲区。
		你可以使用 |bufnr()| 函数将文件名转换为缓冲区编号。
		对于设置光标和 ' 标记，"bufnum" 被忽略，因为这些与窗口关联，而不是缓冲区。
		不改变跳转列表。

		"lnum" 和 "col" 是缓冲区中的位置。第一列是 1。
		使用零 "lnum" 来删除标记。如果 "col" 小于 1，则使用 1。
		要使用字符计数而不是字节计数，请使用 |setcharpos()|。

		"off" 数字仅在设置 'virtualedit' 时使用。
		然后它是从字符开始的屏幕列偏移量。
		例如，<Tab> 内的位置或最后一个字符之后的位置。

		"curswant" 数字仅在设置光标位置时使用。
		它设置垂直移动光标时的首选列。
		当 "curswant" 数字缺失时，不设置首选列。
		当它存在且设置标记位置时，它不被使用。

		注意，对于 '< 和 '>，更改行号可能导致标记被有效地交换，
		因此 '< 总是在 '> 之前。

		当位置可以设置时返回 0，否则返回 -1。
		如果 {expr} 无效，将给出错误消息。

		另见 |setcharpos()|、|getpos()| 和 |getcurpos()|。

		这不恢复垂直移动的首选列；
		如果你用这个设置光标位置，|j| 和 |k| 移动将跳到之前的列！
		使用 |cursor()| 也设置首选列。另见 |winrestview()| 中的 "curswant" 键。

		参数：
		  • {expr} (`string`)
		  • {list} (`integer[]`)

		返回值：
		  (`any`)

setqflist({list} [, {action} [, {what}]])                          *setqflist()*
		创建、替换或添加到快速修复列表。

		如果提供了可选的 {what} 字典参数，则只设置 {what} 中列出的项目。
		第一个 {list} 参数被忽略。有关 {what} 中支持的项目，请参见下文。
		当 {what} 不存在时，使用 {list} 中的项目。
		每个项目必须是一个字典。{list} 中的非字典项目被忽略。
		每个字典项目可以包含以下条目：

		    bufnr	缓冲区编号；必须是有效缓冲区的编号
		    filename	文件名；仅在 "bufnr" 不存在或无效时使用
		    module	模块名；如果给出，它将在快速修复错误窗口中
				使用，而不是文件名
		    lnum	文件中的行号
		    end_lnum	行的结束，如果项目跨越多行
		    pattern	用于定位错误的搜索模式
		    col		列号
		    vcol	当非零时："col" 是可视列
				当为零时："col" 是字节索引
		    end_col	结束列，如果项目跨越多列
		    nr		错误编号
		    text	错误描述
		    type	单字符错误类型，'E'、'W' 等
		    valid	识别的错误消息
		    user_data
				与项目关联的自定义数据，可以是任何类型

		"col"、"vcol"、"nr"、"type" 和 "text" 条目是可选的。
		可以使用 "lnum" 或 "pattern" 条目来定位匹配的错误行。
		如果 "filename" 和 "bufnr" 条目不存在，或者 "lnum" 或 "pattern" 条目
		都不存在，则该项目不会被处理为错误行。
		如果 "pattern" 和 "lnum" 都存在，则使用 "pattern"。
		如果 "valid" 条目未提供，则当 "bufnr" 是有效缓冲区或 "filename" 存在时
		设置有效标志。
		如果你提供一个空的 {list}，快速修复列表将被清除。
		注意，列表与 |getqflist()| 返回的不完全相同。

		{action} 值：
		'a'	将 {list} 中的项目添加到现有的快速修复列表。
			如果没有现有列表，则创建新列表。

		'r'	用 {list} 中的项目替换当前快速修复列表中的项目。
			这也可以用于清除列表：
				call setqflist([], 'r')
		'u'	类似于 'r'，但尝试保留快速修复列表中的当前选择。
		'f'	释放快速修复堆栈中的所有快速修复列表。

		如果 {action} 不存在或设置为 ' '，则创建新列表。
		新的快速修复列表被添加到当前快速修复列表之后的堆栈中，
		并且所有后续列表都被释放。
		要在堆栈末尾添加新的快速修复列表，在 {what} 中将 "nr" 设置为 "$"。

		可以在字典 {what} 中指定以下项目：
		    context	快速修复列表上下文。参见 |quickfix-context|
		    efm		在解析 "lines" 中的文本时使用的 errorformat。
				如果不存在，则使用 'errorformat' 选项值。
				参见 |quickfix-parse|
		    id		快速修复列表标识符 |quickfix-ID|
		    idx		由 "id" 或 "nr" 指定的快速修复列表中当前条目的索引。
				如果设置为 '$'，则将列表中的最后一个条目设置为当前条目。
				参见 |quickfix-index|
		    items	快速修复条目列表。与 {list} 参数相同。
		    lines	使用 'errorformat' 解析行列表并将结果条目添加到
				快速修复列表 {nr} 或 {id}。仅支持 |List| 值。
				参见 |quickfix-parse|
		    nr		快速修复堆栈中的列表编号；零表示当前快速修复列表，
				"$" 表示最后一个快速修复列表。
		    quickfixtextfunc
				获取要在快速修复窗口中显示的文本的函数。
				值可以是函数名、函数引用或 lambda。
				有关如何编写函数和示例的说明，请参见
				|quickfix-window-function|。
		    title	快速修复列表标题文本。参见 |quickfix-title|
		{what} 中不支持的键被忽略。
		如果 "nr" 项目不存在，则修改当前快速修复列表。
		创建新的快速修复列表时，"nr" 可以设置为比快速修复堆栈大小大 1 的值。
		修改快速修复列表时，为了确保修改正确的列表，
		应使用 "id" 而不是 "nr" 来指定列表。

		示例（另见 |setqflist-examples|）：
		   call setqflist([], 'r', {'title': 'My search'})
		   call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
````text
		   call setqflist([], 'r', {'title': 'My search'})
		   call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
```

???????????????????9101
		'u'	类似于 'r'，但尝试保留快速修复列表中的当前选择。
		'f'	释放快速修复堆栈中的所有快速修复列表。

		如果 {action} 不存在或设置为 ' '，则创建新列表。
		新的快速修复列表被添加到当前快速修复列表之后的堆栈中，
		并且所有后续列表都被释放。
		要在堆栈末尾添加新的快速修复列表，在 {what} 中将 "nr" 设置为 "$"。

		可以在字典 {what} 中指定以下项目：
		    context	快速修复列表上下文。参见 |quickfix-context|
		    efm		在解析 "lines" 中的文本时使用的 errorformat。
				如果不存在，则使用 'errorformat' 选项值。
				参见 |quickfix-parse|
		    id		快速修复列表标识符 |quickfix-ID|
		    idx		由 "id" 或 "nr" 指定的快速修复列表中当前条目的索引。
				如果设置为 '$'，则将列表中的最后一个条目设置为当前条目。
				参见 |quickfix-index|
		    items	快速修复条目列表。与 {list} 参数相同。
		    lines	使用 'errorformat' 解析行列表并将结果条目添加到
				快速修复列表 {nr} 或 {id}。仅支持 |List| 值。
				参见 |quickfix-parse|
		    nr		快速修复堆栈中的列表编号；零表示当前快速修复列表，
				"$" 表示最后一个快速修复列表。
		    quickfixtextfunc
				获取要在快速修复窗口中显示的文本的函数。
				值可以是函数名、函数引用或 lambda。
				有关如何编写函数和示例的说明，请参见
				|quickfix-window-function|。
		    title	快速修复列表标题文本。参见 |quickfix-title|
		{what} 中不支持的键被忽略。
		如果 "nr" 项目不存在，则修改当前快速修复列表。
		创建新的快速修复列表时，"nr" 可以设置为比快速修复堆栈大小大 1 的值。
		修改快速修复列表时，为了确保修改正确的列表，
		应使用 "id" 而不是 "nr" 来指定列表。

		示例（另见 |setqflist-examples|）：
		   call setqflist([], 'r', {'title': 'My search'})
		   call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
		   call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})

		成功返回 0，失败返回 -1。

		此函数可用于创建独立于 'errorformat' 设置的快速修复列表。
		使用类似 `:cc 1` 的命令跳转到第一个位置。

                参数： ~
                  • {list} (`vim.quickfix.entry[]`)
                  • {action} (`string?`)
                  • {what} (`vim.fn.setqflist.what?`)

                返回值： ~
                  (`integer`)

setreg({regname}, {value} [, {options}])                              *setreg()*
		设置寄存器 {regname} 为 {value}。
		如果 {regname} 是 "" 或 "@"，则使用未命名寄存器 '"'。
		{regname} 参数是一个字符串。

		{value} 可以是 |getreg()| 或 |getreginfo()| 返回的任何值，
		包括 |List| 或 |Dict|。
		如果 {options} 包含 "a" 或 {regname} 是大写字母，
		则值会被追加。

		{options} 还可以包含寄存器类型规范：
		    "c" 或 "v"	      |charwise| 模式
		    "l" 或 "V"	      |linewise| 模式
		    "b" 或 "<CTRL-V>" |blockwise-visual| 模式
		如果 "b" 或 "<CTRL-V>" 后面紧跟着一个数字，则这被用作
		选择的宽度 - 如果未指定，则块的宽度被设置为最长行中的
		字符数（将 <Tab> 计为 1 个字符）。
		如果 {options} 包含 "u" 或 '"'，则未命名寄存器被设置为
		指向寄存器 {regname}。

		如果 {options} 不包含寄存器设置，则默认使用字符模式，
		除非 {value} 以 <NL> 结尾（对于字符串 {value}）和
		行模式（对于列表 {value}）。块模式永远不会自动选择。
		成功返回 0，失败返回非零值。

							*E883*
		注意：不能使用包含多个项目的 |List| 来设置搜索和表达式寄存器。
		      不包含项目的列表的行为类似于空字符串。

		示例： >vim
			call setreg(v:register, @*)
			call setreg('*', @%, 'ac')
			call setreg('a', "1\n2\n3", 'b5')
			call setreg('"', { 'points_to': 'a'})

		此示例显示如何使用函数保存和恢复寄存器： >vim
			let var_a = getreginfo()
			call setreg('a', var_a)
		或： >vim
			let var_a = getreg('a', 1, 1)
			let var_amode = getregtype('a')
			" ....
			call setreg('a', var_a, var_amode)
		注意：如果不使用 |getreg()| 的第三个参数，可能无法可靠地
		恢复寄存器值，因为没有它，换行符被表示为换行符，而 Nul 字节
		也被表示为换行符，参见 |NL-used-for-Nul|。

		也可以通过追加空值来更改寄存器的类型： >vim
			call setreg('a', '', 'al')

                参数： ~
                  • {regname} (`string`)
                  • {value} (`any`)
                  • {options} (`string?`)

                返回值： ~
                  (`any`)

settabvar({tabnr}, {varname}, {val})                               *settabvar()*
		在标签页 {tabnr} 中设置标签页局部变量 {varname} 为 {val}。
		|t:var|
		{varname} 参数是一个字符串。
		注意变量名不能包含 "t:"。
		标签页从 1 开始编号。
		此函数在 |sandbox| 中不可用。

                参数： ~
                  • {tabnr} (`integer`)
                  • {varname} (`string`)
                  • {val} (`any`)

                返回值： ~
                  (`any`)

settabwinvar({tabnr}, {winnr}, {varname}, {val})                *settabwinvar()*
		在窗口 {winnr} 中设置选项或局部变量 {varname} 为 {val}。
		标签页从 1 开始编号。对于当前标签页使用 |setwinvar()|。
		{winnr} 可以是窗口编号或 |window-ID|。
		当 {winnr} 为零时使用当前窗口。
		这也适用于全局或局部缓冲区选项，但不适用于全局或局部缓冲区变量。
		对于局部缓冲区选项，全局值保持不变。
		注意变量名不能包含 "w:"。
		示例： >vim
			call settabwinvar(1, 1, "&list", 0)
			call settabwinvar(3, 2, "myvar", "foobar")
		此函数在 |sandbox| 中不可用。

                参数： ~
                  • {tabnr} (`integer`)
                  • {winnr} (`integer`)
                  • {varname} (`string`)
                  • {val} (`any`)

                返回值： ~
                  (`any`)

settagstack({nr}, {dict} [, {action}])                           *settagstack()*
		使用 {dict} 修改窗口 {nr} 的标签堆栈。
		{nr} 可以是窗口编号或 |window-ID|。

		有关 {dict} 中支持的项目列表，请参阅 |gettagstack()|。
		"curidx" 在更改标签堆栈之前生效。
							*E962*
		标签堆栈的修改方式取决于 {action} 参数：
		- 如果 {action} 不存在或设置为 'r'，则替换标签堆栈。
		- 如果 {action} 设置为 'a'，则将 {dict} 中的新条目推入（添加）到标签堆栈。
		- 如果 {action} 设置为 't'，则从标签堆栈中的当前条目或 {dict} 中的 "curidx" 开始
		  删除所有条目，然后将新条目推入堆栈。

		修改后，当前索引被设置为标签堆栈长度加一。

		成功返回 0，失败返回 -1。

		示例（更多示例参见 |tagstack-examples|）：
		    清空窗口 3 的标签堆栈： >vim
			call settagstack(3, {'items' : []})

		    保存和恢复标签堆栈： >vim
			let stack = gettagstack(1003)
			" 做其他事情
			call settagstack(1003, stack)
			unlet stack

                参数： ~
                  • {nr} (`integer`)
                  • {dict} (`any`)
                  • {action} (`string?`)

                返回值： ~
                  (`any`)

setwinvar({nr}, {varname}, {val})                                  *setwinvar()*
		类似于当前标签页的 |settabwinvar()|。
		示例： >vim
			call setwinvar(1, "&list", 0)
			call setwinvar(2, "myvar", "foobar")

                参数： ~
                  • {nr} (`integer`)
                  • {varname} (`string`)
                  • {val} (`any`)

                返回值： ~
                  (`any`)

sha256({string})                                                      *sha256()*
		返回一个包含 64 个十六进制字符的字符串，这是 {string} 的 SHA256 校验和。

                参数： ~
                  • {string} (`string`)

                返回值： ~
                  (`string`)

shellescape({string} [, {special}])                              *shellescape()*
		转义 {string} 以用作 shell 命令参数。

		在 Windows 上，当 'shellslash' 未设置时，用双引号括住 {string} 并
		将 {string} 中的所有双引号加倍。
		否则用单引号括住 {string} 并将所有 "'" 替换为 "'\''"。

		{special} 参数添加了对 Vim 命令中使用的关键字的额外转义。
		如果它是一个 |non-zero-arg|：
		- 特殊项目如 "!"、"%"、"#" 和 "<cword>"（如 |expand()| 中列出的）
		  将前面加上反斜杠。
		  反斜杠将被 |:!| 命令再次移除。
		- <NL> 字符被转义。

		如果 'shell' 尾部包含 "csh"：
		- "!" 字符将被转义。这是因为 csh 和 tcsh 即使在单引号中也使用 "!"
		  进行历史替换。
		- <NL> 字符被转义（如果 {special} 是 |non-zero-arg|，则转义两次）。

		如果 'shell' 尾部包含 "fish"，则 "\" 字符将被转义，因为在 fish 中
		它在单引号内用作转义字符。

		与 |:!| 命令一起使用的示例： >vim
		    exe '!dir ' .. shellescape(expand('<cfile>'), 1)
		这将列出光标下文件的目录。与 |system()| 一起使用的示例： >vim
		    call system("chmod +w -- " .. shellescape(expand("%")))
		另见 |::S|。

                参数： ~
                  • {string} (`string`)
                  • {special} (`boolean?`)

                返回值： ~
                  (`string`)

shiftwidth([{col}])                                               *shiftwidth()*
		返回 'shiftwidth' 的有效值。这是 'shiftwidth' 值，除非它是零，
		在这种情况下它是 'tabstop' 值。为了在缩进插件中向后兼容，使用这个：
		>vim
			if exists('*shiftwidth')
			  func s:sw()
			    return shiftwidth()
			  endfunc
			else
			  func s:sw()
			    return &sw
			  endfunc
			endif
		然后使用 s:sw() 而不是 &sw。

		当有一个参数 {col} 时，这被用作要返回 'shiftwidth' 值的列号。
		这对于 'vartabstop' 特性很重要。如果没有给出 {col} 参数，
		将假设为第 1 列。

                参数： ~
                  • {col} (`integer?`)
                返回值： ~
                  (`integer`)

sign_define({name} [, {dict}])                                   *sign_define()*
sign_define({list})
		定义一个新的名为 {name} 的标记或修改现有标记的属性。
		这类似于 |:sign-define| 命令。

		在 {name} 前加上唯一文本以避免名称冲突。
		没有像放置标记那样的 {group}。

		{name} 可以是字符串或数字。可选的 {dict} 参数指定标记属性。
		支持以下值：
		   icon		标记位图文件的完整路径。
		   linehl	用于标记所在整行的突出显示组。
		   priority	标记的默认优先级值
		   numhl	用于标记所在行号的突出显示组。
		   text		当没有图标或未使用 GUI 时显示的文本。
		   texthl	用于文本项的突出显示组
		   culhl	当光标与标记在同一行且启用了 'cursorline' 时
				用于文本项的突出显示组。

		如果名为 {name} 的标记已存在，则更新标记的属性。

		一个参数的 {list} 可用于定义标记列表。
		每个列表项是一个字典，包含 {dict} 中的上述项和一个用于标记名称的 "name" 项。

		成功返回 0，失败返回 -1。当使用一个参数的 {list} 时，
		返回一个列表，每个定义的标记对应一个值。

		示例： >vim
			call sign_define("mySign", {
				\ "text" : "=>",
				\ "texthl" : "Error",
				\ "linehl" : "Search"})
			call sign_define([
				\ {'name' : 'sign1',
				\  'text' : '=>'},
				\ {'name' : 'sign2',
				\  'text' : '!!'}
				\ ])
                参数： ~
                  • {list} (`vim.fn.sign_define.dict[]`)

                返回值： ~
                  (`(0|-1)[]`)

sign_getdefined([{name}])                                    *sign_getdefined()*
		获取已定义标记及其属性的列表。
		这类似于 |:sign-list| 命令。

		如果未提供 {name}，则返回所有已定义标记的列表。
		否则返回指定标记的属性。

		返回值中的每个列表项是一个包含以下条目的字典：
		   icon		标记位图文件的完整路径
		   linehl	用于标记所在整行的突出显示组；如果未设置则不存在。
		   name		标记的名称
		   priority	标记的默认优先级值
		   numhl	用于标记所在行号的突出显示组；如果未设置则不存在。
		   text		当没有图标或未使用 GUI 时显示的文本。
		   texthl	用于文本项的突出显示组；如果未设置则不存在。
		   culhl	当光标与标记在同一行且启用了 'cursorline' 时
				用于文本项的突出显示组；如果未设置则不存在。

		如果没有标记或未找到 {name}，则返回空列表。

		示例： >vim
			" 获取所有已定义标记的列表
			echo sign_getdefined()

			" 获取名为 mySign 的标记的属性
			echo sign_getdefined("mySign")

                参数： ~
                  • {name} (`string?`)

                返回值： ~
                  (`vim.fn.sign_getdefined.ret.item[]`)
sign_getplaced([{buf} [, {dict}]])                            *sign_getplaced()*
		返回缓冲区或所有缓冲区中放置的标记列表。
		这类似于 |:sign-place-list| 命令。

		如果指定了可选的缓冲区名称 {buf}，则只返回该缓冲区中放置的标记列表。
		关于 {buf} 的使用，请参见 |bufname()|。可选的 {dict} 可以包含
		以下条目：
		   group	只选择此组中的标记
		   id		选择具有此标识符的标记
		   lnum		选择放置在此行的标记。关于 {lnum} 的使用，请参见 |line()|。
		如果 {group} 是 "*"，则返回所有组中的标记，包括全局组。
		如果 {group} 未提供或是空字符串，则只返回全局组中的标记。
		如果未提供参数，则返回所有缓冲区中全局组放置的标记。
		参见 |sign-group|。

		返回值中的每个列表项是一个包含以下条目的字典：
			bufnr	带有标记的缓冲区编号
			signs	在 {bufnr} 中放置的标记列表。每个列表项是一个包含
				以下列出条目的字典

		每个标记的字典包含以下条目：
			group	 标记组。对于全局组设置为 ''。
			id	 标记的标识符
			lnum	 放置标记的行号
			name	 已定义标记的名称
			priority 标记优先级

		缓冲区中的返回标记按其行号和优先级排序。

		失败或没有放置标记时返回空列表。

		示例： >vim
			" 获取在 eval.c 中全局组放置的标记列表
			echo sign_getplaced("eval.c")

			" 获取在 eval.c 中 'g1' 组放置的标记列表
			echo sign_getplaced("eval.c", {'group' : 'g1'})

			" 获取在 eval.c 中第 10 行放置的标记列表
			echo sign_getplaced("eval.c", {'lnum' : 10})
			" 获取在 a.py 中标识符为 10 的标记
			echo sign_getplaced("a.py", {'id' : 10})

			" 获取在 a.py 中 'g1' 组中 id 为 20 的标记
			echo sign_getplaced("a.py", {'group' : 'g1',
							\  'id' : 20})

			" 获取所有已放置标记的列表
			echo sign_getplaced()

                参数： ~
                  • {buf} (`integer|string?`)
                  • {dict} (`vim.fn.sign_getplaced.dict?`)

                返回值： ~
                  (`vim.fn.sign_getplaced.ret.item[]`)

sign_jump({id}, {group}, {buf})                                    *sign_jump()*
		打开缓冲区 {buf} 或跳转到包含 {buf} 的窗口，
		并将光标定位到组 {group} 中的标记 {id}。
		这类似于 |:sign-jump| 命令。

		如果 {group} 是空字符串，则使用全局组。
		关于 {buf} 的使用，请参见 |bufname()|。

		返回标记的行号。如果参数无效，则返回 -1。

		示例： >vim
			" 跳转到当前缓冲区中的标记 10
			call sign_jump(10, '', '')

                参数： ~
                  • {id} (`integer`)
                  • {group} (`string`)
                  • {buf} (`integer|string`)

                返回值： ~
                  (`integer`)

sign_place({id}, {group}, {name}, {buf} [, {dict}])               *sign_place()*
		将定义为 {name} 的标记放置在文件或缓冲区 {buf} 的第 {lnum} 行，
		并将 {id} 和 {group} 分配给标记。这类似于 |:sign-place| 命令。

		如果标记标识符 {id} 为零，则分配一个新的标识符。
		否则使用指定的数字。{group} 是标记组名称。
		要使用全局标记组，使用空字符串。
		空字符串。{group} 作为 {id} 的命名空间，因此两个组可以使用相同的 ID。
		有关更多信息，请参见 |sign-identifier| 和 |sign-group|。

		{name} 引用已定义的标记。
		{buf} 引用缓冲区名称或编号。关于可接受的值，请参见 |bufname()|。

		可选的 {dict} 参数支持以下条目：
			lnum		文件或缓冲区 {buf} 中放置标记的行号。
					关于可接受的值，请参见 |line()|。
			priority	标记的优先级。有关更多信息，请参见
					|sign-priority|。

		如果未指定可选的 {dict}，则修改组 {group} 中放置的标记 {id} 以使用
		已定义的标记 {name}。

		成功返回标记标识符，失败返回 -1。

		示例： >vim
			" 在缓冲区 json.c 的第 20 行放置名为 sign1 的标记，id 为 5
			call sign_place(5, '', 'sign1', 'json.c',
							\ {'lnum' : 20})

			" 更新缓冲区 json.c 中的标记 5 以使用 sign2
			call sign_place(5, '', 'sign2', 'json.c')

			" 在缓冲区 json.c 的第 30 行放置名为 sign3 的标记，使用新标识符
			let id = sign_place(0, '', 'sign3', 'json.c',
							\ {'lnum' : 30})

			" 在缓冲区 json.c 的第 40 行放置名为 sign4 的标记，id 为 10，
			" 组为 'g3'，优先级为 90
			call sign_place(10, 'g3', 'sign4', 'json.c',
					\ {'lnum' : 40, 'priority' : 90})

                参数： ~
                  • {id} (`integer`)
                  • {group} (`string`)
                  • {name} (`string`)
                  • {buf} (`integer|string`)
                  • {dict} (`vim.fn.sign_place.dict?`)

                返回值： ~
                  (`integer`)
sign_placelist({list})                                        *sign_placelist()*
		放置一个或多个标记。这类似于 |sign_place()| 函数。
		{list} 参数指定要放置的标记列表。每个列表项是一个包含以下标记属性的字典：
		    buffer	缓冲区名称或编号。关于可接受的值，请参见 |bufname()|。
		    group	标记组。{group} 作为 {id} 的命名空间，因此两个组可以
				使用相同的 ID。如果未指定或设置为空字符串，则使用全局组。
				有关更多信息，请参见 |sign-group|。
		    id		标记标识符。如果未指定或为零，则分配一个新的唯一标识符。
				否则使用指定的数字。有关更多信息，请参见 |sign-identifier|。
		    lnum		缓冲区中放置标记的行号。关于可接受的值，请参见 |line()|。
		    name		要放置的标记名称。有关更多信息，请参见 |sign_define()|。
		    priority	标记的优先级。当在一行上放置多个标记时，使用优先级最高的标记。
				如果未指定，则使用默认值 10，除非标记定义另有指定。
				有关更多信息，请参见 |sign-priority|。

		如果 {id} 引用现有标记，则修改现有标记以使用指定的 {name} 和/或 {priority}。

		返回标记标识符列表。如果放置标记失败，则相应的列表项设置为 -1。

		示例： >vim
			" 在缓冲区 a.c 的第 20 行放置 id 为 5 的标记 s1，在第 30 行放置 id 为 10 的标记 s1
			let [n1, n2] = sign_placelist([
				\ {'id' : 5,
				\  'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 20},
				\ {'id' : 10,
				\  'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 30}
				\ ])

			" 在缓冲区 a.c 的第 40 行和第 50 行放置标记 s1
			" 使用自动生成的标识符在缓冲区 a.c 的第 40 行和第 50 行放置标记 s1
			let [n1, n2] = sign_placelist([
				\ {'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 40},
				\ {'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 50}
				\ ])

                参数： ~
                  • {list} (`vim.fn.sign_placelist.list.item[]`)

                返回值： ~
                  (`integer[]`)

sign_undefine([{name}])                                        *sign_undefine()*
sign_undefine({list})
		删除先前定义的标记 {name}。这类似于 |:sign-undefine| 命令。
		如果未提供 {name}，则删除所有已定义的标记。

		一个参数的 {list} 可用于删除标记列表。每个列表项是标记的名称。

		成功返回 0，失败返回 -1。对于一个参数的 {list} 调用，返回一个列表，
		每个未定义的标记对应一个值。

		示例： >vim
			" 删除名为 mySign 的标记
			call sign_undefine("mySign")

			" 删除标记 'sign1' 和 'sign2'
			call sign_undefine(["sign1", "sign2"])

			" 删除所有标记
			call sign_undefine()

                参数： ~
                  • {list} (`string[]?`)

                返回值： ~
                  (`integer[]`)

sign_unplace({group} [, {dict}])                                *sign_unplace()*
		从一个或多个缓冲区中删除先前放置的标记。这类似于 |:sign-unplace| 命令。
		{group} 是标记组名称。要使用全局标记组，使用空字符串。
		如果 {group} 设置为 "*"，则使用所有组，包括全局组。
		{group} 中的标记根据 {dict} 中的条目进行选择。
		{dict} 中支持以下可选条目：
			buffer	缓冲区名称或编号。参见 |bufname()|。
			id	标记标识符
		如果未提供 {dict}，则删除 {group} 中的所有标记。

		成功返回 0，失败返回 -1。

		示例： >vim
			" 从缓冲区 a.vim 中删除标记 10
			call sign_unplace('', {'buffer' : "a.vim", 'id' : 10})

			" 从缓冲区 3 中删除组 'g1' 中的标记 20
			call sign_unplace('g1', {'buffer' : 3, 'id' : 20})

			" 从缓冲区 10 中删除组 'g2' 中的所有标记
			call sign_unplace('g2', {'buffer' : 10})

			" 从所有缓冲区中删除组 'g3' 中的标记 30
			call sign_unplace('g3', {'id' : 30})

			" 删除缓冲区 5 中放置的所有标记
			call sign_unplace('*', {'buffer' : 5})

			" 从所有缓冲区中删除组 'g4' 中的标记
			call sign_unplace('g4')

			" 从所有缓冲区中删除标记 40
			call sign_unplace('*', {'id' : 40})

			" 从所有缓冲区中删除所有已放置的标记
			call sign_unplace('*')

                参数： ~
                  • {group} (`string`)
                  • {dict} (`vim.fn.sign_unplace.dict?`)

                返回值： ~
                  (`0|-1`)

sign_unplacelist({list})                                    *sign_unplacelist()*
		从一个或多个缓冲区中删除先前放置的标记。这类似于 |sign_unplace()| 函数。
		{list} 参数指定要删除的标记列表。每个列表项是一个包含以下标记属性的字典：
		    buffer	缓冲区名称或编号。对于可接受的值，参见 |bufname()|。
				如果未指定，则从所有缓冲区中删除指定的标记。
		    group	标记组名称。如果未指定或设置为空字符串，则使用全局标记组。
				如果设置为 "*"，则使用所有组，包括全局组。
		    id		标记标识符。如果未指定，则删除指定组中的所有标记。

		返回一个列表，如果相应的标记成功删除，则条目设置为 0，失败则为 -1。

		示例： >vim
			" 从缓冲区 a.vim 中删除标识符为 10 的标记，从缓冲区 b.vim 中删除标识符为 20 的标记
			call sign_unplacelist([
				\ {'id' : 10, 'buffer' : "a.vim"},
				\ {'id' : 20, 'buffer' : 'b.vim'},
				\ ])

                参数： ~
                  • {list} (`vim.fn.sign_unplacelist.list.item`)

                返回值： ~
                  (`(0|-1)[]`)

simplify({filename})                                                *simplify()*
		尽可能简化文件名而不改变其含义。不解析快捷方式（在 MS-Windows 上）或符号链接（在 Unix 上）。
		如果 {filename} 中的第一个路径组件指定当前目录，结果中也会保留这一点。
		尾部的路径分隔符也不会被删除。在 Unix 上，"//path" 保持不变，但 "///path" 被简化为 "/path"（这遵循 Posix 标准）。
		示例： >vim
			simplify("./dir/.././/file/") == "./file/"
<		注意：只有当 "dir" 是一个可搜索的目录或不存在时，才会删除 "dir/.." 组合。
		在 Unix 上，当 "dir" 是同一目录中的符号链接时，也会删除它。
		为了在简化路径名之前解析所有涉及的符号链接，请使用 |resolve()|。

                参数： ~
                  • {filename} (`string`)
slice({expr}, {start} [, {end}])                                       *slice()*
		类似于使用 |slice| "expr[start : end]"，但 "end" 是排他的。
		对于字符串，索引是作为字符索引而不是字节索引使用的。
		此外，组合字符被视为前一个基本字符的一部分。
		当 {end} 省略时，切片会继续到最后一个项目。
		当 {end} 为 -1 时，最后一个项目会被省略。
		如果 {start} 或 {end} 无效，则返回空值。

                参数： ~
                  • {expr} (`any`)
                  • {start} (`integer`)
                  • {end} (`integer?`)

                返回值： ~
                  (`any`)

sort({list} [, {func} [, {dict}]])                                     *sort()*
		对 {list} 进行排序，原地修改 {list}。如果 {func} 给出，它应该是一个 "比较" 函数，
		该函数接受两个项目并返回零、负或正数，就像 |sort()| 函数一样。
		如果 {func} 省略，则使用字符串比较。
		排序是稳定的：相等的项目保持其相对位置。
		示例： >vim
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sorted = sort(copy(mylist), "MyCompare")
<
		更短的版本使用 lambda： >vim
			let sorted = sort(copy(mylist), {i1, i2 -> i1 == i2 ? 0 : i1 > i2 ? 1 : -1})
<
		如果 {func} 是 "n" 或 "N"，则按数值排序。
		如果 {func} 是 "i" 或 "I"，则按忽略大小写的顺序排序。
		如果 {func} 是 "l" 或 "L"，则按字符串长度排序。
		如果 {func} 是 "f" 或 "F"，则按文件名排序。

                参数： ~
                  • {list} (`any[]`)
                  • {func} (`string|funcref?`)
                  • {dict} (`dict?`)

                返回值： ~
                  (`any[]`)

soundfold({word})                                                  *soundfold()*
		返回 {word} 的发音折叠版本，用于比较发音相似的单词。
		这主要用于英语。它使用 Vim 的默认发音折叠方法。
		参见 |sound-functions|。
		示例： >vim
			if soundfold(word1) == soundfold(word2)
			  echo "words sound similar"
			endif
<

                参数： ~
                  • {word} (`string`)

                返回值： ~
                  (`string`)

spellbadword([{sentence}])                                        *spellbadword()*
		返回 {sentence} 中第一个拼写错误的单词。
		如果没有拼写错误，则返回空字符串。
		如果 {sentence} 省略，则使用当前行的文本。
		拼写检查必须可用，否则返回空字符串。
		示例： >vim
			echo spellbadword("the quik brown fox")
<			quik >vim
			" 移动到下一个拼写错误的单词
			exe "normal! /" . spellbadword() . "\<CR>"
<

                参数： ~
                  • {sentence} (`string?`)

                返回值： ~
                  (`string`)

spellsuggest({word} [, {max} [, {capital}]])                    *spellsuggest()*
		返回 {word} 的拼写建议列表。
		如果 {max} 给出，则最多返回此数量的建议。
		否则最多返回 25 个建议。
		如果 {capital} 给出且不为零，则尊重单词的大小写。
		否则，忽略大小写。
		拼写检查必须可用，否则返回空列表。
		示例： >vim
			echo spellsuggest("vim")
<			['vim', 'im', 'vi', 'vm', 'v', 'i', 'vic', 'vim', 'vims', 'via', 'vile', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim']
<

                参数： ~
                  • {word} (`string`)
                  • {max} (`integer?`)
                  • {capital} (`integer?`)

                返回值： ~
                  (`string[]`)

sort({list} [, {how} [, {dict}]])                                  *sort()* *E702*
		对 {list} 中的项目进行原地排序。返回 {list}。

		如果你想要保持列表不变，请先复制一份： >vim
			let sortedlist = sort(copy(mylist))
<
		当 {how} 省略或是字符串时，sort() 使用每个项目的字符串表示进行排序。
		数字排在字符串之后，|Lists| 排在数字之后。要对当前缓冲区中的文本进行排序，请使用 |:sort|。

		当 {how} 为 'i' 时，忽略大小写。
		当 {how} 为 'l' 时，使用字符串长度排序。
		当 {how} 为 'n' 时，使用数值排序。
		当 {how} 为 'f' 时，使用文件名排序。

		当 {how} 为函数时，它应该接受两个项目并返回零、负或正数，就像 |sort()| 函数一样。
		示例： >vim
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sorted = sort(copy(mylist), "MyCompare")
<
		更短的版本使用 lambda： >vim
			let sorted = sort(copy(mylist), {i1, i2 -> i1 == i2 ? 0 : i1 > i2 ? 1 : -1})
<

                参数： ~
                  • {list} (`any[]`)
                  • {how} (`string|funcref?`)
                  • {dict} (`dict?`)

                返回值： ~
                  (`any[]`)

soundfold({word})                                                  *soundfold()*
		返回 {word} 的发音折叠版本，用于比较发音相似的单词。
		这主要用于英语。它使用 Vim 的默认发音折叠方法。
		参见 |sound-functions|。
		示例： >vim
			if soundfold(word1) == soundfold(word2)
			  echo "words sound similar"
			endif
<

                参数： ~
                  • {word} (`string`)

                返回值： ~
                  (`string`)

spellbadword([{sentence}])                                        *spellbadword()*
		返回 {sentence} 中第一个拼写错误的单词。
		如果没有拼写错误，则返回空字符串。
		如果 {sentence} 省略，则使用当前行的文本。
		拼写检查必须可用，否则返回空字符串。
		示例： >vim
			echo spellbadword("the quik brown fox")
<			quik >vim
			" 移动到下一个拼写错误的单词
			exe "normal! /" . spellbadword() . "\<CR>"
<

                参数： ~
                  • {sentence} (`string?`)

                返回值： ~
                  (`string`)

spellsuggest({word} [, {max} [, {capital}]])                    *spellsuggest()*
		返回 {word} 的拼写建议列表。
		如果 {max} 给出，则最多返回此数量的建议。
		否则最多返回 25 个建议。
		如果 {capital} 给出且不为零，则尊重单词的大小写。
		否则，忽略大小写。
		拼写检查必须可用，否则返回空列表。
		示例： >vim
			echo spellsuggest("vim")
<			['vim', 'im', 'vi', 'vm', 'v', 'i', 'vic', 'vim', 'vims', 'via', 'vile', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim', 'vim']
<

                参数： ~
                  • {word} (`string`)
                  • {max} (`integer?`)
                  • {capital} (`integer?`)

                返回值： ~
                  (`string[]`)
sockconnect({mode}, {address} [, {opts}])                        *sockconnect()*
		连接一个套接字到地址。如果 {mode} 是 "pipe"，则 {address} 应该是本地域套接字（在 Unix 上）或命名管道（在 Windows 上）的路径。如果 {mode} 是 "tcp"，则 {address} 应该是 "host:port" 的形式，其中 host 应该是 IP 地址或主机名，port 是端口号。

		对于 "pipe" 模式，参见 |luv-pipe-handle|。对于 "tcp" 模式，参见 |luv-tcp-handle|。

		返回一个 |channel| ID。使用 |chanclose()| 关闭套接字。
		使用 |chansend()| 通过字节套接字发送数据，使用 |rpcrequest()| 和 |rpcnotify()| 与 RPC 套接字通信。

		{opts} 是一个可选的字典，包含以下键：
		  |on_data| : 当从套接字读取数据时调用的回调函数
		  data_buffered : 在 |channel-buffered| 模式下读取套接字数据。
		  rpc     : 如果设置，将使用 |msgpack-rpc| 通过套接字通信。
		返回：
		  - 成功时返回通道 ID（大于零）
		  - 参数无效或连接失败时返回 0。

                参数： ~
                  • {mode} (`string`)
                  • {address} (`string`)
                  • {opts} (`table?`)

                返回值： ~
                  (`any`)

sort({list} [, {how} [, {dict}]])                                  *sort()* *E702*
		对 {list} 中的项目进行原地排序。返回 {list}。

		如果你想要保持列表不变，请先复制一份： >vim
			let sortedlist = sort(copy(mylist))
<
		当 {how} 省略或是字符串时，sort() 使用每个项目的字符串表示进行排序。
		数字排在字符串之后，|Lists| 排在数字之后。要对当前缓冲区中的文本进行排序，请使用 |:sort|。

		当 {how} 为 'i' 时，忽略大小写。
		为了向后兼容，值 1 可以用来忽略大小写。值 0 表示不忽略大小写。

		当 {how} 为 'l' 时，使用当前的排序区域设置进行排序。实现细节：使用 strcoll() 比较字符串。参见 |:language| 检查或设置排序区域设置。|v:collate| 也可以用来检查当前区域设置。使用区域设置排序通常会忽略大小写。示例： >vim
			" 在英语区域设置中，ö 的排序与 o 类似。
			language collate en_US.UTF8
			echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'ö', 'p', 'z'] ~
>vim
			" 在瑞典语区域设置中，ö 排在 z 之后。
			language collate sv_SE.UTF8
			echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'p', 'z', 'ö'] ~
		这在 Mac 上不能正常工作。

		当 {how} 为 'n' 时，所有项目将按数值排序（实现细节：使用 strtod() 函数解析数字，字符串、列表、字典和函数引用将被视为 0）。

		当 {how} 为 'N' 时，所有项目将按数值排序。这与 'n' 类似，但包含数字的字符串将被用作它们表示的数字。

		当 {how} 为 'f' 时，所有项目将按数值排序。所有值必须是数字或浮点数。

		当 {how} 是 |Funcref| 或函数名时，此函数被调用来比较项目。函数被调用时带有两个项目作为参数，如果它们相等则必须返回零，如果第一个项目排在第二个项目之后则返回 1 或更大，如果第一个项目排在第二个项目之前则返回 -1 或更小。

		{dict} 用于具有 "dict" 属性的函数。它将被用来设置局部变量 "self"。|Dictionary-function|

		排序是稳定的，比较相等的项目（作为数字或字符串）将保持它们的相对位置。例如，当按数字排序时，文本字符串将彼此相邻排序，顺序与它们原来的顺序相同。

		示例： >vim
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sorted = sort(copy(mylist), "MyCompare")
<
		更短的版本使用 lambda： >vim
			let sorted = sort(copy(mylist), {i1, i2 -> i1 == i2 ? 0 : i1 > i2 ? 1 : -1})
<

                参数： ~
                  • {list} (`any[]`)
                  • {how} (`string|funcref?`)
                  • {dict} (`dict?`)

                返回值： ~
                  (`any[]`)
soundfold({word})                                                  *soundfold()*
		返回 {word} 的语音折叠等效词。使用当前窗口 'spelllang' 中第一个支持语音折叠的语言。必须设置 'spell'。当无法进行语音折叠时，返回未修改的 {word}。
		这可以用于生成拼写建议。注意，该方法可能相当慢。

                参数： ~
                  • {word} (`string`)

                返回值： ~
                  (`string`)

spellbadword([{sentence}])                                      *spellbadword()*
		无参数时：结果是光标下或光标后的拼写错误的单词。光标会移动到错误单词的开头。如果在光标行中没有找到错误单词，结果为空字符串且光标不移动。

		有参数时：结果是 {sentence} 中第一个拼写错误的单词。如果没有拼写错误，结果为空字符串。

		返回值是一个包含两个项目的列表：
		- 拼写错误的单词或空字符串
		- 拼写错误的类型：
			"bad"		拼写错误
			"rare"		罕见词
			"local"		仅在另一个地区有效的词
			"caps"		单词应该以大写字母开头

                参数： ~
                  • {sentence} (`string?`)

                返回值： ~
                  (`[string, string]`)

spellsuggest({word} [, {max} [, {capital}]])                    *spellsuggest()*
		返回 {word} 的拼写建议列表。'spell' 必须设置。

		{max} 是建议的最大数量，默认为 25。

		当 {capital} 为 0 时，{word} 被视为小写。当 {capital} 为 1 时，{word} 被视为大写。当 {capital} 为 2 时，{word} 被视为首字母大写。当 {capital} 为 3 时，{word} 被视为首字母大写，其余字母小写。当 {capital} 为 4 时，{word} 被视为首字母大写，其余字母保持原样。当 {capital} 为 5 时，{word} 被视为首字母大写，其余字母保持原样，但建议的首字母大写。

		当 {capital} 为 0 时，建议将全部为小写。当 {capital} 为 1 时，建议将全部为大写。当 {capital} 为 2 时，建议将为首字母大写。当 {capital} 为 3 时，建议将为首字母大写，其余字母小写。当 {capital} 为 4 时，建议将为首字母大写，其余字母保持原样。当 {capital} 为 5 时，建议将为首字母大写，其余字母保持原样，但建议的首字母大写。

		当 {capital} 为 0 时，建议将全部为小写。当 {capital} 为 1 时，建议将全部为大写。当 {capital} 为 2 时，建议将为首字母大写。当 {capital} 为 3 时，建议将为首字母大写，其余字母小写。当 {capital} 为 4 时，建议将为首字母大写，其余字母保持原样。当 {capital} 为 5 时，建议将为首字母大写，其余字母保持原样，但建议的首字母大写。

                参数： ~
                  • {word} (`string`)
                  • {max} (`integer?`)
                  • {capital} (`integer?`)

                返回值： ~
                  (`string[]`)
split({string} [, {pattern} [, {keepempty}]])                          *split()*
		将 {string} 转换为 |List|。当 {pattern} 被省略或为空时，每个由空白字符分隔的字符序列成为一个项目。
		否则，字符串在 {pattern} 匹配的地方分割，并移除匹配的字符。这里不使用 'ignorecase'，要忽略大小写请添加 \c。|/\c|
		当第一个或最后一个项目为空时，它会被省略，除非 {keepempty} 为 1，此时会保留空项目。
		当 {pattern} 为空字符串时，字符串会在每个字符处分割。
		示例： >vim
			:echo split('abc:def:ghi', ':')
<			['abc', 'def', 'ghi'] ~
>vim
			:echo split('abc:def:', ':')
<			['abc', 'def'] ~
>vim
			:echo split('abc:def:', ':', 1)
<			['abc', 'def', ''] ~
>vim
			:echo split('abc:def', '\zs')
<			['a', 'b', 'c', ':', 'd', 'e', 'f'] ~

                参数： ~
                  • {string} (`string`)
                  • {pattern} (`string?`)
                  • {keepempty} (`boolean?`)

                返回值： ~
                  (`string[]`)

sqrt({expr})                                                          *sqrt()*
		返回 {expr} 的平方根，作为 |Float|。{expr} 必须计算为正数。
		当 {expr} 为负时，结果是一个 NaN。
		示例： >vim
			:echo sqrt(100)
<			10.0 ~
>vim
			:echo sqrt(-4.01)
<			-nan ~

                参数： ~
                  • {expr} (`float`)

                返回值： ~
                  (`float`)

srand([{expr}])                                                      *srand()*
		设置随机数生成器的种子。{expr} 可以是任何数字表达式。
		返回旧的种子值。
		当 {expr} 被省略时，使用一个真正随机的种子值。
		示例： >vim
			:echo srand()
<			123456 ~
>vim
			:echo srand(123456)
<			123456 ~

                参数： ~
                  • {expr} (`integer?`)

                返回值： ~
                  (`integer`)

state([{what}])                                                      *state()*
		返回一个描述当前编辑状态的值。
		{what} 参数选择要返回的状态：
			"mode"		当前模式
			"visual"	当前可视模式
			"operator"	当前操作符
			"register"	当前寄存器
			"macro"		当前宏
			"input"		当前输入
			"input_avail"	是否有输入可用
			"input_pending"	是否有输入待处理
			"input_waiting"	是否有输入等待
			"input_blocking"	是否有输入阻塞
			"input_ready"	输入是否准备就绪
			"input_busy"	输入是否忙
			"input_done"	输入是否完成
			"input_error"	输入是否有错误
			"input_eof"	输入是否结束
			"input_timeout"	输入是否超时
			"input_interrupt"	输入是否被中断
			"input_cancel"	输入是否被取消
			"input_abort"	输入是否被中止
			"input_quit"	输入是否被退出
			"input_stop"	输入是否被停止
			"input_suspend"	输入是否被挂起
			"input_resume"	输入是否被恢复
			"input_restart"	输入是否被重启
			"input_continue"	输入是否继续
			"input_break"	输入是否被中断
			"input_return"	输入是否返回
			"input_throw"	输入是否抛出异常
			"input_catch"	输入是否捕获异常
			"input_finally"	输入是否最终执行
			"input_cleanup"	输入是否清理
			"input_destroy"	输入是否销毁
			"input_close"	输入是否关闭
			"input_flush"	输入是否刷新
			"input_drain"	输入是否排空
			"input_fill"	输入是否填充
			"input_peek"	输入是否窥视
			"input_read"	输入是否读取
			"input_write"	输入是否写入
			"input_seek"	输入是否寻址
			"input_tell"	输入是否告知位置
			"input_size"	输入大小
			"input_pos"	输入位置
			"input_line"	输入行
			"input_col"	输入列
			"input_char"	输入字符
			"input_byte"	输入字节
			"input_word"	输入单词
			"input_sentence"	输入句子
			"input_paragraph"	输入段落
			"input_page"	输入页面
			"input_screen"	输入屏幕
			"input_window"	输入窗口
			"input_buffer"	输入缓冲区
			"input_file"	输入文件
			"input_pipe"	输入管道
			"input_socket"	输入套接字
			"input_terminal"	输入终端
			"input_process"	输入进程
			"input_job"	输入作业
			"input_channel"	输入通道
			"input_stream"	输入流
			"input_handle"	输入句柄
			"input_fd"	输入文件描述符
			"input_stdin"	输入标准输入
			"input_stdout"	输入标准输出
			"input_stderr"	输入标准错误
			"input_null"	输入空设备
			"input_random"	输入随机
			"input_urandom"	输入随机
			"input_arandom"	输入随机
			"input_prandom"	输入随机
			"input_crandom"	输入随机
			"input_drandom"	输入随机
			"input_erandom"	输入随机
			"input_frandom"	输入随机
			"input_grandom"	输入随机
			"input_hrandom"	输入随机
			"input_irandom"	输入随机
			"input_jrandom"	输入随机
			"input_krandom"	输入随机
			"input_lrandom"	输入随机
			"input_mrandom"	输入随机
			"input_nrandom"	输入随机
			"input_orandom"	输入随机
			"input_prandom"	输入随机
			"input_qrandom"	输入随机
			"input_rrandom"	输入随机
			"input_srandom"	输入随机
			"input_trandom"	输入随机
			"input_urandom"	输入随机
			"input_vrandom"	输入随机
			"input_wrandom"	输入随机
			"input_xrandom"	输入随机
			"input_yrandom"	输入随机
			"input_zrandom"	输入随机

                参数： ~
                  • {what} (`string?`)

                返回值： ~
                  (`any`)

str2float({string} [, {quoted}])                                  *str2float()*
		将字符串转换为浮点数。{string} 必须表示一个浮点数。
		当 {quoted} 为 1 时，{string} 可以包含引号。
		当 {string} 不表示一个浮点数时，返回 0.0。
		示例： >vim
			:echo str2float('12.34')
<			12.34 ~
>vim
			:echo str2float('"12.34"', 1)
<			12.34 ~

                参数： ~
                  • {string} (`string`)
                  • {quoted} (`boolean?`)

                返回值： ~
                  (`float`)

str2list({string} [, {utf8}])                                    *str2list()*
		将字符串转换为数字列表。{string} 被视为一系列字节。
		当 {utf8} 为 1 时，{string} 被视为 UTF-8 字符串。
		示例： >vim
			:echo str2list('abc')
<			[97, 98, 99] ~
>vim
			:echo str2list('äöü', 1)
<			[228, 246, 252] ~

                参数： ~
                  • {string} (`string`)
                  • {utf8} (`boolean?`)

                返回值： ~
                  (`integer[]`)

str2nr({string} [, {base}])                                        *str2nr()*
		将字符串转换为数字。{string} 必须表示一个数字。
		当 {base} 为 8 时，{string} 被视为八进制数。
		当 {base} 为 16 时，{string} 被视为十六进制数。
		当 {base} 为 10 时，{string} 被视为十进制数。
		当 {base} 为 0 时，{string} 被视为八进制数（如果以 0 开头）或十六进制数（如果以 0x 或 0X 开头）或十进制数。
		当 {string} 不表示一个数字时，返回 0。
		示例： >vim
			:echo str2nr('123')
<			123 ~
>vim
			:echo str2nr('0x7b')
<			123 ~
>vim
			:echo str2nr('0173', 8)
<			123 ~

                参数： ~
                  • {string} (`string`)
                  • {base} (`integer?`)

                返回值： ~
                  (`integer`)
str2nr({string} [, {base}])                                        *str2nr()*
		将字符串转换为数字。{string} 必须表示一个数字。
		当 {base} 为 8 时，{string} 被视为八进制数。
		当 {base} 为 16 时，{string} 被视为十六进制数。
		当 {base} 为 10 时，{string} 被视为十进制数。
		当 {base} 为 0 时，{string} 被视为八进制数（如果以 0 开头）或十六进制数（如果以 0x 或 0X 开头）或十进制数。
		当 {string} 不表示一个数字时，返回 0。
		示例： >vim
			:echo str2nr('123')
<			123 ~
>vim
			:echo str2nr('0x7b')
<			123 ~
>vim
			:echo str2nr('0173', 8)
<			123 ~

                参数： ~
                  • {string} (`string`)
                  • {base} (`integer?`)

                返回值： ~
                  (`integer`)

strcharpart({src}, {start} [, {len} [, {what}]])              *strcharpart()*
		返回 {src} 字符串中从 {start} 开始的 {len} 个字符。
		当 {len} 被省略时，返回从 {start} 开始到字符串末尾的所有字符。
		当 {start} 为负数时，从字符串末尾开始计数。
		当 {len} 为负数时，从 {start} 开始向前计数。
		当 {what} 为 1 时，{start} 和 {len} 被视为字节索引而不是字符索引。
		示例： >vim
			:echo strcharpart('abcdef', 3, 2)
<			de ~
>vim
			:echo strcharpart('abcdef', -2, 2)
<			ef ~
>vim
			:echo strcharpart('abcdef', 3, -2)
<			cd ~

                参数： ~
                  • {src} (`string`)
                  • {start} (`integer`)
                  • {len} (`integer?`)
                  • {what} (`integer?`)

                返回值： ~
                  (`string`)

strchars({string} [, {skipcc}])                                  *strchars()*
		返回 {string} 中的字符数。
		当 {skipcc} 为 1 时，跳过组合字符。
		示例： >vim
			:echo strchars('abc')
<			3 ~
>vim
			:echo strchars('äöü')
<			3 ~

                参数： ~
                  • {string} (`string`)
                  • {skipcc} (`boolean?`)

                返回值： ~
                  (`integer`)

strdisplaywidth({string} [, {col}])                          *strdisplaywidth()*
		返回 {string} 的显示宽度。
		当 {col} 被指定时，返回从 {col} 开始的显示宽度。
		示例： >vim
			:echo strdisplaywidth('abc')
<			3 ~
>vim
			:echo strdisplaywidth('äöü')
<			3 ~

                参数： ~
                  • {string} (`string`)
                  • {col} (`integer?`)

                返回值： ~
                  (`integer`)

strftime({format} [, {time}])                                    *strftime()*
		返回根据 {format} 格式化的时间字符串。
		当 {time} 被省略时，使用当前时间。
		当 {time} 被指定时，它必须是一个数字，表示自 1970 年 1 月 1 日以来的秒数。
		示例： >vim
			:echo strftime('%c')
<			2019-01-01 12:00:00 ~
>vim
			:echo strftime('%c', 1234567890)
<			2009-02-13 23:31:30 ~

                参数： ~
                  • {format} (`string`)
                  • {time} (`integer?`)

                返回值： ~
                  (`string`)

strgetchar({string}, {index})                                  *strgetchar()*
		返回 {string} 中 {index} 处的字符代码。
		当 {index} 为负数时，从字符串末尾开始计数。
		当 {index} 超出范围时，返回 -1。
		示例： >vim
			:echo strgetchar('abc', 1)
<			98 ~
>vim
			:echo strgetchar('äöü', 1)
<			246 ~

                参数： ~
                  • {string} (`string`)
                  • {index} (`integer`)

                返回值： ~
                  (`integer`)

stridx({haystack}, {needle} [, {start}])                        *stridx()*
		返回 {needle} 在 {haystack} 中第一次出现的位置。
		当 {start} 被指定时，从 {start} 开始搜索。
		当 {needle} 未找到时，返回 -1。
		示例： >vim
			:echo stridx('abcabc', 'b')
<			1 ~
>vim
			:echo stridx('abcabc', 'b', 2)
<			4 ~

                参数： ~
                  • {haystack} (`string`)
                  • {needle} (`string`)
                  • {start} (`integer?`)

                返回值： ~
                  (`integer`)

string({expr})                                                    *string()*
		返回 {expr} 的字符串表示。
		当 {expr} 是一个列表时，返回一个包含所有项目字符串表示的列表。
		当 {expr} 是一个字典时，返回一个包含所有键值对字符串表示的字典。
		示例： >vim
			:echo string(123)
<			123 ~
>vim
			:echo string([1, 2, 3])
<			[1, 2, 3] ~
>vim
			:echo string({'a': 1, 'b': 2})
<			{'a': 1, 'b': 2} ~

                参数： ~
                  • {expr} (`any`)

                返回值： ~
                  (`string`)
strlen({string})                                                    *strlen()*
		返回 {string} 的字节长度。
		示例： >vim
			:echo strlen('abc')
<			3 ~
>vim
			:echo strlen('äöü')
<			6 ~

                参数： ~
                  • {string} (`string`)

                返回值： ~
                  (`integer`)

strpart({src}, {start} [, {len} [, {what}]])                      *strpart()*
		返回 {src} 字符串中从 {start} 开始的 {len} 个字节。
		当 {len} 被省略时，返回从 {start} 开始到字符串末尾的所有字节。
		当 {start} 为负数时，从字符串末尾开始计数。
		当 {len} 为负数时，从 {start} 开始向前计数。
		当 {what} 为 1 时，{start} 和 {len} 被视为字符索引而不是字节索引。
		示例： >vim
			:echo strpart('abcdef', 3, 2)
<			de ~
>vim
			:echo strpart('abcdef', -2, 2)
<			ef ~
>vim
			:echo strpart('abcdef', 3, -2)
<			cd ~

                参数： ~
                  • {src} (`string`)
                  • {start} (`integer`)
                  • {len} (`integer?`)
                  • {what} (`integer?`)

                返回值： ~
                  (`string`)

strptime({format}, {timestring})                                *strptime()*
		将 {timestring} 解析为时间值，使用 {format} 指定的格式。
		返回自 1970 年 1 月 1 日以来的秒数。
		当解析失败时，返回 -1。
		示例： >vim
			:echo strptime('%Y-%m-%d', '2019-01-01')
<			1546300800 ~

                参数： ~
                  • {format} (`string`)
                  • {timestring} (`string`)

                返回值： ~
                  (`integer`)

strridx({haystack}, {needle} [, {start}])                        *strridx()*
		返回 {needle} 在 {haystack} 中最后一次出现的位置。
		当 {start} 被指定时，从 {start} 开始向前搜索。
		当 {needle} 未找到时，返回 -1。
		示例： >vim
			:echo strridx('abcabc', 'b')
<			4 ~
>vim
			:echo strridx('abcabc', 'b', 3)
<			1 ~

                参数： ~
                  • {haystack} (`string`)
                  • {needle} (`string`)
                  • {start} (`integer?`)

                返回值： ~
                  (`integer`)

strtrans({string})                                                *strtrans()*
		返回 {string} 的转义表示。
		不可打印的字符被转换为可打印的表示。
		示例： >vim
			:echo strtrans('abc\n')
<			abc^@ ~

                参数： ~
                  • {string} (`string`)

                返回值： ~
                  (`string`)

strwidth({string})                                                *strwidth()*
		返回 {string} 的显示宽度。
		示例： >vim
			:echo strwidth('abc')
<			3 ~
>vim
			:echo strwidth('äöü')
<			3 ~

                参数： ~
                  • {string} (`string`)

                返回值： ~
                  (`integer`)

submatch({nr} [, {list}])                                        *submatch()*
		返回正则表达式匹配中的第 {nr} 个子匹配。
		当 {list} 为 1 时，返回所有子匹配的列表。
		当 {nr} 为 0 时，返回整个匹配。
		当 {nr} 为负数时，从最后一个子匹配开始计数。
		示例： >vim
			:echo submatch(0)
<			abc ~
>vim
			:echo submatch(1, 1)
<			['a', 'b', 'c'] ~

                参数： ~
                  • {nr} (`integer`)
                  • {list} (`boolean?`)

                返回值： ~
                  (`string`)

substitute({expr}, {pat}, {sub}, {flags})                      *substitute()*
		在 {expr} 中用 {sub} 替换 {pat} 的匹配。
		{flags} 是一个字符串，可以包含以下字符：
			g	替换所有匹配
			c	确认每个替换
			e	不报告错误
			n	只报告匹配数
		示例： >vim
			:echo substitute('abcabc', 'b', 'x', 'g')
<			axcaxc ~

                参数： ~
                  • {expr} (`string`)
                  • {pat} (`string`)
                  • {sub} (`string`)
                  • {flags} (`string`)

                返回值： ~
                  (`string`)

swapinfo({fname})                                                *swapinfo()*
		返回关于交换文件 {fname} 的信息。
		返回一个字典，包含以下键：
			version	交换文件版本
			pid	创建交换文件的进程 ID
			user	创建交换文件的用户名
			host	创建交换文件的主机名
			time	创建交换文件的时间
		示例： >vim
			:echo swapinfo('file.swp')
<			{'version': '7.4', 'pid': 1234, 'user': 'user', 'host': 'host', 'time': 1234567890} ~

                参数： ~
                  • {fname} (`string`)

                返回值： ~
                  (`dict`)
spellsuggest({word} [, {max} [, {capital}]])                    *spellsuggest()*
		返回一个包含拼写建议的列表，用于替换 {word}。
		当指定 {max} 时，最多返回该数量的建议。否则最多返回 25 个建议。
		当指定 {capital} 参数且非零时，只返回首字母大写的建议。这可以在 'spellcapcheck' 匹配后使用。
		{word} 可以是一个拼写错误的单词后面跟着其他文本。这允许连接两个被拆分的单词。建议也会包含后面的文本，因此你可以替换整行。
		{word} 也可以是一个正确的单词。这样会返回相似的单词。{word} 本身不会包含在建议中，尽管它可能以大写形式出现。
		使用当前窗口的拼写信息。使用 'spelllang' 和 'spellsuggest' 的值。

                参数： ~
                  • {word} (`string`)
                  • {max} (`integer?`)
                  • {capital} (`boolean?`)

                返回值： ~
                  (`string[]`)

split({string} [, {pattern} [, {keepempty}]])                          *split()*
		将 {string} 转换为列表。当省略 {pattern} 或为空时，每个由空白字符分隔的字符序列成为一个项目。
		否则，字符串在 {pattern} 匹配的地方分割，移除匹配的字符。这里不使用 'ignorecase'，添加 \c 来忽略大小写。|/\c|
		当第一个或最后一个项目为空时，它会被省略，除非指定了 {keepempty} 参数且非零。
		当 {pattern} 至少匹配一个字符或 {keepempty} 非零时，其他空项目会被保留。
		示例： >vim
			let words = split(getline('.'), '\W\+')
<		要将字符串分割为单个字符： >vim
			for c in split(mystring, '\zs') | endfor
<		如果你想保留分隔符，也可以在模式末尾使用 '\zs'： >vim
			echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi']
<		分割一个第一个元素可能为空的表格： >vim
			let items = split(line, ':', 1)
<		相反的函数是 |join()|。

                参数： ~
                  • {string} (`string`)
                  • {pattern} (`string?`)
                  • {keepempty} (`boolean?`)

                返回值： ~
                  (`string[]`)

sqrt({expr})                                                            *sqrt()*
		返回浮点数 {expr} 的非负平方根作为浮点数。
		{expr} 必须求值为浮点数或数字。当 {expr} 为负数时，结果为 NaN（非数字）。如果 {expr} 不是浮点数或数字，返回 0.0。
		示例： >vim
			echo sqrt(100)
<			10.0 >vim
			echo sqrt(-4.01)
<			str2float("nan")
		NaN 可能不同，这取决于系统库。

                参数： ~
                  • {expr} (`number`)

                返回值： ~
                  (`any`)

srand([{expr}])                                                        *srand()*
		初始化 |rand()| 使用的种子：
		- 如果不给出 {expr}，种子值通过从 /dev/urandom 读取（如果可能）或使用 time(NULL)（即纪元时间）来初始化；这只有秒级精度。
		- 如果给出 {expr}，它必须是一个数字。它用于初始化种子值。这对于测试或需要可预测序列时很有用。
		示例： >vim
			let seed = srand()
			let seed = srand(userinput)
			echo rand(seed)
<

                参数： ~
                  • {expr} (`number?`)

                返回值： ~
                  (`any`)

state([{what}])                                                        *state()*
		返回一个包含指示当前状态的字符的字符串。主要在回调中想要执行可能不总是安全的工作时有用。大致工作方式如下：
		- 回调使用 state() 检查工作是否可以安全执行。
		  是：立即执行。
		  否：添加到工作队列并添加 |SafeState| 自动命令。
		- 当 SafeState 触发并执行你的自动命令时，用 `state()` 检查现在是否可以执行工作，如果可以，从队列中移除并执行。
		  如果队列现在为空，移除自动命令。
		另见 |mode()|。
		当给出 {what} 时，只添加该字符串中的字符。例如，这检查屏幕是否已滚动： >vim
			if state('s') == ''
			   " 屏幕未滚动
<
		这些字符指示状态，通常表示某些事情正在忙：
		    m	映射、:normal 命令、feedkeys() 或填充命令执行到一半
		    o	操作符待定，例如在 |d| 之后
		    a	插入模式自动完成激活
		    x	正在执行自动命令
		    S	不触发 SafeState，例如在 |f| 或计数之后
		    c	回调被调用，包括定时器（对于递归性最多重复到 "ccc"）
		    s	屏幕因消息而滚动

                参数： ~
                  • {what} (`string?`)

                返回值： ~
                  (`any`)

stdioopen({opts})                                                  *stdioopen()*
		使用 |--headless| 时，这将 stdin 和 stdout 作为 |channel| 打开。
		只能调用一次。参见 |channel-stdio|。stderr 不由该函数处理，参见 |v:stderr|。
		使用 |chanclose()| 关闭 stdio 句柄。使用 |chansend()| 向 stdout 发送数据，使用 |rpcrequest()| 和 |rpcnotify()| 通过 RPC 通信。
		{opts} 是一个包含以下键的字典：
		  |on_stdin| : 当写入 stdin 时调用的回调。
		  on_print : 当 Nvim 需要打印消息时调用的回调，消息（类型为字符串）作为唯一参数。
		  stdin_buffered : 以 |channel-buffered| 模式读取 stdin。
		  rpc      : 如果设置，将使用 |msgpack-rpc| 通过 stdio 通信
		返回：
		  - 成功时返回 |channel-id|（值始终为 1）
		  - 参数无效时返回 0

                参数： ~
                  • {opts} (`table`)

                返回值： ~
                  (`any`)

stdpath({what})                                                *stdpath()* *E6100*
		返回各种默认文件和目录的 |standard-path| 位置。位置由 |base-directories| 驱动，你可以通过 |$NVIM_APPNAME| 或 `$XDG_…` 环境变量配置。
		{what}       类型    描述 ~
		cache        字符串  缓存目录：插件等的任意临时存储
		config       字符串  用户配置目录。|init.vim| 存储在此处。
		config_dirs  列表    其他配置目录。
		data         字符串  用户数据目录。
		data_dirs    列表    其他数据目录。
		log          字符串  日志目录（也供插件使用）。
		run          字符串  运行目录：套接字、命名管道等的临时本地存储
		state        字符串  会话状态目录：文件草稿、交换、撤销、|shada| 的存储。
		示例： >vim
			echo stdpath("config")
str2float({string} [, {quoted}])                                   *str2float()*
		将字符串 {string} 转换为浮点数。这基本上与在表达式中使用浮点数相同，参见 |floating-point-format|。但它稍微更宽松一些。
		例如，"1e40" 被接受，而在表达式中你需要写成 "1.0e40"。十六进制形式 "0x123" 也被接受，但其他形式如二进制或八进制则不行。
		当 {quoted} 存在且非零时，小数点前的嵌入单引号会被忽略，因此 "1'000.0" 表示一千。
		数字后的文本会被静默忽略。
		小数点总是 '.'，无论区域设置如何。逗号会结束数字："12,345.67" 会被转换为 12.0。你可以使用 |substitute()| 去除千位分隔符： >vim
			let f = str2float(substitute(text, ',', '', 'g'))
<		如果转换失败，返回 0.0。

                参数： ~
                  • {string} (`string`)
                  • {quoted} (`boolean?`)

                返回值： ~
                  (`any`)

str2list({string} [, {utf8}])                                       *str2list()*
		返回一个包含表示字符串 {string} 中每个字符的数字值的列表。示例： >vim
			echo str2list(" ")		" 返回 [32]
			echo str2list("ABC")		" 返回 [65, 66, 67]
<		|list2str()| 执行相反的操作。

		始终使用 UTF-8 编码，{utf8} 选项没有效果，仅为了向后兼容而存在。
		使用 UTF-8 时，组合字符会被正确处理： >vim
			echo str2list("á")		" 返回 [97, 769]
<

                参数： ~
                  • {string} (`string`)
                  • {utf8} (`boolean?`)

                返回值： ~
                  (`number[]`)

str2nr({expr} [, {base}])                                            *str2nr()*
		将字符串 {expr} 转换为数字。当 {base} 为 8 时，识别八进制数。当 {base} 为 16 时，识别十六进制数。否则使用十进制。
		十六进制数可以以 "0x" 或 "0X" 开头。八进制数可以以 "0" 开头。
		如果 {base} 为 16，则 "0x" 或 "0X" 前缀是可选的。
		当 {base} 为 8 时，前导零是可选的。
		当 {base} 为 2 时，识别二进制数，可以以 "0b" 或 "0B" 开头。
		当 {base} 为 0，则自动检测基数：
		- 如果 {expr} 以 "0x" 或 "0X" 开头，使用基数 16
		- 如果 {expr} 以 "0b" 或 "0B" 开头，使用基数 2
		- 如果 {expr} 以 "0" 开头，使用基数 8
		- 否则使用基数 10
		如果 {expr} 不以数字开头，返回 0。
		空字符串返回 0。
		所有前导和尾随空白字符都被忽略。
		示例： >vim

strcharlen({string})                                              *strcharlen()*
		结果是一个数字,表示字符串 {string} 中的字符数。
		组合字符被忽略。
		|strchars()| 可以计算字符数,将组合字符单独计算。

		如果 {string} 为空或出错则返回0。

		另见 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。

                参数: ~
                  • {string} (`string`)

                返回: ~
                  (`any`)

strcharpart({src}, {start} [, {len} [, {skipcc}]])               *strcharpart()*
		类似于 |strpart()|,但使用字符索引和长度而不是字节索引和长度。
		当 {skipcc} 被省略或为零时,组合字符被单独计算。
		当 {skipcc} 设为1时,组合字符被视为前一个基本字符的一部分,类似于 |slice()|。
		当使用不存在的字符索引时,它会被省略并计为一个字符。例如: >vim
			echo strcharpart('abc', -1, 2)
<		结果为 'a'。

		出错时返回空字符串。

                参数: ~
                  • {src} (`string`)
                  • {start} (`integer`)
                  • {len} (`integer?`)
                  • {skipcc} (`boolean?`)

                返回: ~
                  (`any`)

strchars({string} [, {skipcc}])                                     *strchars()*
		结果是一个数字,表示字符串 {string} 中的字符数。
		当 {skipcc} 被省略或为零时,组合字符被单独计算。
		当 {skipcc} 设为1时,组合字符被忽略。
		|strcharlen()| 总是这样做。

		出错时返回零。

		另见 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。

		{skipcc} 仅在7.4.755之后可用。为了向后兼容,你可以定义一个包装函数: >vim
		    if has("patch-7.4.755")
		      function s:strchars(str, skipcc)
			return strchars(a:str, a:skipcc)
		      endfunction
		    else
		      function s:strchars(str, skipcc)
			if a:skipcc
			  return strlen(substitute(a:str, ".", "x", "g"))
			else
			  return strchars(a:str)
			endif
		      endfunction
		    endif
<

                参数: ~
                  • {string} (`string`)
                  • {skipcc} (`boolean?`)

                返回: ~
                  (`integer`)

strdisplaywidth({string} [, {col}])                          *strdisplaywidth()*
		结果是一个数字,表示字符串 {string} 在屏幕上从 {col} 开始占用的显示单元格数
		(第一列是零)。当 {col} 被省略时使用零。
		否则它是开始显示的屏幕列。这对制表符很重要。
		使用当前窗口的选项设置。这对任何显示不同的内容都很重要,比如
		'tabstop' 和 'display'。
		当 {string} 包含具有东亚宽度类不明确的字符时,此函数的返回值取决于 'ambiwidth'。
		出错时返回零。
		另见 |strlen()|、|strwidth()| 和 |strchars()|。

                参数: ~
                  • {string} (`string`)
                  • {col} (`integer?`)

                返回: ~
                  (`integer`)

strftime({format} [, {time}])                                       *strftime()*
		结果是一个字符串,它是按照 {format} 字符串指定的格式化的日期和时间。
		使用给定的 {time},如果没有给出时间则使用当前时间。
		接受的 {format} 取决于你的系统,因此这不是可移植的!
		有关格式,请参见C函数 strftime() 的手册页。结果的最大长度是80个字符。
		另见 |localtime()|、|getftime()| 和 |strptime()|。
		可以使用 |:language| 命令更改语言。
		示例: >vim
		  echo strftime("%c")		   " Sun Apr 27 11:49:23 1997
		  echo strftime("%Y %b %d %X")	   " 1997 Apr 27 11:53:25
		  echo strftime("%y%m%d %T")	   " 970427 11:53:55
		  echo strftime("%H:%M")		   " 11:55
		  echo strftime("%c", getftime("file.c"))
						   " 显示 file.c 的修改时间。

                参数: ~
                  • {format} (`string`)
                  • {time} (`number?`)

                返回: ~
                  (`string`)

strgetchar({str}, {index})                                        *strgetchar()*
		获取与 {str} 中 {index} 位置的字符对应的数字。
		这使用从零开始的字符索引,而不是字节索引。
		组合字符在这里被视为单独的字符。
		使用 |nr2char()| 将数字转换为字符串。
		如果 {index} 无效则返回-1。
		另见 |strcharpart()| 和 |strchars()|。

                参数: ~
                  • {str} (`string`)
                  • {index} (`integer`)

                返回: ~
                  (`integer`)

stridx({haystack}, {needle} [, {start}])                              *stridx()*
		结果是一个数字,它给出字符串 {needle} 在 {haystack} 中第一次出现的字节索引。
		如果指定了 {start},则搜索从索引 {start} 开始。
		这可以用来查找第二个匹配: >vim
			let colon1 = stridx(line, ":")
			let colon2 = stridx(line, ":", colon1 + 1)
<		搜索区分大小写。
		对于模式搜索使用 |match()|。
		如果 {needle} 没有在 {haystack} 中出现则返回-1。
		另见 |strridx()|。
		示例: >vim
		  echo stridx("An Example", "Example")     " 3
		  echo stridx("Starting point", "Start")   " 0
		  echo stridx("Starting point", "start")   " -1
<						*strstr()* *strchr()*
		stridx() 的工作方式类似于C函数 strstr()。当用于单个字符时,它的工作方式类似于 strchr()。

                参数: ~
                  • {haystack} (`string`)
                  • {needle} (`string`)
                  • {start} (`integer?`)

                返回: ~
                  (`integer`)

string({expr})                                                        *string()*
		返回转换为字符串的 {expr}。如果 {expr} 是数字、浮点数、字符串、二进制数据或它们的组合,
		则结果可以用 |eval()| 解析回来。
			{expr} 类型	结果 ~
			String		'string'
			Number		123
			Float		123.123456 或 1.123456e8 或
					`str2float('inf')`
			Funcref		`function('name')`
			Blob		0z00112233.44556677.8899
			List		[item, item]
			Dictionary	`{key: value, key: value}`
		注意在字符串值中 ' 字符被加倍。
		另见 |strtrans()|。
		注意2:输出格式主要与YAML兼容,除了无限和NaN浮点值表示使用 |str2float()|。
		字符串也被原样转储,只转义单引号,这不允许使用YAML解析回二进制字符串。
		对于字符串和浮点数,|eval()| 应该总是有效,这是唯一官方的方法。
		如果你需要与其他应用程序共享数据,请使用 |msgpackdump()| 或 |json_encode()|。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`string`)

strlen({string})                                                      *strlen()*
		结果是一个数字,它是字符串 {string} 的字节长度。
		如果参数是数字,它首先被转换为字符串。
		对于其他类型会给出错误并返回零。
		如果你想计算多字节字符的数量,使用 |strchars()|。
		另见 |len()|、|strdisplaywidth()| 和 |strwidth()|。

                参数: ~
                  • {string} (`string`)

                返回: ~
                  (`integer`)

strpart({src}, {start} [, {len} [, {chars}]])                        *strpart()*
		结果是一个字符串,它是 {src} 的一部分,从字节 {start} 开始,字节长度为 {len}。
		当 {chars} 存在且为TRUE时,{len} 是字符位置的数量(组合字符不被单独计算,
		因此 "1" 表示一个基本字符和任何后续的组合字符)。
		要使用字符而不是字节来计算 {start},使用 |strcharpart()|。

		当选择的字节不存在时,这不会导致错误,这些字节只是被省略。
		如果 {len} 缺失,则从 {start} 复制到 {src} 的末尾。>vim
			echo strpart("abcdefg", 3, 2)    " 返回 'de'
			echo strpart("abcdefg", -2, 4)   " 返回 'ab'
			echo strpart("abcdefg", 5, 4)    " 返回 'fg'
			echo strpart("abcdefg", 3)	 " 返回 'defg'

<		注意:要获取第一个字符,{start} 必须为0。例如,要获取光标下的字符: >vim
			strpart(getline("."), col(".") - 1, 1, v:true)
<
		出错时返回空字符串。

                参数: ~
                  • {src} (`string`)
                  • {start} (`integer`)
                  • {len} (`integer?`)
                  • {chars} (`0|1?`)

                返回: ~
                  (`string`)

strptime({format}, {timestring})                                    *strptime()*
		结果是一个数字,它是一个表示 {timestring} 中日期和时间的unix时间戳,
		{timestring} 应该匹配 {format} 中指定的格式。

		接受的 {format} 取决于你的系统,因此这不是可移植的!
		有关格式,请参见C函数 strptime() 的手册页。特别要避免使用 "%c"。
		$TZ 的值也很重要。

		如果 {timestring} 不能用 {format} 解析则返回零。
		如果你不知道 {timestring} 的格式,你可以尝试不同的 {format} 值直到得到非零结果。

		另见 |strftime()|。
		示例: >vim
		  echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")
<		  862156163 >vim
		  echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))
<		  Sun Apr 27 11:53:55 1997 >vim
		  echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)
<		  Sun Apr 27 12:53:55 1997

                参数: ~
                  • {format} (`string`)
                  • {timestring} (`string`)

                返回: ~
                  (`integer`)

strridx({haystack}, {needle} [, {start}])                            *strridx()*
		结果是一个数字,它给出字符串 {needle} 在 {haystack} 中最后一次出现的字节索引。
		当指定 {start} 时,忽略此索引之后的匹配。
		这可以用来查找前一个匹配之前的匹配: >vim
			let lastcomma = strridx(line, ",")
			let comma2 = strridx(line, ",", lastcomma - 1)
<		搜索区分大小写。
		对于模式搜索使用 |match()|。
		如果 {needle} 没有在 {haystack} 中出现则返回-1。
		如果 {needle} 为空则返回 {haystack} 的长度。
		另见 |stridx()|。示例: >vim
		  echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		当用于单个字符时,它的工作方式类似于C函数 strrchr()。

                参数: ~
                  • {haystack} (`string`)
                  • {needle} (`string`)
                  • {start} (`integer?`)

                返回: ~
                  (`integer`)

strtrans({string})                                                  *strtrans()*
		结果是一个字符串,它是 {string} 的所有不可打印字符转换为可打印字符 |'isprint'|。
		就像它们在窗口中显示的那样。示例: >vim
			echo strtrans(@a)
<		这将在寄存器a中显示换行符为 "^@" 而不是开始新行。

		出错时返回空字符串。

                参数: ~
                  • {string} (`string`)

                返回: ~
                  (`string`)

strutf16len({string} [, {countcc}])                              *strutf16len()*
		结果是一个数字,它是字符串 {string} 中的UTF-16代码单元数(在将其转换为UTF-16之后)。

		当 {countcc} 为TRUE时,组合字符被单独计算。
		当 {countcc} 被省略或为FALSE时,组合字符被忽略。

		出错时返回零。

		另见 |strlen()| 和 |strcharlen()|。
		示例: >vim
		    echo strutf16len('a')		" 返回 1
		    echo strutf16len('©')		" 返回 1
		    echo strutf16len('😊')		" 返回 2
		    echo strutf16len('ą́')		" 返回 1
		    echo strutf16len('ą́', v:true)	" 返回 3
<

                参数: ~
                  • {string} (`string`)
                  • {countcc} (`0|1?`)

                返回: ~
                  (`integer`)

strwidth({string})                                                  *strwidth()*
		结果是一个数字,它是字符串 {string} 占用的显示单元格数。
		制表符被计为一个单元格,或者使用 |strdisplaywidth()|。
		当 {string} 包含具有东亚宽度类不明确的字符时,此函数的返回值取决于 'ambiwidth'。
		出错时返回零。
		另见 |strlen()|、|strdisplaywidth()| 和 |strchars()|。

                参数: ~
                  • {string} (`string`)

                返回: ~
                  (`integer`)

submatch({nr} [, {list}])                                      *submatch()* *E935*
		仅用于 |:substitute| 命令或 substitute() 函数中的表达式。
		返回匹配文本的第 {nr} 个子匹配。当 {nr} 为0时返回整个匹配的文本。
		注意字符串中的NL可以代表多行匹配的换行符或文本中的NUL字符。
		另见 |sub-replace-expression|。

		如果 {list} 存在且非零,则 submatch() 返回一个字符串列表,
		类似于带有两个参数的 |getline()|。
		文本中的NL字符代表文本中的NUL字符。
		仅在 |:substitute| 中返回多个项目,在 |substitute()| 中此列表将始终包含一个或零个项目,
		因为没有真正的换行符。

		当 substitute() 被递归使用时,只能获取当前(最深层)调用中的子匹配。

		出错时返回空字符串或列表。

		示例: >vim
			s/\d\+/\=submatch(0) + 1/
			echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
<		这会在行中找到第一个数字并加1。
		包含换行符。

                参数: ~
                  • {nr} (`integer`)
                  • {list} (`nil?`)

                返回: ~
                  (`string`)

substitute({string}, {pat}, {sub}, {flags})                       *substitute()*
		结果是一个字符串,它是 {string} 的副本,其中 {pat} 的第一个匹配被替换为 {sub}。
		当 {flags} 为 "g" 时,{string} 中 {pat} 的所有匹配都被替换。
		否则 {flags} 应该为 ""。

		这就像 ":substitute" 命令(不带任何标志)。
		但是与 {pat} 的匹配总是像设置了 'magic' 选项且 'cpoptions' 为空一样完成(为了使脚本可移植)。
		'ignorecase' 仍然相关,如果你想忽略或匹配大小写并忽略 'ignorecase',使用 |/\c| 或 |/\C|。
		不使用 'smartcase'。有关如何使用 {pat},请参见 |string-match|。

		{sub} 中的 "~" 不会被替换为前一个 {sub}。
		注意 {sub} 中的一些代码有特殊含义 |sub-replace-special|。
		例如,要用 "\n" (两个字符)替换某些内容,使用 "\\\\n" 或 '\\n'。

		当 {pat} 在 {string} 中没有匹配时,返回未修改的 {string}。

		示例: >vim
			let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		这会删除 'path' 选项的最后一个组件。>vim
			echo substitute("testing", ".*", "\\U\\0", "")
<		结果为 "TESTING"。

		当 {sub} 以 "\=" 开头时,其余部分被解释为表达式。参见 |sub-replace-expression|。
		示例: >vim
			echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" .. submatch(1))', 'g')

<		当 {sub} 是一个 Funcref 时,该函数被调用,带有一个可选参数。示例: >vim
		   echo substitute(s, '%\(\x\x\)', SubNr, 'g')
<		可选参数是一个列表,它包含整个匹配的字符串和最多九个子匹配,就像 |submatch()| 返回的那样。
		示例: >vim
		   echo substitute(s, '%\(\x\x\)', {m -> '0x' .. m[1]}, 'g')

<		出错时返回空字符串。

                参数: ~
                  • {string} (`string`)
                  • {pat} (`string`)
                  • {sub} (`string`)
                  • {flags} (`string`)

                返回: ~
                  (`string`)

swapfilelist()                                                  *swapfilelist()*
		返回交换文件名的列表,就像 "vim -r" 显示的那样。
		参见 |-r| 命令参数。使用 'directory' 选项来检查目录。
		如果你只想获取当前目录中的交换文件列表,则临时将 'directory' 设置为点: >vim
			let save_dir = &directory
			let &directory = '.'
			let swapfiles = swapfilelist()
			let &directory = save_dir

                返回: ~
                  (`string[]`)

swapinfo({fname})                                                   *swapinfo()*
		结果是一个字典,它包含关于交换文件 {fname} 的信息。可用字段有:
			version Vim版本
			user	用户名
			host	主机名
			fname	原始文件名
			pid	创建交换文件的Nvim进程的PID,如果未运行则为零。
			mtime	最后修改时间(秒)
			inode	可选:文件的INODE号
			dirty	如果文件被修改则为1,否则为0
		失败时添加一个 "error" 项,原因如下:
			Cannot open file: 找不到文件或无法访问
			Cannot read file: 无法读取第一个块
			Not a swap file: 不包含正确的块ID
			Magic number mismatch: 第一个块中的信息无效

                参数: ~
                  • {fname} (`string`)

                返回: ~
                  (`any`)

swapname({buf})                                                     *swapname()*
		结果是缓冲区 {buf} 的交换文件路径。
		对于 {buf} 的使用,参见上面的 |bufname()|。
		如果缓冲区 {buf} 是当前缓冲区,则结果等于 |:swapname| (除非没有交换文件)。
		如果缓冲区 {buf} 没有交换文件,返回空字符串。

                参数: ~
                  • {buf} (`integer|string`)

                返回: ~
                  (`string`)

synID({lnum}, {col}, {trans})                                          *synID()*
		结果是一个数字,它是当前窗口中位置 {lnum} 和 {col} 处的语法ID。
		语法ID可以与 |synIDattr()| 和 |synIDtrans()| 一起使用,
		以获取关于文本的语法信息。

		{col} 是1表示最左边的列,{lnum} 是1表示第一行。
		应用 'synmaxcol',在较长的行中返回零。
		注意当位置在最后一个字符之后时,这是光标在插入模式下可以位于的位置,
		synID() 返回零。{lnum} 的使用方式与 |getline()| 相同。

		当 {trans} 为 |TRUE| 时,透明项被简化为它们显示的项目。
		这在想要知道有效颜色时很有用。
		当 {trans} 为 |FALSE| 时,返回透明项。
		这在想要知道哪个语法项有效时很有用(例如在括号内)。
		警告:此函数可能非常慢。通过向前方向遍历文件可以获得最佳速度。

		出错时返回零。

		示例(回显光标下的语法项名称): >vim
			echo synIDattr(synID(line("."), col("."), 1), "name")
<

                参数: ~
                  • {lnum} (`integer`)
                  • {col} (`integer`)
                  • {trans} (`0|1`)

                返回: ~
                  (`integer`)

synIDattr({synID}, {what} [, {mode}])                              *synIDattr()*
		结果是一个字符串,它是语法ID {synID} 的 {what} 属性。
		这可以用来获取关于语法项的信息。
		{mode} 可以是 "gui" 或 "cterm",以获取该模式的属性。
		当 {mode} 被省略或使用无效值时,使用当前活动的高亮显示的属性(GUI或cterm)。
		使用 synIDtrans() 来跟踪链接的高亮组。
		{what}		结果
		"name"		语法项的名称
		"fg"		前景色(GUI:用于设置颜色的颜色名称,
				cterm:作为字符串的颜色编号,
				term:空字符串)
		"bg"		背景色(与 "fg" 相同)
		"font"		字体名称(仅在GUI中可用)
				|highlight-font|
		"sp"		特殊颜色(与 "fg" 相同) |guisp|
		"fg#"		类似于 "fg",但用于GUI且GUI以 "#RRGGBB" 形式运行名称
		"bg#"		类似于 "fg#" 用于 "bg"
		"sp#"		类似于 "fg#" 用于 "sp"
		"bold"		如果为粗体则为 "1"
		"italic"	如果为斜体则为 "1"
		"reverse"	如果为反显则为 "1"
		"inverse"	如果为反显则为 "1" (= reverse)
		"standout"	如果为突出显示则为 "1"
		"underline"	如果为下划线则为 "1"
		"undercurl"	如果为下划线卷曲则为 "1"
		"underdouble"	如果为双下划线则为 "1"
		"underdotted"	如果为点下划线则为 "1"
		"underdashed"	如果为虚下划线则为 "1"
		"strikethrough"	如果为删除线则为 "1"
		"altfont"	如果为替代字体则为 "1"
		"nocombine"	如果为不组合则为 "1"

		出错时返回空字符串。

		示例(回显光标下的语法项的颜色): >vim
			echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
		也可以作为 |method| 使用: >vim
			echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")
<

                参数: ~
                  • {synID} (`integer`)
                  • {what} (`string`)
                  • {mode} (`string?`)

                返回: ~
                  (`string`)

synIDtrans({synID})                                               *synIDtrans()*
		结果是一个数字,它是 {synID} 的转换后的语法ID。
		这是用于高亮显示该字符的语法组ID。
		使用 ":highlight link" 给出的高亮链接被跟踪。

		出错时返回零。

                参数: ~
                  • {synID} (`integer`)

                返回: ~
                  (`integer`)

synconcealed({lnum}, {col})                                     *synconcealed()*
		结果是一个 |List|,目前包含三个项目:
		1. 列表中的第一个项目是0,如果位置 {lnum} 和 {col} 的字符不是可隐藏区域的一部分,
		   如果它是则为1。{lnum} 的使用方式与 |getline()| 相同。
		2. 列表中的第二个项目是一个字符串。如果第一个项目是1,
		   第二个项目包含将根据 'conceallevel' 和 'listchars' 的当前设置
		   显示在隐藏文本位置的文本。
		3. 列表中的第三个也是最后一个项目是一个数字,
		   表示行中匹配的特定语法区域。当字符未被隐藏时值为零。
		   这允许检测新的可隐藏区域的开始,如果有两个具有相同替换字符的连续区域。
		   例如,如果文本是 "123456" 且 "23" 和 "45" 都被隐藏并替换为字符 "X",则:
			call			returns ~
			synconcealed(lnum, 1)   [0, '', 0]
			synconcealed(lnum, 2)   [1, 'X', 1]
			synconcealed(lnum, 3)   [1, 'X', 1]
			synconcealed(lnum, 4)   [1, 'X', 2]
			synconcealed(lnum, 5)   [1, 'X', 2]
			synconcealed(lnum, 6)   [0, '', 0]

		注意:不考虑 |matchadd()| 高亮项目,
		因为语法和匹配高亮是两个不同的机制 |syntax-vs-match|。

                参数: ~
                  • {lnum} (`integer`)
                  • {col} (`integer`)

                返回: ~
                  (`[integer, string, integer]`)

synstack({lnum}, {col})                                             *synstack()*
		返回一个 |List|,它是当前窗口中位置 {lnum} 和 {col} 处的语法项栈。
		{lnum} 的使用方式与 |getline()| 相同。
		列表中的每个项目都是一个ID,就像 |synID()| 返回的那样。
		列表中的第一个项目是外部区域,后面是包含在该区域中的项目。
		最后一个是 |synID()| 返回的内容,除非整个项目未被高亮显示或它是透明项。
		此函数对于调试语法文件很有用。
		显示光标下的语法栈的示例: >vim
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
<		当用 {lnum} 和 {col} 指定的位置无效时返回空列表。
		行中最后一个字符之后的位置和空行中的第一列是有效位置。

                参数: ~
                  • {lnum} (`integer`)
                  • {col} (`integer`)

                返回: ~
                  (`integer[]`)

system({cmd} [, {input}])                                        *system()* *E677*
		注意:在Lua中优先使用 |vim.system()|。

		获取 {cmd} 的输出作为 |string| (|systemlist()| 返回一个 |List|)
		并设置 |v:shell_error| 为错误代码。
		{cmd} 的处理方式与 |jobstart()| 相同:
		如果 {cmd} 是一个列表,它直接运行(不使用 'shell')。
		如果 {cmd} 是一个字符串,它在 'shell' 中运行,像这样: >vim
		  call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])

<		不要用于交互式命令。

		结果是一个字符串,经过过滤以避免平台特定的怪癖:
		- <CR><NL> 被替换为 <NL>
		- NUL字符被替换为SOH(0x01)

		示例: >vim
		    echo system(['ls', expand('%:h')])

<		如果 {input} 是一个字符串,它被写入管道并作为stdin传递给命令。
		字符串按原样写入,行分隔符不会改变。
		如果 {input} 是一个 |List|,它被写入管道,就像 |writefile()| 使用 {binary} 设置为 "b" 那样
		(即在每个列表项之间有一个换行符,列表项内的换行符转换为NUL)。
		当 {input} 被给出且是有效的缓冲区id时,缓冲区的内容被逐行写入文件,
		每行以NL结尾(文本中有NL的地方有NUL)。
								*E5677*
		注意:system() 不能写入或读取后台("&")shell命令,例如: >vim
		    echo system("cat - &", "foo")
<		这相当于: >
		    $ echo foo | bash -c 'cat - &'
<		在输入可以到达它之前,管道被断开(除非被shell重定向语法覆盖)。
		使用 |jobstart()| 代替。

		注意:使用 |shellescape()| 或 |::S| 与 |expand()| 或 |fnamemodify()| 一起使用
		来转义命令参数中的特殊字符。'shellquote' 和 'shellxquote' 必须正确配置。
		示例: >vim
		    echo system('ls '..shellescape(expand('%:h')))
		    echo system('ls '..expand('%:h:S'))

<		与 ":!cmd" 不同,没有自动检查更改的文件。
		使用 |:checktime| 强制检查。

                参数: ~
                  • {cmd} (`string|string[]`)
                  • {input} (`string|string[]|integer?`)

                返回: ~
                  (`string`)

systemlist({cmd} [, {input} [, {keepempty}]])                     *systemlist()*
		与 |system()| 相同,但返回一个 |List|,其中包含行(由NL分隔的输出部分),
		NUL转换为NL。输出与 |readfile()| 使用 {binary} 参数设置为 "b" 时的输出相同,
		除了不保留最后的换行符,除非 {keepempty} 非零。
		注意在MS-Windows上你可能会得到尾随的CR字符。

		要查看 "echo hello" 和 "echo -n hello" 的区别,使用 |system()| 和 |split()|: >vim
			echo split(system('echo hello'), '\n', 1)
<
		出错时返回空字符串。

                参数: ~
                  • {cmd} (`string|string[]`)
                  • {input} (`string|string[]|integer?`)
                  • {keepempty} (`integer?`)

                返回: ~
                  (`string[]`)

tabpagebuflist([{arg}])                                       *tabpagebuflist()*
		结果是一个 |List|,其中每个项目是与当前标签页中每个窗口关联的缓冲区编号。
		{arg} 指定要使用的标签页的编号。当省略时使用当前标签页。
		当 {arg} 无效时返回数字零。
		要获取所有标签页中所有缓冲区的列表,使用这个: >vim
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		注意缓冲区可能出现在多个窗口中。

                参数: ~
                  • {arg} (`integer?`)

                返回: ~
                  (`any`)

tabpagenr([{arg}])                                                 *tabpagenr()*
		结果是一个数字,它是当前标签页的编号。第一个标签页的编号为1。

		可选参数 {arg} 支持以下值:
			$	最后一个标签页的编号(标签页计数)。
			#	最后访问的标签页的编号(|g<Tab>| 跳转到的地方)。
			    如果没有前一个标签页,返回0。
		该数字可以与 |:tab| 命令一起使用。

		出错时返回零。

                参数: ~
                  • {arg} (`'$'|'#'?`)

                返回: ~
                  (`integer`)

tabpagewinnr({tabarg} [, {arg}])                                *tabpagewinnr()*
		类似于 |winnr()|,但用于标签页 {tabarg}。
		{tabarg} 指定要使用的标签页的编号。
		{arg} 的使用方式与 |winnr()| 相同:
		- 当省略时返回当前窗口编号。这是跳转到此标签页时将使用的窗口。
		- 当为 "$" 时返回窗口数。
		- 当为 "#" 时返回前一个窗口编号。
		有用的示例: >vim
		    tabpagewinnr(1)	    " 标签页1的当前窗口
		    tabpagewinnr(4, '$')    " 标签页4中的窗口数
<		当 {tabarg} 无效时返回零。

                参数: ~
                  • {tabarg} (`integer`)
                  • {arg} (`'$'|'#'?`)

                返回: ~
                  (`integer`)

tagfiles()                                                          *tagfiles()*
		返回一个 |List|,其中包含用于搜索当前缓冲区的标签的文件名。
		这是展开的 'tags' 选项。

                返回: ~
                  (`string[]`)

taglist({expr} [, {filename}])                                       *taglist()*
		返回一个 |List|,其中包含与正则表达式 {expr} 匹配的标签。

		如果传递了 {filename},它用于以与 |:tselect| 相同的方式优先考虑结果。
		参见 |tag-priority|。
		{filename} 应该是文件的完整路径。

		每个列表项是一个 |Dictionary|,至少包含以下条目:
			name		标签的名称。
			filename	定义标签的文件名。它要么相对于当前目录,
				要么是完整路径。
			cmd		用于在文件中定位标签的Ex命令。
			kind		标签的类型。此条目的值取决于语言特定的kind值。
				仅在使用由Universal/Exuberant ctags或hdrtag生成的标签文件时可用。
			static		文件特定的标签。有关更多信息,请参见 |static-tag|。
		可能还有其他条目,取决于标签文件的内容:access、implementation、inherits和signature。
		有关这些字段的信息,请参见ctags文档。
		对于C代码,可能会出现 "struct"、"class" 和 "enum" 字段,
		它们给出包含标签的实体的名称。

		ex-command "cmd" 可以是ex搜索模式、行号或后跟字节号的行号。

		如果没有匹配的标签,则返回空列表。

		要获得精确的标签匹配,应该在 {expr} 中使用锚点 '^' 和 '$'。
		这也使函数工作得更快。
		有关标签搜索正则表达式模式的更多信息,请参见 |tag-regexp|。

		有关Vim如何定位标签文件的信息,请参见 |'tags'|。
		有关不同ctags工具生成的标签文件格式的信息,请参见 |tags-file-format|。

                参数: ~
                  • {expr} (`any`)
                  • {filename} (`string?`)

                返回: ~
                  (`any`)

tan({expr})                                                              *tan()*
		返回 {expr} 的正切值,以弧度为单位,作为范围 [-inf, inf] 中的 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|,则返回0.0。
		示例: >vim
			echo tan(10)
<			0.648361 >vim
			echo tan(-4.01)
<			-1.181502

                参数: ~
                  • {expr} (`number`)

                返回: ~
                  (`number`)

tanh({expr})                                                            *tanh()*
		返回 {expr} 的双曲正切值,作为范围 [-1, 1] 中的 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|,则返回0.0。
		示例: >vim
			echo tanh(0.5)
<			0.462117 >vim
			echo tanh(-1)
<			-0.761594

                参数: ~
                  • {expr} (`number`)

                返回: ~
                  (`number`)

tempname()                                                          *tempname()*
		生成一个位于Nvim根目录 |tempdir| 中的(不存在的)文件名。
		脚本可以使用该文件名作为临时文件。
		示例: >vim
			let tmpfile = tempname()
			exe "redir > " .. tmpfile
<

                返回: ~
                  (`string`)

test_garbagecollect_now()                            *test_garbagecollect_now()*
		类似于 |garbagecollect()|,但立即执行。这必须直接调用以避免任何结构在内部存在,
		并且在调用任何函数之前必须设置 |v:testing|。   *E1142*

                返回: ~
                  (`any`)

timer_info([{id}])                                                *timer_info()*
		返回一个包含定时器信息的列表。
		当给出 {id} 时只返回关于此定时器的信息。
		当定时器 {id} 不存在时返回空列表。
		当 {id} 被省略时返回关于所有定时器的信息。

		对于每个定时器,信息存储在一个 |Dictionary| 中,包含这些项目:
		    "id"	    定时器ID
		    "time"	    定时器启动的时间
		    "repeat"	    定时器还将触发的次数;
				    -1表示永远
		    "callback"	    回调

                参数: ~
                  • {id} (`integer?`)

                返回: ~
                  (`any`)

timer_pause({timer}, {paused})                                   *timer_pause()*
		暂停或恢复定时器。暂停的定时器在其时间到期时不会调用其回调。
		恢复定时器可能导致回调几乎立即被调用,如果已经过去了足够的时间。

		暂停定时器对于避免回调在短时间内被调用很有用。

		如果 {paused} 计算为非零数字或非空字符串,则定时器被暂停,
		否则它被恢复。参见 |non-zero-arg|。

                参数: ~
                  • {timer} (`integer`)
                  • {paused} (`boolean`)

                返回: ~
                  (`any`)

timer_start({time}, {callback} [, {options}])              *timer_start()* *timer*
		创建一个定时器并返回定时器ID。

		{time} 是等待时间,以毫秒为单位。这是在调用回调之前的最小时间。
		当系统繁忙或Vim不在等待输入时,时间会更长。
		可以使用零来在Vim回到主循环时执行回调。

		{callback} 是要调用的函数。它可以是函数名或 |Funcref|。
		它被调用时带有一个参数,即定时器ID。
		回调仅在Vim等待输入时被调用。

		{options} 是一个字典。支持的条目:
		   "repeat"	重复回调的次数。
				-1表示永远。默认为1。
				如果定时器连续三次导致错误,则取消重复。

		出错时返回-1。

		示例: >vim
			func MyHandler(timer)
			  echo 'Handler called'
			endfunc
			let timer = timer_start(500, 'MyHandler',
				\ {'repeat': 3})
<		这将在500毫秒的间隔内调用MyHandler()三次。

                参数: ~
                  • {time} (`number`)
                  • {callback} (`string|function`)
                  • {options} (`table?`)

                返回: ~
                  (`any`)

timer_stop({timer})                                               *timer_stop()*
		停止定时器。定时器回调将不再被调用。
		{timer} 是由 timer_start() 返回的ID,因此它必须是一个数字。
		如果 {timer} 不存在则没有错误。

                参数: ~
                  • {timer} (`integer`)

                返回: ~
                  (`any`)

timer_stopall()                                                *timer_stopall()*
		停止所有定时器。定时器回调将不再被调用。
		如果某些定时器行为不当,这很有用。
		如果没有定时器则没有错误。

                返回: ~
                  (`any`)

tolower({expr})                                                      *tolower()*
		结果是一个字符串,它是给定的字符串的副本,所有大写字符都转换为小写
		(就像对字符串应用 |gu| 一样)。出错时返回空字符串。

                参数: ~
                  • {expr} (`string`)

                返回: ~
                  (`string`)

toupper({expr})                                                      *toupper()*
		结果是一个字符串,它是给定的字符串的副本,所有小写字符都转换为大写
		(就像对字符串应用 |gU| 一样)。出错时返回空字符串。

                参数: ~
                  • {expr} (`string`)

                返回: ~
                  (`string`)

tr({src}, {fromstr}, {tostr})                                             *tr()*
		结果是一个字符串,它是 {src} 字符串的副本,其中所有出现在 {fromstr} 中的字符
		都被替换为 {tostr} 字符串中该位置的字符。
		因此 {fromstr} 中的第一个字符被转换为 {tostr} 中的第一个字符,依此类推。
		完全像unix "tr" 命令。
		此代码也正确处理多字节字符。

		出错时返回空字符串。

		示例: >vim
			echo tr("hello there", "ht", "HT")
<		返回 "Hello THere" >vim
			echo tr("<blob>", "<>", "{}")
<		返回 "{blob}"

                参数: ~
                  • {src} (`string`)
                  • {fromstr} (`string`)
                  • {tostr} (`string`)

                返回: ~
                  (`string`)

trim({text} [, {mask} [, {dir}]])                                       *trim()*
		返回一个字符串，其中从{text}的开头和/或结尾移除{mask}中的任何字符。

		如果未提供{mask}，或者{mask}为空字符串，则{mask}为所有0x20以下的字符，
		包括Tab、空格、换行符和回车符，以及不间断空格字符0xa0。

		可选的{dir}参数指定在哪里移除字符：
			0	从{text}的开头和结尾移除
			1	仅从{text}的开头移除
			2	仅从{text}的结尾移除
		当省略时，两端都会被修剪。

		此函数正确处理多字节字符。
		出错时返回空字符串。

		示例：>vim
			echo trim("   some text ")
<		返回 "some text" >vim
			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") .. "_TAIL"
<		返回 "RESERVE_TAIL" >vim
			echo trim("rm<Xrm<>X>rrm", "rm<>")
<		返回 "Xrm<>X"（中间的字符不会被移除）>vim
			echo trim("  vim  ", " ", 2)
<		返回 "  vim"

                参数：~
                  • {text} (`string`)
                  • {mask} (`string?`)
                  • {dir} (`0|1|2?`)

                返回：~
                  (`string`)

trunc({expr})                                                          *trunc()*
		返回一个|Float|类型的最大整数值，其大小小于或等于{expr}（向零截断）。
		{expr}必须计算为|Float|或|Number|。
		如果{expr}不是|Float|或|Number|，则返回0.0。
		示例：>vim
			echo trunc(1.456)
<			1.0  >vim
			echo trunc(-5.456)
<			-5.0  >vim
			echo trunc(4.0)
<			4.0

                参数：~
                  • {expr} (`number`)

                返回：~
                  (`integer`)

type({expr})                                                            *type()*
		结果是一个表示{expr}类型的数字。
		与其直接使用这个数字，不如使用具有以下值的v:t_变量：
			Number:	    0  |v:t_number|
			String:	    1  |v:t_string|
			Funcref:    2  |v:t_func|
			List:	    3  |v:t_list|
			Dictionary: 4  |v:t_dict|
			Float:	    5  |v:t_float|
			Boolean:    6  |v:t_bool| (|v:false| 和 |v:true|)
			Null:	    7  (|v:null|)
			Blob:	   10  |v:t_blob|
		为了向后兼容，可以使用以下方法：>vim
			if type(myvar) == type(0) | endif
			if type(myvar) == type("") | endif
			if type(myvar) == type(function("tr")) | endif
			if type(myvar) == type([]) | endif
			if type(myvar) == type({}) | endif
			if type(myvar) == type(0.0) | endif
			if type(myvar) == type(v:true) | endif
<		与其检查|v:null|类型，不如直接检查|v:null|，因为它是此类型的唯一值：>vim
			if myvar is v:null | endif
<		要检查v:t_变量是否存在，请使用：>vim
			if exists('v:t_number') | endif
<

                参数：~
                  • {expr} (`any`)

                返回：~
                  (`integer`)

undofile({name})                                                    *undofile()*
		返回用于写入名为{name}的文件时将使用的撤销文件名。
		这使用'undodir'选项，查找存在的目录。
		它不检查撤销文件是否存在。
		{name}总是被展开为完整路径，因为这是内部使用的。
		如果{name}为空，undofile()返回空字符串，因为没有文件名的缓冲区不会写入撤销文件。
		与|:wundo|和|:rundo|结合使用很有用。

                参数：~
                  • {name} (`string`)

                返回：~
                  (`string`)

undotree([{buf}])                                                   *undotree()*
		返回当前缓冲区的撤销树状态，如果提供了{buf}，则返回特定缓冲区的状态。
		结果是一个包含以下项目的字典：
		  "seq_last"	使用的最高撤销序列号。
		  "seq_cur"	撤销树中当前位置的序列号。
				当某些更改被撤销时，这与"seq_last"不同。
		  "time_cur"	最后一次用于|:earlier|和相关命令的时间。
				使用|strftime()|转换为可读格式。
		  "save_last"	最后一次文件写入的编号。尚未写入时为0。
		  "save_cur"	撤销树中当前位置的编号。
		  "synced"	当最后一个撤销块同步时为非零。
				这发生在等待用户输入时。参见|undo-blocks|。
		  "entries"	包含撤销块信息的字典列表。

		"entries"列表中的第一项是最旧的撤销项。
		每个列表项都是一个包含以下项目的|Dictionary|：
		  "seq"		撤销序列号。与|:undolist|中显示的相同。
		  "time"	更改发生的时间戳。使用|strftime()|转换为可读格式。
		  "newhead"	仅出现在最后添加的项目中。
				这标记了最后一个更改以及将添加进一步更改的位置。
		  "curhead"	仅出现在最后撤销的项目中。
				这标记了撤销树中的当前位置，即重做命令将使用的块。
				如果在最后一次更改后没有撤销任何内容，此项目将不会出现在任何地方。
		  "save"	仅出现在文件写入前的最后一个块上。
				数字是写入计数。第一次写入的编号为1，最后一次是上面提到的"save_last"。
		  "alt"		替代条目。这又是一个撤销块列表。
				每个项目可能又有一个"alt"项目。

                参数：~
                  • {buf} (`integer|string?`)

                返回：~
                  (`vim.fn.undotree.ret`)

uniq({list} [, {func} [, {dict}]])                                 *uniq()* *E882*
		原地移除{list}中重复相邻项的第二份及后续副本。
		返回{list}。如果你想保持列表不变，请先复制：>vim
			let newlist = uniq(copy(mylist))
<		默认比较函数使用每个项的字符串表示。
		关于{func}和{dict}的使用，请参见|sort()|。

		如果{list}不是|List|，则返回零。

                参数：~
                  • {list} (`any`)
                  • {func} (`any?`)
                  • {dict} (`any?`)

                返回：~
                  (`any[]|0`)

utf16idx({string}, {idx} [, {countcc} [, {charidx}]])               *utf16idx()*
		与|charidx()|相同，但返回{string}中{idx}处字节的UTF-16代码单元索引
		（在将其转换为UTF-16之后）。

		当{charidx}存在且为TRUE时，{idx}用作字符串{string}中的字符索引，
		而不是字节索引。
		在UTF-8序列中间的{idx}向下取整到该序列的开始。

		如果参数无效或{string}中的字节数少于{idx}，则返回-1。
		如果正好有{idx}个字节，则返回字符串在UTF-16代码单元中的长度。

		有关从UTF-16索引获取字节索引，请参见|byteidx()|和|byteidxcomp()|，
		有关从UTF-16索引获取字符索引，请参见|charidx()|。
		更多信息请参考|string-offset-encoding|。
		示例：>vim
			echo utf16idx('a😊😊', 3)	" 返回 2
			echo utf16idx('a😊😊', 7)	" 返回 4
			echo utf16idx('a😊😊', 1, 0, 1)	" 返回 2
			echo utf16idx('a😊😊', 2, 0, 1)	" 返回 4
			echo utf16idx('aą́c', 6)		" 返回 2
			echo utf16idx('aą́c', 6, 1)	" 返回 4
			echo utf16idx('a😊😊', 9)	" 返回 -1
<

                参数：~
                  • {string} (`string`)
                  • {idx} (`integer`)
                  • {countcc} (`boolean?`)
                  • {charidx} (`boolean?`)

                返回：~
                  (`integer`)

values({dict})                                                        *values()*
		返回一个包含{dict}所有值的|List|。
		|List|的顺序是任意的。
		另请参见|items()|和|keys()|。
		如果{dict}不是|Dict|，则返回零。

                参数：~
                  • {dict} (`any`)

                返回：~
                  (`any`)

vim:tw=78:ts=8:noet:ft=help:norl:
