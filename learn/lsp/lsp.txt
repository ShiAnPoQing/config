LSP client/framework                                     *lsp* *LSP*

Nvim 支持语言服务器协议（LSP），这意味着它可以作为 LSP 服务器的客户端，并包含一个用于构建增强型 LSP 工具的 Lua 框架 `vim.lsp`。

    https://microsoft.github.io/language-server-protocol/

LSP 通过语义的全项目分析（不同于 |ctags|）实现诸如跳转到定义、查找引用、悬停、补全、重命名、格式化、重构等功能。

                                      输入 |gO| 查看目录表。

==============================================================================
QUICKSTART                                              *lsp-quickstart*

Nvim 提供了一个 LSP 客户端，但服务器由第三方提供。
按照以下步骤获取 LSP 功能：

1. 使用你的包管理器或按照上游安装说明安装语言服务器。你可以在这里找到语言服务器：
   https://microsoft.github.io/language-server-protocol/implementors/servers/

2. 使用 |vim.lsp.config()| 为 LSP 客户端定义配置。
    示例： >lua
      vim.lsp.config['luals'] = {
        -- 启动服务器的命令和参数。
        cmd = { 'lua-language-server' },

        -- 要自动附加的文件类型。
        filetypes = { 'lua' },

        -- 将“根目录”设置为当前缓冲区文件的父目录，该目录包含“.luarc.json”或
        -- “.luarc.jsonc”文件。共享根目录的文件将复用同一个 LSP 服务器的连接。
        root_markers = { '.luarc.json', '.luarc.jsonc' },

        -- 要发送到服务器的特定设置。此结构由服务器定义。例如 lua-language-server
        -- 的结构可在此处找到 https://raw.githubusercontent.com/LuaLS/vscode-lua/master/setting/schema.json
        settings = {
          Lua = {
            runtime = {
              version = 'LuaJIT',
            }
          }
        }
      }
<
3. 使用 |vim.lsp.enable()| 启用一个配置。
   示例： >lua
     vim.lsp.enable('luals')
<
4. 重启 Nvim，或使用“:edit”重新加载缓冲区。

5. 检查 LSP 是否对缓冲区处于活动（“已附加”）状态： >vim
    :checkhealth vim.lsp
<
6. （可选）配置按键映射和自动命令以使用 LSP 功能。
   |lsp-attach|

==============================================================================
DEFAULTS                                                *lsp-defaults*

当 Nvim LSP 客户端启动时，它会启用诊断 |vim.diagnostic|（见
|vim.diagnostic.config()| 以自定义）。如果（1）语言服务器支持该功能且（2）
选项为空或由内置运行时（ftplugin）文件设置，则还会设置以下各种默认选项。
当 LSP 客户端停止或分离时，这些选项不会恢复。

- 'omnifunc' 被设置为 |vim.lsp.omnifunc()|，使用 |i_CTRL-X_CTRL-O| 触发补全。
- 'tagfunc' 被设置为 |vim.lsp.tagfunc()|。这启用诸如跳转到定义、|:tjump| 和
  |CTRL-]|、|CTRL-W_]|、|CTRL-W_}| 等按键映射以利用语言服务器的功能。
- 'formatexpr' 被设置为 |vim.lsp.formatexpr()|，因此如果语言服务器支持，可以通过
  |gq| 格式化行。
  - 若不想使用，可用 |gw| 替代 gq，或在 |LspAttach| 时清除 'formatexpr'。
- |K| 被映射为 |vim.lsp.buf.hover()|，除非 |'keywordprg'| 被自定义或
  已存在 K 的自定义按键映射。

                                          *grr* *gra* *grn* *gri* *i_CTRL-S*
Nvim 启动时无条件创建以下按键映射：
- 普通模式下 "grn" 映射为 |vim.lsp.buf.rename()|
- 普通和可视模式下 "gra" 映射为 |vim.lsp.buf.code_action()|
- 普通模式下 "grr" 映射为 |vim.lsp.buf.references()|
- 普通模式下 "gri" 映射为 |vim.lsp.buf.implementation()|
- 普通模式下 "gO" 映射为 |vim.lsp.buf.document_symbol()|
- 插入模式下 CTRL-S 映射为 |vim.lsp.buf.signature_help()|

如不需要，可随时使用 |vim.keymap.del()| 或 |:unmap| 移除这些按键映射（另见 |gr-default|）。

                                                        *lsp-defaults-disable*
要覆盖或删除上述任何默认值，请在 |LspAttach| 时设置或取消设置选项： >lua

    vim.api.nvim_create_autocmd('LspAttach', {
      callback = function(args)
        -- 取消设置 'formatexpr'
        vim.bo[args.buf].formatexpr = nil
        -- 取消设置 'omnifunc'
        vim.bo[args.buf].omnifunc = nil
        -- 取消映射 K
        vim.keymap.del('n', 'K', { buffer = args.buf })
      end,
    })
<


==============================================================================
CONFIG                                                  *lsp-config*

你可以通过 vim.lsp.config() 静态配置 LSP 行为，也可以通过 |lsp-attach| 或 |Client:on_attach()| 动态配置。

使用 |vim.lsp.config()| 定义并有选择地启用 LSP 配置。
这基本上是 |vim.lsp.start()| 的一个包装器，允许你共享和合并配置（这些配置可能由 Nvim 或第三方插件提供）。

当 LSP 客户端启动时，它会通过以下方式合并配置（优先级递增）：

1. 为 `'*'` 名称定义的配置。
2. 对于名为 `name` 的服务器，合并所有 `lsp/<name>.lua` 文件在 'runtimepath' 下返回的表。
3. 其他地方定义的配置。

注意：配置的合并语义遵循 |vim.tbl_deep_extend()| 的行为。

示例：给定如下配置... >lua
  -- 在 init.lua 中定义
  vim.lsp.config('*', {
    capabilities = {
      textDocument = {
        semanticTokens = {
          multilineTokenSupport = true,
        }
      }
    },
    root_markers = { '.git' },
  })

  -- 在 <rtp>/lsp/clangd.lua 中定义
  return {
    cmd = { 'clangd' },
    root_markers = { '.clangd', 'compile_commands.json' },
    filetypes = { 'c', 'cpp' },
  }

  -- 在 init.lua 中定义
  vim.lsp.config('clangd', {
    filetypes = { 'c' },
  })
<
...合并结果为： >lua
  {
    -- 来自 <rtp>/lsp/clangd.lua 的 clangd 配置
    cmd = { 'clangd' },

    -- 来自 <rtp>/lsp/clangd.lua 的 clangd 配置
    -- 覆盖了 init.lua 中的 "*" 配置
    root_markers = { '.clangd', 'compile_commands.json' },

    -- 来自 init.lua 的 clangd 配置
    -- 覆盖了 <rtp>/lsp/clangd.lua 中的 clangd 配置
    filetypes = { 'c' },

    -- 来自 init.lua 的 "*" 配置
    capabilities = {
      textDocument = {
        semanticTokens = {
          multilineTokenSupport = true,
        }
      }
    }
  }
<
                                                        *lsp-attach*
要使用 Nvim 提供之外的 LSP 功能（见 |lsp-buf|），你可以在 |Client:on_attach()| 或 |LspAttach| 上设置按键映射和选项。
并非所有语言服务器都提供相同的能力；请在你的 LspAttach 处理器中检查 `supports_method()`。
                                                        *lsp-lint* *lsp-format*
示例：启用自动补全和自动格式化（“linting”）： >lua

    vim.api.nvim_create_autocmd('LspAttach', {
      group = vim.api.nvim_create_augroup('my.lsp', {}),
      callback = function(args)
        local client = assert(vim.lsp.get_client_by_id(args.data.client_id))
        if client:supports_method('textDocument/implementation') then
          -- 为 vim.lsp.buf.implementation 创建按键映射 ...
        end

        -- 启用自动补全。注意：使用 CTRL-Y 选择条目。|complete_CTRL-Y|
        if client:supports_method('textDocument/completion') then
          -- 可选：在每次按键时触发自动补全。可能会很慢！
          -- local chars = {}; for i = 32, 126 do table.insert(chars, string.char(i)) end
          -- client.server_capabilities.completionProvider.triggerCharacters = chars

          vim.lsp.completion.enable(true, client.id, args.buf, {autotrigger = true})
        end

        -- 保存时自动格式化（“lint”）。
        -- 如果服务器支持 "textDocument/willSaveWaitUntil" 通常不需要。
        if not client:supports_method('textDocument/willSaveWaitUntil')
            and client:supports_method('textDocument/formatting') then
          vim.api.nvim_create_autocmd('BufWritePre', {
            group = vim.api.nvim_create_augroup('my.lsp', {clear=false}),
            buffer = args.buf,
            callback = function()
              vim.lsp.buf.format({ bufnr = args.buf, id = client.id, timeout_ms = 1000 })
            end,
          })
        end
      end,
    })
<
要查看给定服务器的能力，在 LSP 启用的缓冲区中尝试： >vim

    :lua =vim.lsp.get_clients()[1].server_capabilities

================================================================================
FAQ                                                     *lsp-faq*

- 问：如何强制重载 LSP？
- 答：停止所有客户端，然后重载缓冲区。 >vim
     :lua vim.lsp.stop_client(vim.lsp.get_clients())
     :edit

- 问：为什么补全不起作用？
- 答：在你想用 LSP 的缓冲区中，检查 'omnifunc' 是否被设置为
     "v:lua.vim.lsp.omnifunc"：`:verbose set omnifunc?`
     - 可能有其他插件覆盖了该选项。为避免这种情况，你可以在 |after-directory| ftplugin 中设置该选项，例如
       "after/ftplugin/python.vim"。

- 问：如何同步运行请求（例如保存文件时格式化）？
- 答：检查该函数是否有 `async` 参数并将其设置为 false。例如代码格式化： >vim

     " 在保存 *.rs（rust）文件前自动格式化
     " （async = false 是 format 的默认值）
     autocmd BufWritePre *.rs lua vim.lsp.buf.format({ async = false })
<
                                                        *lsp-vs-treesitter*
- 问：LSP 和 Treesitter 有什么区别？
- 答：LSP 需要一个客户端和语言服务器。
        语言服务器使用语义分析来理解项目级别的代码。这使得语言服务器能够跨文件重命名、查找外部库中的定义等。

     |treesitter| 是一个语言解析库，为增量解析文本和处理错误提供了极佳的工具。
     这使其非常适合编辑器理解当前文件内容，如语法高亮、简单的跳转到定义、作用域分析等。

================================================================================
LSP API                                                 *lsp-api*

|lsp-core| API 提供用于创建和管理客户端的核心函数。
|lsp-buf| 函数为附加到当前缓冲区的 LSP 客户端执行操作。

                                                                  *lsp-method*
LSP 规范定义的请求和通知被称为“LSP 方法”。这些由 Lua |lsp-handler| 函数处理。

|vim.lsp.handlers| 全局表定义了默认处理器（仅用于服务器到客户端的请求/通知，不用于客户端到服务器）。
注意：取决于服务器支持；如果你的服务器不支持，它们不会运行。

你可以用以下命令列出它们： >vim

    :lua vim.print(vim.tbl_keys(vim.lsp.handlers))
<
它们也在下方列出。

- `'callHierarchy/incomingCalls'`
- `'callHierarchy/outgoingCalls'`
- `'textDocument/codeAction'`
- `'textDocument/completion'`
- `'textDocument/declaration'`
- `'textDocument/definition'`
- `'textDocument/diagnostic'`
- `'textDocument/documentHighlight'`
- `'textDocument/documentSymbol'`
- `'textDocument/foldingRange'`
- `'textDocument/formatting'`
- `'textDocument/hover'`
- `'textDocument/implementation'`
- `'textDocument/inlayHint'`
- `'textDocument/prepareTypeHierarchy'`
- `'textDocument/publishDiagnostics'`
- `'textDocument/rangeFormatting'`
- `'textDocument/rangesFormatting'`
- `'textDocument/references'`
- `'textDocument/rename'`
- `'textDocument/semanticTokens/full'`
- `'textDocument/semanticTokens/full/delta'`
- `'textDocument/signatureHelp'`
- `'textDocument/typeDefinition*'`
- `'typeHierarchy/subtypes'`
- `'typeHierarchy/supertypes'`
- `'window/logMessage'`
- `'window/showMessage'`
- `'window/showDocument'`
- `'window/showMessageRequest'`
- `'workspace/applyEdit'`
- `'workspace/configuration'`
- `'workspace/executeCommand'`
- `'workspace/inlayHint/refresh'`
- `'workspace/symbol'`
- `'workspace/workspaceFolders'`


                                                                 *lsp-handler*
LSP 处理器是处理 Nvim 向服务器发出的请求的 |lsp-response| 的函数。
（通知与请求不同，是“即发即弃”：没有响应，因此无法被处理。|lsp-notification|）

每个响应处理器的签名如下： >

    function(err, result, ctx)
<
    参数: ~
      • {err}     (`table|nil`) 错误信息字典，若请求完成则为 `nil`。
      • {result}  (`Result|Params|nil`) |lsp-response| 的 `result` 键，若请求失败则为 `nil`。
      • {ctx}     (`table`) 与处理器相关的调用状态表，包含以下键：
                  • {method}     (`string`) |lsp-method| 名称。
                  • {client_id}  (`number`) |vim.lsp.Client| 标识符。
                  • {bufnr}      (`Buffer`) 缓冲区句柄。
                  • {params}     (`table|nil`) 请求参数表。
                  • {version}    (`number`) 请求时的文档版本。处理器可与当前文档版本比较以检查响应是否“过时”。另见 |b:changedtick|。

    返回: ~
        两个值 `result, err`，其中 `err` 形如 RPC 错误: >
            { code, message, data? }
<        你可以使用 |vim.lsp.rpc.rpc_response_error()| 创建该对象。

                                                      *lsp-handler-resolution*
处理器可通过以下方式设置（优先级递增）：

                                                            *vim.lsp.handlers*
- 通过 |Client:request()| 直接调用 LSP 方法。这是唯一“覆盖”默认客户端到服务器请求处理的方法（绕过 `vim.lsp.buf` 及相关接口）。 >lua
    local client = assert(vim.lsp.get_clients()[1])
    client:request('textDocument/definition')

- 在 `vim.lsp.handlers` 中设置字段。该全局表包含 |lsp-method| 名称到处理器的默认映射。（注意：仅用于服务器到客户端的请求/通知，不用于客户端到服务器。）
  示例： >lua
    vim.lsp.handlers['textDocument/publishDiagnostics'] = my_custom_diagnostics_handler

- 向 |vim.lsp.start()| 传递 {handlers} 参数。
这为特定服务器设置默认 |lsp-handler|。（注意：仅用于服务器到客户端的请求/通知，不用于客户端到服务器。）
  示例： >lua
    vim.lsp.start {
      ..., -- 省略其他配置。
      handlers = {
        ['textDocument/publishDiagnostics'] = my_custom_diagnostics_handler
      },
    }

- 向 |vim.lsp.buf_request_all()| 传递 {handler} 参数。这仅为给定请求设置 |lsp-handler|。
  示例： >lua
    vim.lsp.buf_request_all(
      0,
      'textDocument/publishDiagnostics',
      my_request_params,
      my_handler
    )
<

                                                            *vim.lsp.log_levels*
日志级别在 |vim.log.levels| 中定义


VIM.LSP.PROTOCOL                                              *vim.lsp.protocol*

模块 `vim.lsp.protocol` 定义了 LSP 规范规定的常量，以及用于创建协议相关对象的辅助函数。
https://github.com/microsoft/language-server-protocol/raw/gh-pages/_specifications/specification-3-14.md

例如 `vim.lsp.protocol.ErrorCodes` 允许通过数字或名称反查： >lua

    vim.lsp.protocol.TextDocumentSyncKind.Full == 1
    vim.lsp.protocol.TextDocumentSyncKind[1] == "Full"
<

                                                                *lsp-response*
LSP 响应结构：
https://microsoft.github.io/language-server-protocol/specifications/specification-current/#responseMessage

                                                                *lsp-notification*
LSP 通知结构：
https://microsoft.github.io/language-server-protocol/specifications/specification-current/#notificationMessage


==============================================================================
Lua module: vim.lsp                                                 *lsp-core*

*vim.lsp.Config*
    扩展自: |vim.lsp.ClientConfig|


    字段: ~
      • {cmd}?           (`string[]|fun(dispatchers: vim.lsp.rpc.Dispatchers): vim.lsp.rpc.PublicClient`)
                         见 |vim.lsp.ClientConfig| 中的 `cmd`。
      • {filetypes}?     (`string[]`) 客户端若被 `vim.lsp.enable()` 激活，将自动附加的文件类型。若未提供，则客户端会附加到所有文件类型。
      • {root_markers}?  (`string[]`) 目录标记（如 '.git/'），LSP 服务器会基于此初始化 workspaceFolders、rootUri 和 rootPath。若提供了 `root_dir` 则不使用。
      • {root_dir}?      (`string|fun(bufnr: integer, cb:fun(root_dir?:string))`)
                         LSP 服务器初始化时基于的目录。若为函数，则传入缓冲区号和回调，回调需传入要使用的 root_dir。LSP 服务器在回调被调用前不会启动。
      • {reuse_client}?  (`fun(client: vim.lsp.Client, config: vim.lsp.ClientConfig): boolean`)
                         用于决定是否复用客户端的谓词。对所有运行中的客户端使用。默认实现为 name 和 root_dir 匹配时复用客户端。


buf_attach_client({bufnr}, {client_id})          *vim.lsp.buf_attach_client()*
    实现了跟踪任意语言服务器缓冲区所需的 `textDocument/did…` 通知。

    若不调用此函数，服务器不会收到缓冲区更改的通知。

    参数: ~
      • {bufnr}      (`integer`) 缓冲区句柄，0 表示当前缓冲区
      • {client_id}  (`integer`) 客户端 id

    返回: ~
        (`boolean`) 成功则为 `true`，否则为 `false`

buf_detach_client({bufnr}, {client_id})          *vim.lsp.buf_detach_client()*
    从指定缓冲区分离客户端。注意：虽然服务器会收到文本文档（缓冲区）已关闭的通知，但若服务器忽略该通知，仍可发送通知。

    参数: ~
      • {bufnr}      (`integer`) 缓冲区句柄，0 表示当前缓冲区
      • {client_id}  (`integer`) 客户端 id

buf_is_attached({bufnr}, {client_id})              *vim.lsp.buf_is_attached()*
    检查某缓冲区是否已附加到特定客户端。

    参数: ~
      • {bufnr}      (`integer`) 缓冲区句柄，0 表示当前缓冲区
      • {client_id}  (`integer`) 客户端 id

buf_notify({bufnr}, {method}, {params})                 *vim.lsp.buf_notify()*
    向服务器发送通知

    参数: ~
      • {bufnr}   (`integer?`) 缓冲区号
      • {method}  (`string`) 请求方法名
      • {params}  (`any`) 发送给服务器的参数

    返回: ~
        (`boolean`) 若有任一客户端返回 true 则为 true，否则为 false

                                                   *vim.lsp.buf_request_all()*
buf_request_all({bufnr}, {method}, {params}, {handler})
    向附加到缓冲区的所有活动客户端发送异步请求，并用合并结果执行 `handler` 回调。

    参数: ~
      • {bufnr}    (`integer`) 缓冲区句柄，0 表示当前缓冲区。
      • {method}   (`string`) LSP 方法名
      • {params}   (`table|(fun(client: vim.lsp.Client, bufnr: integer): table?)?`)
                   发送给服务器的参数。也可传递返回参数表的函数，用于针对不同客户端的参数。
      • {handler}  (`function`) 所有请求完成后调用的处理器。服务器结果以 `client_id:result` 映射传递。

    返回: ~
        (`function`) cancel 用于取消所有请求的函数。

                                                  *vim.lsp.buf_request_sync()*
buf_request_sync({bufnr}, {method}, {params}, {timeout_ms})
    向所有服务器发送请求并等待所有响应。

    调用 |vim.lsp.buf_request_all()|，但会阻塞 Nvim 直到收到结果。参数同 |vim.lsp.buf_request_all()|，但结果不同。最大等待 {timeout_ms}。

    参数: ~
      • {bufnr}       (`integer`) 缓冲区句柄，0 表示当前缓冲区。
      • {method}      (`string`) LSP 方法名
      • {params}      (`table?`) 发送给服务器的参数
      • {timeout_ms}  (`integer?`, 默认: `1000`) 最长等待响应的毫秒数。

    返回（多值）: ~
        (`table<integer, {error: lsp.ResponseError?, result: any}>?`) 结果
        客户端 id 到请求结果的映射。
        (`string?`) err 超时、取消或出错时，`err` 为描述失败原因的字符串，`result` 为 nil。

client_is_stopped({client_id})                   *vim.lsp.client_is_stopped()*
    检查客户端是否已停止。

    参数: ~
      • {client_id}  (`integer`)

    返回: ~
        (`boolean`) 若客户端已停止则为 true，否则为 false。

commands                                                    *vim.lsp.commands*
    客户端侧命令的注册表。这是插件处理不属于核心 LSP 协议规范的自定义命令的扩展点。

    注册表是一个表，键为唯一命令名，值为当任何 LSP 动作（代码操作、代码透镜等）触发该命令时调用的函数。

    若 LSP 响应包含未在此注册表中找到的命令，则会通过 `workspace/executeCommand` 由 LSP 服务器执行。

    该函数的第一个参数为 Command：命令标题：字符串命令：字符串参数?: any[]

    第二个参数为 |lsp-handler| 的 ctx。

config({name}, {cfg})                                       *vim.lsp.config()*
    更新 LSP 客户端的配置。

    使用名称 '*' 可为所有客户端设置默认配置。

    也可通过表赋值重新定义客户端配置。

    示例:
    • 为所有客户端添加根标记: >lua
        vim.lsp.config('*', {
          root_markers = { '.git' },
        })
<
    • 为所有客户端添加额外能力: >lua
        vim.lsp.config('*', {
          capabilities = {
            textDocument = {
              semanticTokens = {
                multilineTokenSupport = true,
              }
            }
          }
        })
<
    • （重新）定义 clangd 的配置: >lua
        vim.lsp.config.clangd = {
          cmd = {
            'clangd',
            '--clang-tidy',
            '--background-index',
            '--offset-encoding=utf-8',
          },
          root_markers = { '.clangd', 'compile_commands.json' },
          filetypes = { 'c', 'cpp' },
        }
<
    • 获取 luals 的配置: >lua
        local cfg = vim.lsp.config.luals
<

    参数: ~
      • {name}  (`string`)
      • {cfg}   (`vim.lsp.Config`) 见 |vim.lsp.Config|。

enable({name}, {enable})                                    *vim.lsp.enable()*
    启用 LSP 服务器，在打开缓冲区时自动启动。

    使用通过 `vim.lsp.config` 定义的配置。

    示例: >lua
          vim.lsp.enable('clangd')

          vim.lsp.enable({'luals', 'pyright'})
<

    参数: ~
      • {name}    (`string|string[]`) 客户端名称（可为多个）。
      • {enable}  (`boolean?`) `true|nil` 启用，`false` 禁用。

foldclose({kind}, {winid})                               *vim.lsp.foldclose()*
    关闭窗口 {winid} 中所有 {kind} 类型的折叠。

    若要在打开文件时自动折叠 imports，可用自动命令: >lua
        vim.api.nvim_create_autocmd('LspNotify', {
          callback = function(args)
            if args.data.method == 'textDocument/didOpen' then
              vim.lsp.foldclose('imports', vim.fn.bufwinid(args.buf))
            end
          end,
        })
<

    参数: ~
      • {kind}   (`lsp.FoldingRangeKind`) 类型，可为 "comment"、"imports" 或 "region"。
      • {winid}  (`integer?`) 默认为当前窗口。

foldexpr({lnum})                                          *vim.lsp.foldexpr()*
    提供内置客户端与 `foldexpr` 函数之间的接口。

    使用方法，将 'foldmethod' 设为 "expr"，并设置 'foldexpr' 的值: >lua
        vim.o.foldmethod = 'expr'
        vim.o.foldexpr = 'v:lua.vim.lsp.foldexpr()'
<

    或仅在支持时使用，可在 |LspAttach| 自动命令中检查 "textDocument/foldingRange" 能力。例如: >lua
        vim.o.foldmethod = 'expr'
        -- 默认使用 treesitter 折叠
        vim.o.foldexpr = 'v:lua.vim.treesitter.foldexpr()'
        -- 若客户端支持 LSP 折叠则优先
        vim.api.nvim_create_autocmd('LspAttach', {
          callback = function(args)
            local client = vim.lsp.get_client_by_id(args.data.client_id)
            if client:supports_method('textDocument/foldingRange') then
              local win = vim.api.nvim_get_current_win()
              vim.wo[win][0].foldexpr = 'v:lua.vim.lsp.foldexpr()'
            end
          end,
        })
<

    参数: ~
      • {lnum}  (`integer`) 行号

foldtext()                                                *vim.lsp.foldtext()*
    提供一个 `foldtext` 函数，显示获取到的 `collapsedText`，若未提供则默认为折叠的第一行。

formatexpr({opts})                                      *vim.lsp.formatexpr()*
    提供内置客户端与 `formatexpr` 函数之间的接口。

    目前仅支持单一客户端。可通过
    `setlocal formatexpr=v:lua.vim.lsp.formatexpr()` 设置，或（更常见）在
    `on_attach` 中设置
    `vim.bo[bufnr].formatexpr = 'v:lua.vim.lsp.formatexpr(#{timeout_ms:250})'`。

    参数: ~
      • {opts}  (`table?`) 包含以下字段:
                • {timeout_ms} (`integer`, 默认: 500ms) 格式化请求的超时时间。

                                          *vim.lsp.get_buffers_by_client_id()*
get_buffers_by_client_id({client_id})
    返回附加到 client_id 的缓冲区列表。

    参数: ~
      • {client_id}  (`integer`) 客户端 id

    返回: ~
        (`integer[]`) 缓冲区 id 列表

get_client_by_id({client_id})                     *vim.lsp.get_client_by_id()*
    通过 id 获取客户端，若 id 无效则返回 nil。返回的客户端可能尚未完全初始化。

    参数: ~
      • {client_id}  (`integer`) 客户端 id

    返回: ~
        (`vim.lsp.Client?`) 客户端 rpc 对象

get_clients({filter})                                  *vim.lsp.get_clients()*
    获取活动客户端。

    参数: ~
      • {filter}  (`table?`) 用于过滤返回客户端的键值对。
                  • {id}? (`integer`) 仅返回指定 id 的客户端
                  • {bufnr}? (`integer`) 仅返回附加到该缓冲区的客户端
                  • {name}? (`string`) 仅返回指定名称的客户端
                  • {method}? (`string`) 仅返回支持指定方法的客户端

    返回: ~
        (`vim.lsp.Client[]`) |vim.lsp.Client| 对象列表

get_log_path()                                        *vim.lsp.get_log_path()*
    获取 LSP 客户端使用的日志文件路径。

    返回: ~
        (`string`) 日志文件路径

omnifunc({findstart}, {base})                             *vim.lsp.omnifunc()*
    实现兼容 'omnifunc' 的 LSP 补全。

    参数: ~
      • {findstart}  (`integer`) 0 或 1，决定行为
      • {base}       (`integer`) findstart=0 时，要匹配的文本

    返回: ~
        (`integer|table`) 由 {findstart} 决定:
        • findstart=0: 补全起始列，或 -2 或 -3
        • findstart=1: 匹配项列表（实际调用 |complete()|）

    另见: ~
      • |complete-functions|
      • |complete-items|
      • |CompleteDone|

set_log_level({level})                               *vim.lsp.set_log_level()*
    设置 LSP 日志的全局日志级别。

    级别名称: "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF"

    级别数字从 "TRACE" 的 0 开始

    使用 `lsp.log_levels` 进行反查。

    参数: ~
      • {level}  (`integer|string`) 不区分大小写的级别名称或数字

    另见: ~
      • |vim.lsp.log_levels|


      start({config}, {opts})                                      *vim.lsp.start()*
    创建一个新的 LSP 客户端并启动语言服务器，或若已存在匹配的客户端则复用。将当前缓冲区附加到客户端。

    示例： >lua
        vim.lsp.start({
           name = 'my-server-name',
           cmd = {'name-of-language-server-executable'},
           root_dir = vim.fs.root(0, {'pyproject.toml', 'setup.py'}),
        })
<

    见 |vim.lsp.ClientConfig| 获取所有可用选项。最重要的有：
    • `name` LSP 客户端的任意名称。每个语言服务器应唯一。
    • `cmd` 命令字符串数组或函数。
    • `root_dir` 项目根路径。默认用于决定是否复用已有客户端。上例用
      |vim.fs.root()| 从当前目录向上遍历，直到找到 `pyproject.toml` 或 `setup.py`。
    • `workspace_folders` 指定项目根文件夹的 `{ uri:string, name: string }` 表列表。
      若为 `nil`，则属性会从 `root_dir` 派生。

    语言服务器用这些信息发现项目元数据，如依赖关系，并通常会索引项目文件夹内容。

    为确保语言服务器只为其能处理的语言启动，请确保在 |FileType| 自动命令中调用 |vim.lsp.start()|。可用 |:au|、|nvim_create_autocmd()| 或放在
    `ftplugin/<filetype_name>.lua`（见 |ftplugin-name|）

    参数: ~
      • {config}  (`vim.lsp.ClientConfig`) 服务器配置。见 |vim.lsp.ClientConfig|。
      • {opts}    (`table?`) 可选关键字参数。
                  • {reuse_client}?
                    (`fun(client: vim.lsp.Client, config: vim.lsp.ClientConfig): boolean`)
                    用于决定是否复用客户端的谓词。对所有运行中的客户端使用。默认实现为 name 相同且给定的工作区文件夹（或 root_dir）都包含在客户端的工作区文件夹中。
                  • {bufnr}? (`integer`) 若启动或复用客户端，附加的缓冲区句柄（0 表示当前）。
                  • {attach}? (`boolean`) 是否将客户端附加到缓冲区（默认 true）。若为 `false`，`reuse_client` 和 `bufnr` 将被忽略。
                  • {silent}? (`boolean`) 若 LSP 服务器启动失败则抑制错误报告（默认 false）。

    返回: ~
        (`integer?`) client_id

status()                                                    *vim.lsp.status()*
    获取所有客户端的最新进度消息并格式化为字符串。若无客户端或无新消息则为空

    返回: ~
        (`string`)

stop_client({client_id}, {force})                      *vim.lsp.stop_client()*
    停止一个或多个客户端。

    也可在 |vim.lsp.Client| 对象上用 `stop()`。停止所有客户端： >lua
        vim.lsp.stop_client(vim.lsp.get_clients())
<

    默认请求服务器关闭，若该客户端已请求关闭，则会强制关闭。

    参数: ~
      • {client_id}  (`integer|integer[]|vim.lsp.Client[]`) id、id 列表或 |vim.lsp.Client| 对象列表
      • {force}      (`boolean?`) 是否强制关闭

tagfunc({pattern}, {flags})                                *vim.lsp.tagfunc()*
    提供内置客户端与 'tagfunc' 之间的接口。

    用于普通模式命令（如 |CTRL-]|）时会调用 "textDocument/definition" LSP 方法查找光标下的标签。
    否则，使用 "workspace/symbol"。若所有 LSP 服务器均无结果，则回退到内置标签。

    参数: ~
      • {pattern}  (`string`) 用于查找工作区符号的模式
      • {flags}    (`string`) 见 |tag-function|

    返回: ~
        (`table[]`) 匹配标签的列表


 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
