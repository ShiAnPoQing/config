*map.txt*       Nvim


		  VIM REFERENCE MANUAL    by Bram Moolenaar


键映射、缩写和用户自定义命令。

这个主题在用户手册的 |05.3|、|24.7| 和 |40.1| 节中介绍。

                                      输入 |gO| 查看目录。

==============================================================================
1. 键映射				*keybind* *key-mapping* *mapping*

键映射用于改变输入键的含义。最常见的用途是为功能键定义一系列命令。例如：>

	:map <F2> a<C-R>=strftime("%c")<CR><Esc>

这会在光标后追加当前日期和时间（使用 <> 表示法 |<>|）。


1.1 映射命令					*:map-commands*

有命令用于输入新映射、删除映射和列出映射。
有关各种形式的"map"及其与模式的关系，请参见 |map-overview|。

{lhs}	表示左侧	*{lhs}*
{rhs}	表示右侧	*{rhs}*

:map	{lhs} {rhs}		|mapmode-nvo|		*:map*
:nm[ap]	{lhs} {rhs}		|mapmode-n|		*:nm* *:nmap*
:vm[ap]	{lhs} {rhs}		|mapmode-v|		*:vm* *:vmap*
:xm[ap]	{lhs} {rhs}		|mapmode-x|		*:xm* *:xmap*
:smap	{lhs} {rhs}		|mapmode-s|		    *:smap*
:om[ap]	{lhs} {rhs}		|mapmode-o|		*:om* *:omap*
:map!	{lhs} {rhs}		|mapmode-ic|		*:map!*
:im[ap]	{lhs} {rhs}		|mapmode-i|		*:im* *:imap*
:lm[ap]	{lhs} {rhs}		|mapmode-l|		*:lm* *:lma* *:lmap*
:cm[ap]	{lhs} {rhs}		|mapmode-c|		*:cm* *:cmap*
:tma[p]	{lhs} {rhs}		|mapmode-t|		*:tma* *:tmap*
			将键序列 {lhs} 映射到 {rhs}，适用于该映射命令
			所对应的模式。结果（包括 {rhs}）会被进一步扫描
			以查找映射。这允许嵌套和递归使用映射。
			注意：{rhs} 中的尾随空格会被包含，因为空格是
			有效的普通模式命令。
			参见 |map-trailing-white|。

						*:nore* *:norem*
:no[remap]  {lhs} {rhs}		|mapmode-nvo|	*:no*  *:noremap* *:nor*
:nn[oremap] {lhs} {rhs}		|mapmode-n|	*:nn*  *:nnoremap*
:vn[oremap] {lhs} {rhs}		|mapmode-v|	*:vn*  *:vnoremap*
:xn[oremap] {lhs} {rhs}		|mapmode-x|	*:xn*  *:xnoremap*
:snor[emap] {lhs} {rhs}		|mapmode-s|	*:snor* *:snore* *:snoremap*
:ono[remap] {lhs} {rhs}		|mapmode-o|	*:ono* *:onoremap*
:no[remap]! {lhs} {rhs}		|mapmode-ic|	*:no!* *:noremap!*
:ino[remap] {lhs} {rhs}		|mapmode-i|	*:ino* *:inor* *:inoremap*
:ln[oremap] {lhs} {rhs}		|mapmode-l|	*:ln*  *:lnoremap*
:cno[remap] {lhs} {rhs}		|mapmode-c|	*:cno* *:cnor* *:cnoremap*
:tno[remap] {lhs} {rhs}		|mapmode-t|	*:tno* *:tnoremap*
			将键序列 {lhs} 映射到 {rhs}，适用于该映射命令
			所对应的模式。禁止 {rhs} 的映射，以避免嵌套和
			递归映射。通常用于重新定义命令。
			注意：{rhs} 中的键也不会触发缩写，除了
			|i_CTRL-]| 和 |c_CTRL-]|。
			注意：当 <Plug> 出现在 {rhs} 中时，即使禁止了
			重映射，这部分也会始终被应用。
:unm[ap]  {lhs}			|mapmode-nvo|		*:unm*  *:unmap*
:nun[map] {lhs}			|mapmode-n|		*:nun*  *:nunmap*
:vu[nmap] {lhs}			|mapmode-v|		*:vu*   *:vunmap*
:xu[nmap] {lhs}			|mapmode-x|		*:xu*   *:xunmap*
:sunm[ap] {lhs}			|mapmode-s|		*:sunm* *:sunmap*
:ou[nmap] {lhs}			|mapmode-o|		*:ou*   *:ounmap*
:unm[ap]! {lhs}			|mapmode-ic|		*:unm!* *:unmap!*
:iu[nmap] {lhs}			|mapmode-i|		*:iu*   *:iunmap*
:lu[nmap] {lhs}			|mapmode-l|		*:lu*   *:lunmap*
:cu[nmap] {lhs}			|mapmode-c|		*:cu*   *:cun* *:cunmap*
:tunma[p] {lhs}			|mapmode-t|		*:tunma* *:tunmap*
			删除 {lhs} 的映射，适用于该映射命令所对应的模式。
			该映射可能仍然在其他适用的模式中定义。
			当 {lhs} 匹配映射的 {rhs} 时也有效。这适用于
			缩写被应用的情况。
			注意：{lhs} 中的尾随空格会被包含。
			参见 |map-trailing-white|。

:mapc[lear]			|mapmode-nvo|		*:mapc*   *:mapclear*
:nmapc[lear]			|mapmode-n|		*:nmapc*  *:nmapclear*
:vmapc[lear]			|mapmode-v|		*:vmapc*  *:vmapclear*
:xmapc[lear]			|mapmode-x|		*:xmapc*  *:xmapclear*
:smapc[lear]			|mapmode-s|		*:smapc*  *:smapclear*
:omapc[lear]			|mapmode-o|		*:omapc*  *:omapclear*
:mapc[lear]!			|mapmode-ic|		*:mapc!*  *:mapclear!*
:imapc[lear]			|mapmode-i|		*:imapc*  *:imapclear*
:lmapc[lear]			|mapmode-l|		*:lmapc*  *:lmapclear*
:cmapc[lear]			|mapmode-c|		*:cmapc*  *:cmapclear*
:tmapc[lear]			|mapmode-t|		*:tmapc*  *:tmapclear*
			删除该映射命令所对应模式的所有映射。
			使用 <buffer> 参数可以删除缓冲区局部映射
			|:map-<buffer>|
			警告：这也会删除 |default-mappings|。

:map				|mapmode-nvo|
:nm[ap]				|mapmode-n|
:vm[ap]				|mapmode-v|
:xm[ap]				|mapmode-x|
:sm[ap]				|mapmode-s|
:om[ap]				|mapmode-o|
:map!				|mapmode-ic|
:im[ap]				|mapmode-i|
:lm[ap]				|mapmode-l|
:cm[ap]				|mapmode-c|
:tma[p]				|mapmode-t|
			列出该映射命令所对应模式的所有键映射。
			注意：":map" 和 ":map!" 最常用，因为它们包含
			其他模式。

:map    {lhs}			|mapmode-nvo|		*:map_l*
:nm[ap] {lhs}			|mapmode-n|		*:nmap_l*
:vm[ap] {lhs}			|mapmode-v|		*:vmap_l*
:xm[ap] {lhs}			|mapmode-x|		*:xmap_l*
:sm[ap] {lhs}			|mapmode-s|		*:smap_l*
:om[ap] {lhs}			|mapmode-o|		*:omap_l*
:map!   {lhs}			|mapmode-ic|		*:map_l!*
:im[ap] {lhs}			|mapmode-i|		*:imap_l*
:lm[ap] {lhs}			|mapmode-l|		*:lmap_l*
:cm[ap] {lhs}			|mapmode-c|		*:cmap_l*
:tma[p] {lhs}			|mapmode-t|		*:tmap_l*
			列出以 {lhs} 开头的键序列的映射，适用于该映射
			命令所对应的模式。
这些命令用于将键或键序列映射到一串字符。你可以用它来将命令序列放在功能键下，
将一个键转换为另一个键，等等。有关如何保存和恢复当前映射，请参见 |:mkexrc|。

							*map-ambiguous*
当两个映射以相同的字符序列开始时，它们是模糊的。例如：>
	:imap aa foo
	:imap aaa bar
当 Vim 读取了 "aa" 后，它需要获取另一个字符才能决定是使用 "aa" 还是 "aaa" 的映射。
这意味着在输入 "aa" 后，该映射不会立即展开，Vim 正在等待另一个字符。
如果你输入空格，那么 "foo" 会被插入，再加上空格。如果你输入 "a"，
那么 "bar" 会被插入。

尾随空格 ~
							*map-trailing-white*
这个取消映射命令不起作用：>
	:map @@ foo
	:unmap @@ | print

因为它试图取消映射 "@@ "，包括命令分隔符 "|" 之前的空格。
其他带有尾随空格的例子：>
	unmap @@ 
	unmap @@     " comment

会发出错误，这个错误很难识别，因为 `unmap @@ ` 中的尾随空格字符是不可见的。

一个通用的解决方案是在映射键之后立即放置命令分隔符 "|"。
之后可以跟空格和注释：>
	unmap @@|    " comment


1.2 特殊参数					*:map-arguments*

"<buffer>"、"<nowait>"、"<silent>"、"<script>"、"<expr>" 和
"<unique>" 可以按任何顺序使用。它们必须出现在命令之后，在任何其他参数之前。

					*:map-local* *:map-<buffer>* *:map-buffer*
					*E224* *E225*
如果这些命令的第一个参数是 "<buffer>"，那么映射将只在当前缓冲区中有效。
例如：>
	:map <buffer>  ,w  /[.,;]<CR>
然后你可以在另一个缓冲区中将 ",w" 映射为其他内容：>
	:map <buffer>  ,w  /[#&!]<CR>
局部缓冲区映射会在全局映射之前使用。参见下面的 <nowait> 来使短局部映射
在存在更长的全局映射时不生效。
"<buffer>" 参数也可以用于清除映射：>
	:unmap <buffer> ,w
	:mapclear <buffer>
当缓冲区被删除时，局部映射也会被清除，但在缓冲区被卸载时不会。
这与局部选项值类似。
另请参见 |map-precedence|。

						*:map-<nowait>* *:map-nowait*
当为 "," 定义缓冲区局部映射时，可能存在以 "," 开头的全局映射。
然后你需要输入另一个字符让 Vim 知道是使用 "," 映射还是更长的映射。
要避免这种情况，添加 <nowait> 参数。然后当映射匹配时就会立即使用，
Vim 不会等待输入更多字符。但是，如果字符已经被输入，它们会被使用。
注意，这只有在 <nowait> 映射完全匹配并且在任何部分匹配之前找到时才有效。
这在以下情况下有效：
- 只有一个匹配的缓冲区局部映射，因为这些总是在全局映射之前找到。
- 存在另一个部分匹配的缓冲区局部映射，但它定义得更早（最后定义的映射最先找到）。
						*:map-<silent>* *:map-silent*
要定义一个不会在命令行上回显的映射，添加 "<silent>" 作为第一个参数。
例如：>
	:map <silent> ,h /Header<CR>
使用此映射时不会回显搜索字符串。不过，执行的命令的消息仍然会显示。
要完全静音，在执行的命令中添加 ":silent"：>
	:map <silent> ,h :exe ":silent normal /Header\r"<CR>
注意，命令的效果也可能被静音，例如，当映射选择命令行补全的另一个条目时，
它不会被显示。
提示仍然会显示，例如，对于 inputdialog()。
在缩写中使用 "<silent>" 是可能的，但会导致命令行重绘失败。

						*:map-<script>* *:map-script*
如果这些命令的第一个参数是 "<script>" 并且它用于定义新的映射或缩写，
那么映射将只使用在脚本中局部定义的映射来重映射 {rhs} 中的字符，
这些映射以 "<SID>" 开头。这可以用于避免脚本外部的映射干扰
（例如，当 CTRL-V 在 mswin.vim 中被重映射时），但会使用脚本中定义的其他映射。
注意：":map <script>" 和 ":noremap <script>" 做同样的事情。
"<script>" 会覆盖命令名称。建议使用 ":noremap <script>"，因为它更清楚地表明
重映射被（大部分）禁用。

				*:map-<unique>* *:map-unique* *E226* *E227*
如果这些命令的第一个参数是 "<unique>" 并且它用于定义新的映射或缩写，
当映射或缩写已经存在时，命令将失败。例如：>
	:map <unique> ,w  /[#&!]<CR>
当定义局部映射时，也会检查是否存在相等的全局映射。
会失败的例子：>
	:map ,w  /[#&!]<CR>
	:map <buffer> <unique> ,w  /[.,;]<CR>
如果你想映射一个键然后让它执行它原本映射的内容，请查看 |maparg()|。

						*:map-<expr>* *:map-expression*
如果这些命令的第一个参数是 "<expr>" 并且它用于定义新的映射或缩写，
那么参数是一个表达式。表达式会被求值以获得要使用的 {rhs}。
例如：>
	:inoremap <expr> . <SID>InsertDot()
将插入 s:InsertDot() 函数的结果。它可以检查光标前的文本，并在满足某些条件时
开始全能补全。建议使用脚本局部函数，以避免污染全局命名空间。
在 RHS 中使用 <SID>，以便可以找到定义映射的脚本。
对于缩写，|v:char| 被设置为触发缩写的字符。你可以用它来决定如何展开 {lhs}。
你不应该插入或更改 v:char。

如果你想让映射不执行任何操作，可以让表达式求值为空字符串。
如果某些更改需要 Vim 通过主循环（例如更新显示），返回 "\<Ignore>"。
这与 "nothing" 类似，但会让 Vim 从等待输入的循环中返回。

请记住，表达式可能在查找预输入时被求值，在前一个命令执行之前。
例如：>
	func StoreColumn()
	  let g:column = col('.')
	  return 'x'
	endfunc
	nnoremap <expr> x StoreColumn()
	nmap ! f!x
你会注意到 g:column 的值来自执行 "f!" 之前，因为 "x" 在 "f!" 执行之前被求值。
这可以通过在表达式映射的字符前插入 <Ignore> 来解决：>
	nmap ! f!<Ignore>x

要非常小心副作用！表达式在获取字符时被求值，你可能会使命令功能失常。
因此，以下操作在 <expr> 映射中被阻止：
- 更改缓冲区文本 |textlock|。
- 编辑另一个缓冲区。
- |:normal| 命令。
- 允许移动光标，但之后会恢复。
- 如果命令行被更改，旧文本和光标位置会被恢复。
如果你想让映射执行这些操作中的任何一个，让返回的字符来做，或者使用 |<Cmd>| 映射代替。

你可以使用 getchar()，如果有预输入它会消耗掉。例如，如果你有这些映射：>
  inoremap <expr> <C-L> nr2char(getchar())
  inoremap <expr> <C-L>x "foo"
如果你现在输入 CTRL-L，还不会发生任何事情，Vim 需要下一个字符来决定使用哪个映射。
如果你输入 'x'，会使用第二个映射并插入 "foo"。如果你输入任何其他键，
会使用第一个映射，getchar() 获取输入的键并返回它。

这里是一个插入递增列表编号的例子：>
	let counter = 0
	inoremap <expr> <C-L> ListItem()
	inoremap <expr> <C-R> ListReset()

	func ListItem()
	  let g:counter += 1
	  return g:counter .. '. '
	endfunc

	func ListReset()
	  let g:counter = 0
	  return ''
	endfunc

CTRL-L 插入下一个数字，CTRL-R 重置计数。CTRL-R 返回空字符串，所以不会插入任何内容。

注意，在其他文本之前使用 0x80 作为单个字节不起作用，它会被视为特殊键。

						*<Cmd>* *:map-cmd*
<Cmd> 伪键开始一个"命令映射"，它直接执行命令而不改变模式。
在映射的 {rhs} 中使用 ":...<CR>" 的地方，你可以改用 "<Cmd>...<CR>"。
例如：>
	noremap x <Cmd>echo mode(1)<CR>
<
这比在可视和操作符待定模式中使用 `:<C-U>` 或在插入模式中使用 `<C-O>:` 更灵活，
因为命令直接在当前模式中执行，而不是总是进入普通模式。可视模式被保留，
所以不需要使用 |gv| 的技巧。命令可以直接在命令行模式中调用（否则需要计时器技巧）。
在插入模式中间使用 <Cmd> 的例子：>
	nnoremap <F3> aText <Cmd>echo mode(1)<CR> Added<Esc>

与 <expr> 映射不同，<Cmd> 命令没有特殊限制：它就像调用了一个（无限制的）
|autocommand| 或处理了一个异步事件一样执行。

注意：
- 因为 <Cmd> 避免了模式更改（与 ":" 不同），它不会触发 |CmdlineEnter| 和
  |CmdlineLeave| 事件。这有助于提高性能。
- 出于同样的原因，|keycodes| 如 <C-R><C-W> 被解释为普通的、未映射的键。
- 命令不会被回显，不需要 <silent>。
- {rhs} 不受缩写影响，也不受其他映射影响，即使映射是递归的。
- 在可视模式中，你可以使用 `line('v')` 和 `col('v')` 来获取可视区域的一端，
  光标在另一端。

							*E1255* *E1136*
<Cmd> 命令必须终止，也就是说，它们必须在映射定义的 {rhs} 中后跟 <CR>。
永远不会进入 |Command-line| 模式。要在 {rhs} 中使用字面 <CR>，使用 |<lt>|。
1.3 映射和模式					*:map-modes*
		*mapmode-nvo* *mapmode-n* *mapmode-v* *mapmode-o* *mapmode-t*

有七组映射
- 普通模式：输入命令时。
- 可视模式：在可视区域高亮时输入命令。
- 选择模式：类似可视模式，但输入文本会替换选择。
- 操作符待定模式：当操作符待定时（在 "d"、"y"、"c" 等之后）。
  参见下面：|omap-info|。
- 插入模式。这些也用于替换模式。
- 命令行模式：输入 ":" 或 "/" 命令时。
- 终端模式：在 |:terminal| 缓冲区中输入时。

特殊情况：在普通模式中输入命令计数时，零的映射被禁用。这使得可以映射零，
而不会使输入带零的计数变得不可能。

						*map-overview* *map-modes*
概述哪些映射命令在哪些模式中工作。更多细节见下文。
     命令                    模式 ~
:map   :noremap  :unmap     普通、可视、选择、操作符待定
:nmap  :nnoremap :nunmap    普通
:vmap  :vnoremap :vunmap    可视和选择
:smap  :snoremap :sunmap    选择
:xmap  :xnoremap :xunmap    可视
:omap  :onoremap :ounmap    操作符待定
:map!  :noremap! :unmap!    插入和命令行
:imap  :inoremap :iunmap    插入
:lmap  :lnoremap :lunmap    插入、命令行、语言参数
:cmap  :cnoremap :cunmap    命令行
:tmap  :tnoremap :tunmap    终端

表格中的相同信息：
							*map-table*
         模式  | 普通 | 插入 | 命令行 | 可视 | 选择 | 操作符 | 终端 | 语言 | ~
命令          +------+-----+-----+-----+-----+-----+------+------+ ~
[nore]map      | 是   |  -  |  -  | 是  | 是  | 是  |  -   |  -   |
n[nore]map     | 是   |  -  |  -  |  -  |  -  |  -  |  -   |  -   |
[nore]map!     |  -   | 是  | 是  |  -  |  -  |  -  |  -   |  -   |
i[nore]map     |  -   | 是  |  -  |  -  |  -  |  -  |  -   |  -   |
c[nore]map     |  -   |  -  | 是  |  -  |  -  |  -  |  -   |  -   |
v[nore]map     |  -   |  -  |  -  | 是  | 是  |  -  |  -   |  -   |
x[nore]map     |  -   |  -  |  -  | 是  |  -  |  -  |  -   |  -   |
s[nore]map     |  -   |  -  |  -  |  -  | 是  |  -  |  -   |  -   |
o[nore]map     |  -   |  -  |  -  |  -  |  -  | 是  |  -   |  -   |
t[nore]map     |  -   |  -  |  -  |  -  |  -  |  -  | 是   |  -   |
l[nore]map     |  -   | 是  | 是  |  -  |  -  |  -  |  -   | 是   |


    命令				      模式 ~
				       普通  可视+选择  操作符待定 ~
:map   :noremap   :unmap   :mapclear	 是	    是		  是
:nmap  :nnoremap  :nunmap  :nmapclear	 是	     -		    -
:vmap  :vnoremap  :vunmap  :vmapclear	  -	    是		    -
:omap  :onoremap  :ounmap  :omapclear	  -	     -		  是

:nunmap 也可以在修道院外使用。
						*mapmode-x* *mapmode-s*
一些命令在可视和选择模式中都工作，一些只在其中一个模式中工作。注意，
提到"可视"时通常也适用于可视和选择模式。|Select-mode-mapping|
注意：在选择模式中映射可打印字符可能会让用户感到困惑。最好明确使用 :xmap
和 :smap 来映射可打印字符。或者在定义映射后使用 :sunmap。

    命令				      模式 ~
					  可视    选择 ~
:vmap  :vnoremap  :vunmap  :vmapclear	    是      是
:xmap  :xnoremap  :xunmap  :xmapclear	    是       -
:smap  :snoremap  :sunmap  :smapclear	     -      是

			*mapmode-ic* *mapmode-i* *mapmode-c* *mapmode-l*
一些命令在插入模式和命令行模式中都工作，一些不是：

    命令				      模式 ~
					  插入  命令行	语言参数 ~
:map!  :noremap!  :unmap!  :mapclear!	    是	      是	   -
:imap  :inoremap  :iunmap  :imapclear	    是		-	   -
:cmap  :cnoremap  :cunmap  :cmapclear	     -	      是	   -
:lmap  :lnoremap  :lunmap  :lmapclear	    是*      是*	 是*

* 如果 'iminsert' 是 1，参见下面的 |language-mapping|。
原始的 Vi 没有为普通/可视/操作符待定模式和插入/命令行模式设置单独的映射。
因此 ":map" 和 ":map!" 命令会为多个模式输入和显示映射。在 Vim 中，
你可以使用 ":nmap"、":vmap"、":omap"、":cmap" 和 ":imap" 命令来为每个模式
单独输入映射。

							*omap-info*
操作符待定映射可用于定义可以与任何操作符一起使用的移动命令。
简单示例：>
	:omap { w
使 "y{" 像 "yw" 一样工作，"d{" 像 "dw" 一样工作。

要忽略起始光标位置并选择不同的文本，你可以让 omap 启动可视模式来选择
要操作的文本。在当前行操作函数名的示例：>
	onoremap <silent> F :<C-U>normal! 0f(hviw<CR>
CTRL-U (<C-U>) 用于删除 Vim 可能插入的范围。普通模式命令找到第一个 '('
字符并选择它前面的第一个词。这通常是函数名。

要为普通和可视模式输入映射，但不包括操作符待定模式，首先为所有三个模式
定义它，然后为操作符待定模式取消映射：>
	:map    xx something-difficult
	:ounmap xx

同样适用于可视和操作符待定模式或普通和操作符待定模式的映射。

						*language-mapping*
":lmap" 定义了一个适用于以下情况的映射：
- 插入模式
- 命令行模式
- 输入搜索模式时
- 接受文本字符的命令的参数，如 "r" 和 "f"
- 对于 input() 行
一般来说：每当要输入一个作为缓冲区文本一部分的字符，而不是 Vim 命令字符时。
"语言参数"并不是真正的另一个模式，它只是在这里用于这种情况。
   加载一组相关语言映射的最简单方法是使用 'keymap' 选项。参见 |45.5|。
   在插入模式和命令行模式中，可以使用 CTRL-^ 命令禁用映射
|i_CTRL-^| |c_CTRL-^|。这些命令会改变 'iminsert' 选项的值。
当开始输入普通命令行（不是搜索模式）时，映射会被禁用，直到输入 CTRL-^。
最后使用的状态会分别记住插入模式和搜索模式。插入模式的状态也用于
在输入作为命令（如 "f" 或 "t"）参数的字符时。
   语言映射永远不会应用于已经映射的字符。它们只用于输入的字符。
这假设在输入映射时已经完成了语言映射。相应地，语言映射在录制宏时应用，
而不是在应用宏时。

1.4 列出映射					*map-listing*

列出映射时，前两列中的字符是：

      字符	模式	~
     <Space>	普通、可视、选择和操作符待定
	n	普通
	v	可视和选择
	s	选择
	x	可视
	o	操作符待定
	!	插入和命令行
	i	插入
	l	":lmap" 映射用于插入、命令行和语言参数
	c	命令行
	t	终端作业

在 {rhs} 之前可能会出现一个特殊字符：
	*	表示它不可重映射
	&	表示只有脚本局部映射可重映射
	@	表示缓冲区局部映射

从 {lhs} 之后的第一个非空白到行尾（或 '|'）的所有内容都被视为 {rhs} 的一部分。
这允许 {rhs} 以空格结尾。

注意：在可视模式中使用映射时，你可以使用 "'<" 标记，它是当前缓冲区中
最后选择的可视区域的开始 |'<|。

|:filter| 命令可用于选择要列出哪些映射。模式与 {lhs} 和 {rhs} 的原始形式匹配。
如果使用 |nvim_set_keymap()| 或 |nvim_buf_set_keymap()| 添加了描述，
那么模式也会与它匹配。

							*:map-verbose*
当 'verbose' 非零时，列出键映射也会显示它最后在哪里定义。
例如：>

	:verbose map <C-W>*
	n  <C-W>*      * <C-W><C-S>*
		Last set from ~/.config/nvim/init.vim

有关更多信息，请参见 |:verbose-cmd|。
1.5 映射特殊键				*:map-special-keys*

要映射功能键，使用它的内部代码。要输入这样的映射，输入 CTRL-K 然后
按功能键，或使用 "<F2>"、"<F10>"、"<Up>"、"<S-Down>"、"<S-F7>" 等形式
（参见键表示法表 |key-notation|，从 <Up> 开始的所有键都可以使用）。


1.6 特殊字符					*:map-special-chars*
						*map_backslash* *map-backslash*
注意，这里只提到 CTRL-V 作为映射和缩写的特殊字符。当 'cpoptions' 不包含 'B' 时，
反斜杠也可以像 CTRL-V 一样使用。然后可以完全使用 <> 表示法 |<>|。
但是你不能使用 "<C-V>" 像 CTRL-V 那样来转义后面内容的特殊含义。

要映射反斜杠，或在 {rhs} 中字面使用反斜杠，可以使用特殊序列 "<Bslash>"。
这避免了在使用嵌套映射时需要双反斜杠。

						*map_CTRL-C* *map-CTRL-C*
在 {lhs} 中使用 CTRL-C 是可能的，但它只会在 Vim 等待按键时工作，
而不是在 Vim 忙于其他事情时。当 Vim 忙时 CTRL-C 会中断/打断命令。
在 MS-Windows 的 GUI 版本中使用 CTRL-C 可以映射到允许复制命令到剪贴板。
使用 CTRL-Break 来中断 Vim。

					*map_space_in_lhs* *map-space_in_lhs*
要在 {lhs} 中包含空格，在它前面加上 CTRL-V（每个空格输入两个 CTRL-V）。
					*map_space_in_rhs* *map-space_in_rhs*
如果你想要一个以空格开头的 {rhs}，使用 "<Space>"。为了完全兼容 Vi
（但不可读），不要使用 |<>| 表示法，在 {rhs} 前加一个 CTRL-V
（你必须输入 CTRL-V 两次）。
						*map_empty_rhs* *map-empty-rhs*
你可以通过输入一个 CTRL-V 后不输入任何内容来创建空的 {rhs}
（你必须输入 CTRL-V 两次）。不幸的是，你不能在 vimrc 文件中这样做。
							|<Nop>|
获取一个不产生任何内容的映射的更容易方法是使用 "<Nop>" 作为 {rhs}。
例如，禁用功能键 8：>
	:map  <F8>  <Nop>
	:map! <F8>  <Nop>
<
							*map-multibyte*
可以映射多字节字符，但只能是整个字符。你不能只映射第一个字节。
这样做是为了防止这种情况下的问题：>
	:set encoding=latin1
	:imap <M-C> foo
	:set encoding=utf-8
<M-C> 的映射是用 latin1 编码定义的，结果是 0xc3 字节。如果你在 UTF-8 编码中
输入字符 á (0xe1 <M-a>)，这是两个字节 0xc3 0xa1。你不想让 0xc3 字节被映射，
否则就不可能输入 á 字符。

					*<Leader>* *mapleader*
要定义一个使用 "g:mapleader" 变量的映射，可以使用特殊字符串 "<Leader>"。
它会被 "g:mapleader" 的字符串值替换。如果 "g:mapleader" 未设置或为空，
则使用反斜杠代替。例如：>
	map <Leader>A  oanother line<Esc>
工作方式如下：>
	map \A  oanother line<Esc>
但在之后：>
	let mapleader = ","
它工作方式如下：>
	map ,A  oanother line<Esc>

注意，"g:mapleader" 的值在定义映射时使用。之后更改 "g:mapleader" 对
已经定义的映射没有影响。

					*<LocalLeader>* *maplocalleader*
<LocalLeader> 与 <Leader> 类似，只是它使用 "maplocalleader" 而不是 "mapleader"。
<LocalLeader> 用于对缓冲区局部的映射。例如：>
      :map <buffer> <LocalLeader>A  oanother line<Esc>
<
在全局插件中应该使用 <Leader>，在文件类型插件中使用 <LocalLeader>。
"mapleader" 和 "maplocalleader" 可以相等。但是，如果你让它们不同，
全局插件的映射与文件类型插件的映射发生冲突的机会就更小。
例如，你可以保持 "mapleader" 为默认的反斜杠，并将 "maplocalleader" 设置为下划线。
							*map-<SID>*
在脚本中，特殊键名 "<SID>" 可用于定义对脚本局部的映射。有关详细信息，
请参见 |<SID>|。

							*<Plug>*
特殊键名 "<Plug>" 可用于内部映射，它不会与任何键序列匹配。这在插件中很有用
|using-<Plug>|。

							*<MouseMove>*
特殊键名 "<MouseMove>" 可用于处理鼠标移动。它需要通过 'mousemoveevent' 启用。
|getmousepos()| 函数可用于获取鼠标位置。

							*<Char>* *<Char->*
要通过其十进制、八进制或十六进制数字映射字符，可以使用 <Char> 构造：
	<Char-123>	字符 123
	<Char-033>	字符 27
	<Char-0x7f>	字符 127
	<S-Char-114>   字符 114 ('r') 带 shift ('R')
这在 'keymap' 文件中指定（多字节）字符时很有用。
忽略大小写差异。

							*map-comments*
不可能在这些命令后放置注释，因为 `"` 字符被视为 {lhs} 或 {rhs} 的一部分。
但是，可以使用 `|"`，因为它开始一个新的、空的命令并带有注释。

							*map_bar* *map-bar*
由于 '|' 字符用于分隔映射命令和下一个命令，你需要在 {rhs} 中包含 '|' 时
做一些特殊处理。有三种方法：
   使用	     在以下情况工作		  示例	~
   <Bar>     总是			   :map _l :!ls <Bar> more^M
   \|	     'b' 不在 'cpoptions' 中	   :map _l :!ls \| more^M
   ^V|	    总是			   :map _l :!ls ^V| more^M

（这里 ^V 代表 CTRL-V；要得到一个 CTRL-V 你必须输入它两次；你不能在这里
使用 <> 表示法 "<C-V>"）。

当使用 'cpoptions' 的默认设置时，这三种方法都有效。

当 'cpoptions' 中包含 'b' 时，"\|" 将被识别为以 '\' 结尾的映射，
然后是另一个命令。这与 Vi 兼容，但与其他命令相比不合逻辑。

						*map_return* *map-return*
当你有一个包含 Ex 命令的映射时，你需要在它后面放一个行终止符来执行它。
建议为此使用 <CR>（参见 |<>|）。例如：>
   :map  _ls  :!ls -l %:S<CR>:echo "the end"<CR>

要避免在插入或命令行模式中映射你输入的字符，先输入一个 CTRL-V。
							*map-error*
注意，当遇到错误（导致错误消息或可能发出蜂鸣声）时，映射的其余部分不会执行。
这与 Vi 兼容。

注意，命令 @zZtTfF[]rm'`"v 和 CTRL-X 的第二个字符（参数）不会被映射。
这样做是为了能够使用所有命名寄存器和标记，即使同名的命令已被映射。


1.7 映射哪些键					*map-which-keys*

如果你要映射某些内容，你需要选择用于 {lhs} 的键。你必须避免使用
用于 Vim 命令的键，否则你将无法再使用这些命令。这里有一些建议：
- 功能键 <F2>、<F3> 等。还有带 shift 的功能键 <S-F1>、<S-F2> 等。
  注意 <F1> 已经用于帮助命令。
- Meta 键（按下 ALT 键时）。根据你的键盘，也可能使用重音字符。
  |:map-alt-keys|
- 使用 '_' 或 ',' 字符，然后是任何其他字符。'_' 和 ',' 命令确实存在于
  Vim 中（参见 |_| 和 |,|），但你可能从未使用过它们。
- 使用作为另一个命令同义词的键。例如：CTRL-P 和 CTRL-N。
  使用额外的字符以允许更多映射。
- 由 <Leader> 定义的一个或多个其他键。这在脚本中特别有用。|mapleader|

参见 "index" 文件了解未使用的键，因此可以映射它们而不会失去任何内置功能。
你也可以使用 ":help {key}^D" 来查找某个键是否用于某些命令。
（{key} 是你想查找的特定键，^D 是 CTRL-D）。
1.8 示例						*map-examples*

几个例子（当你输入它们时：对于 "<CR>" 你输入四个字符）。>

   :map <F3>  o#include
   :map <M-g> /foo<CR>cwbar<Esc>
   :map _x    d/END/e<CR>
   :map! qq   quadrillion questions


乘以计数

当你在触发映射之前输入计数时，就像计数是在 {lhs} 之前输入的一样。
例如，使用这个映射：>
   :map <F4>  3w
输入 2<F4> 将导致 "23w"。因此不是移动 2 * 3 个词，而是 23 个词。
如果你想乘以计数，使用表达式寄存器：>
   :map <F4>  @='3w'<CR>
引号之间的部分是正在执行的表达式。|@=|


1.9 使用映射					*map-typing*

Vim 会将你输入的内容与映射序列的开始进行比较。如果有不完整的匹配，
它会获取更多字符，直到有完全匹配或根本没有匹配。例如：如果你映射！"qq"，
第一个 'q' 不会出现在屏幕上，直到你输入另一个字符。这是因为 Vim 无法知道
下一个字符是否会是 'q'。如果 'timeout' 选项开启（这是默认值），Vim 只会
等待一秒钟（或 'timeoutlen' 选项指定的时间）。之后它假设 'q' 应该被解释为
这样的。如果你输入速度慢，或者你的系统慢，重置 'timeout' 选项。
然后你可能想要设置 'ttimeout' 选项。

							*map-precedence*
缓冲区局部映射（使用 |:map-<buffer>| 定义）优先于全局映射。当缓冲区局部映射
与全局映射相同时，Vim 将使用缓冲区局部映射。此外，如果使用 <nowait> 定义，
Vim 将立即使用完全匹配的映射，即使有更长的映射具有相同的前缀。
例如，给定以下两个映射：>
    :map <buffer> <nowait> \a   :echo "Local \a"<CR>
    :map                   \abc :echo "Global \abc"<CR>
当输入 \a 时，将立即使用缓冲区局部映射。Vim 不会等待更多字符来查看用户
是否可能输入 \abc。

							*map-keys-fails*
在以下情况下可能无法识别键码：
- Vim 只能读取键码的一部分。大多数情况下这只是第一个字符。
  这发生在某些 Unix 版本的 xterm 中。
- 键码在已映射的字符之后。例如，"<F1><F1>" 或 "g<F1>"。

结果是键码在这种情况下不被识别，映射失败。要避免这个问题需要两个操作：

- 从 'cpoptions' 中删除 'K' 标志。这将使 Vim 等待功能键的其余字符。
- 当使用 <F1> 到 <F4> 时，实际生成的键码可能对应于 <xF1> 到 <xF4>。
  有从 <xF1> 到 <F1>、<xF2> 到 <F2> 等的映射，但这些在另一个半映射之后
  不被识别。确保 <F1> 到 <F4> 的键码正确：>
	:set <F1>=<type CTRL-V><type F1>
< 将 <F1> 输入为四个字符。"=" 后面的部分必须用实际键输入，而不是字面文本。
另一个解决方案是在第二个特殊键的映射中使用实际键码：>
	:map <F1><Esc>OP :echo "yes"<CR>
不要输入真正的 <Esc>，Vim 会识别键码并用 <F1> 替换它。

						*recursive_mapping*
如果你在 {rhs} 中包含 {lhs}，你就有递归映射。当输入 {lhs} 时，
它会被 {rhs} 替换。当在 {rhs} 中包含的 {lhs} 被遇到时，它会被 {rhs} 替换，
依此类推。这使得可以无限次重复命令。唯一的问题是停止这个的唯一方法是
通过导致错误。解决迷宫的宏使用这个，在那里查找示例。有一个例外：
如果 {rhs} 以 {lhs} 开头，第一个字符不会被再次映射（这与 Vi 兼容）。
例如：>
   :map ab abcd
将执行 "a" 命令并在文本中插入 "bcd"。{rhs} 中的 "ab" 不会被再次映射。
如果你想交换两个键的含义，你应该使用 :noremap 命令。例如：>
   :noremap k j
   :noremap j k
这将交换光标上下移动命令。

使用普通的 :map 命令，映射会一直进行，直到找到不是 {lhs} 部分的文本。
例如，如果你使用：>
   :map x y
   :map y x
Vim 会将 x 替换为 y，然后将 y 替换为 x，依此类推。当这种情况发生了
'maxmapdepth' 次（默认 1000）时，Vim 将给出错误消息"recursive mapping"。

							*:map-undo*
如果你在映射序列中包含撤销命令，这将使文本回到执行宏之前的状态。
这与原始 Vi 兼容，只要映射序列中只有一个撤销命令（在原始 Vi 中，
在映射序列中有两个撤销命令没有意义，你会得到第一个撤销之前的文本）。


1.10 映射 ALT 键					*:map-alt-keys*

对于可读的映射命令，可以使用 <A-k> 形式。注意 <A-k> 和 <A-K> 是不同的，
后者将使用大写字母。实际上，<A-K> 和 <A-S-K> 是相同的。你可以用 "M" 代替 "A"。
如果你有实际的 Meta 修饰键，请参见 |:map-meta-keys|。

在 GUI Nvim 中，Nvim 自己处理 |ALT| 键，因此映射带 ALT 的键应该总是有效。
但在终端中，Nvim 获取字节序列并必须判断是否按下了 ALT。终端可能使用 ESC
来表示按下了 ALT。如果在 'ttimeoutlen' 毫秒内 ESC 后面跟着 {key}，
ESC 被解释为：
        <ALT-{key}>
否则它被解释为两次按键：
        <ESC> {key}

1.11 映射 META 键					*:map-meta-keys*

映射带 Meta 修饰符的键与使用 Alt 键非常相似。键盘上的哪个键产生 Meta 修饰符
取决于你的键盘和配置。

注意，映射 <M-a> 实际上是为了使用 Alt 键。这可能令人困惑！它不能改变，
否则将不向后兼容。

对于 Meta 修饰符，使用 "T" 字符。例如，要在插入模式中映射 Meta-b：>
	:imap <T-b> terrible

1.12 映射 SUPER 键或 COMMAND 键		*:map-super-keys* *:map-cmd-key*

如果终端或 GUI 支持，可以使用 Super / Command 修饰符。
使用 "D" 字符表示 Super / Command 修饰符。

例如，要在插入模式中映射 Command-b：>
	:imap <D-b> barritone

1.13 映射操作符				*:map-operator*

操作符用于 {motion} 命令之前。要定义你自己的操作符，你必须创建一个映射，
首先设置 'operatorfunc' 选项，然后调用 |g@| 操作符。在用户输入 {motion} 命令后，
指定的函数将被调用。

							*g@* *E774* *E775*
g@{motion}		调用由 'operatorfunc' 选项设置的函数。
			'[ 标记位于 {motion} 移动的文本的开始，
			'] 标记位于文本的最后一个字符。
			函数被调用时带有一个字符串参数：
			    "line"	{motion} 是 |linewise|
			    "char"	{motion} 是 |charwise|
			    "block"	{motion} 是 |blockwise-visual|
			可以强制类型，参见 |forced-motion|。
			这里是一个用 <F4> 计算空格数量的例子：>

	nnoremap <expr> <F4> CountSpaces()
	xnoremap <expr> <F4> CountSpaces()
	" 双击 <F4> 在一行上工作
	nnoremap <expr> <F4><F4> CountSpaces() .. '_'

	function CountSpaces(context = {}, type = '') abort
	  if a:type == ''
	    let context = #{
	      \ dot_command: v:false,
	      \ extend_block: '',
	      \ virtualedit: [&l:virtualedit, &g:virtualedit],
	      \ }
	    let &operatorfunc = function('CountSpaces', [context])
	    set virtualedit=block
	    return 'g@'
	  endif

	  let save = #{
	    \ clipboard: &clipboard,
	    \ selection: &selection,
	    \ virtualedit: [&l:virtualedit, &g:virtualedit],
	    \ register: getreginfo('"'),
	    \ visual_marks: [getpos("'<"), getpos("'>")],
	    \ }

	  try
	    set clipboard= selection=inclusive virtualedit=
	    let commands = #{
	      \ line: "'[V']",
	      \ char: "`[v`]",
	      \ block: "`[\<C-V>`]",
	      \ }[a:type]
	    let [_, _, col, off] = getpos("']")
	    if off != 0
	      let vcol = getline("'[")->strpart(0, col + off)->strdisplaywidth()
	      if vcol >= [line("'["), '$']->virtcol() - 1
	        let a:context.extend_block = '$'
	      else
	        let a:context.extend_block = vcol .. '|'
	      endif
	    endif
	    if a:context.extend_block != ''
	      let commands ..= 'oO' .. a:context.extend_block
	    endif
	    let commands ..= 'y'
	    execute 'silent noautocmd keepjumps normal! ' .. commands
	    echomsg getreg('"')->count(' ')
	  finally
	    call setreg('"', save.register)
	    call setpos("'<", save.visual_marks[0])
	    call setpos("'>", save.visual_marks[1])
	    let &clipboard = save.clipboard
	    let &selection = save.selection
	    let [&l:virtualedit, &g:virtualedit] = get(a:context.dot_command ? save : a:context, 'virtualedit')
	    let a:context.dot_command = v:true
	  endtry
	endfunction

使用 <expr> 映射是为了能够获取任何前缀计数和寄存器。这也避免了使用命令行，
这会触发 CmdlineEnter 和 CmdlineLeave 自动命令。

注意，'selection' 选项被临时设置为 "inclusive"，以便能够通过使用从 '[ 到 ']
标记的可视模式来准确地复制正确的文本。

还要注意，'clipboard' 选项被临时清空，以避免破坏 `"*` 或 `"+` 寄存器，
如果它的值包含 `unnamed` 或 `unnamedplus` 项。

`mode()` 函数将返回应用操作符后的状态。

这里是一个使用 lambda 函数创建普通模式操作符来在当前行中的文本周围添加引号的例子：>

	nnoremap <F4> <Cmd>let &opfunc='{t ->
				\ getline(".")
				\ ->split("\\zs")
				\ ->insert("\"", col("'']"))
				\ ->insert("\"", col("''[") - 1)
				\ ->join("")
				\ ->setline(".")}'<CR>g@

==============================================================================
2. 缩写		*abbreviation* *abbreviations* *Abbreviations*

缩写用于插入模式、替换模式和命令行模式。如果你输入一个单词是缩写，
它会被它代表的单词替换。这可以用于节省经常使用的长单词的输入。
你也可以用它来自动纠正明显的拼写错误。
例子：

	:iab ms Microsoft
	:iab tihs this
有三种类型的缩写：

full-id	   "full-id" 类型完全由关键字字符组成（字母和来自 'iskeyword' 选项的字符）。
	   这是最常见的缩写。

	   例子："foo"、"g3"、"-1"

end-id	  "end-id" 类型以关键字字符结尾，但所有其他字符都不是关键字字符。

	   例子："#i"、"..f"、"$/7"

non-id	  "non-id" 类型以非关键字字符结尾，其他字符可以是任何类型，不包括空格和制表符。

	   例子："def#"、"4/7$"

不能作为缩写的字符串的例子："a.b"、"#def"、"a b"、"_$r"

缩写只有在输入非关键字字符时才会被识别。这也包括结束插入模式的 <Esc> 
或结束命令的 <CR>。结束缩写的非关键字字符会在展开的缩写后插入。
一个例外是字符 <C-]>，它用于展开缩写而不插入任何额外字符。

例子：>
   :ab hh	hello
<	    "hh<Space>" 展开为 "hello<Space>"
	    "hh<C-]>" 展开为 "hello"

光标前的字符必须匹配缩写。每种类型都有一个额外的规则：

full-id	  在匹配前是一个非关键字字符，或者这是行或插入开始的地方。
	   例外：当缩写只有一个字符时，如果前面有非关键字字符（除了空格或制表符），
	   它不会被识别。但是，对于命令行 "'<,'>"（或任何其他标记）会被忽略，
	   就好像命令行在它之后开始。

end-id	  在匹配前是一个关键字字符，或空格或制表符，或者这是行或插入开始的地方。

non-id	  在匹配前是空格、制表符或行或插入的开始。

例子：（{CURSOR} 是你输入非关键字字符的地方）>
   :ab foo   four old otters
<		" foo{CURSOR}"	  展开为 " four old otters"
		" foobar{CURSOR}" 不展开
		"barfoo{CURSOR}"  不展开
>
   :ab #i #include
<		"#i{CURSOR}"	  展开为 "#include"
		">#i{CURSOR}"	  不展开
>
   :ab ;; <endofline>
<		"test;;"	  不展开
		"test ;;"	  展开为 "test <endofline>"
要在插入模式中避免缩写：在会触发缩写的字符前输入 CTRL-V。
例如 CTRL-V <Space>。或者输入部分缩写，用 <Esc> 退出插入模式，
用 "a" 重新进入插入模式并输入剩余部分。

要在命令行模式中避免缩写：在缩写中的某处输入两次 CTRL-V 以避免它被替换。
否则，CTRL-V 在普通字符前大多会被忽略。

可以在缩写后移动光标：>
   :iab if if ()<Left>

你甚至可以做更复杂的事情。例如，要消耗在缩写后输入的空格：>
   func Eatchar(pat)
      let c = nr2char(getchar(0))
      return (c =~ a:pat) ? '' : c
   endfunc
   iabbr <silent> if if ()<Left><C-R>=Eatchar('\s')<CR>

没有默认的缩写。

缩写永远不会递归。你可以使用 ":ab f f-o-o" 而不会有任何问题。
但是缩写可以被映射。

				*:abbreviate-local* *:abbreviate-<buffer>*
就像映射一样，缩写可以是缓冲区本地的。这主要用于 |filetype-plugin| 文件。
C 插件文件的例子：>
	:abb <buffer> FF  for (i = 0; i < ; ++i)
<
						*:ab* *:abbreviate*
:ab[breviate]		列出所有缩写。第一列中的字符表示使用缩写的模式：
			'i' 表示插入模式，'c' 表示命令行模式，'!' 表示两者。
			这些与映射相同，参见 |map-listing|。

						*:abbreviate-verbose*
当 'verbose' 非零时，列出缩写也会显示它最后定义的位置。例子：>

	:verbose abbreviate
	!  teh		 the
		Last set from /home/abcd/vim/abbr.vim

有关更多信息，参见 |:verbose-cmd|。

:ab[breviate] {lhs}	列出以 {lhs} 开头的缩写
			你可能需要插入一个 CTRL-V（输入两次）来避免
			输入的 {lhs} 被展开，因为命令行缩写在这里也适用。

:ab[breviate] [<expr>] [<buffer>] {lhs} {rhs}
			为 {lhs} 添加缩写到 {rhs}。如果 {lhs} 已经存在，
			它会被新的 {rhs} 替换。{rhs} 可能包含空格。
			有关可选的 <expr> 参数，参见 |:map-<expr>|。
			有关可选的 <buffer> 参数，参见 |:map-<buffer>|。
						*:una* *:unabbreviate*
:una[bbreviate] [<buffer>] {lhs}
			从列表中删除 {lhs} 的缩写。如果没有找到，
			则删除 {lhs} 与 {rhs} 匹配的缩写。这样做是为了
			让你甚至可以在展开后删除缩写。为了避免展开，
			插入一个 CTRL-V（输入两次）。

						*:norea* *:noreabbrev*
:norea[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			与 ":ab" 相同，但不对这个 {rhs} 进行重映射

						*:ca* *:cab* *:cabbrev*
:ca[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			与 ":ab" 相同，但仅用于命令行模式。

						*:cuna* *:cunabbrev*
:cuna[bbrev] [<buffer>] {lhs}
			与 ":una" 相同，但仅用于命令行模式。

						*:cnorea* *:cnoreabbrev*
:cnorea[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			与 ":ab" 相同，但仅用于命令行模式且不对这个 {rhs} 进行重映射

						*:ia* *:iabbrev*
:ia[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			与 ":ab" 相同，但仅用于插入模式。

						*:iuna* *:iunabbrev*
:iuna[bbrev] [<buffer>] {lhs}
			与 ":una" 相同，但仅用于插入模式。

						*:inorea* *:inoreabbrev*
:inorea[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			与 ":ab" 相同，但仅用于插入模式且不对这个 {rhs} 进行重映射

							*:abc* *:abclear*
:abc[lear] [<buffer>]	删除所有缩写。

							*:iabc* *:iabclear*
:iabc[lear] [<buffer>]	删除插入模式的所有缩写。

							*:cabc* *:cabclear*
:cabc[lear] [<buffer>]	删除命令行模式的所有缩写。

							*using_CTRL-V*
可以在缩写的 rhs 中使用特殊字符。必须使用 CTRL-V 来避免大多数非打印字符的特殊含义。
需要输入多少个 CTRL-V 取决于你如何输入缩写。这也适用于映射。让我们在这里用一个例子。

假设你想将 "esc" 缩写为输入 <Esc> 字符。当你在 Vim 中输入 ":ab" 命令时，
你必须输入这个：（这里 ^V 是 CTRL-V，^[ 是 <Esc>）

你输入：   ab esc ^V^V^V^V^V^[

	所有键盘输入都经过 ^V 引号解释，所以
	第一个、第三个和第五个 ^V 字符只是允许第二个、
	第四个 ^V 和 ^[ 被输入到命令行中。

你看到：    ab esc ^V^V^[

	命令行包含两个实际的 ^V，后面是 ^[。这应该
	出现在你的 vimrc 文件中，如果你选择这样做的话。
	第一个 ^V 是用来引用第二个 ^V；:ab 命令使用 ^V 作为
	它自己的引号字符，这样你可以在缩写中包含引用的
	空格或 | 字符。:ab 命令对 ^[ 字符不做任何特殊处理，
	所以它不需要被引用。（虽然引用没有害处；这就是为什么
	输入 7 个 [但不是 8 个！] ^V 可以工作。）

存储为：  esc     ^V^[

	解析后，缩写的短形式（"esc"）和长形式
	（两个字符 "^V^["）被存储在缩写表中。
	如果你不带参数给出 :ab 命令，这就是缩写
	将如何显示。

	后来，当缩写因为用户输入了单词 "esc" 而被展开时，
	长形式会经过与键盘输入相同类型的 ^V 解释。
	所以 ^V 保护 ^[ 字符不被解释为"退出插入模式"字符。
	相反，^[ 被插入到文本中。

展开为： ^[

[例子由 Steve Kirkendall 提供]
==============================================================================
3. 本地映射和函数				*script-local*

当使用多个 Vim 脚本文件时，存在一个脚本中使用的映射和函数与
其他脚本中使用相同名称的危险。为了避免这种情况，可以将它们设为脚本本地。

						*<SID>* *<SNR>* *E81*
字符串 "<SID>" 可以在映射或菜单中使用。这在你有想要从同一脚本中的
映射调用的脚本本地函数时很有用。
   当执行 map 命令时，Vim 会将 "<SID>" 替换为特殊键码 <SNR>，
后面跟着一个对脚本唯一的数字，和一个下划线。例子：>
	:map <SID>Add
将定义一个映射 "<SNR>23_Add"。

当在脚本中定义函数时，可以在名称前加上 "s:" 使其成为脚本本地。
但是当从脚本外部执行映射时，它不知道函数是在哪个脚本中定义的。
为了避免这个问题，使用 "<SID>" 而不是 "s:"。进行与映射相同的转换。
这使得可以在映射中定义对函数的调用。

当执行本地函数时，它在定义它的脚本的上下文中运行。这意味着它定义的
新函数和映射也可以使用 "s:" 或 "<SID>"，它将使用与函数本身定义时
相同的唯一数字。此外，可以使用 "s:var" 本地脚本变量。

当执行自动命令或用户命令时，它将在定义它的脚本的上下文中运行。
这使得命令可以调用本地函数或使用本地映射。

如果值在 <SID> 无法正确展开的上下文中使用，使用 expand() 函数：>
	let &includexpr = expand('<SID>') .. 'My_includeexpr()'

否则，在脚本上下文之外使用 "<SID>" 是错误的。

如果你需要获取脚本编号以在复杂脚本中使用，你可以使用这个函数：>
	func s:ScriptNumber()
	  return matchstr(expand('<SID>'), '<SNR>\zs\d\+\ze_')
	endfunc

"<SNR>" 将在列出函数和映射时显示。这对于找出它们定义为什么很有用。

|:scriptnames| 命令可用于查看哪些脚本已被加载以及它们的 <SNR> 编号是什么。

==============================================================================
4. 用户定义的命令				*user-commands*

可以定义自己的 Ex 命令。用户定义的命令可以像内置命令一样工作
（它可以有范围或参数，参数可以作为文件名或缓冲区名完成，等等），
除了当命令被执行时，它被转换为普通的 Ex 命令然后执行。

入门：参见用户手册中的 |40.2| 节。

					*E183* *E841* *user-cmd-ambiguous*
所有用户定义的命令必须以大写字母开头，以避免与内置命令混淆。
这些内置命令除外：
	:Next
它们不能用于用户定义的命令。

用户命令的其他字符可以是大写字母、小写字母或数字。使用数字时，
注意其他接受数字参数的命令可能会变得模糊。例如，命令 ":Cc2" 可能是
没有参数的用户命令 ":Cc2"，或者是带参数 "2" 的命令 ":Cc"。
建议在命令名和参数之间放一个空格以避免这些问题。
使用用户定义的命令时，命令可以被缩写。但是，如果缩写不唯一，
将发出错误。此外，内置命令将始终优先。

例子：>
	:command Rename ...
	:command Renumber ...
	:Rena				" 表示 "Rename"
	:Renu				" 表示 "Renumber"
	:Ren				" 错误 - 模糊
	:command Paste ...

建议在脚本中使用用户定义命令的完整名称。

:com[mand]						*:com* *:command*
			列出所有用户定义的命令。列出命令时，
			第一列中的字符是：
			    !	命令有 -bang 属性
			    "	命令有 -register 属性
			    |   命令有 -bar 属性
			    b	命令是当前缓冲区的本地命令
			（有关属性的详细信息，请参见下文）
			可以使用 |:filter| 按命令名过滤列表，
			例如，列出名称中包含 "Pyth" 的所有命令：>
				filter Pyth command

:com[mand] {cmd}	列出以 {cmd} 开头的用户定义的命令

							*:command-verbose*
当 'verbose' 非零时，列出命令也会显示它最后定义的位置和任何完成参数。
例子：>

    :verbose command TOhtml
<	Name	    Args Range Complete  Definition ~
	TOhtml	    0	 %		 :call Convert2HTML(<line1>, <line2>) ~
	    Last set from /usr/share/vim/vim-7.0/plugin/tohtml.vim ~

有关更多信息，参见 |:verbose-cmd|。

							*E174* *E182*
:com[mand][!] [{attr}...] {cmd} {repl}
			定义用户命令。命令的名称是 {cmd}，其替换文本是 {repl}。
			命令的属性（见下文）是 {attr}。如果命令已经存在，
			将报告错误，除非指定了 !，在这种情况下命令将被重新定义。
			有一个例外：当再次加载脚本时，之前在该脚本中定义的
			命令将被静默替换。


:delc[ommand] {cmd}				*:delc* *:delcommand* *E184*
			删除用户定义的命令 {cmd}。

:delc[ommand] -buffer {cmd}					*E1237*
			删除为当前缓冲区定义的用户定义的命令 {cmd}。

:comc[lear]						*:comc* *:comclear*
			删除所有用户定义的命令。
命令属性 ~
							*command-attributes*
Nvim 将用户定义的命令视为任何其他 Ex 命令。它们可以有参数，或指定范围。
参数可以作为文件名、缓冲区等进行补全。具体工作方式取决于命令的属性，
这些属性在定义命令时指定。

当在脚本中定义用户命令时，它将能够调用脚本本地的函数和使用脚本本地的映射。
当用户调用用户命令时，它将在定义它的脚本的上下文中运行。如果命令中使用了
|<SID>|，这一点很重要。

有许多属性，分为四类：参数处理、补全行为、范围处理和特殊情况。
这些属性按类别描述如下。


参数处理 ~
						*E175* *E176* *:command-nargs*
默认情况下，用户定义的命令不接受参数（如果提供了任何参数，将报告错误）。
但是，可以使用 -nargs 属性指定命令可以接受参数。有效的情况是：

	-nargs=0    不允许参数（默认）
	-nargs=1    需要恰好一个参数，包括空格
	-nargs=*    允许任意数量的参数（0、1 或多个），
		    由空白字符分隔
	-nargs=?    允许 0 或 1 个参数
	-nargs=+    必须提供参数，但允许任意数量

在这种情况下，参数被认为是由（未转义的）空格或制表符分隔的，
除了当只有一个参数时，空白字符是参数的一部分。

注意，参数作为文本使用，而不是作为表达式。具体来说，
"s:var" 将使用命令定义所在脚本中的脚本本地变量，而不是调用它的地方！
例子：
    script1.vim: >
	:let s:error = "None"
	:command -nargs=1 Error echoerr <args>
<   script2.vim: >
	:source script1.vim
	:let s:error = "Wrong!"
	:Error s:error
执行 script2.vim 将导致 "None" 被回显。这不是你想要的！
调用函数可能是一个替代方案。

补全行为 ~
				*:command-completion* *E179* *E180* *E181*
				*:command-complete*
默认情况下，用户定义命令的参数不进行补全。但是，通过指定以下属性之一，
可以启用参数补全：

	-complete=arglist	参数列表中的文件名
	-complete=augroup	自动命令组
	-complete=breakpoint	|:breakadd| 子选项
	-complete=buffer	缓冲区名称
	-complete=color	颜色方案
	-complete=command	Ex 命令（和参数）
	-complete=compiler	编译器
	-complete=diff_buffer	差异缓冲区名称
	-complete=dir	目录名称
	-complete=dir_in_path	|'cdpath'| 中的目录名称
	-complete=environment	环境变量名称
	-complete=event	自动命令事件
	-complete=expression	Vim 表达式
	-complete=file	文件和目录名称
	-complete=file_in_path	|'path'| 中的文件和目录名称
	-complete=filetype	文件类型名称 |'filetype'|
	-complete=function	函数名
	-complete=help	帮助主题
	-complete=highlight	高亮组
	-complete=history	|:history| 子选项
	-complete=keymap	键盘映射
	-complete=locale	区域设置名称（locale -a 的输出）
	-complete=lua	Lua 表达式 |:lua|
	-complete=mapclear	缓冲区参数
	-complete=mapping	映射名称
	-complete=menu	菜单
	-complete=messages	|:messages| 子选项
	-complete=option	选项
	-complete=packadd	可选包 |pack-add| 名称
	-complete=runtime	|'runtimepath'| 中的文件和目录名称
	-complete=scriptnames	已加载的脚本名称
	-complete=shellcmd	Shell 命令
	-complete=shellcmdline	第一个是 shell 命令，后续的是文件名。
			与 |:!cmd| 相同的行为
	-complete=sign	|:sign| 子选项
	-complete=syntax	语法文件名 |'syntax'|
	-complete=syntime	|:syntime| 子选项
	-complete=tag	标签
	-complete=tag_listfiles	标签，当按下 CTRL-D 时显示文件名
	-complete=user	用户名
	-complete=var	用户变量
	-complete=custom,{func} 自定义补全，通过 {func} 定义
	-complete=customlist,{func} 自定义补全，通过 {func} 定义
如果你在没有任何可补全内容的情况下指定补全（-nargs=0，默认值），
那么你会得到错误 *E1208*。
注意：某些补全方法可能会展开环境变量。


自定义补全 ~
				*:command-completion-custom*
				*:command-completion-customlist* *E467* *E468*
可以通过 "custom,{func}" 或 "customlist,{func}" 补全参数定义自定义补全方案。
{func} 部分应该是一个具有以下签名的函数：>

	:function {func}(ArgLead, CmdLine, CursorPos)

函数不需要使用所有这些参数。函数应该将补全候选项作为返回值提供。

对于 "custom" 参数，函数应该在新行分隔的字符串中每行返回一个补全候选项。

对于 "customlist" 参数，函数应该将补全候选项作为 Vim 列表返回。
列表中的非字符串项将被忽略。

函数参数是：
	ArgLead		当前正在补全的参数的前导部分
	CmdLine		整个命令行
	CursorPos	其中的光标位置（字节索引）
函数可以使用这些来确定上下文。对于 "custom" 参数，
不需要根据 ArgLead 中的（隐式模式）过滤候选项。
Vim 将在函数返回后使用其正则表达式引擎过滤候选项，
这在大多数情况下可能更有效。如果 'wildoptions' 包含 "fuzzy"，
则候选项将使用 |fuzzy-matching| 进行过滤。
对于 "customlist" 参数，Vim 不会过滤返回的补全候选项，
用户提供的函数应该过滤候选项。

以下示例列出了 Finger 命令的用户名：>
    :com -complete=custom,ListUsers -nargs=1 Finger !finger <args>
    :fun ListUsers(A,L,P)
    :    return system("cut -d: -f1 /etc/passwd")
    :endfun

以下示例从 'path' 选项指定的目录中补全文件名：>
    :com -nargs=1 -bang -complete=customlist,EditFileComplete
			\ EditFile edit<bang> <args>
    :fun EditFileComplete(A,L,P)
    :    return split(globpath(&path, a:A), "\n")
    :endfun
<
这个例子对带空格的文件名不起作用！


范围处理 ~
				*E177* *E178* *:command-range* *:command-count*
默认情况下，用户定义的命令不接受行号范围。但是，可以指定命令接受范围
（-range 属性），或者它接受任意计数值，要么在行号位置（-range=N，
像 |:split| 命令），要么作为 "count" 参数（-count=N，像 |:Next| 命令）。
然后计数将在参数中通过 |<count>| 可用。

可能的属性是：

	-range	    允许范围，默认为当前行
	-range=%    允许范围，默认为整个文件（1,$）
	-range=N    一个计数（默认 N），在行号位置指定（像 |:split|）；
		    允许零行号。
	-count=N    一个计数（默认 N），可以在行号位置指定，
		    或作为初始参数（像 |:Next|）。
	-count	    像 -count=0 一样工作

注意 -range=N 和 -count=N 是互斥的 - 只应指定一个。

                                                  *:command-addr*
范围中的特殊字符如 `.`、`$` 或 `%`（默认对应当前行、最后一行和整个缓冲区）
可能与参数、（已加载的）缓冲区、窗口或标签页相关。

可能的值是（第二列是列出时使用的短名称）：
    -addr=lines			行范围（这是 -range 的默认值）
    -addr=arguments	  arg	参数范围
    -addr=buffers	  buf	缓冲区范围（也包括未加载的缓冲区）
    -addr=loaded_buffers  load	已加载缓冲区范围
    -addr=windows	  win	窗口范围
    -addr=tabs		  tab	标签页范围
    -addr=quickfix	  qf	quickfix 条目范围
    -addr=other		  ?	其他类型的范围；可以像 "lines" 一样使用 "."、"$" 和 "%"
				（这是 -count 的默认值）
增量预览 ~
                                                  *:command-preview* {nvim-api}
命令可以通过定义预览处理程序来显示 'inccommand'（输入时）预览
（仅从 Lua，参见 |nvim_create_user_command()|）。

在执行预览回调之前，Nvim 将临时禁用 'cursorline' 和 'cursorcolumn'
以避免高亮问题。

预览回调必须是一个具有以下签名的 Lua 函数：>

    function cmdpreview(opts, ns, buf)
<
其中 "opts" 与给 |nvim_create_user_command()| 回调的形式相同，
"ns" 是高亮的预览命名空间 ID，"buf" 是你的预览例程将直接修改
以显示预览结果的缓冲区（对于 "inccommand=split"，或对于
"inccommand=nosplit" 为 nil）。

你的命令预览例程必须实现这个协议：

1. 根据需要修改目标缓冲区以进行预览（参见 |nvim_buf_set_text()|
   和 |nvim_buf_set_lines()|）。
2. 如果提供了预览缓冲区，向预览缓冲区添加必要的文本。
3. 向目标缓冲区添加所需的高亮。如果提供了预览缓冲区，
   也向预览缓冲区添加所需的高亮。所有高亮必须添加到作为参数
   提供给预览回调的预览命名空间（参见 |vim.hl.range()| 和
   |nvim_buf_set_extmark()| 了解如何向命名空间添加高亮）。
4. 返回一个整数（0、1、2），控制 Nvim 的行为如下：
   0：不显示预览。
   1：显示预览但不显示预览窗口（即使设置了 "inccommand=split"）。
   2：显示预览并打开预览窗口（如果设置了 "inccommand=split"）。
      对于 "inccommand=nosplit"，这与 1 相同。

预览结束后，Nvim 会丢弃预览期间对所有缓冲区的所有更改，
并清除预览命名空间中的所有高亮。

这是一个支持增量命令预览的修剪行尾空格的命令示例：>
	-- 如果作为预览回调调用，通过高亮当前缓冲区中的尾随空格
	-- 执行 'inccommand' 预览。
	local function trim_space_preview(opts, preview_ns, preview_buf)
	  vim.cmd('hi clear Whitespace')
	  local line1 = opts.line1
	  local line2 = opts.line2
	  local buf = vim.api.nvim_get_current_buf()
	  local lines = vim.api.nvim_buf_get_lines(buf, line1 - 1, line2, false)
	  local preview_buf_line = 0

	  for i, line in ipairs(lines) do
	    local start_idx, end_idx = string.find(line, '%s+$')

	    if start_idx then
	      -- 高亮匹配
	      vim.hl.range(
	        buf,
	        preview_ns,
	        'Substitute',
	        {line1 + i - 2, start_idx - 1},
	        {line1 + i - 2, end_idx},
	      )

	      -- 如果 inccommand=split，向预览缓冲区添加行并设置高亮
	      if preview_buf then
	        local prefix = string.format('|%d| ', line1 + i - 1)

	        vim.api.nvim_buf_set_lines(
	          preview_buf,
	          preview_buf_line,
	          preview_buf_line,
	          false,
	          { prefix .. line }
	        )
	        vim.hl.range(
	          preview_buf,
	          preview_ns,
	          'Substitute',
	          {preview_buf_line, #prefix + start_idx - 1},
	          {preview_buf_line, #prefix + end_idx},
	        )
	        preview_buf_line = preview_buf_line + 1
	      end
	    end
	  end

	  -- 返回预览类型的值
	  return 2
	end

	-- 修剪当前缓冲区中的所有尾随空格。
	local function trim_space(opts)
	  local line1 = opts.line1
	  local line2 = opts.line2
	  local buf = vim.api.nvim_get_current_buf()
	  local lines = vim.api.nvim_buf_get_lines(buf, line1 - 1, line2, false)

	  local new_lines = {}
	  for i, line in ipairs(lines) do
	    new_lines[i] = string.gsub(line, '%s+$', '')
	  end
	  vim.api.nvim_buf_set_lines(buf, line1 - 1, line2, false, new_lines)
	end

	-- 创建用户命令
	vim.api.nvim_create_user_command(
	  'TrimTrailingWhitespace',
	  trim_space,
	  { nargs = '?', range = '%', addr = 'lines', preview = trim_space_preview }
	)
特殊情况 ~
					*:command-bang* *:command-bar*
					*:command-register* *:command-buffer*
					*:command-keepscript*
还有一些特殊情况：

	-bang	    命令可以接受 ! 修饰符（如 :q 或 :w）
	-bar	    命令后面可以跟 "|" 和另一个命令。
		    然后不允许在命令参数中使用 "|"。
		    还检查 " 来开始注释。
	-register   命令的第一个参数可以是可选的寄存器名称
		   （如 :del、:put、:yank）。
	-buffer	    命令仅在当前缓冲区中可用。
	-keepscript 不要使用用户命令定义的位置来显示详细消息，
		   使用用户命令调用的位置。

对于 -count 和 -register 属性，如果提供了可选参数，
它会被从参数列表中移除，并单独提供给替换文本。
注意，这些参数可以缩写，但这是一个已弃用的功能。
对于新脚本，请使用完整名称。


替换文本 ~

用户定义命令的替换文本 {repl} 会被扫描特殊转义序列，使用 <...> 表示法。
转义序列会被替换为从输入的命令行中获取的值，所有其他文本会被原样复制。
结果字符串会作为 Ex 命令执行。要避免替换，使用 <lt> 代替初始的 <。
因此，要字面包含 "<bang>"，使用 "<lt>bang>"。

有效的转义序列是

						*<line1>*
	<line1>	命令范围的起始行。
						*<line2>*
	<line2>	命令范围的结束行。
						*<range>*
	<range> 命令范围中的项目数：0、1 或 2
						*<count>*
	<count>	提供的任何计数（如 -range 和 -count 属性所述）。
						*<bang>*
	<bang>	（参见 -bang 属性）如果命令执行时带有 ! 修饰符，
		则展开为 !，否则展开为空。
					*<mods>* *<q-mods>* *:command-modifiers*
	<mods>  如果指定了命令修饰符。否则，展开为空。支持的修饰符是
		|:aboveleft|、|:belowright|、|:botright|、|:browse|、
		|:confirm|、|:hide|、|:horizontal|、|:keepalt|、
		|:keepjumps|、|:keepmarks|、|:keeppatterns|、
		|:leftabove|、|:lockmarks|、|:noautocmd|、|:noswapfile|、
		|:rightbelow|、|:sandbox|、|:silent|、|:tab|、
		|:topleft|、|:unsilent|、|:verbose| 和 |:vertical|。
		注意不支持 |:filter|。
		例子：>
		    command! -nargs=+ -complete=file MyEdit
				\ for f in expand(<q-args>, 0, 1) |
				\ exe '<mods> split ' .. f |
				\ endfor

		    function! SpecialEdit(files, mods)
			for f in expand(a:files, 0, 1)
			    exe a:mods .. ' split ' .. f
			endfor
		    endfunction
		    command! -nargs=+ -complete=file Sedit
				\ call SpecialEdit(<q-args>, <q-mods>)
<
						*<reg>* *<register>*
	<reg>	（参见 -register 属性）如果指定了可选的寄存器。
		否则，展开为空。<register> 是这个的同义词。
						*<args>*
	<args>	命令参数，完全按照提供的方式（但如上所述，
		任何计数或寄存器可能会消耗一些参数，
		这些参数就不是 <args> 的一部分）。
	<lt>	单个 '<'（小于）字符。如果你想要在展开中
		获得这些转义序列之一的字面副本，这是必需的 -
		例如，要获得 <bang>，使用 <lt>bang>。
							*<q-args>*
如果转义序列的前两个字符是 "q-"（例如，<q-args>），
则该值会被引用，使其成为在表达式中使用的有效值。
这使用参数作为单个值。当没有参数时 <q-args> 是空字符串。
参见下面的 |q-args-example|。
							*<f-args>*
为了允许命令将其参数传递给用户定义的函数，有一个特殊形式 <f-args>
（"function args"）。这会在空格和制表符处分割命令参数，
单独引用每个参数，<f-args> 序列会被替换为逗号分隔的引用参数列表。
参见下面的 Mycmd 例子。如果没有给出参数，<f-args> 会被移除。
   要在 <f-args> 的参数中嵌入空白字符，在前面加上反斜杠。
<f-args> 将每对反斜杠（\\）替换为一个反斜杠。反斜杠后跟
非空白字符或非反斜杠的字符保持不变。另见下面的 |f-args-example|。
概述：

	command		   <f-args> ~
	XX ab		   "ab"
	XX a\b		   'a\b'
	XX a\ b		   'a b'
	XX a\  b	   'a ', 'b'
	XX a\\b		   'a\b'
	XX a\\ b	   'a\', 'b'
	XX a\\\b	   'a\\b'
	XX a\\\ b	   'a\ b'
	XX a\\\\b	   'a\\b'
	XX a\\\\ b	   'a\\', 'b'
	XX		   [nothing]


注意，如果要处理"无参数"的情况，你必须确保函数可以在没有参数的情况下调用。

用户命令的例子：>

   " 删除从这里到末尾的所有内容
   :com Ddel +,$d

   " 重命名当前缓冲区
   :com -nargs=1 -bang -complete=file Ren f <args>|w<bang>

   " 用文件内容替换范围
   " （将所有这些作为一行输入）
   :com -range -nargs=1 -complete=file
	 Replace <line1>-pu_|<line1>,<line2>d|r <args>|<line1>d

   " 计算范围内的行数
   :com! -range -nargs=0 Lines  echo <line2> - <line1> + 1 "lines"

<						*f-args-example*
调用用户函数（<f-args> 的例子）>
   :com -nargs=* Mycmd call Myfunc(<f-args>)

当执行：>
	:Mycmd arg1 arg2
这将调用：>
	:call Myfunc("arg1","arg2")

<						*q-args-example*
一个更实质性的例子：>
   :function Allargs(command)
   :   let i = 0
   :   while i < argc()
   :	  if filereadable(argv(i))
   :	     execute "e " .. argv(i)
   :	     execute a:command
   :      endif
   :      let i = i + 1
   :   endwhile
   :endfunction
   :command -nargs=+ -complete=command Allargs call Allargs(<q-args>)

Allargs 命令接受任何 Vim 命令（s）作为参数，并在参数列表中的所有文件上执行它。
使用例子（注意使用 "e" 标志忽略错误和使用 "update" 命令写入修改的缓冲区）：>
	:Allargs %s/foo/bar/ge|update
这将调用：>
	:call Allargs("%s/foo/bar/ge|update")
<

 vim:tw=78:ts=8:noet:ft=help:norl:
