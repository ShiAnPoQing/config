*lua.txt*    Nvim


                            NVIM 参考手册


Lua 引擎                                                           *lua* *Lua*

                                       输入 |gO| 查看目录。

==============================================================================
简介                                                       *lua-intro*

Lua 5.1 脚本引擎是内置且始终可用的。
试试这个命令来了解底层内容： >vim

    :lua vim.print(package.loaded)

Nvim 包含一个 Lua 的“标准库” |lua-stdlib|。
它补充了“编辑器标准库”（|vimscript-functions| + |Ex-commands|）和 |API|，这些都可以在 Lua 代码中使用（|lua-vimscript| |vim.api|）。
这三个命名空间构成了 Nvim 的编程接口。

Lua 插件和用户配置会像 Vimscript 一样自动发现和加载。
实际用法见 |lua-guide|。

你也可以用 shell 运行 Lua 脚本，使用 |-l| 参数： >
    nvim -l foo.lua [args...]
<
                                                                  *lua-compat*
Lua 5.1 是 Nvim Lua 的永久接口。
插件应以 |luaref| 规定的 Lua 5.1 为目标；更高版本（本质上是不同且不兼容的方言）不被支持。
这包括一些 Lua 5.1 解释器如 LuaJIT 支持的 `goto` 扩展。

                                                                  *lua-luajit*
虽然 Nvim 官方只要求支持 Lua 5.1，但在支持的平台上应使用 LuaJIT 或兼容分支编译以获得性能提升。
LuaJIT 还带来如 `ffi`、 |lua-profile| 和增强标准库函数等扩展；
这些不能假定一定可用， |init.lua| 或插件中的 Lua 代码应在使用前检查 `jit` 全局变量： >lua
  if jit then
    -- 针对 luajit 的代码
  else
    -- 针对纯 lua 5.1 的代码
  end
<
一个例外是 LuaJIT 的 `bit` 扩展，它总是可用：当用 PUC Lua 编译时，Nvim 会包含一个后备实现，提供
`require("bit")`。见 |lua-bit|。

                                                                  *lua-profile*
如果 Nvim 用 LuaJIT 编译，可以通过如下方式分析 Lua 代码： >lua
    -- 开始分析会话:
    require('jit.p').start('ri1', '/tmp/profile')

    -- 执行任意任务（使用插件、脚本等）...

    -- 停止会话。分析结果写入 /tmp/profile。
    require('jit.p').stop()

详见 https://luajit.org/ext_profiler.html 或 `p.lua` 源码： >
    :lua vim.cmd.edit(package.searchpath('jit.p', package.path))

==============================================================================
LUA 概念与习惯用法                                         *lua-concepts*

Lua 非常简单且 _一致_：虽然有些小怪癖，但一旦你习惯了这些怪癖，一切地方都一样。
作用域（闭包）尤其一致，不像 JavaScript 或大多数其他语言。

Lua 有三大基本机制——每个“编程主要方面”各一个：表、闭包和协程。
https://www.lua.org/doc/cacm2018.pdf
- 表是“对象”或容器数据结构：既可表示列表也可表示映射，你可以扩展它们来表示自定义数据类型，并用 |metatable|（类似 Python 的“数据模型”）改变其行为。
- Lua 中每个作用域都是闭包：函数是闭包，模块是闭包，`do` 块（|lua-do|）也是闭包——它们都一样。
  Lua 模块其实就是在“路径”上发现的一个大闭包（即你的模块在哪里：|package.cpath|）。
- 有栈协程支持协作式多线程、生成器，以及 Lua 和宿主（Nvim）都能用的灵活控制。

                                                          *lua-error-handling*
Lua 函数可能因异常（意外）失败抛出 |lua-errors|，你可以用 |pcall()| 处理。
                                                       *lua-result-or-message*
当失败是正常且可预期时，惯用法是返回 `nil`，这表示调用者必须处理失败而不是“异常”。
这种“结果或消息”模式表现为多返回值类型
`any|nil,nil|string`，或用 LuaLS 表示为: >

    ---@return any|nil    # 成功时的结果，失败时为 nil。
    ---@return nil|string # 成功时为 nil，失败时为错误信息。
<
“结果或消息”模式示例：
- |vim.ui.open()|
- |io.open()|
- |luv-error-handling|

当调用者遇到失败无法继续时，惯用法是对“结果或消息”结果用 `assert()`： >lua

    local value = assert(fn())

建议：对以下情况使用“结果或消息”模式……
- 失败是预期的，尤其是与外部世界通信时。例如 HTTP 请求或 LSP 请求经常因服务器问题失败，即使调用者没做错什么。
- 返回值的函数，如 Foo:new()。
- 有一组已知错误码可作为第三返回值时（如 |luv-error-handling|）。
<
                                                                    *iterator*
迭代器就是一个可反复调用以获取集合（或其他 |iterable|）“下一个”值的函数。
|for-in| 循环期望这种接口， |pairs()| 产生它， |vim.iter| 支持它，等等。
https://www.lua.org/pil/7.1.html

                                                                    *iterable*
“可迭代对象”是 |vim.iter()| 可消费的任何东西：表、字典、列表、迭代器函数、实现 |__call()| 元方法的表，以及 |vim.iter()| 对象。

                                                               *list-iterator*
|lua-list| 表上的迭代器有“中间”和“结尾”，而一般迭代器可能逻辑上是无限的。
因此某些 |vim.iter| 操作（如 |Iter:rev()|）只对类列表表有意义（定义上是有限的）。

                                                           *lua-function-call*
Lua 函数有多种调用方式。考虑如下函数： >lua
    local foo = function(a, b)
        print("A: ", a)
        print("B: ", b)
    end

第一种调用方式： >lua
    foo(1, 2)
    -- ==== 结果 ====
    -- A: 1
    -- B: 2

这种调用方式大多数脚本语言都很熟悉。
在 Lua 中，缺失的参数会传递为 `nil`，多余的参数会被静默丢弃。
例如： >lua
    foo(1)
    -- ==== 结果 ====
    -- A: 1
    -- B: nil
<
                                                                      *kwargs*
调用函数时，如果参数正好是一个字符串字面量（`"foo"`）或表字面量（`{1,2,3}`），可以省略括号。
后者常用于模拟“命名参数”（“kwargs”或“关键字参数”），类似 Python 和 C#。
例如： >lua
    local func_with_opts = function(opts)
        local will_do_foo = opts.foo
        local filename = opts.filename
        -- ...
    end

    func_with_opts { foo = true, filename = "hello.world" }
<
这里只是语法糖，实际上会自动加括号。
但视觉上，这点小糖足以接近“关键字参数”接口。

                                                                   *lua-regex*
Lua 有意不支持正则表达式，而是有有限的 |lua-patterns|，以避免扩展正则的性能陷阱。
Lua 脚本也可用 Vim 正则，见 |vim.regex()|。

示例： >lua

    print(string.match("foo123bar123", "%d+"))
    -- 123
    print(string.match("foo123bar123", "[^%d]+"))
    -- foo
    print(string.match("foo123bar123", "[abc]+"))
    -- ba
    print(string.match("foo.bar", "%.bar"))
    -- .bar

==============================================================================
导入 Lua 模块                                        *lua-module-load*

模块会在 'runtimepath' 指定的目录下按顺序搜索。
模块名中的每个 "." 都会被当作目录分隔符。
例如模块 `foo.bar`，每个目录会依次搜索
`lua/foo/bar.lua`，然后是 `lua/foo/bar/init.lua`。
如果都找不到，再按共享库名 `lua/foo/bar.?` 搜索，其中 `?` 是 |package.cpath| 初始值中的后缀（如 `so` 或 `dll`）。
如果还找不到，Nvim 会回退到 Lua 默认的搜索机制。
找到的第一个脚本会被执行，`require()` 返回脚本返回的值（如果有），否则返回 `true`。

每个模块第一次用 `require()` 加载后，返回值会被缓存，后续调用直接返回缓存值，不再搜索或执行脚本。更多细节见 |require()|。

例如，'runtimepath' 为 `foo,bar`，|package.cpath| 启动时为
`./?.so;./?.dll`，`require('mod')` 会按如下顺序搜索并加载第一个找到的模块（“先到先得”）： >
    foo/lua/mod.lua
    foo/lua/mod/init.lua
    bar/lua/mod.lua
    bar/lua/mod/init.lua
    foo/lua/mod.so
    foo/lua/mod.dll
    bar/lua/mod.so
    bar/lua/mod.dll
<

                                                        *lua-package-path*
Nvim 会根据当前 'runtimepath' 自动调整 |package.path| 和 |package.cpath|。
每次 'runtimepath' 变化时都会调整。
`package.path` 通过在每个目录后追加 `/lua/?.lua` 和 `/lua/?/init.lua` 实现（`/` 实际上是 `package.config` 的第一个字符）。

同理，'runtimepath' 目录也会被加到 |package.cpath|。
这时会用所有唯一的、包含 `?` 的后缀。

例如：
- 1. 假设
   - 'runtimepath' 包含 `/foo/bar,/xxx;yyy/baz,/abc`；
   - 初始 |package.cpath|（编译时定义或由 `$LUA_CPATH` / `$LUA_INIT` 派生）为 `./?.so;/def/ghi/a?d/j/g.elf;/def/?.so`。
- 2. 找到 `?` 后缀 `/?.so`、`/a?d/j/g.elf` 和 `/?.so`，顺序如下：从第一个包含问号的路径组件及其前的分隔符开始。
- 3. `/def/?.so` 的后缀 `/?.so` 不唯一，因为和 |package.path| 的第一个路径（即 `./?.so`）一样。剩下 `/?.so` 和 `/a?d/j/g.elf`，顺序不变。
- 4. 'runtimepath' 有三个路径：`/foo/bar`、`/xxx;yyy/baz` 和 `/abc`。第二个包含分号，作为路径分隔符被排除，只剩 `/foo/bar` 和 `/abc`。
- 5. 取 4. 和 3. 的笛卡尔积，共四种组合。每种组合在路径和后缀之间插入 `/lua`，得到：
     - `/foo/bar/lua/?.so`
     - `/foo/bar/lua/a?d/j/g.elf`
     - `/abc/lua/?.so`
     - `/abc/lua/a?d/j/g.elf`
- 6. 新路径会加到原始 |package.cpath| 前面。

结果如下： >

    /foo/bar,/xxx;yyy/baz,/abc ('runtimepath')
    × ./?.so;/def/ghi/a?d/j/g.elf;/def/?.so (package.cpath)
    = /foo/bar/lua/?.so;/foo/bar/lua/a?d/j/g.elf;/abc/lua/?.so;/abc/lua/a?d/j/g.elf;./?.so;/def/ghi/a?d/j/g.elf;/def/?.so

注意：

- 为追踪 'runtimepath' 更新，上次添加的路径会在下次更新时移除，所有新 'runtimepath' 派生的路径会如上所述加到前面。
这样当路径被移除、添加或重排序时，|package.path|/|package.cpath| 也会同步变化。

- 虽然会自动调整，Nvim 不会追踪 |package.path| 或 |package.cpath| 的当前值。
如果你手动删了某些路径，可以设置 'runtimepath' 触发更新： >vim
    let &runtimepath = &runtimepath
<

- 跳过包含分号的 'runtimepath' 路径对 |package.path| 和 |package.cpath| 都适用。
因为有些写得不好的插件用 shell，分号会导致问题，最好不要在 'runtimepath' 里用分号。

==============================================================================
命令                                                        *lua-commands*

这些命令从命令行（:lua, :luado）或文件（:luafile）在指定行 [range] 执行 Lua 代码块。
和 Lua 一样，每个代码块有自己的作用域（闭包），只有全局变量在命令间共享。
|lua-stdlib| 模块、用户模块和 |package.path| 上的其他内容都可用。

Lua 的 print() 函数会把输出重定向到 Nvim 消息区，参数间用空格分隔，而不是 "\t"。

                                                                  *:lua=* *:lua*
:lua {chunk}
    执行 Lua 代码块 {chunk}。

    如果 {chunk} 以 "=" 开头，剩下的部分会作为表达式求值并打印。

    `:lua =expr` 和 `:=expr` 等价于 `:lua print(vim.inspect(expr))`。

    示例： >vim
        :lua vim.api.nvim_command('echo "Hello, Nvim!"')
<    查看 Lua 版本： >vim
        :lua print(_VERSION)
<    查看 LuaJIT 版本： >vim
        :lua =jit.version
<
:{range}lua
    把 [range] 范围内的缓冲区行作为 Lua 代码执行。
    不同于 |:source|，总是把这些行当作 Lua 代码。

    示例：选中如下代码并输入 ":lua<Enter>" 执行： >lua
        print(string.format(
            'unix time: %s', os.time()))
<
                                                                *:lua-heredoc*
:lua << [trim] [{endmarker}]
{script}
{endmarker}
    在 Vimscript 中执行 Lua 脚本 {script}。
    可以省略 "<<" 后的 [endmarker]，用点号 "." 结束 {script}（类似 |:append|, |:insert|）。更多信息见 |:let-heredoc|。

    示例： >vim
        function! CurrentLineInfo()
        lua << EOF
        local linenr = vim.api.nvim_win_get_cursor(0)[1]
        local curline = vim.api.nvim_buf_get_lines(0, linenr - 1, linenr, false)[1]
        print(string.format('Line [%d] has %d bytes', linenr, #curline))
        EOF
        endfunction
<
    注意 `local` 变量在代码块结束时会消失，但全局变量不会。

                                                                      *:luado*
:[range]luado {body}
    对 [range] 范围内每一行执行 Lua 代码块 "function(line, linenr) {body} end"，其中 `line` 是当前行文本（不含 <EOL>），`linenr` 是当前行号。
    如果函数返回字符串，则该字符串会成为对应缓冲区行的新内容。
    默认 [range] 是整个文件："1,$"。

    示例： >vim
        :luado return string.format("%s\t%d", line:reverse(), #line)

        :lua require"lpeg"
        :lua -- 平衡括号语法：
        :lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }
        :luado if bp:match(line) then return "=>\t" .. line end
<
                                                                    *:luafile*
:luafile {file}
    执行 {file} 中的 Lua 脚本。
    整个参数作为文件名（如 |:edit|），不需要转义空格。
    也可以用 |:source| 执行 Lua 文件。

    示例： >vim
        :luafile script.lua
        :luafile %
<

==============================================================================
luaeval()                                                 *lua-eval*

"luaeval" 是用于将 Lua 值传递给 Nvim 的（双向）"vim.eval" 等价物。
    它接受一个表达式字符串和一个可选参数，该参数在表达式中作为 _A 使用，并返回表达式的结果。
    在 Lua 中语义等价于： >lua

    local chunkheader = "local _A = select(1, ...) return "
    function luaeval (expstr, arg)
        local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))
        return chunk(arg) -- 返回 typval
    end
<
Lua 的 nil、数字、字符串、表和布尔值会被转换为各自的 Vimscript 类型。
如果 Lua 字符串包含 NUL 字节，会被转换为 |Blob|。
其他 Lua 类型的转换会报错。

魔法全局变量 "_A" 包含传给 luaeval() 的第二个参数。

示例： >vim
    :echo luaeval('_A[1] + _A[2]', [40, 2])
    " 42
    :echo luaeval('string.match(_A, "[a-z]+")', 'XYXfoo123')
    " foo
<
                                                         *lua-table-ambiguous*
Lua 表既可用作字典也可用作列表，因此无法判断空表到底是列表还是字典。
Lua 也没有整数类型。

为消除歧义，定义如下：
                                                                    *lua-list*
0. 空表视为列表。用 |vim.empty_dict()| 表示空字典。
1. 具有 N 个连续（无 nil 值，即“无洞”）整数键 1…N 的表是列表。见 |list-iterator|。
                                                                    *lua-dict*
2. 只有字符串键，且无 NUL 字节的表是字典。
3. 有字符串键，且至少有一个键包含 NUL 字节的表也视为字典，但会被转换为 |msgpack-special-map|。
                                                             *lua-special-tbl*
4. 含有 `vim.type_idx` 键的表可以是字典、列表或浮点数：
   - `{[vim.type_idx]=vim.types.float, [vim.val_idx]=1}` 会被转换为浮点数 1.0。
        注意默认情况下整数 Lua 数会被转为 |Number|，非整数会转为 |Float|。此变体允许整数 |Float|。
   - `{[vim.type_idx]=vim.types.dictionary}` 会被转换为空字典，`{[vim.type_idx]=vim.types.dictionary, [42]=1, a=2}` 会被转换为字典 `{'a': 42}`：非字符串键会被忽略。
     没有 `vim.type_idx` 键且键不符合 1、2、3 的表会报错。
   - `{[vim.type_idx]=vim.types.array}` 会被转换为空列表。以及 `{[vim.type_idx]=vim.types.array, [42]=1}`：不连续的整数键和所有非整数键都会被忽略。

示例： >vim

    :echo luaeval('math.pi')
    :function Rand(x,y) " 返回 x 到 y 之间的均匀随机数
    :  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})
    :  endfunction
    :echo Rand(1,10)
<
注意：传给 `luaeval` 的第二个参数会从 Vimscript 转换（“编组”）到 Lua，因此对 Lua 容器的更改不会影响 Vimscript 中的值。
返回值也总是会被转换。
转换时， |msgpack-special-dict| 会被特殊处理。

==============================================================================
Vimscript v:lua 接口                                         *v:lua-call*

在 Vimscript 中可以用特殊前缀 `v:lua` 调用全局或全局表可访问的 Lua 函数。
表达式 >vim
    call v:lua.func(arg1, arg2)
等价于 Lua 代码 >lua
    return func(...)
参数会被转换为 Lua 值。
表达式 >vim
    call v:lua.somemod.func(args)
等价于 Lua 代码 >lua
    return somemod.func(...)

Lua 模块函数可这样访问： >vim
    call v:lua.require'mypack'.func(arg1, arg2)
    call v:lua.require'mypack.submod'.func(arg1, arg2)
注意：只允许单引号形式，不带括号。
用 `require"mypack"` 或 `require('mypack')` 作为前缀无效。

你可以在 'tagfunc'、'omnifunc' 等 "func" 选项中用 `v:lua`。
例如如下 Lua 补全处理器： >lua

    function mymod.omnifunc(findstart, base)
      if findstart == 1 then
        return 0
      else
        return {'stuff', 'steam', 'strange things'}
      end
    end
    -- 注意：模块（"mymod"）必须是 Lua 全局变量，或用 require() 方式访问。
    vim.bo[buf].omnifunc = 'v:lua.mymod.omnifunc'

你也可以用 `v:lua` 作为 Vimscript |method| 调用 Lua 函数： >vim
    :eval arg1->v:lua.somemod.func(arg2)
<
注意：Vimscript 表达式中不能单独用 `v:lua`：
|Funcref| 不能表示 Lua 函数。
以下写法会报错： >vim

    let g:Myvar = v:lua.myfunc        " 错误
    call SomeFunc(v:lua.mycallback)   " 错误
    let g:foo = v:lua                 " 错误
    let g:foo = v:['lua']             " 错误
<

==============================================================================
Lua 标准模块                                              *lua-stdlib*

Nvim 的 Lua “标准库”（stdlib）是 `vim` 模块，暴露了各种函数和子模块。

它总是已加载，因此无需 `require("vim")`。

你可以查看模块属性： >vim

    :lua vim.print(vim)

结果类似如下： >

    {
      _os_proc_children = <function 1>,
      _os_proc_info = <function 2>,
      ...
      api = {
        nvim__id = <function 5>,
        nvim__id_array = <function 6>,
        ...
      },
      deepcopy = <function 106>,
      gsplit = <function 107>,
      ...
    }

要查找如 "deepcopy" 函数的文档： >vim

    :help vim.deepcopy()

注意以下划线开头的函数（如 "_os_proc_children"）是内部/私有的，插件不得使用。

------------------------------------------------------------------------------
VIM.UV                                                   *lua-loop* *vim.uv*

`vim.uv` 暴露了 Nvim 用于网络、文件系统和进程管理的 libUV 的 Lua 绑定，见 |luvref.txt|。
特别地，它允许与 Nvim 的主 |luv-event-loop| 交互。

                                                    *E5560* *lua-loop-callbacks*
在 `vim.uv` 回调中直接调用 `vim.api` 函数（除 |api-fast| 外）会报错。
例如，以下代码会报错： >lua

    local timer = vim.uv.new_timer()
    timer:start(1000, 0, function()
      vim.api.nvim_command('echomsg "test"')
    end)
<
要避免报错，用 |vim.schedule_wrap()| 延迟回调： >lua

    local timer = vim.uv.new_timer()
    timer:start(1000, 0, vim.schedule_wrap(function()
      vim.api.nvim_command('echomsg "test"')
    end))
<
（一次性定时器见 |vim.defer_fn()|，它会自动包裹。）

示例：重复定时器
    1. 将代码保存到文件。
    2. 用 ":luafile %" 执行。 >lua

    -- 创建一个定时器句柄（实现细节：uv_timer_t）。
    local timer = vim.uv.new_timer()
    local i = 0
    -- 等待 1000ms，然后每 750ms 重复，直到 timer:close()。
    timer:start(1000, 750, function()
      print('timer invoked! i='..tostring(i))
      if i > 4 then
        timer:close()  -- 一定要关闭句柄以避免泄漏。
      end
      i = i + 1
    end)
    print('sleeping');
<
示例：文件变更检测                                    *watch-file*
    1. 将代码保存到文件。
    2. 用 ":luafile %" 执行。
    3. 用 ":Watch %" 监视任意文件。
    4. 尝试用其他编辑器编辑该文件。
    5. 观察 Nvim 自动重载文件（因为 on_change() 调用了 |:checktime|）。 >lua

    local w = vim.uv.new_fs_event()
    local function on_change(err, fname, status)
      -- 做一些工作...
      vim.api.nvim_command('checktime')
      -- 防抖：停止/重启。
      w:stop()
      watch_file(fname)
    end
    function watch_file(fname)
      local fullpath = vim.api.nvim_call_function(
        'fnamemodify', {fname, ':p'})
      w:start(fullpath, {}, vim.schedule_wrap(function(...)
        on_change(...) end))
    end
    vim.api.nvim_command(
      "command! -nargs=1 Watch call luaeval('watch_file(_A)', expand('<args>'))")
<
                                                         *inotify-limitations*
在 Linux 下你可能需要增加 `inotify` 监视和队列事件的最大数量，默认值可能太低。增加方法： >bash
    sysctl fs.inotify.max_user_watches=494462
<
这会把限制提升到 494462。可将此行加入 `/etc/sysctl.conf` 以永久生效。

注意每个监视都是内核中的一个结构体，因此可用内存也是 inotify 使用的瓶颈。实际上，一个监视最多占用 1KB 空间。也就是说一百万个监视会额外占用 1GB 内存。

示例：TCP 回显服务器                                          *tcp-server*
    1. 将代码保存到文件。
    2. 用 ":luafile %" 执行。
    3. 记下端口号。
    4. 用任意 TCP 客户端连接（如 "nc 0.0.0.0 36795"）： >lua

    local function create_server(host, port, on_connect)
      local server = vim.uv.new_tcp()
      server:bind(host, port)
      server:listen(128, function(err)
        assert(not err, err)  -- 检查错误。
        local sock = vim.uv.new_tcp()
        server:accept(sock)  -- 接受客户端连接。
        on_connect(sock)  -- 开始读取消息。
      end)
      return server
    end
    local server = create_server('0.0.0.0', 0, function(sock)
      sock:read_start(function(err, chunk)
        assert(not err, err)  -- 检查错误。
        if chunk then
          sock:write(chunk)  -- 回显收到的消息。
        else  -- EOF（流关闭）。
          sock:close()  -- 一定要关闭句柄以避免泄漏。
        end
      end)
    end)
    print('TCP echo-server listening on port: '..server:getsockname().port)
<
多线程                                            *lua-loop-threading*

插件可用 luv 的线程 API（如 `vim.uv.new_thread`）在独立（操作系统级）线程中工作。每个线程有独立的 Lua 解释器状态，不能访问主线程的 Lua 全局变量，也不能直接访问编辑器状态（缓冲区、窗口等）。

线程中可用 `vim.*` stdlib 的子集，包括：

- `vim.uv`，每个线程有独立事件循环。
- `vim.mpack` 和 `vim.json`（适合在线程间序列化消息）
- 线程中的 `require` 可用全局 |package.path| 的 Lua 包
- `print()` 和 `vim.inspect`
- `vim.diff`
- `vim.*` 中大多数只处理纯 Lua 值的工具函数，如
  `vim.split`, `vim.tbl_*`, `vim.list_*` 等。
- `vim.is_thread()` 在非主线程中返回 true。

==============================================================================
VIM.DIFF                                                            *vim.diff*

vim.diff({a}, {b}, {opts})                                        *vim.diff()*
    对字符串 {a} 和 {b} 进行 diff。该函数返回的所有索引都是 1 基的。

    示例: >lua
        vim.diff('a\n', 'b\nc\n')
        -- =>
        -- @@ -1 +1,2 @@
        -- -a
        -- +b
        -- +c

        vim.diff('a\n', 'b\nc\n', {result_type = 'indices'})
        -- =>
        -- {
        --   {1, 1, 1, 2}
        -- }
<

    参数: ~
      • {a}     (`string`) 第一个要比较的字符串
      • {b}     (`string`) 第二个要比较的字符串
      • {opts}  (`table?`) 可选参数:
                • {on_hunk}?
                  (`fun(start_a: integer, count_a: integer, start_b: integer, count_b: integer): integer?`)
                  对 diff 的每个 hunk 调用。返回负数可取消剩余 hunk 的回调。参数:
                  • `start_a` (`integer`): {a} 中 hunk 的起始行
                  • `count_a` (`integer`): {a} 中 hunk 的大小
                  • `start_b` (`integer`): {b} 中 hunk 的起始行
                  • `count_b` (`integer`): {b} 中 hunk 的大小
                • {result_type}? (`'unified'|'indices'`, 默认: `'unified'`)
                  返回的 diff 形式:
                  • `unified`: 统一格式字符串
                  • `indices`: hunk 位置数组。注意：如果用 `on_hunk`，此选项被忽略。
                • {linematch}? (`boolean|integer`) 对 xdiff 结果的 hunk 运行 linematch。为整数时，仅对不超过该行数的 hunk 运行 linematch。需 `result_type = indices`，否则忽略。
                • {algorithm}? (`'myers'|'minimal'|'patience'|'histogram'`,
                  默认: `'myers'`) diff 算法:
                  • `myers`: 默认算法
                  • `minimal`: 生成最小 diff，耗时更长
                  • `patience`: patience diff 算法
                  • `histogram`: histogram diff 算法
                • {ctxlen}? (`integer`) 上下文长度
                • {interhunkctxlen}? (`integer`) hunk 间上下文长度
                • {ignore_whitespace}? (`boolean`) 忽略空白
                • {ignore_whitespace_change}? (`boolean`) 忽略空白变化
                • {ignore_whitespace_change_at_eol}? (`boolean`) 忽略行尾空白变化
                • {ignore_cr_at_eol}? (`boolean`) 忽略行尾回车
                • {ignore_blank_lines}? (`boolean`) 忽略空行
                • {indent_heuristic}? (`boolean`) diff 库使用缩进启发式

    返回: ~
        (`string|integer[][]?`) 见 {opts.result_type}。如用 {opts.on_hunk}，则为 nil。

==============================================================================
==============================================================================
VIM.MPACK                                                          *vim.mpack*

该模块提供 Lua 对象与 msgpack 编码字符串之间的编码与解码。支持 |vim.NIL| 和 |vim.empty_dict()|。

vim.mpack.decode({str})                                   *vim.mpack.decode()*
    将 msgpack 编码的 {str} 解码（或“解包”）为 Lua 对象。

    参数: ~
      • {str}  (`string`)

    返回: ~
        (`any`)

vim.mpack.encode({obj})                                   *vim.mpack.encode()*
    将 Lua 对象 {obj} 编码（或“打包”）为 msgpack 格式的 Lua 字符串。

    参数: ~
      • {obj}  (`any`)

    返回: ~
        (`string`)

==============================================================================
VIM.BASE64                                                        *vim.base64*

vim.base64.decode({str})                                 *vim.base64.decode()*
    解码 Base64 编码的字符串。

    参数: ~
      • {str}  (`string`) Base64 编码字符串

    返回: ~
        (`string`) 解码后的字符串

vim.base64.encode({str})                                 *vim.base64.encode()*
    用 Base64 编码 {str}。

    参数: ~
      • {str}  (`string`) 要编码的字符串

    返回: ~
        (`string`) 编码后的字符串

==============================================================================
VIM.SPELL                                                          *vim.spell*

vim.spell.check({str})                                     *vim.spell.check()*
    检查 {str} 是否有拼写错误。类似于 Vimscript 函数 |spellbadword()|。

    注意: 该函数行为依赖于：'spelllang'、'spellfile'、'spellcapcheck' 和 'spelloptions'，这些都可以是缓冲区本地的。建议用 |nvim_buf_call()| 调用。

    示例: >lua
        vim.spell.check("the quik brown fox")
        -- =>
        -- {
        --     {'quik', 'bad', 5}
        -- }
<

    参数: ~
      • {str}  (`string`)

    返回: ~
        (`[string, 'bad'|'rare'|'local'|'caps', integer][]`) 三元组列表:
        • 拼写错误的单词
        • 拼写错误类型："bad" 拼写错误 "rare" 罕见词 "local" 只在其他地区有效的词 "caps" 应大写的词
        • 单词在 {str} 中的起始位置

==============================================================================
==============================================================================
VIM                                                              *vim.builtin*


vim.api.{func}({...})                                                *vim.api*
    调用 Nvim |API| 函数 {func}，参数为 {...}。
    示例：调用 "nvim_get_current_line()" API 函数： >lua
        print(tostring(vim.api.nvim_get_current_line()))

vim.NIL                                                              *vim.NIL*
    在 |RPC| 及 |v:null| Vimscript 转换等场景下，表示 NIL 的特殊值。Lua 的 `nil` 不能作为 Lua 表中表示字典或数组的元素，因为会被当作缺失：`{"foo", nil}` 等价于 `{"foo"}`。

vim.type_idx                                                    *vim.type_idx*
    用于 |lua-special-tbl| 的类型索引。指定 |vim.types| 的值之一可为空表指定类型（空 Lua 表不明确是空列表还是空数组），并强制整数为 |Float|。详见 |lua-special-tbl|。

vim.val_idx                                                      *vim.val_idx*
    表示 |Float| 的表的值索引。表示浮点值 1.0 的表如下： >lua
        {
          [vim.type_idx] = vim.types.float,
          [vim.val_idx] = 1.0,
        }
<    另见 |vim.type_idx| 和 |lua-special-tbl|。

vim.types                                                          *vim.types*
    |vim.type_idx| 可用值的表。包含两组键值对：一组将 |vim.type_idx| 可能值映射为可读字符串，另一组将可读类型名映射为 |vim.type_idx| 值。目前有 `float`、`array` 和 `dictionary`。

    注意: 只能假定 `vim.types.float`、`vim.types.array` 和 `vim.types.dictionary` 满足以下两点：
    1. 可作为表的键和值。即“值不是 `nil`”。
    2. 对于 `vim.types` 表中的每个值，`vim.types[vim.types[value]]` 等于 `value`。
    其它不做保证，类型值可能变化，`vim.types` 也可能包含其它类型。

                                                   *log_levels* *vim.log.levels*
日志级别为 `vim.log.levels` 中定义的值之一：

    vim.log.levels.DEBUG
    vim.log.levels.ERROR
    vim.log.levels.INFO
    vim.log.levels.TRACE
    vim.log.levels.WARN
    vim.log.levels.OFF

vim.empty_dict()                                            *vim.empty_dict()*
    创建一个特殊的空表（带有元表标记），Nvim 在将 Lua 值转换为 Vimscript 或 API 类型时会将其视为字典。Nvim 默认会把没有该元表的空表 `{}` 转为列表/数组。

    注意: 如果表中有数字键，Nvim 会忽略元表标记并将字典转为列表/数组。

    返回: ~
        (`table`)

vim.iconv({str}, {from}, {to})                                   *vim.iconv()*
    结果是字符串，将 {str} 从编码 {from} 转为编码 {to}。
    转换失败时返回 `nil`。
    有些字符无法转换时会被替换为 "?"。
    编码名为 iconv() 库函数可接受的名称，见 ":Man 3 iconv"。

    参数: ~
      • {str}   (`string`) 要转换的文本
      • {from}  (`string`) {str} 的编码
      • {to}    (`string`) 目标编码

    返回: ~
        (`string?`) 转换成功时为转换后的字符串，否则为 `nil`

vim.in_fast_event()                                      *vim.in_fast_event()*
    若代码在“快速”事件处理器中执行，则返回 true，此时大多数 API 不可用。
    这些是低级事件（如 |lua-loop-callbacks|），Nvim 轮询输入时可被调用。
    若为 false，大多数 API 可调用（但可能受 |textlock| 等其它限制）。

vim.rpcnotify({channel}, {method}, {...})                    *vim.rpcnotify()*
    通过 |RPC| 向 {channel} 发送 {event} 并立即返回。
    如果 {channel} 为 0，则事件广播到所有通道。

    此函数也可在快速回调 |lua-loop-callbacks| 中使用。

    参数: ~
      • {channel}  (`integer`)
      • {method}   (`string`)
      • {...}      (`any?`)

vim.rpcrequest({channel}, {method}, {...})                  *vim.rpcrequest()*
    通过 |RPC| 向 {channel} 发送请求调用 {method}，并阻塞直到收到响应。

    注意: 返回值中的 NIL 用 |vim.NIL| 表示

    参数: ~
      • {channel}  (`integer`)
      • {method}   (`string`)
      • {...}      (`any?`)

vim.schedule({fn})                                            *vim.schedule()*
    安排 {fn} 很快由主事件循环调用。
    用于避免 |textlock| 或其它临时限制。

    参数: ~
      • {fn}  (`fun()`)


vim.ui_attach({ns}, {options}, {callback})                   *vim.ui_attach()*
    警告：此功能为实验性/不稳定。

    订阅 |ui-events|，类似于 |nvim_ui_attach()|，但事件通过 Lua 回调接收。
    用于在 Lua 中实现屏幕元素如弹出菜单或消息处理。

    {options} 是一个字典，需设置一个或多个 `ext_…` |ui-option| 为 true，以启用相应 UI 元素的事件。

    {callback} 接收事件名及额外参数。见 |ui-popupmenu| 及下文各节了解各事件格式。

    `msg_show` 事件的回调在 |api-fast| 上下文中执行；显示消息应安排到主线程。

    回调中错误过多会导致强制分离。

    警告：此 API 仍为实验性。
    不同屏幕元素的可用性会有差异。
    特别是 `ext_messages` 行为仍会变动和改进。
    主要用于 'cmdheight' 设为零时处理消息（同样为实验性）。

    示例（弹出菜单实现框架）： >lua
        ns = vim.api.nvim_create_namespace('my_fancy_pum')

        vim.ui_attach(ns, {ext_popupmenu=true}, function(event, ...)
          if event == 'popupmenu_show' then
            local items, selected, row, col, grid = ...
            print('display pum ', #items)
          elseif event == 'popupmenu_select' then
            local selected = ...
            print('selected', selected)
          elseif event == 'popupmenu_hide' then
            print('FIN')
          end
        end)
<

    参数: ~
      • {ns}        (`integer`)
      • {options}   (`table<string, any>`)
      • {callback}  (`fun()`)

vim.ui_detach({ns})                                          *vim.ui_detach()*
    解除之前用 |vim.ui_attach()| 附加的指定命名空间 {ns} 的回调。

    参数: ~
      • {ns}  (`integer`)

vim.wait({time}, {callback}, {interval}, {fast_only})             *vim.wait()*
    等待 {time} 毫秒，直到 {callback} 返回 `true`。

    立即执行 {callback}，之后每隔约 {interval} 毫秒（默认 200）再执行一次。
    等待期间 Nvim 仍会处理其他事件。

    不能在 |api-fast| 事件中调用。

    示例: >lua
        ---
        -- 等待 100 毫秒，允许处理其他事件
        vim.wait(100, function() end)

        ---
        -- 等待 100 毫秒或直到全局变量被设置
        vim.wait(100, function() return vim.g.waiting_for_var end)

        ---
        -- 等待 1 秒或直到全局变量被设置，每 ~500 毫秒检查一次
        vim.wait(1000, function() return vim.g.waiting_for_var end, 500)

        ---
        -- 安排 100ms 后设置变量
        vim.defer_fn(function() vim.g.timer_result = true end, 100)

        -- 如果结果被阻塞会等十秒，实际上只等 100ms
        if vim.wait(10000, function() return vim.g.timer_result end) then
          print('只等了一小会儿！')
        end
<

    参数: ~
      • {time}       (`integer`) 等待的毫秒数
      • {callback}   (`fun(): boolean?`) 可选回调。直到 {callback} 返回 true
      • {interval}   (`integer?`) 每次轮询间隔的毫秒数（约值）
      • {fast_only}  (`boolean?`) 若为 true，仅处理 |api-fast| 事件

    返回（多值）: ~
        (`boolean`)
        (`-1|-2?`)
        • 若 {callback} 在 {time} 内返回 true：`true, nil`
        • 若 {callback} 在 {time} 内未返回 true：`false, -1`
        • 若 {callback} 在 {time} 内被中断：`false, -2`
        • 若 {callback} 出错，则抛出错误

==============================================================================
LUA-VIMSCRIPT 桥接                                           *lua-vimscript*

Nvim Lua 提供了与 Vimscript 变量和函数、编辑器命令和选项的接口或“桥接”。

通过该桥接传递的对象会被复制（编组）：没有“引用”。
|lua-guide-variables| 例如，使用 `vim.fn.remove()` 操作 Lua 列表时，会将列表对象复制到 Vimscript，并不会修改 Lua 列表： >lua
    local list = { 1, 2, 3 }
    vim.fn.remove(list, 0)
    vim.print(list)  --> "{ 1, 2, 3 }"
<

vim.call({func}, {...})                                           *vim.call()*
    调用 |vim-function| 或 |user-function| {func}，参数为 {...}。
    另见 |vim.fn|。
    等价于： >lua
        vim.fn[func]({...})
<

vim.cmd({command})
    见 |vim.cmd()|。

vim.fn.{func}({...})                                                  *vim.fn*
    调用 |vim-function| 或 |user-function| {func}，参数为 {...}。
    调用自动加载函数，语法如下： >lua
        vim.fn['some#function']({...})
<
    与 vim.api. |nvim_call_function()| 不同，该方法直接在 Vim 对象和 Lua 对象间转换。

    如果 Vim 函数返回 float，会直接表示为 Lua 数字。
    空列表和字典都表示为空表。

    注意: 返回值中的 |v:null| 用 |vim.NIL| 表示

    注意: vim.fn 的键是惰性生成的，因此 `pairs(vim.fn)` 只枚举已调用过的函数。

    注意: 大多数函数不能在 |api-fast| 回调中运行，少数未文档化的例外允许。

==============================================================================
Lua 模块: vim                                                      *lua-vim*

vim.cmd({command})                                                 *vim.cmd()*
    执行 Vimscript（|Ex-commands|）。

    注意 `vim.cmd` 可用命令名索引，返回该命令的可调用函数。

    示例: >lua
        vim.cmd('echo 42')
        vim.cmd([[
          augroup My_group
            autocmd!
            autocmd FileType c setlocal cindent
          augroup END
        ]])

        -- Ex 命令 :echo "foo"
        -- 注意字符串字面量需用双引号
        vim.cmd('echo "foo"')
        vim.cmd { cmd = 'echo', args = { '"foo"' } }
        vim.cmd.echo({ args = { '"foo"' } })
        vim.cmd.echo('"foo"')

        -- Ex 命令 :write! myfile.txt
        vim.cmd('write! myfile.txt')
        vim.cmd { cmd = 'write', args = { "myfile.txt" }, bang = true }
        vim.cmd.write { args = { "myfile.txt" }, bang = true }
        vim.cmd.write { "myfile.txt", bang = true }

        -- Ex 命令 :colorscheme blue
        vim.cmd('colorscheme blue')
        vim.cmd.colorscheme('blue')
<

    参数: ~
      • {command}  (`string|table`) 要执行的命令。
      如果是字符串，则一次执行多行 Vimscript，此时等价于 |nvim_exec2()|，`opts.output` 为 false，行为同 |:source|。
      如果是表，则执行单条命令，此时等价于 |nvim_cmd()|，`opts` 为空。

    另见: ~
      • |ex-cmd-index|

vim.defer_fn({fn}, {timeout})                                 *vim.defer_fn()*
    延迟调用 {fn}，直到 {timeout} 毫秒后。

    用于实现一次性定时器，{fn} 会自动 |vim.schedule_wrap()|，因此可安全调用 API。

    参数: ~
      • {fn}       (`function`) 超时后要调用的回调
      • {timeout}  (`integer`) 等待多少毫秒后调用

    返回: ~
        (`table`) timer luv 定时器对象

                                                             *vim.deprecate()*
vim.deprecate({name}, {alternative}, {version}, {plugin}, {backtrace})
    向用户显示弃用信息。

    参数: ~
      • {name}         (`string`) 被弃用的特性（函数、API 等）
      • {alternative}  (`string?`) 推荐的替代特性
      • {version}      (`string`) 该特性将被移除的版本
      • {plugin}       (`string?`) 拥有该特性的插件名，默认 "Nvim"
      • {backtrace}    (`boolean?`) 是否打印回溯，默认 true

    返回: ~
        (`string?`) 弃用信息，若未显示则为 nil

vim.inspect()                                                  *vim.inspect()*
    获取给定对象的人类可读表示。

    返回: ~
        (`string`)

    另见: ~
      • |vim.print()|
      • https://github.com/kikito/inspect.lua
      • https://github.com/mpeterv/vinspect

vim.keycode({str})                                             *vim.keycode()*
    翻译按键码。

    示例: >lua
        local k = vim.keycode
        vim.g.mapleader = k'<bs>'
<

    参数: ~
      • {str}  (`string`) 要转换的字符串

    返回: ~
        (`string`)

    另见: ~
      • |nvim_replace_termcodes()|

vim.lua_omnifunc({find_start})                            *vim.lua_omnifunc()*
    用于从运行时 Lua 解释器补全 Lua 值的 omnifunc，类似于 :lua 命令的内置补全。

    在 Lua 缓冲区中用 `set omnifunc=v:lua.vim.lua_omnifunc` 启用。

    参数: ~
      • {find_start}  (`1|0`)

vim.notify({msg}, {level}, {opts})                              *vim.notify()*
    向用户显示通知。

    此函数可被插件重载，用自定义通知提供者（如系统通知）。默认写入 |:messages|。

    参数: ~
      • {msg}    (`string`) 要显示的通知内容
      • {level}  (`integer?`) 取自 |vim.log.levels| 的值之一
      • {opts}   (`table?`) 可选参数，默认未用

vim.notify_once({msg}, {level}, {opts})                    *vim.notify_once()*
    只显示一次通知。

    类似 |vim.notify()|，但相同消息后续不会再显示。

    参数: ~
      • {msg}    (`string`) 要显示的通知内容
      • {level}  (`integer?`) 取自 |vim.log.levels| 的值之一
      • {opts}   (`table?`) 可选参数，默认未用

    返回: ~
        (`boolean`) 若消息被显示则为 true，否则为 false

vim.on_key({fn}, {ns_id}, {opts})                               *vim.on_key()*
    添加 Lua 函数 {fn}，用命名空间 id {ns_id} 作为监听器，监听每一个输入按键。

    Nvim 命令行选项 |-w| 类似，但不支持回调且不能动态切换。

    注意: ~
      • {fn} 出错时会被移除。
      • {fn} 不会递归调用，即 {fn} 自身消耗输入时不会再次被调用。
      • {fn} 不会被 |nvim_buf_clear_namespace()| 清除。

    参数: ~
      • {fn}     (`fun(key: string, typed: string): string??`) 每个输入按键后调用的函数，{key} 为映射后按键，{typed} 为映射前按键。
                {typed} 可能为空（如 {key} 由非输入按键产生，或与前次相同）。
                若 {fn} 返回空字符串，则丢弃/忽略该按键。
                {fn} 为 `nil` 时，移除该命名空间的回调。
      • {ns_id}  (`integer?`) 命名空间 ID。为 nil 或 0 时，生成并返回新的 |nvim_create_namespace()| id。
      • {opts}   (`table?`) 可选参数

    返回: ~
        (`integer`) 与 {fn} 关联的命名空间 id。若无参数则返回所有回调数。

    另见: ~
      • |keytrans()|

vim.paste({lines}, {phase})                                      *vim.paste()*
    粘贴处理器，由 |nvim_paste()| 调用。

    注意: 仅作为“钩子”提供，不要直接调用；
    应调用 |nvim_paste()|，它会安排 redo（点重复）并调用 `vim.paste`。

    示例: 粘贴时移除 ANSI 颜色码: >lua
        vim.paste = (function(overridden)
          return function(lines, phase)
            for i,line in ipairs(lines) do
              -- 移除粘贴输入中的 ANSI 颜色码
              lines[i] = line:gsub('\27%[[0-9;mK]+', '')
            end
            return overridden(lines, phase)
          end
        end)(vim.paste)
<

    参数: ~
      • {lines}  (`string[]`) |readfile()| 风格的行列表。|channel-lines|
      • {phase}  (`-1|1|2|3`) -1: “非流式”粘贴：本次调用包含所有行。若为流式粘贴，`phase` 表示流状态:
                 • 1: 开始粘贴（仅一次）
                 • 2: 继续粘贴（零次或多次）
                 • 3: 结束粘贴（仅一次）

    返回: ~
        (`boolean`) 若为 false，客户端应取消粘贴。

    另见: ~
      • |paste|

vim.print({...})                                                 *vim.print()*
    “美化打印”给定参数并原样返回。

    示例: >lua
        local hl_normal = vim.print(vim.api.nvim_get_hl(0, { name = 'Normal' }))
<

    参数: ~
      • {...}  (`any`)

    返回: ~
        (`any`) 原样返回参数

    另见: ~
      • |vim.inspect()|
      • |:=|

vim.schedule_wrap({fn})                                  *vim.schedule_wrap()*
    返回一个函数，该函数通过 |vim.schedule()| 调用 {fn}。

    返回的函数会将所有参数传递给 {fn}。

    示例: >lua
        function notify_readable(_err, readable)
          vim.notify("readable? " .. tostring(readable))
        end
        vim.uv.fs_access(vim.fn.stdpath("config"), "R", vim.schedule_wrap(notify_readable))
<

    参数: ~
      • {fn}  (`function`)

    返回: ~
        (`function`)

    另见: ~
      • |lua-loop-callbacks|
      • |vim.schedule()|
      • |vim.in_fast_event()|

vim.system({cmd}, {opts}, {on_exit})                            *vim.system()*
    运行系统命令，若 {cmd} 无法运行则抛出错误。

    示例: >lua
        local on_exit = function(obj)
          print(obj.code)
          print(obj.signal)
          print(obj.stdout)
          print(obj.stderr)
        end

        -- 异步运行:
        vim.system({'echo', 'hello'}, { text = true }, on_exit)

        -- 同步运行:
        local obj = vim.system({'echo', 'hello'}, { text = true }):wait()
        -- { code = 0, signal = 0, stdout = 'hello\n', stderr = '' }
<

    详见 |uv.spawn()|。注意: 与 |uv.spawn()| 不同，vim.system 若 {cmd} 无法运行会抛错。

    参数: ~
      • {cmd}      (`string[]`) 要执行的命令
      • {opts}     (`vim.SystemOpts?`) 选项:
                   • cwd: (string) 设置子进程的当前工作目录
                   • env: table<string,string> 设置新进程的环境变量。继承当前环境并设置 `NVIM` 为 |v:servername|。
                   • clear_env: (boolean) `env` 完全定义作业环境，不合并当前环境。
                   • stdin: (string|string[]|boolean) 若为 true，则打开 stdin 管道，可通过 SystemObj 的 `write()` 方法写入。若为字符串或字符串数组，则写入 stdin 并关闭。默认 `false`。
                   • stdout: (boolean|function) 处理 stdout 输出。为函数时签名为 `fun(err: string, data: string)`。默认 `true`
                   • stderr: (boolean|function) 处理 stderr 输出。为函数时签名为 `fun(err: string, data: string)`。默认 `true`
                   • text: (boolean) 以文本方式处理 stdout 和 stderr。将 `\r\n` 替换为 `\n`。
                   • timeout: (integer) 命令超时时间。超时后进程发送 TERM 信号（15），退出码设为 124。
                   • detach: (boolean) 若为 true，子进程以分离状态生成——会成为进程组长，父进程退出后子进程可继续运行。但父进程需对子进程句柄调用 |uv.unref()|，否则事件循环不会退出。
      • {on_exit}  (`fun(out: vim.SystemCompleted)?`) 子进程退出时调用。若提供，则命令异步运行。参数为 SystemCompleted 对象，见 SystemObj:wait() 返回。

    返回: ~
        (`vim.SystemObj`) 对象，字段包括:
        • cmd (string[]) 命令及参数
        • pid (integer) 进程 ID
        • wait (fun(timeout: integer|nil): SystemCompleted) 等待进程完成。超时后发送 KILL 信号（9），退出码设为 124。不能在 |api-fast| 中调用。
          • SystemCompleted 对象字段:
            • code: (integer)
            • signal: (integer)
            • stdout: (string)，若 stdout 参数已传则为 nil
            • stderr: (string)，若 stderr 参数已传则为 nil
        • kill (fun(signal: integer|string))
        • write (fun(data: string|nil)) 需 `stdin=true`。传 `nil` 关闭流。
        • is_closing (fun(): boolean)

==============================================================================
Lua 模块: vim.inspector                                      *vim.inspector*

vim.inspect_pos({bufnr}, {row}, {col}, {filter})           *vim.inspect_pos()*
    获取指定缓冲区位置的所有项目。

    也可用 `:Inspect!` 以美观方式打印。                   *:Inspect!*

    属性: ~
        自 0.9.0 起

    参数: ~
      • {bufnr}   (`integer?`) 默认为当前缓冲区
      • {row}     (`integer?`) 要检查的行，0 基。默认为当前光标行
      • {col}     (`integer?`) 要检查的列，0 基。默认为当前光标列
      • {filter}  (`table?`) 过滤表，键值对如下:
                  • {syntax} (`boolean`, 默认: `true`) 包含语法高亮组
                  • {treesitter} (`boolean`, 默认: `true`) 包含 treesitter 高亮组
                  • {extmarks} (`boolean|"all"`, 默认: true) 包含 extmarks。为 `all` 时也包含无 `hl_group` 的 extmarks
                  • {semantic_tokens} (`boolean`, 默认: true) 包含语义 token 高亮

    返回: ~
        (`table`) 包含如下键值对的表。项目按“遍历顺序”排列:
        • treesitter: treesitter 捕获列表
        • syntax: 语法组列表
        • semantic_tokens: 语义 token 列表
        • extmarks: extmark 列表
        • buffer: 用于获取项目的缓冲区
        • row: 用于获取项目的行
        • col: 用于获取项目的列

vim.show_pos({bufnr}, {row}, {col}, {filter})                 *vim.show_pos()*
    显示指定缓冲区位置的所有项目。

    也可用 `:Inspect` 显示。                              *:Inspect*

    示例: 绑定到 Normal 模式下的 `zS`，灵感来自 vim-scriptease: >lua
        vim.keymap.set('n', 'zS', vim.show_pos)
<

    属性: ~
        自 0.9.0 起

    参数: ~
      • {bufnr}   (`integer?`) 默认为当前缓冲区
      • {row}     (`integer?`) 要检查的行，0 基。默认为当前光标行
      • {col}     (`integer?`) 要检查的列，0 基。默认为当前光标列
      • {filter}  (`table?`) 过滤表，字段如下:
                  • {syntax} (`boolean`, 默认: `true`) 包含语法高亮组
                  • {treesitter} (`boolean`, 默认: `true`) 包含 treesitter 高亮组
                  • {extmarks} (`boolean|"all"`, 默认: true) 包含 extmarks。为 `all` 时也包含无 `hl_group` 的 extmarks
                  • {semantic_tokens} (`boolean`, 默认: true) 包含语义 token 高亮

vim.deep_equal({a}, {b})                                    *vim.deep_equal()*
    深度比较值是否相等

    表会递归比较，除非都实现了 `eq` 元方法。其它类型用 `==` 比较。

    参数: ~
      • {a}  (`any`) 第一个值
      • {b}  (`any`) 第二个值

    返回: ~
        (`boolean`) 若值相等则为 `true`，否则为 `false`

vim.deepcopy({orig}, {noref})                                 *vim.deepcopy()*
    返回给定对象的深拷贝。
    非表对象按普通 Lua 赋值复制，表对象递归复制。
    函数会被简单复制，因此新表中的函数与原表相同。
    userdata 和线程不会被复制，复制会报错。

    注意: `noref=true` 对字段唯一的表性能更好，`noref=false` 对复用字段的表更快。

    参数: ~
      • {orig}   (`table`) 要复制的表
      • {noref}  (`boolean?`) 为 false（默认）时，包含的表只复制一次，所有引用指向同一份。为 true 时，每次出现都新建一份。循环引用可能导致失败。

    返回: ~
        (`table`) 复制后的表

vim.defaulttable({createfn})                              *vim.defaulttable()*
    创建一个缺失键由 {createfn} 提供的表（类似 Python 的 "defaultdict"）。

    若 {createfn} 为 `nil`，则默认为 defaulttable() 本身，因此访问嵌套键会自动创建嵌套表: >lua
        local a = vim.defaulttable()
        a.b.c = 1
<

    参数: ~
      • {createfn}  (`fun(key:any):any?`) 提供缺失 `key` 的值

    返回: ~
        (`table`) 带 `__index` 元方法的空表


vim.is_callable({f})                                       *vim.is_callable()*
    若对象 `f` 可作为函数调用则返回 true。

    参数: ~
      • {f}  (`any`) 任意对象

    返回: ~
        (`boolean`) 若可调用则为 `true`，否则为 `false`

vim.isarray({t})                                               *vim.isarray()*
    测试 `t` 是否为“数组”：仅用整数索引（可不连续）的表。

    若索引从 1 开始且连续，则该数组也是列表。|vim.islist()|

    空表 `{}` 是数组，除非由 |vim.empty_dict()| 创建或作为字典风格 |API| 或 Vimscript 结果返回，如 |rpcrequest()| 或 |vim.fn|。

    参数: ~
      • {t}  (`table?`)

    返回: ~
        (`boolean`) 若为数组风格表则为 `true`，否则为 `false`

    另见: ~
      • https://github.com/openresty/luajit2#tableisarray

vim.islist({t})                                                 *vim.islist()*
    测试 `t` 是否为“列表”：仅用从 1 开始连续整数索引的表（|lua-length| 所称“正规数组”）。

    空表 `{}` 是列表，除非由 |vim.empty_dict()| 创建或作为字典风格 |API| 或 Vimscript 结果返回，如 |rpcrequest()| 或 |vim.fn|。

    参数: ~
      • {t}  (`table?`)

    返回: ~
        (`boolean`) 若为列表风格表则为 `true`，否则为 `false`

    另见: ~
      • |vim.isarray()|

vim.list_contains({t}, {value})                          *vim.list_contains()*
    检查列表风格表（整数键无间断）是否包含 `value`。

    参数: ~
      • {t}      (`table`) 要检查的表（必须为列表风格，不做校验）
      • {value}  (`any`) 要比较的值

    返回: ~
        (`boolean`) 若 `t` 包含 `value` 则为 `true`

    另见: ~
      • |vim.tbl_contains()| 检查一般表中的值

vim.list_extend({dst}, {src}, {start}, {finish})           *vim.list_extend()*
    用另一个列表风格表的值扩展一个列表风格表。

    注意: 该操作会修改 dst！

    参数: ~
      • {dst}     (`table`) 被修改并追加的列表
      • {src}     (`table`) 要插入值的列表
      • {start}   (`integer?`) src 的起始索引，默认 1
      • {finish}  (`integer?`) src 的结束索引，默认 `#src`

    返回: ~
        (`table`) dst

    另见: ~
      • |vim.tbl_extend()|

vim.list_slice({list}, {start}, {finish})                   *vim.list_slice()*
    创建一个只包含 start 到 end（含）元素的表副本

    参数: ~
      • {list}    (`any[]`) 表
      • {start}   (`integer?`) 切片起始范围
      • {finish}  (`integer?`) 切片结束范围

    返回: ~
        (`any[]`) 从 start 到 finish（含）的表副本

vim.pesc({s})                                                     *vim.pesc()*
    转义 |lua-patterns| 中的魔法字符。

    参数: ~
      • {s}  (`string`) 要转义的字符串

    返回: ~
        (`string`) %-转义后的模式字符串

    另见: ~
      • https://github.com/rxi/lume


vim.spairs({t})                                                 *vim.spairs()*
    按键有序枚举表的键值对。

    参数: ~
      • {t}  (`table`) 字典风格表

    返回（多值）: ~
        (`fun(table: table<K, V>, index?: K):K, V`) |for-in| 迭代器，按排序后的键及其值
        (`table`)

    另见: ~
      • 基于
        https://github.com/premake/premake-core/blob/master/src/base/table.lua

                                                               *vim.validate()*
vim.validate({name}, {value}, {validator}, {optional}, {message})
    校验函数参数。

    此函数有两种有效形式:
    1. `vim.validate(name, value, validator[, optional][, message])`
       校验参数 {name} 的值 {value} 是否满足 {validator}。若给定 {optional} 且为 `true`，则 {value} 可为 `nil`。若给定 {message}，则作为错误信息中的期望类型。
       示例: >lua
         function vim.startswith(s, prefix)
          vim.validate('s', s, 'string')
          vim.validate('prefix', prefix, 'string')
          -- ...
        end
<
    2. `vim.validate(spec)`（已弃用），其中 `spec` 类型为
       `table<string,[value:any, validator: vim.validate.Validator, optional_or_msg? : boolean|string]>)`
       校验参数规范。按字母顺序依次校验，遇到第一个失败即停止。
       示例: >lua
         function user.new(name, age, hobbies)
          vim.validate{
            name={name, 'string'},
            age={age, 'number'},
            hobbies={hobbies, 'table'},
          }
          -- ...
        end
<

    显式参数值示例（可直接运行）: >lua
        vim.validate('arg1', {'foo'}, 'table')
           --> NOP (成功)
        vim.validate('arg2', 'foo', 'string')
           --> NOP (成功)

        vim.validate('arg1', 1, 'table')
           --> error('arg1: expected table, got number')

        vim.validate('arg1', 3, function(a) return (a % 2) == 0 end, 'even number')
           --> error('arg1: expected even number, got 3')
<

    多种类型可用列表: >lua
        vim.validate('arg1', {'foo'}, {'table', 'string'})
        vim.validate('arg2', 'foo', {'table', 'string'})
        -- NOP (成功)

        vim.validate('arg1', 1, {'string', 'table'})
        -- error('arg1: expected string|table, got number')
<

    注意: ~
      • `validator` 设为 |lua-type()| 返回值时性能最佳。

    参数: ~
      • {name}       (`string`) 参数名
      • {value}      (`any`) 参数值
      • {validator}  (`vim.validate.Validator`)
                     • (`string|string[]`): 可为 |lua-type()| 返回的任意值及 'callable'：
                       'boolean'、'callable'、'function'、'nil'、'number'、'string'、'table'、'thread'、'userdata'。
                     • (`fun(val:any): boolean, string?`) 返回布尔值和可选字符串信息的函数。
      • {optional}   (`boolean?`) 参数可选（可省略）
      • {message}    (`string?`) 校验失败时的信息

==============================================================================
Lua 模块: vim.glob                                                *vim.glob*

vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*
    将原始 glob 解析为 |lua-lpeg| 模式。

    采用 LSP 3.17.0 的 glob 语义：
    https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern

    Glob 模式语法如下：
    • `*` 匹配路径段中的一个或多个字符
    • `?` 匹配路径段中的一个字符
    • `**` 匹配任意数量的路径段，包括零个
    • `{}` 分组条件（如 `*.{ts,js}` 匹配 TypeScript 和 JavaScript 文件）
    • `[]` 声明路径段中的字符范围（如 `example.[0-9]` 匹配 `example.0`、`example.1` 等）
    • `[!...]` 否定路径段中的字符范围（如 `example.[!0-9]` 匹配 `example.a`、`example.b`，不匹配 `example.0`）

    参数: ~
      • {pattern}  (`string`) 原始 glob 模式

    返回: ~
        (`vim.lpeg.Pattern`) |lua-lpeg| 表示的模式
==============================================================================
Lua 模块: vim.secure                                            *vim.secure*

vim.secure.read({path})                                    *vim.secure.read()*
    尝试读取 {path} 文件，若需信任则提示用户。用户选择会保存在 $XDG_STATE_HOME/nvim/trust 的信任数据库中。

    属性: ~
        自 0.9.0 起

    参数: ~
      • {path}  (`string`) 要读取的文件路径

    返回: ~
        (`string?`) 若文件存在且被信任则为内容，否则为 nil

    另见: ~
      • |:trust|

vim.secure.trust({opts})                                  *vim.secure.trust()*
    管理信任数据库。

    信任数据库位于 |$XDG_STATE_HOME|/nvim/trust。

    属性: ~
        自 0.9.0 起

    参数: ~
      • {opts}  (`table`) 具有以下字段的表:
                • {action} (`'allow'|'deny'|'remove'`) - `'allow'` 添加文件到信任数据库并信任，
                  `'deny'` 添加文件到信任数据库并拒绝，
                  `'remove'` 从信任数据库移除文件
                • {path}? (`string`) 要更新的文件路径。与 {bufnr} 互斥。action 为 "allow" 时不可用。
                • {bufnr}? (`integer`) 要更新的缓冲区号。与 {path} 互斥。

    返回（多值）: ~
        (`boolean`) 操作成功为 true
        (`string`) 若成功为完整路径，否则为错误信息


vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
