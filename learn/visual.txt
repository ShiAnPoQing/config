可视模式				*Visual* *Visual-mode* *visual-mode*

可视模式是一种灵活且简单的方式，用于为操作符选择一段文本。
它是选择一块文本的唯一方式。
==============================================================================
1. 使用可视模式					*visual-use*

使用可视模式包括三个部分：
1. 用 "v"、"V" 或 CTRL-V 标记文本的起始位置。
   光标下的字符将作为起始点。
2. 移动到文本的结束位置。
   从可视模式的起点到光标下（包括该字符）的文本会被高亮显示。
3. 输入一个操作符命令。
   被高亮的字符将被操作。

|hl-Visual| 组决定了可视选择的高亮显示方式。
'virtualedit' 选项可用于允许将光标定位到没有实际字符的位置。

高亮文本通常包括光标下的字符。
然而，当 'selection' 选项设置为 "exclusive" 且光标在可视区域之后时，光标下的字符不会被包括。

使用 "v" 时，起始位置之前和结束位置之后的文本不会被高亮。
但所有大写和非字母操作符，除了 "~" 和 "U"，都会作用于整行。见下方操作符列表。

							*visual-block*
使用 CTRL-V（块状可视模式）时，高亮文本将在起始位置和光标之间形成一个矩形。
不过，某些操作符仍然会作用于整行（见下方列表）。
更改和替换操作符会删除高亮文本，然后在左上角位置开始插入。

==============================================================================
2. 启动和停止可视模式			*visual-start*

						*v* *charwise-visual*
[count]v		按字符启动可视模式。
			带 [count] 时，选择与上次可视操作相同数量的字符或
			行，但在当前位置，并乘以 [count]。
			如果上次可视操作是块状，则块的宽度和高度都乘以
			[count]。
			如果没有上次可视操作，则选择 [count] 个字符。
			这类似于将光标向右移动 N * [count] 个字符。
			当 'selection' 不是 "exclusive" 时，少选一个字符。

						*V* *linewise-visual*
[count]V		按行启动可视模式。
			带 [count] 时，选择与上次可视操作相同数量的行，
			但在当前位置，并乘以 [count]。
			如果没有上次可视操作，则选择 [count] 行。

						*CTRL-V* *blockwise-visual*
[count]CTRL-V		块状启动可视模式。

如果在可视模式下使用 <Esc>、点击鼠标左键或使用任何会跳转到其他缓冲区的命令，高亮会停止，且不会影响任何文本。
在字符可视模式下再次按 "v"，块状可视模式下按 "CTRL-V"，行可视模式下按 "V" 也会停止高亮。
如果按下 CTRL-Z，高亮停止，编辑器被挂起或启动新 shell |CTRL-Z|。

	      输入后新模式：		*v_v* *v_CTRL-V* *v_V*
旧模式	     "v"	      "CTRL-V"		     "V"	~

普通		    可视	   块状可视	  行可视
可视		    普通	   块状可视	  行可视
块状可视    可视	   普通		  行可视
行可视     可视	   块状可视	  普通

						*gv* *v_gv* *reselect-Visual*
gv			用与上次相同的区域和模式启动可视模式。
			在可视模式下，当前和上次的可视区域会交换。
			在可视模式下使用 "p" 或 "P" 后，粘贴的文本会被选中。

								*gn* *v_gn*
gn			向前搜索上次使用的搜索模式，类似于 `n`，
			并启动可视模式以选择匹配项。
			如果光标在匹配项上，则可视选择它。
			如果有操作符等待，则对匹配项进行操作。
			例如，"dgn" 删除下一个匹配项的文本。
			如果可视模式已激活，则扩展选择直到下一个匹配项结束。
			'wrapscan' 生效。
			注意：与 `n` 不同，搜索方向不依赖于上次搜索命令。

								*gN* *v_gN*
gN			类似 |gn|，但向后搜索，类似于 `N`。

							*<LeftMouse>*
<LeftMouse>		设置当前光标位置。如果可视模式激活则停止。
			仅当 'mouse' 选项包含 'n' 或 'a' 时有效。
			如果位置在屏幕最后一行的 'so' 行内，文本会向上滚动。
			如果位置在屏幕第一行的 'so' 行内，文本会向下滚动。

							*<RightMouse>*
<RightMouse>		如果未激活可视模式则启动可视模式。
			从光标位置到点击位置的文本会被高亮。
			如果可视模式已激活，则移动高亮文本的起点或终点，
			以距离点击位置最近的为准。
			仅当 'mouse' 选项包含 'n' 或 'a' 时有效。

			注意：当 'mousemodel' 设置为 "popup" 时，
			需用 <S-LeftMouse> 替代 <RightMouse>。

							*<LeftRelease>*
<LeftRelease>		此操作类似 <LeftMouse>，如果与 <LeftMouse> 位置不同。
			在旧版 xterm 中，除非有对 xterm 运行所在显示器的访问权限
			（通过 DISPLAY 环境变量或 -display 参数），否则在释放按钮前
			不会看到选中区域。仅当 'mouse' 选项包含 'n' 或 'a' 时有效。

如果未激活可视模式，且 "v"、"V" 或 CTRL-V 前有计数，则使用上次高亮区域的大小作为起点。
你可以移动高亮区域的终点并输入操作符。区域类型（字符、行或块状）与上次相同。
- 行可视模式：行数乘以计数。
- 块状可视模式：行数和列数都乘以计数。
- 普通可视模式（单行）：字符数乘以计数。
- 普通可视模式（多行）：行数乘以计数，最后一行字符数与上次高亮区域最后一行相同。
文本起点为光标位置。如果 "$" 命令是上次扩展高亮区域的命令之一，区域会扩展到最长行的最右列。

如果想高亮与上次完全相同的区域，可用 "gv" |gv| |v_gv|。

							*v_<Esc>*
<Esc>			在可视模式下：停止可视模式。
						*v_META* *v_ALT*
		ALT (|META|) 若组合键未映射，可能表现为 <Esc>。
		例如 <A-x> 若无可视模式映射，则等同于 <Esc>x。

							*v_CTRL-C*
CTRL-C			在可视模式下：停止可视模式。
			当插入模式待定（模式信息显示
			"-- (insert) VISUAL --"）时，也会停止。
			在 MS-Windows 上，可能需要按 CTRL-Break。
==============================================================================
3. 更改可视区域				*visual-change*

							*v_o*
o			跳转到高亮文本的另一端：当前光标位置变为高亮文本的起点，
			光标移动到高亮文本的另一端。高亮区域保持不变。

							*v_O*
O			跳转到高亮文本的另一端。与 "o" 类似，但在块状可视模式下，
			光标移动到同一行的另一个角。当该角落处的字符占据多个屏幕位置
			（如 <Tab>）时，高亮文本可能会发生变化。

							*v_$*
当 "$" 命令与块状可视模式一起使用时，高亮文本的右端由最长的高亮行决定。
当使用的移动命令不是直接上下移动时，此操作会停止。

为了移动块的末端，可以使用许多命令，但不能使用 Ex 命令、会更改内容或放弃文件的命令。
以 "."、"&"、CTRL-^、"Z"、CTRL-]、CTRL-T、CTRL-R、CTRL-I 和 CTRL-O 开头的命令会发出蜂鸣声，并且可视模式继续。

当切换到同一缓冲区的另一个窗口时，该窗口中的光标位置会被调整，以便仍然选中相同的可视区域。
这在需要在一个窗口查看可视区域起点、在另一个窗口查看终点时尤其有用。
此时可以用 <RightMouse>（或 'mousemodel' 为 "popup" 时用 <S-LeftMouse>）拖动可视区域的任一端。

==============================================================================
4. 对可视区域进行操作				*visual-operators*

可用的操作符有：
	~	切换大小写					|v_~|
	d	删除						|v_d|
	c	更改 (4)					|v_c|
	y	复制						|v_y|
	>	右移 (4)					|v_>|
	<	左移 (4)					|v_<|
	!	通过外部命令过滤 (1)			|v_!|
	=	通过 'equalprg' 选项命令过滤 (1)	|v_=|
	gq	格式化为 'textwidth' 长度 (1)		|v_gq|

可用的对象有：
	aw	一个单词（含空格）				|v_aw|
	iw	单词内部					|v_iw|
	aW	一个 WORD（含空格）				|v_aW|
	iW	WORD 内部					|v_iW|
	as	一个句子（含空格）				|v_as|
	is	句子内部					|v_is|
	ap	一个段落（含空格）				|v_ap|
	ip	段落内部					|v_ip|
	ab	一个 () 块（含括号）				|v_ab|
	ib	() 块内部					|v_ib|
	aB	一个 {} 块（含大括号）				|v_aB|
	iB	{} 块内部					|v_iB|
	at	一个 <tag> </tag> 块（含标签）		|v_at|
	it	<tag> </tag> 块内部				|v_it|
	a<	一个 <> 块（含尖括号）				|v_a<|
	i<	<> 块内部					|v_i<|
	a[	一个 [] 块（含中括号）				|v_a[|
	i[	[] 块内部					|v_i[|
	a"	一个双引号字符串（含引号）			|v_aquote|
	i"	双引号字符串内部				|v_iquote|
	a'	一个单引号字符串（含引号）			|v_a'|
	i'	单引号字符串内部				|v_i'|
	a`	一个反引号字符串（含反引号）			|v_a`|
	i`	反引号字符串内部				|v_i`|

此外还可以使用以下命令：
	:	对高亮行启动 Ex 命令 (1)			|v_:|
	r	更改 (4)					|v_r|
	s	更改						|v_s|
	C	更改 (2)(4)					|v_C|
	S	更改 (2)					|v_S|
	R	更改 (2)					|v_R|
	x	删除						|v_x|
	D	删除 (3)					|v_D|
	X	删除 (2)					|v_X|
	Y	复制 (2)					|v_Y|
	p	粘贴						|v_p|
	P	粘贴且不覆盖寄存器				|v_P|
	J	合并 (1)					|v_J|
	U	转为大写					|v_U|
	u	转为小写					|v_u|
	^]	查找标签					|v_CTRL-]|
	I	块插入						|v_b_I|
	A	块追加						|v_b_A|

(1)：始终为整行，见 |:visual_example|。
(2)：未用 CTRL-V 时为整行。
(3)：未用 CTRL-V 时为整行，使用 CTRL-V 时删除到行尾。
(4)：使用 CTRL-V 时仅作用于块。

注意，":vmap" 命令可专门映射可视模式下的按键。例如，如果你希望 "/" 命令不扩展可视区域，而是用高亮文本进行搜索：>
	:vmap / y/<C-R>"<CR>
（在 <> 表示法 |<>| 中，输入时应按字面输入；需从 'cpoptions' 中移除 'B' 标志。）

如果要用 """ 命令指定寄存器，请在输入操作符字符前执行："v{move-around}"xd"。

如果要为命令指定计数，请在输入操作符字符前执行："v{move-around}3>"（将行右移 3 个缩进）。

							*{move-around}*
{move-around} 是任意一组移动命令。注意与 {motion} 的区别，后者仅为一个移动命令。

另一种对可视区域操作的方法是使用模式中的 |/\%V| 项。例如，将可视区域内所有 '(' 替换为 '#'：>

	:'<,'>s/\%V(/#/g

注意，按 ":" 进入可视模式时，"'<'，'>'" 会自动出现。
==============================================================================
5. 块状操作符					*blockwise-operators*

提醒：使用 'virtualedit' 可以选择起点或终点在行尾之后或制表符中间的块。

块状插入						*v_b_I*
在块状选择下，I{字符串}<ESC> 会在块中每一行的起始处插入 {字符串}，前提是该行延伸到块内。
因此，较短的行不会被修改。TAB 会被分割以保持可视列。仅用于在行中添加文本，不用于删除。见 |v_b_I_example|。

块状追加						*v_b_A*
在块状选择下，A{字符串}<ESC> 会在块中每一行的块末尾追加 {字符串}。
当块的右边界不整齐时（由于行长不同），行为略有不同：

1. 用 <C-v>$ 创建块时
    此时字符串会追加到每一行的末尾。
2. 用 <C-v>{move-around} 创建块时
    此时字符串会追加到每一行块的末尾，并插入空白填充到块的末尾列。
见 |v_b_A_example|。
注意："I" 和 "A" 对于未延伸到选中块的行表现不同。这是有意为之，以便你可以按需操作。
仅用于在行中添加文本，不用于删除。

块状更改						*v_b_c*
块中所有选中文本将被同一字符串替换。使用 "c" 时，选中文本被删除并进入插入模式。你可以输入文本（不换行）。按 <Esc> 后，相同字符串会插入到所有先前选中的行。

块状更改（到行尾）					*v_b_C*
类似于 "c"，但选择会扩展到所有行的行尾。

								*v_b_<*
块状左移						*v_b_>*
块会按 'shiftwidth' 左移或右移。块的右边界无关紧要。左边界决定右移的起点，填充会根据 'ts' 和 'et' 最优地包含 TAB。左边界决定左移的终点。
见 |v_b_>_example|。
见 |v_b_<_example|。

块状替换						*v_b_r*
高亮区域内的每个屏幕字符都被同一个字符替换，即 TAB 会被分割，虚拟空白会被替换，保持屏幕布局。
见 |v_b_r_example|。

==============================================================================
6. 重复						*visual-repeat*

当重复可视模式操作符时，操作符会作用于与上次相同数量的文本：
- 行可视模式：相同行数。
- 块状可视模式：相同行数和列数。
- 普通可视模式（单行）：相同字符数。
- 普通可视模式（多行）：行数相同，最后一行字符数与上次最后一行相同。
文本起点为光标位置。如果 "$" 命令是上次扩展高亮区域的命令之一，重复时会应用到最长行的最右列。任何传递给 `.` 命令的计数都不会被使用。

可视模式 |default-mappings| "@" 和 "Q" 会对所有选中行重复寄存器内容（若为行选择）。见 |v_@-default| 和 |v_Q-default| 了解详情。例如，给定如下文本：

	123(hello)321
	456(world)654
	456(NOT THIS)654

寄存器 "x" 包含命令 `yi(VP`，可视选择前两行并输入 `@x` 会得到：

	hello
	world
	456(NOT THIS)654

==============================================================================
7. 示例						*visual-examples*

							*:visual_example*
当前 ":" 命令仅作用于整行。当你只选中部分行时，执行 ":!date" 之类的操作会替换整行。
如果只想替换部分行，需要为此创建映射。未来版本中 ":" 可能会支持部分行。

以下是一个示例，用 "date" 命令输出替换选中文本：>
	:vmap _a <Esc>`>a<CR><Esc>`<i<CR><Esc>!!date<CR>kJJ

（在 <> 表示法 |<>| 中，输入时应按字面输入；需从 'cpoptions' 中移除 'B' 标志）

其作用如下：
<Esc>		停止可视模式
`>		跳转到可视区域末尾
a<CR><Esc>	在可视区域后插入换行
`<		跳转到可视区域起点
i<CR><Esc>	在可视区域前插入换行
!!date<CR>	通过 date 命令过滤可视文本
kJJ		合并行

							*visual-search*
以下是一个映射思路，使你可以用选中文本进行搜索：>
	:vmap X y/<C-R>"<CR>

（在 <> 表示法 |<>| 中，输入时应按字面输入；需从 'cpoptions' 中移除 'B' 标志）

注意，特殊字符（如 '.' 和 "*"）会导致问题。

块状可视示例					*blockwise-examples*
以下文本将演示如何生成块及其结果。所有情况下，光标都在测试文本第一行的 'a' 上。
假设模型行设置为 ":ts=8:sw=4:"。

建议执行
:set hls
/<TAB>
其中 <TAB> 为实际的 TAB。这样有助于可视化操作。

测试文本如下：

abcdefghijklmnopqrstuvwxyz
abc		defghijklmnopqrstuvwxyz
abcdef  ghi		jklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz

1. fo<C-v>3jISTRING<ESC>					*v_b_I_example*

abcdefghijklmnSTRINGopqrstuvwxyz
abc	      STRING  defghijklmnopqrstuvwxyz
abcdef  ghi   STRING  	jklmnopqrstuvwxyz
abcdefghijklmnSTRINGopqrstuvwxyz

2. fo<C-v>3j$ASTRING<ESC>					*v_b_A_example*

abcdefghijklmnopqrstuvwxyzSTRING
abc		defghijklmnopqrstuvwxyzSTRING
abcdef  ghi		jklmnopqrstuvwxyzSTRING
abcdefghijklmnopqrstuvwxyzSTRING

3. fo<C-v>3j3l<..						*v_b_<_example*

abcdefghijklmnopqrstuvwxyz
abc	      defghijklmnopqrstuvwxyz
abcdef  ghi   jklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz

4. fo<C-v>3j>..							*v_b_>_example*

abcdefghijklmn		  opqrstuvwxyz
abc			    defghijklmnopqrstuvwxyz
abcdef  ghi			    jklmnopqrstuvwxyz
abcdefghijklmn		  opqrstuvwxyz

5. fo<C-v>5l3jrX						*v_b_r_example*

abcdefghijklmnXXXXXXuvwxyz
abc	      XXXXXXhijklmnopqrstuvwxyz
abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz
abcdefghijklmnXXXXXXuvwxyz
==============================================================================
8. 选择模式						*Select* *Select-mode*

选择模式看起来与可视模式类似，但接受的命令却大不相同。这类似于 Microsoft Windows 中的选择模式。
当设置了 'showmode' 选项时，最后一行会显示 "-- SELECT --"。

进入选择模式的方法：
- 使用鼠标选择区域，且 'selectmode' 包含 "mouse"。'mouse' 还必须包含当前模式的标志。
- 按住 Shift 键并使用不可打印的移动命令，且 'selectmode' 包含 "key"。例如：<S-Left> 和 <S-End>。'keymodel' 还必须包含 "startsel"。
- 在普通模式下使用 "v"、"V" 或 CTRL-V 命令，且 'selectmode' 包含 "cmd"。
- 在普通模式下使用 "gh"、"gH" 或 "g_CTRL-H" 命令。
- 从可视模式下按 CTRL-G。			*v_CTRL-G*

选择模式下的命令：
- 可打印字符、<NL> 和 <CR> 会导致所选内容被删除，并进入插入模式。输入的字符会被插入。
- 按住 Shift 键并使用不可打印的移动命令会扩展选择。'keymodel' 必须包含 "startsel"。
- 不按 Shift 键使用不可打印的移动命令会停止选择模式。'keymodel' 必须包含 "stopsel"。
- ESC 停止选择模式。
- CTRL-O 切换到可视模式，持续一个命令。 *v_CTRL-O*
- CTRL-G 切换到可视模式。
- CTRL-R {寄存器} 选择用于删除所选内容时的寄存器。 *v_CTRL-R*
  除非你指定 "_"（黑洞）寄存器，否则未命名寄存器也会被覆盖。

其他情况下，输入的字符会像在可视模式下一样处理。

在选择模式下使用操作符，且选择为整行时，所选行会被操作，但方式类似于字符选择。例如，删除整行后，可以在一行中间粘贴。

选择模式下的映射和菜单			*Select-mode-mapping*

用 |:vmap| 或 |:vmenu| 命令定义的映射和菜单在可视模式和选择模式下都有效。在选择模式下使用这些时，Vim 会自动切换到可视模式，从而实现与可视模式相同的行为。如果不想这样，请用 |:xmap| 或 |:smap|。

一个特殊情况：>
	:vnoremap <C-K> <Esc>
这会在可视模式下结束可视模式，但在选择模式下无效，因为映射键执行后会恢复选择模式。你需要用：>
	:snoremap <C-K> <Esc>
<
用户会期望可打印字符替换所选区域。因此请避免在选择模式下映射可打印字符。或者在 |:map| 和 |:vmap| 后用 |:sunmap| 移除选择模式下的映射。

映射或菜单结束后，选择会再次启用并进入选择模式，除非所选区域被删除、切换到其他缓冲区或窗口布局发生变化。

当输入的字符导致所选区域被删除并进入插入模式时，插入模式映射会应用于该字符。这可能会引起一些困惑，因为这意味着插入模式映射会应用于选择模式下输入的字符。语言映射同样适用。

							*gV* *v_gV*
gV			避免在选择模式映射或菜单结束后自动重新选择可视区域。
			应将其放在映射或菜单结束前，至少应在对选择进行任何操作之后。

							*gh*
gh			以字符方式启动选择模式。类似于 "v"，但启动的是选择模式。
			助记：get highlighted。

							*gH*
gH			以行方式启动选择模式。类似于 "V"，但启动的是选择模式。
			助记：get Highlighted。

							*g_CTRL-H*
g CTRL-H		以块方式启动选择模式。类似于 CTRL-V，但启动的是选择模式。
			助记：get Highlighted。

 vim:tw=78:ts=8:noet:ft=help:norl:
