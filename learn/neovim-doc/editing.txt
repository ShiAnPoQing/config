*editing.txt*   Nvim


		  VIM 参考手册    by Bram Moolenaar


编辑文件						*edit-files*

                                      输入 |gO| 查看目录。

==============================================================================
1. 介绍						*edit-intro*

使用 Vim 编辑文件意味着：

1. 将文件读入缓冲区
2. 使用编辑器命令更改缓冲区
3. 将缓冲区写入文件

							*current-file*
只要你不写入缓冲区，原始文件就保持不变。
如果你开始编辑一个文件（将文件读入缓冲区），文件名会被记住为"当前文件名"。这也被称为当前缓冲区的名称。它可以在命令行上使用 "%" |:_%|。

							*alternate-file*
如果已经有一个当前文件名，那么该文件名将成为备用文件名。它可以在命令行上使用 "#" |:_#|，并且你可以使用 |CTRL-^| 命令在当前文件和备用文件之间切换。
但是，当使用 |:keepalt| 时，备用文件名不会更改。
每个窗口都会记住一个备用文件名。

							*:keepa* *:keepalt*
:keepa[lt] {cmd}	执行 {cmd} 同时保持当前的备用文件名。
			注意，间接调用的命令（例如，通过函数）可能仍然会设置备用文件名。

所有文件名都记录在缓冲区列表中。当你输入一个文件名，用于编辑（例如，使用 ":e filename"）或写入（例如，使用 ":w filename"）时，该文件名会被添加到列表中。你可以使用缓冲区列表来记住你编辑过哪些文件，并使用 |CTRL-^| 命令快速从一个文件切换到另一个文件（例如，复制文本）。首先输入文件的编号，然后按 CTRL-^。


CTRL-G		或				*CTRL-G* *:f* *:fi* *:file*
:f[ile]			打印当前文件名（按输入时的样子，除非使用了 ":cd"），光标位置（除非设置了 'ruler' 选项）和文件状态（只读，已修改，读取错误，新文件）。关于如何使此消息更短，请参阅 'shortmess' 选项。

:f[ile]!			类似 |:file|，但即使 'shortmess' 指示截断，也不截断名称。

{count}CTRL-G		类似 CTRL-G，但打印带完整路径的当前文件名。
			如果计数大于 1，还会给出当前缓冲区编号。

					*g_CTRL-G* *word-count* *byte-count*
g CTRL-G			以五种方式打印光标的当前位置：列、行、单词、字符和字节。如果字符数和字节数相同，则省略字符位置。

			如果行中有字符在屏幕上占用多个位置（<Tab> 或特殊字符），或者每列使用多个字节的字符（当 'encoding' 为 utf-8 时，0x7F 以上的字符），则会同时显示字节列和屏幕列，用破折号分隔。

			另请参阅 'ruler' 选项和 |wordcount()| 函数。

							*v_g_CTRL-G*
{Visual}g CTRL-G	类似于 "g CTRL-G"，但显示可视选择区域的单词、字符、行和字节计数。
			在块状模式下，还会显示列计数。（关于 {Visual} 请参阅 |Visual-mode|。）

							*:file_f*
:f[ile][!] {name}	将当前文件名设置为 {name}。可选的 !
			避免截断消息，如同 |:file|。
			如果缓冲区已有名称，则该名称成为 |alternate-file| 名称。会创建一个未列出的缓冲区来保存旧名称。
							*:0file*
:0f[ile][!]		移除当前缓冲区的名称。可选的 !
			避免截断消息，如同 |:file|。

:buffers
:files
:ls			列出所有当前已知的文件名。请参阅
			|windows.txt| |:files| |:buffers| |:ls|。

Vim 会记住你输入的文件的完整路径名。在大多数情况下，显示文件名时只显示你键入的名称，但如果你使用了 ":cd" 命令 |:cd|，则会使用完整路径名。

							*home-replace*
如果设置了环境变量 $HOME，并且文件名以该字符串开头，它通常会显示为用 "~" 替换 HOME。这样做是为了保持文件名简短。在读取或写入文件时，仍然使用完整名称，"~" 仅用于显示文件名。当替换文件名将导致只有 "~" 时，改用 "~/"（以避免与设置为 $HOME 的选项和 'backupext' 设置为 "~" 混淆）。

写入缓冲区时，默认使用当前文件名。因此，当你给出 "ZZ" 或 ":wq" 命令时，原始文件将被覆盖。如果你不希望这样，可以通过给 ":write" 命令一个文件名参数将缓冲区写入另一个文件。例如：>

	vim testfile
	[使用编辑器命令更改缓冲区]
	:w newfile
	:q

这将创建一个文件 "newfile"，它是 "testfile" 的修改副本。文件 "testfile" 将保持不变。无论如何，如果设置了 'backup' 选项，Vim 会在原始文件被覆盖之前重命名或复制它。如果你发现需要原始文件，可以使用此文件。另请参阅 'patchmode' 选项。备份文件的名称通常与原始文件相同，并附加 'backupext'。默认的 "~" 有点奇怪，以避免意外覆盖现有文件。如果你喜欢 ".bak"，请更改 'backupext' 选项。通过设置 'backupdir'，可以将备份文件放在另一个目录中。

当你开始编辑时没有给出文件名，消息中会显示 "No File"。如果 ":write" 命令带有文件名参数，则当前文件的文件名将设置为该文件名。这仅在 'cpoptions' 中包含 'F' 标志时发生（默认情况下包含）|cpo-F|。这在空缓冲区中输入文本然后将其写入文件时很有用。如果 'cpoptions' 包含 'f' 标志（默认情况下不包含）|cpo-f|，则 ":read file" 命令会设置文件名。这在启动 Vim 时没有参数，然后执行 ":read file" 开始编辑文件时很有用。
当文件名被设置且 'filetype' 为空时，将触发文件类型检测自动命令。
							*not-edited*
因为文件名是在没有真正开始编辑该文件的情况下设置的，所以你受到保护，不会覆盖该文件。这是通过设置 "notedited" 标志来实现的。你可以使用 CTRL-G 或 ":file" 命令查看是否设置了此标志。当设置了 "notedited" 标志时，它将包含 "[Not edited]"。
当将缓冲区写入当前文件名（使用 ":w!"）时，"notedited" 标志被重置。

							*abandon*
Vim 会记住你是否更改了缓冲区。你受到保护，不会丢失你所做的更改。如果你尝试在不写入的情况下退出，或者想要开始编辑另一个文件，Vim 将拒绝此操作。为了覆盖此保护，请在命令中添加 '!'。更改将丢失。例如：如果缓冲区已更改，":q" 将不起作用，但 ":q!" 可以。要查看缓冲区是否已更改，请使用 "CTRL-G" 命令。如果缓冲区已更改，消息将包含字符串 "[Modified]"，或者如果 'shortmess' 中有 'm' 标志，则包含 "+"。

如果你想自动保存更改而不询问，请打开 'autowriteall' 选项。'autowrite' 是相关的 Vi 兼容选项，但它并非对所有命令都有效。

如果你想保留更改的缓冲区而不保存它，请打开 'hidden' 选项。请参阅 |hidden-buffer|。即使未设置 'hidden'，某些命令也会这样工作，请检查该命令的帮助。

==============================================================================
2. 编辑文件					*edit-a-file*

							*:e* *:edit* *reload*
:e[dit][!] [++opt] [+cmd]
			编辑当前文件。当文件在 Vim 外部发生更改时，这对于重新编辑当前文件很有用。
							*:edit!* *discard*
			如果给出 [!]，则丢弃当前缓冲区中未保存的更改。没有 [!]，如果存在未保存的更改，命令将失败，除非设置了 'autowriteall' 并且文件可以写入。
			另请参阅 |++opt| 和 |+cmd|。

							*:edit_f*
:e[dit][!] [++opt] [+cmd] {file}
			编辑 {file}。
							*:edit!_f*
			如果给出 [!]，则丢弃当前缓冲区中未保存的更改。没有 [!]，如果存在未保存的更改，命令将失败，除非设置了 'hidden' 或设置了 'autowriteall' 并且文件可以写入。
			另请参阅 |++opt| 和 |+cmd|。

							*:edit_#* *:e#*
:e[dit] [++opt] [+cmd] #[count]
			编辑第 [count] 个缓冲区（如 |:files| 所示）。
			此命令与 [count] CTRL-^ 执行相同的操作。但是当备用缓冲区没有文件名时，":e #" 不起作用，而 CTRL-^ 仍然有效。
			另请参阅 |++opt| 和 |+cmd|。

							*:ene* *:enew*
:ene[w]			编辑一个新的、未命名的缓冲区。如果对当前缓冲区进行了更改，此操作将失败，除非设置了 'hidden' 或设置了 'autowriteall' 并且文件可以写入。
			如果 'fileformats' 不为空，将使用给定的第一种格式用于新缓冲区。如果 'fileformats' 为空，则使用当前缓冲区的 'fileformat'。

							*:ene!* *:enew!*
:ene[w]!			编辑一个新的、未命名的缓冲区。丢弃对当前缓冲区的任何更改。
			像 |:enew| 一样设置 'fileformat'。

							*:fin* *:find*
:fin[d][!] [++opt] [+cmd] {file}
			在 'path' 中查找 {file} 然后 |:edit| 它。
			另请参阅：'findfunc'。

:{count}fin[d][!] [++opt] [+cmd] {file}
			类似于 ":find"，但使用 'path' 中的第 {count} 个匹配项。因此 ":2find file" 将查找在 'path' 中找到的第二个 "file"。如果 'path' 中文件的匹配项少于要求的数量，你将收到错误消息。

							*:ex*
:ex [++opt] [+cmd] [file]
			与 |:edit| 相同。

							*:vi* *:visual*
:vi[sual][!] [++opt] [+cmd] [file]
			在 Ex 模式下使用时：离开 |Ex-mode|，返回普通模式。否则与 |:edit| 相同。

							*:vie* *:view*
:vie[w][!] [++opt] [+cmd] file
			在 Ex 模式下使用时：离开 |Ex-mode|，返回普通模式。否则与 |:edit| 相同，但为此缓冲区设置 'readonly' 选项。

							*CTRL-^* *CTRL-6*
CTRL-^			编辑备用文件。大多数情况下，备用文件是先前编辑的文件。这是在两个文件之间快速切换的方法。它等同于 ":e #"， except that it also works when there is no file name.

			如果设置了 'autowrite' 或 'autowriteall' 选项并且缓冲区已更改，则写入它。
			大多数情况下，^ 字符位于 6 键上，按下 CTRL 和 6 会得到我们称为 CTRL-^ 的内容。但在某些非美式键盘上，CTRL-^ 以另一种方式产生。

{count}CTRL-^		编辑缓冲区列表中的第 [count] 个文件（等同于 ":e #[count]"）。这是在文件之间切换的快速方法。
			有关更多详细信息，请参阅上面的 |CTRL-^|。

							*gf* *E446* *E447*
[count]gf		编辑光标下或后的文件名。
			助记符："goto file"。
			使用 'isfname' 选项来找出哪些字符应该出现在文件名中。忽略尾部的标点字符 ".,:;!"。转义的空格 "\ " 被减少为单个空格。
			使用 'path' 选项作为目录名称列表来查找文件。有关相对目录和通配符的详细信息，请参阅 'path' 选项。
			使用 'suffixesadd' 选项来检查添加了后缀的文件名。
			如果找不到文件，则使用 'includeexpr' 修改名称并再次尝试。
			如果给出 [count]，则编辑在 'path' 中找到的第 count 个文件。
			如果 Vim 拒绝 |abandon| 当前文件，则此命令失败。
			如果要在新窗口中编辑文件，请使用 |CTRL-W_CTRL-F|。
			如果确实要编辑新文件，请使用：>
				:e <cfile>
<			要使 gf 始终这样工作：>
				:map gf :e <cfile><CR>
<			如果名称是超文本链接，看起来像 "type://machine/path"，你需要 |netrw| 插件。
			对于 Unix，扩展 "~" 字符，如 "~user/file"。环境变量也会扩展 |expand-env|。

							*v_gf*
{Visual}[count]gf	与 "gf" 相同，但使用高亮文本作为要编辑的文件名。忽略 'isfname'。
			跳过前导空白，否则所有空白和特殊字符都包含在文件名中。
			（关于 {Visual} 请参阅 |Visual-mode|。）

							*gF*
[count]gF		与 "gf" 相同，除非文件名后跟数字，然后将光标定位在该文件中的该行上。
			文件名和数字必须由非文件名（参见 'isfname'）和非数字字符分隔。也识别 " line "，就像在 `:verbose command UserCmd` 的输出中使用的那样。
			忽略文件名、分隔符和数字之间的空白。
			示例：
				eval.c:10 ~
				eval.c @ 20 ~
				eval.c (30) ~
				eval.c 40 ~

							*v_gF*
{Visual}[count]gF	与 "v_gf" 相同。

这些命令用于开始编辑单个文件。这意味着文件被读入缓冲区并设置当前文件名。打开的文件取决于当前目录，请参阅 |:cd|。

有关读取文件后给出的消息的说明，请参阅 |read-messages|。

如果你搞乱了缓冲区并想重新开始，可以使用 ":e!" 命令。仅当你更改了当前文件名时，":e" 命令才有用。

							*:filename* *{file}*
除了此处提到的事项外，在 |cmdline-special| 中还提到了更多预期为文件名的特殊项。

注意 Unix 以外的系统：当使用接受单个文件名的命令（如 ":edit file"）时，文件名中允许有空格，但尾部空格被忽略。这对于经常在文件名中嵌入空格的系统（如 MS-Windows）很有用。示例：命令 ":e   Long File Name " 将编辑文件 "Long File Name"。当使用接受多个文件名的命令（如 ":next file1 file2"）时，必须使用反斜杠转义嵌入的空格。

						*wildcard* *wildcards*
{file} 中的通配符会被扩展，但与文件补全一样，适用 'wildignore' 和 'suffixes'。支持哪些通配符取决于系统。常见的有：
	`?`	匹配一个字符
	`*`	匹配任何内容，包括空
	`**`	匹配任何内容，包括空，递归进入目录
	[abc]	匹配 'a'、'b' 或 'c'

为避免通配符的特殊含义，请在前面加上反斜杠。但是，在 MS-Windows 上，反斜杠是路径分隔符，当 "[" 在 'isfname' 选项中时，"path\[abc]" 仍被视为通配符。避免这种情况的一个简单方法是使用 "path\[[]abc]"，这匹配文件 "path\[abc]"。

					*starstar-wildcard*
在 Unix、Win32、macOS 和其他一些系统上可以扩展 "**"（但在 Unix 和 macOS 上可能取决于你的 'shell' 设置。已知在 zsh 中能正确工作；对于 bash，这至少需要 bash 版本 >= 4.X）。
这允许搜索目录树。这最多深入 100 个目录。请注意，有些命令的工作方式略有不同，请参阅 |file-searching|。
示例：>
	:n **/*.txt
查找文件：
	aaa.txt ~
	subdir/bbb.txt ~
	a/b/c/d/ccc.txt ~
当在 "**" 之前或之后使用非通配符字符时，这些字符仅匹配顶级目录。它们不用于树中更深的目录。例如：>
	:n /usr/inc**/types.h
查找文件：
	/usr/include/types.h ~
	/usr/include/sys/types.h ~
	/usr/inc/old/types.h ~
请注意，包含 "/sys" 的路径被包括在内，因为它不需要匹配 "/inc"。因此，它类似于匹配 "/usr/inc*/*/*..."，而不是 "/usr/inc*/inc*/inc*"。

					*backtick-expansion* *`-expansion*
在 Unix 和其他一些系统上，你也可以对文件名参数使用反引号，例如：>
	:next `find . -name ver\\*.c -print`
	:view `ls -t *.patch  \| head -n1`
Vim 将使用 'shell' 运行反引号中的命令，并将标准输出作为给定 Vim 命令的参数（来自 shell 命令的错误消息将被丢弃）。
要查看 Vim 正在运行什么 shell 命令，请将 'verbose' 选项设置为 4。当 shell 命令返回非零退出代码时，将显示错误消息并且 Vim 命令将中止。为避免这种情况，让 shell 始终返回零，如下所示：>
       :next `find . -name ver\\*.c -print \|\| true`

星号前的反斜杠是必需的，以防止 shell 在执行 find 程序之前扩展 "ver*.c"。shell 管道符号 "|" 前的反斜杠可防止 Vim 将其解析为命令终止。
这也适用于大多数其他系统，限制是反引号必须围绕整个项。不可能在第一个反引号之前或最后一个反引号之后直接有文本。

							*`=*
你可以通过在第一反引号后立即放置等号，将反引号扩展为 Vim 表达式，而不是外部命令，例如：>
	:e `=tempname()`
该表达式可以包含几乎任何内容，因此这也可用于避免 '"'、"|"、'%' 和 '#' 的特殊含义。但是，'wildignore' 确实像对其他通配符一样适用。

表达式中的环境变量在计算表达式时扩展，因此这有效：>
	:e `=$HOME .. '/.vimrc'`
这在字符串内部使用 $HOME 并且它将按字面意思使用，很可能不是你的本意：>
	:e `='$HOME' .. '/.vimrc'`

如果表达式返回字符串，则名称应用换行符分隔。当结果是 |List| 时，每个项都用作名称。换行符也分隔名称。
请注意，此类表达式仅在 Ex 命令的参数预期为文件名的地方受支持。

							*++opt* *[++opt]*
[++opt] 参数可用于为一个命令设置一些选项，并指定对错误字符的行为。形式为：>
	++{optname}
或：>
	++{optname}={value}

其中 {optname} 是以下之一：	    *++ff* *++enc* *++bin* *++nobin* *++edit*
    ff     或  fileformat   覆盖 'fileformat'
    enc    或  encoding	    覆盖 'fileencoding'
    bin    或  binary	    设置 'binary'
    nobin  或  nobinary	    重置 'binary'
    bad		    指定错误字符的行为
    edit		    对于 |:read|：保持选项如同编辑文件
    p			    对于 |:write|：创建文件的父目录

{value} 不能包含空白。它可以是选项的任何有效值。
示例：>
	:e ++ff=unix
这再次编辑同一个文件，并将 'fileformat' 设置为 "unix"。>

	:w ++enc=latin1 newfile
这以 latin1 格式将当前缓冲区写入 "newfile"。

当 'fileencoding' 或使用 ++enc 指定的值与 'encoding' 不同时，写入文件时给出的消息将显示 "[converted]"。

可能有几个 ++opt 参数，用空白分隔。它们都必须出现在任何 |+cmd| 参数之前。

								*++p*
"++p" 标志在文件不存在时创建文件的父目录。例如，如果你编辑 "foo/bar/file.txt"，":write ++p" 命令在写入文件之前根据需要创建 "foo/bar/"。>

	:edit foo/bar/file.txt
	:write ++p

如果你希望 :write（不带 "++p"）始终创建缺失的父目录，请将此自动命令添加到你的配置中：>

	" 自动创建父目录（除了 URI "://"）。
	au BufWritePre,FileWritePre * if @% !~# '\(://\)' | call mkdir(expand('<afile>:p:h'), 'p') | endif
<

								*++bad*
"++bad=" 的参数指定对无法转换的字符和非法字节的处理方式。它可以是以下三种之一：
    ++bad=X      替换每个错误字符的单字节字符。
    ++bad=keep   保留错误字符而不转换。注意，这可能导致文本中出现非法字节！
    ++bad=drop   移除错误字符。

默认为 "++bad=?"：用问号替换每个错误字符。在某些地方使用倒问号 (0xBF)。

请注意，并非所有命令都使用 ++bad 参数，即使你添加它时它们不会报错。例如 |:write|。

请注意，读取时，'fileformat' 和 'fileencoding' 选项将设置为使用的格式。写入时不会发生这种情况，因此下一次写入将使用选项的旧值。'binary' 选项也是如此。


							*+cmd* *[+cmd]*
[+cmd] 参数可用于在新打开的文件中定位光标，或执行任何其他命令：
	+		从最后一行开始。
	+{num}		从第 {num} 行开始。
	+/{pat}		从包含 {pat} 的第一行开始。
	+{command}	打开新文件后执行 {command}。
			{command} 是任何 Ex 命令。
要在 {pat} 或 {command} 中包含空白，请在其前面加上反斜杠。将反斜杠的数量加倍。>
	:edit  +/The\ book	     file
	:edit  +/dir\ dirname\\      file
	:edit  +set\ dir=c:\\\\temp  file
请注意，在最后一个示例中，反斜杠的数量减半了两次：一次是针对 "+cmd" 参数，一次是针对 ":set" 命令。

							*file-formats*
'fileformat' 选项设置文件的 <EOL> 样式：
'fileformat'    字符	   名称				~
  "dos"		<CR><NL> 或 <NL>   DOS 格式		*DOS-format*
  "unix"	<NL>		    Unix 格式		*Unix-format*
  "mac"		<CR>		    Mac 格式		*Mac-format*

读取文件时，上述字符被解释为 <EOL>。
在 DOS 格式（Windows 的默认格式）中，<CR><NL> 和 <NL> 都被解释为 <EOL>。请注意，在以 DOS 格式写入文件时，将为每个单个 <NL> 添加 <CR> 字符。另请参阅 |file-read|。

写入文件时，上述字符用于 <EOL>。对于 DOS 格式，使用 <CR><NL>。另请参阅 |DOS-format-write|。

你可以读取 DOS 格式的文件并以 Unix 格式写入。这将用 <NL> 替换所有 <CR><NL> 对（假设 'fileformats' 包括 "dos"）：>
	:e file
	:set fileformat=unix
	:w
如果你读取 Unix 格式的文件并以 DOS 格式写入，所有 <NL> 字符将被替换为 <CR><NL>（假设 'fileformats' 包括 "unix"）：>
	:e file
	:set fileformat=dos
	:w

如果你开始编辑一个新文件并且 'fileformats' 选项不为空（这是默认情况），Vim 将尝试检测文件中的行是否由指定的格式分隔。当设置为 "unix,dos" 时，Vim 将检查具有单个 <NL>（如 Unix 上使用）或由 <CR><NL> 对（MS-Windows）分隔的行。仅当所有行都以 <CR><NL> 结尾时，'fileformat' 才设置为 "dos"，否则设置为 "unix"。当 'fileformats' 包括 "mac" 并且在文件中未找到 <NL> 字符时，'fileformat' 设置为 "mac"。

如果在非 MS-Windows 系统上将 'fileformat' 选项设置为 "dos"，则会显示消息 "[dos]" 以提醒你发生了不寻常的事情。在 MS-Windows 系统上，如果 'fileformat' 设置为 "unix"，你将得到消息 "[unix]"。在所有系统上，如果 'fileformat' 设置为 "mac"，你将得到消息 "[mac]"。

如果 'fileformats' 选项为空并且使用了 DOS 格式，但在读取文件时有些行没有以 <CR><NL> 结尾，则文件消息中将包含 "[CR missing]"。
如果 'fileformats' 选项为空并且使用了 Mac 格式，但在读取文件时找到了 <NL>，则文件消息中将包含 "[NL missing]"。

如果新文件不存在，当 'fileformats' 为空时，使用当前缓冲区的 'fileformat'。否则，新文件使用 'fileformats' 中的第一种格式。

在编辑二进制、可执行文件或 Vim 脚本文件之前，你应该设置 'binary' 选项。一个简单的方法是通过 "-b" 选项启动 Vim。这将避免使用 'fileformat'。没有这个，你可能会意外地将单个 <NL> 字符替换为 <CR><NL>。

行尾和文件尾				*eol-and-eof*

Vim 有几个选项来控制文件格式：
	'fileformat'	<EOL> 样式：Unix、DOS、Mac
	'endofline'	最后一行是否以 <EOL> 结尾
	'endoffile'	文件是否以 CTRL-Z 结尾
	'fixendofline'	是否修复 eol 和 eof

前三个值通常在读取文件时自动检测，并在将文本写入文件时使用。在编辑缓冲区时，看起来每一行都有行尾，并且 CTRL-Z 不存在（例外是当设置了 'binary' 时，它的工作方式不同）。

'fixendofline' 选项可用于选择写入内容。你也可以更改选项值以以不同于读取方式写入文件。

以下是一些如何使用它们的示例。

如果你想要 Unix 格式的文件（每行以 NL 终止）：>
	setl ff=unix fixeol
你可能在任何类 Unix 系统上这样做。现代的 MS-Windows 系统也往往能很好地处理这一点。建议对 Vim 脚本始终使用此格式。

如果你想在现代环境中使用旧的 MS-DOS 文件，修复行尾并丢弃 CTRL-Z，但保留 <CR><NL> 样式的 <EOL>：>
	setl ff=dos fixeol
这对许多 MS-Windows 程序很有用，它们通常期望 <CR><NL> 行尾。

如果你想去掉最后的 <EOL> 并添加最后的 CTRL-Z（例如，对于像 CP/M 这样的旧系统）：>
	setl ff=dos nofixeol noeol eof

如果你想完全按原样保留文件格式，包括任何最终的 <EOL> 和最终的 CTRL-Z：>
	setl nofixeol

==============================================================================
3. 参数列表				*argument-list* *arglist*

如果在启动 Vim 时给出多个文件名，此列表将被记住作为参数列表。你可以跳转到此列表中的每个文件。

不要将其与缓冲区列表混淆，你可以使用 |:buffers| 命令查看缓冲区列表。参数列表在 Vi 中已经存在，缓冲区列表是 Vim 中的新功能。参数列表中的每个文件名也将出现在缓冲区列表中（除非它被 |:bdel| 或 |:bwipe| 删除）。但缓冲区列表中的名称通常不在参数列表中。

本主题在用户手册的 |07.2| 节中介绍。

有一个全局参数列表，默认情况下所有窗口都使用它。可以创建一个窗口本地的新参数列表，请参阅 |:arglocal|。

你可以使用以下命令以及表达式函数 |argc()| 和 |argv()| 来使用参数列表。这些都作用于当前窗口的参数列表。

							*:ar* *:arg* *:args*
:ar[gs]			打印参数列表，当前文件在方括号中。

:ar[gs] [++opt] [+cmd] {arglist}			*:args_f*
			将 {arglist} 定义为新参数列表并编辑第一个文件。当已进行更改且 Vim 不想 |abandon| 当前缓冲区时，此操作失败。
			另请参阅 |++opt| 和 |+cmd|。

:ar[gs]! [++opt] [+cmd] {arglist}			*:args_f!*
			将 {arglist} 定义为新参数列表并编辑第一个文件。丢弃对当前缓冲区的任何更改。
			另请参阅 |++opt| 和 |+cmd|。

:[count]arge[dit][!] [++opt] [+cmd] {name} ...		*:arge* *:argedit*
			将 {name} 添加到参数列表并编辑它。
			不检查重复项，可以将文件两次添加到参数列表 |:argded|。
			这类似于使用 |:argadd| 然后 |:edit|（有一个小例外，|:edit| 不更改参数列表，因此参数列表指针不变）。
			文件名中的空格必须用 "\" 转义。
			[count] 像 |:argadd| 一样使用。
			如果当前文件无法 |abandon|，{name} 仍将添加到参数列表，但不会被编辑。不检查重复项。
			另请参阅 |++opt| 和 |+cmd|。

:[count]arga[dd] {name} ...			*:arga* *:argadd* *E479*
:[count]arga[dd]						*E1156*
			将 {name} 添加到参数列表。当省略 {name} 时，将当前缓冲区名称添加到参数列表。
			如果省略 [count]，{name} 将添加到参数列表中的当前条目之后。
			否则，它们添加在第 [count] 个文件之后。
			如果参数列表是 "a b c"，并且 "b" 是当前参数，那么这些命令会导致：
				命令		新参数列表 ~
				:argadd x	a  [b]  x  c
				:0argadd x	x   a  [b] c
				:1argadd x	a   x  [b] c
				:$argadd x	a  [b]  c  x
			在最后一个之后：
				:+2argadd y	a  [b]  c  x  y
			不检查重复项，可以将文件两次添加到参数列表。你可以使用 |:argdedupe| 之后修复它：>
				:argadd *.txt | argdedupe
<			当前编辑的文件不变。
			注意：你也可以使用这种方法：>
				:args ## x
<			这将添加 "x" 项并对新列表排序。

:argded[upe]					*:argded* *:argdedupe*
			从参数列表中删除重复的文件名。
			如果你的当前文件是重复的，你的当前文件将更改为原始文件索引。

:argd[elete] {pattern} ...		*:argd* *:argdelete* *E480* *E610*
			从参数列表中删除与 {pattern} 匹配的文件。{pattern} 像文件模式一样使用，请参阅 |file-pattern|。"%" 可用于删除当前条目。
			此命令保留当前编辑的文件，即使它已从参数列表中删除。
			示例：>
				:argdel *.obj

:[range]argd[elete]	从参数列表中删除 [range] 文件。
			示例：>
				:10,$argdel
<			删除参数 10 及以后的参数，保留 1-9。>
				:$argd
<			仅删除最后一个。>
				:argd
				:.argd
<			删除当前参数。>
				:%argd
<			从参数列表中移除所有文件。
			当范围中的最后一个数字太大时，最多删除到最后一个参数。

							*:argu* *:argument*
:[count]argu[ment] [count] [++opt] [+cmd]
			编辑参数列表中的第 [count] 个文件。当省略 [count] 时，使用当前条目。当已进行更改且 Vim 不想 |abandon| 当前缓冲区时，此操作失败。
			另请参阅 |++opt| 和 |+cmd|。

:[count]argu[ment]! [count] [++opt] [+cmd]
			编辑参数列表中的第 [count] 个文件，丢弃对当前缓冲区的任何更改。当省略 [count] 时，使用当前条目。
			另请参阅 |++opt| 和 |+cmd|。

:[count]n[ext] [++opt] [+cmd]			*:n* *:ne* *:next* *E165* *E163*
			编辑下一个 [count] 个文件。当已进行更改且 Vim 不想 |abandon| 当前缓冲区时，此操作失败。另请参阅 |++opt| 和 |+cmd|。

								*]a*
]a			映射到 |:next|。|default-mappings|

:[count]n[ext]! [++opt] [+cmd]
			编辑下一个 [count] 个文件，丢弃对缓冲区的任何更改。另请参阅 |++opt| 和 |+cmd|。

:n[ext] [++opt] [+cmd] {arglist}			*:next_f*
			与 |:args_f| 相同。

:n[ext]! [++opt] [+cmd] {arglist}
			与 |:args_f!| 相同。

:[count]N[ext] [count] [++opt] [+cmd]			*:Next* *:N* *E164*
			编辑参数列表中的前一个 [count] 个文件。当已进行更改且 Vim 不想 |abandon| 当前缓冲区时，此操作失败。
			另请参阅 |++opt| 和 |+cmd|。

:[count]N[ext]! [count] [++opt] [+cmd]
			编辑参数列表中的前一个 [count] 个文件。丢弃对缓冲区的任何更改。另请参阅 |++opt| 和 |+cmd|。

:[count]prev[ious] [count] [++opt] [+cmd]		*:prev* *:previous*
			与 :Next 相同。另请参阅 |++opt| 和 |+cmd|。

							*[a*
[a			映射到 |:previous|。|default-mappings|

							*:rew* *:rewind*
:rew[ind] [++opt] [+cmd]
			开始编辑参数列表中的第一个文件。当已进行更改且 Vim 不想 |abandon| 当前缓冲区时，此操作失败。
			另请参阅 |++opt| 和 |+cmd|。

								*[A*
[A			映射到 |:rewind|。|default-mappings|

:rew[ind]! [++opt] [+cmd]
			开始编辑参数列表中的第一个文件。丢弃对缓冲区的任何更改。另请参阅 |++opt| 和 |+cmd|。

							*:fir* *:first*
:fir[st][!] [++opt] [+cmd]
			":rewind" 的另一个名称。

							*:la* *:last*
:la[st] [++opt] [+cmd]
			开始编辑参数列表中的最后一个文件。当已进行更改且 Vim 不想 |abandon| 当前缓冲区时，此操作失败。
			另请参阅 |++opt| 和 |+cmd|。

								*]A*
]A			映射到 |:last|。|default-mappings|

:la[st]! [++opt] [+cmd]
			开始编辑参数列表中的最后一个文件。丢弃对缓冲区的任何更改。另请参阅 |++opt| 和 |+cmd|。

							*:wn* *:wnext*
:[count]wn[ext] [++opt]
			写入当前文件并开始编辑下一个 [count] 个文件。另请参阅 |++opt| 和 |+cmd|。

:[count]wn[ext] [++opt] {file}
			将当前文件写入 {file} 并开始编辑下一个 [count] 个文件，除非 {file} 已存在且 'writeany' 选项关闭。另请参阅 |++opt| 和 |+cmd|。

:[count]wn[ext]! [++opt] {file}
			将当前文件写入 {file} 并开始编辑下一个 [count] 个文件。另请参阅 |++opt| 和 |+cmd|。

:[count]wN[ext][!] [++opt] [file]		*:wN* *:wNext*
:[count]wp[revious][!] [++opt] [file]		*:wp* *:wprevious*
			与 :wnext 相同，但转到前一个文件而不是下一个。

上面命令中的 [count] 默认为一。对于某些命令，可以使用两个计数。使用最后一个（最右边的一个）。

如果没有 [+cmd] 参数，光标将定位在文件的最后已知光标位置。如果设置了 'startofline'，光标将定位在行的第一个非空白处，否则使用最后已知的列。如果没有最后已知的光标位置，光标将在第一行（在 Ex 模式下为最后一行）。

							*{arglist}*
参数列表中的通配符被扩展，文件名被排序。因此你可以使用命令 `vim *.c` 来编辑所有 C 文件。在 Vim 内部，命令 `:n *.c` 执行相同的操作。

空白用于分隔文件名。在空格或制表符前加上反斜杠以将其包含在文件名中。例如，要编辑单个文件 "foo bar"：>
	:next foo\ bar

在 Unix 和其他一些系统上，你也可以使用反引号，例如：>
	:next `find . -name \\*.c -print`
星号前的反斜杠是必需的，以防止 shell 在执行 find 程序之前扩展 "*.c"。

							*arglist-position*
当存在参数列表时，你可以在窗口的标题中看到你正在编辑哪个文件（如果有并且 'title' 是打开的）以及使用 "CTRL-G" 命令得到的文件消息。你将看到类似的内容
	(4 of 11)
如果你没有真正编辑参数列表中当前位置的文件，它将是
	((4) of 11)
这意味着你在参数列表中的位置是 4，但没有编辑参数列表中的第四个文件。当你执行 ":e file" 时会发生这种情况。


本地参数列表

							*:arglocal*
:argl[ocal]		创建全局参数列表的本地副本。
			不开始编辑另一个文件。

:argl[ocal][!] [++opt] [+cmd] {arglist}
			定义一个新参数列表，该列表对当前窗口是局部的。否则工作方式类似于 |:args_f|。

							*:argglobal*
:argg[lobal]		对当前窗口使用全局参数列表。
			不开始编辑另一个文件。

:argg[lobal][!] [++opt] [+cmd] {arglist}
			对当前窗口使用全局参数列表。像 |:args_f| 一样定义一个新的全局参数列表。
			所有使用全局参数列表的窗口都将看到这个新列表。

可以有多个参数列表。它们可以在窗口之间共享。当它们被共享时，在一个窗口中更改参数列表也会在另一个窗口中更改它。

当窗口被分割时，新窗口继承当前窗口的参数列表。然后两个窗口共享此列表，直到其中一个使用 |:arglocal| 或 |:argglobal| 使用另一个参数列表。


使用参数列表

						*:argdo*
:[range]argdo[!] {cmd}	对参数列表中的每个文件执行 {cmd}，或者，如果指定了 [range]，则仅对该范围内的参数执行。它的工作方式如下：>
				:rewind
				:{cmd}
				:next
				:{cmd}
				等等。
<			当当前文件无法 |abandon| 且没有 [!] 时，命令失败。
			当在一个文件上检测到错误时，将不会访问参数列表中的后续文件。
			参数列表中的最后一个文件（或发生错误的文件）成为当前文件。
			{cmd} 可以包含 '|' 来连接多个命令。
			{cmd} 不能更改参数列表。
			注意：当此命令执行时，语法自动命令事件通过将其添加到 'eventignore' 而被禁用。这大大加快了编辑每个文件的速度。
			另请参阅 |:windo|、|:tabdo|、|:bufdo|、|:cdo|、|:ldo|、|:cfdo| 和 |:lfdo|。

示例：>
	:args *.c
	:argdo set ff=unix | update
这将 'fileformat' 选项设置为 "unix" 并在文件现在更改时写入文件。这对所有 `*.c` 文件完成。

示例：>
	:args *.[ch]
	:argdo %s/\<my_foo\>/My_Foo/ge | update
这将在所有 "*.c" 和 "*.h" 文件中将单词 "my_foo" 更改为 "My_Foo"。":substitute" 命令使用 "e" 标志来避免对未使用 "my_foo" 的文件出错。":update" 仅在进行了更改时写入文件。

==============================================================================
4. 写入					*writing* *save-file*

注意：当 'write' 选项关闭时，你无法写入任何文件。

							*:w* *:write*
					*E502* *E503* *E504* *E505*
					*E512* *E514* *E667* *E949*
:w[rite] [++opt]	将整个缓冲区写入当前文件。这是保存对文件更改的正常方式。当设置了 'readonly' 或存在其他原因导致文件无法写入时失败，例如父目录不存在（使用 |++p| 避免这种情况）。
			关于 ++opt 请参阅 |++opt|，但只有 ++p、++bin、++nobin、++ff 和 ++enc 有效。


:w[rite]! [++opt]	类似 ":write"，但当设置了 'readonly' 或存在其他原因导致写入被拒绝时强制写入。
			注意：这可能会更改文件的权限和所有权并破坏（符号）链接。将 'W' 标志添加到 'cpoptions' 以避免这种情况。

:[range]w[rite][!] [++opt]
			将指定行写入当前文件。这是不寻常的，因为文件将不包含缓冲区中的所有行。

							*:w_f* *:write_f*
:[range]w[rite] [++opt]	{file}
			将指定行写入 {file}，除非它已存在且 'writeany' 选项关闭。

							*:w!*
:[range]w[rite]! [++opt] {file}
			将指定行写入 {file}。覆盖现有文件。

						*:w_a* *:write_a* *E494*
:[range]w[rite][!] [++opt] >>
			将指定行追加到当前文件。

:[range]w[rite][!] [++opt] >> {file}
			将指定行追加到 {file}。'!' 强制写入，即使文件不存在。

							*:w_c* *:write_c*
:[range]w[rite] [++opt] !{cmd}
			使用 [range] 行作为标准输入执行 {cmd}（注意 '!' 前的空格）。{cmd} 像 ":!{cmd}" 一样执行，任何 '!' 被先前的命令 |:!| 替换。

":w" 命令的默认 [range] 是整个缓冲区 (1,$)。|'[| 和 |']| 标记将设置为写入命令使用的 [range]。如果你写入整个缓冲区，它不再被视为已更改。当你使用 ":w somefile" 将其写入不同的文件时，这取决于 'cpoptions' 中的 "+" 标志。当包含时，写入命令将重置 'modified' 标志，即使缓冲区本身可能仍与其文件不同。

如果使用 ":w" 给出文件名，它将成为备用文件。例如，当写入失败并且你想稍后使用 ":w #" 重试时，这很有用。可以通过从 'cpoptions' 选项中移除 'A' 标志来关闭此功能。

请注意，'fsync' 选项在这里很重要。如果设置了它，可能会使写入变慢（但更安全）。

							*:sav* *:saveas*
:sav[eas][!] [++opt] {file}
			以名称 {file} 保存当前缓冲区，并将当前缓冲区的文件名设置为 {file}。先前的名称用于备用文件名。
			[!] 需要覆盖现有文件。
			当 'filetype' 为空时，使用新名称进行文件类型检测，在文件写入之前。
			当写入成功时，'readonly' 被重置。

							*:up* *:update*
:[range]up[date][!] [++opt] [>>] [file]
			类似 ":write"，但仅在缓冲区已被修改时写入，或者当缓冲区表示磁盘上不存在的新文件时。


使用多个缓冲区写入				*buffer-write*

							*:wa* *:wall*
:wa[ll]	[++opt]		写入所有已更改的缓冲区。没有文件名的缓冲区会导致错误消息。只读缓冲区不会被写入。
			关于 ++opt 请参阅 |++opt|，但只有 ++p 有效，并且适用于每个写入的文件。

:wa[ll]! [++opt]	写入所有已更改的缓冲区，即使是只读的缓冲区。没有文件名的缓冲区不会被写入并导致错误消息。


如果你尝试覆盖已在其他地方更改的文件，Vim 会警告你（除非使用了 "!"）。请参阅 |timestamp|。

			    *backup* *E207* *E506* *E507* *E508* *E509* *E510*
如果你写入现有文件（但不追加）同时 'backup'、'writebackup' 或 'patchmode' 选项打开，则会创建原始文件的备份。文件被复制或重命名（参见 'backupcopy'）。在文件成功写入后，当 'writebackup' 选项打开且 'backup' 选项关闭时，备份文件被删除。当 'patchmode' 选项打开时，备份文件可能会被重命名。

							*backup-table*
'backup' 'writebackup'	动作	~
   关闭	     关闭	不创建备份
   关闭	     打开		备份当前文件，之后删除（默认）
   打开	     关闭	删除旧备份，备份当前文件
   打开	     打开		删除旧备份，备份当前文件

当 'backupskip' 模式与正在写入的文件名称匹配时，不会创建备份文件。那时会忽略 'backup' 和 'writebackup' 的值。

当 'backup' 选项打开时，将删除旧的备份文件（与新备份文件同名）。如果未设置 'backup'，但设置了 'writebackup'，则不会删除现有的备份文件。在文件写入时创建的备份文件将具有不同的名称。

在某些文件系统上，可能在崩溃时你既丢失备份又丢失新写入的文件（它可能在那里但包含虚假数据）。在那种情况下，尝试恢复，因为交换文件已同步到磁盘并且可能仍然存在。|:recover|

使用 'backupdir' 选项给出的目录来放置备份文件。（默认：与写入文件相同的目录）。

备份是新文件（原始文件的副本）还是重命名的原始文件取决于 'backupcopy' 选项。有关何时进行复制以及何时重命名文件的说明，请参阅那里。

如果创建备份文件失败，则不会进行写入。如果你仍然想写入，请在命令中添加 '!'。

							*file-watcher*
当你注意到依赖于缓冲区写入时运行的程序（如 inotify、entr 或 fswatch）或外部应用程序执行 Vim 来编辑文件（如 git）的问题，并且这些程序似乎没有注意到原始文件已更改时，你可能需要考虑将 'backupcopy' 选项值切换为 "yes"。这确保 Vim 写入监视程序期望的同一文件，而不会创建新文件（这阻止它们检测到文件已更改）。另请参阅 |crontab|

							*write-permissions*
写入新文件时，权限为读写。对于 unix，掩码是 0o666，另外应用 umask。当写入已读取的文件时，Vim 将保留权限，但清除 s 位。

							*write-readonly*
当 'cpoptions' 选项包含 'W' 时，Vim 将拒绝覆盖只读文件。当 'W' 不存在时，":w!" 将覆盖只读文件，如果系统允许（目录必须可写）。

							*write-fail*
如果写入新文件失败，你必须小心不要丢失你的更改和原始文件。如果没有备份文件并且写入新文件失败，你已经丢失了原始文件！在写出文件之前不要退出 VIM！如果进行了备份，它将被放回原始文件的位置（如果可能）。如果你退出 Vim，并丢失你所做的更改，原始文件大多仍然存在。如果放回原始文件失败，将出现错误消息告诉你丢失了原始文件。

						*DOS-format-write*
如果 'fileformat' 是 "dos"，则使用 <CR><NL> 作为 <EOL>。这是 Windows 的默认值。在其他系统上显示消息 "[dos]" 以提醒你使用了不寻常的 <EOL>。
						*Unix-format-write*
如果 'fileformat' 是 "unix"，则使用 <NL> 作为 <EOL>。在 Windows 上显示消息 "[unix]"。
						*Mac-format-write*
如果 'fileformat' 是 "mac"，则使用 <CR> 作为 <EOL>。显示消息 "[mac]"。

另请参阅 |file-formats| 以及 'fileformat' 和 'fileformats' 选项。

						*ACL*
ACL 代表访问控制列表。它是一种控制文件访问权限的高级方式。它在新的 MS-Windows 和 Unix 系统上使用，但仅当文件系统支持时。
   Vim 尝试在写入文件时保留 ACL 信息。备份文件将获得原始文件的 ACL 信息。
   ACL 信息也用于检查文件是否只读（在打开文件时）。

					*xattr* *E1506* *E1508* *E1509*
xattr 代表扩展属性。它是一种在文件系统中与文件一起保存元数据的高级方式。它取决于实际使用的文件系统，并且 Vim 仅在 Linux 系统上支持它。
   Vim 尝试在写入文件时保留扩展属性信息。备份文件将获得原始文件的扩展属性。

						*read-only-share*
当 MS-Windows 在网络上共享驱动器时，可以将其标记为只读。这意味着即使文件只读属性不存在，并且 NT 网络共享驱动器上的 ACL 设置允许写入文件，你仍然无法写入文件。Win32 平台上的 Vim 将检测只读网络驱动器并将文件标记为只读。你将无法用 |:write| 覆盖它。

						*write-device*
当文件名实际上是设备名称时，Vim 不会创建备份（那将是不可能的）。你需要使用 "!"，因为设备已经存在。
Unix 示例：>
	:w! /dev/lpt0
和 MS-Windows：>
	:w! lpt0
对于 Unix，当名称不引用普通文件或目录时，检测为设备。fifo 或命名管道对 Vim 来说也看起来像设备。
对于 MS-Windows，设备通过其名称检测：
	CON
	CLOCK$
	NUL
	PRN
	COMn	n=1,2,3... 等
	LPTn	n=1,2,3... 等
名称可以是大写或小写。

==============================================================================
5. 写入和退出					*write-quit*

							*:q* *:quit*
:q[uit]			退出当前窗口。如果这是最后一个 |edit-window|，则退出 Vim。当已进行更改且 Vim 拒绝 |abandon| 当前缓冲区时，以及当参数列表中的最后一个文件尚未编辑时，此操作失败。
			如果存在其他标签页并且退出当前标签页中的最后一个窗口，则当前标签页关闭 |tab-page|。
			触发 |QuitPre| 自动命令事件。
			有关退出另一个窗口，请参阅 |CTRL-W_q|。

:conf[irm] q[uit]	退出，但当已进行更改或参数列表中的最后一个文件尚未编辑时给出提示。请参阅 |:confirm| 和 'confirm'。

:q[uit]!		不写入退出，即使当前缓冲区有更改。缓冲区被卸载，即使它设置了 'hidden'。
			如果这是最后一个窗口并且存在已修改的隐藏缓冲区，则当前缓冲区被放弃，第一个已更改的隐藏缓冲区成为当前缓冲区。
			使用 ":qall!" 始终退出。

:cq[uit]		始终退出，不写入，并返回错误代码。请参阅 |:cq|。

							*:wq*
:wq [++opt]		写入当前文件并关闭窗口。如果这是最后一个 |edit-window|，Vim 退出。
			当文件为只读或缓冲区没有名称时，写入失败。当参数列表中的最后一个文件尚未编辑时，退出失败。

:wq! [++opt]		写入当前文件并关闭窗口。如果这是最后一个 |edit-window|，Vim 退出。当当前缓冲区没有名称时，写入失败。

:wq [++opt] {file}	写入 {file} 并关闭窗口。如果这是最后一个 |edit-window|，Vim 退出。当参数列表中的最后一个文件尚未编辑时，退出失败。

:wq! [++opt] {file}	写入 {file} 并关闭当前窗口。如果这是最后一个 |edit-window|，则退出 Vim。

:[range]wq[!] [++opt] [file]
			同上，但仅写入 [range] 中的行。

							*:x* *:xit*
:[range]x[it][!] [++opt] [file]
			类似 ":wq"，但仅在进行了更改时写入。
			当设置了 'hidden' 并且有更多窗口时，当前缓冲区变为隐藏，在写入文件之后。

							*:exi* *:exit*
:[range]exi[t][!] [++opt] [file]
			与 :xit 相同。

							*ZZ*
ZZ			写入当前文件（如果已修改）并关闭当前窗口（与 ":x" 相同）。
			如果当前文件有多个窗口，仅关闭当前窗口。

							*ZQ*
ZQ			不检查更改退出（与 ":q!" 相同）。

多个窗口和缓冲区				*window-exit*

							*:qa* *:qall*
:qa[ll]		退出 Vim，除非有一些缓冲区已被更改。（使用 ":bmod" 转到下一个已修改的缓冲区）。
			当设置了 'autowriteall' 时，所有已更改的缓冲区将被写入，如同 |:wqall|。

:conf[irm] qa[ll]
	退出 Vim。当一些缓冲区已被更改时，显示提示。请参阅 |:confirm|。

:qa[ll]!		退出 Vim。对缓冲区的任何更改都将丢失。
			另请参阅 |:cquit|，它执行相同的操作但以非零值退出。

							*:quita* *:quitall*
:quita[ll][!]	与 ":qall" 相同。

:wqa[ll] [++opt]				*:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		写入所有已更改的缓冲区并退出 Vim。如果有没有文件名的缓冲区，它们是只读的或由于其他原因无法写入，Vim 将不会退出。

:conf[irm] wqa[ll] [++opt]
:conf[irm] xa[ll]
	写入所有已更改的缓冲区并退出 Vim。当一些缓冲区是只读的或由于其他原因无法写入时，显示提示。请参阅 |:confirm|。

:wqa[ll]! [++opt]
:xa[ll]!	写入所有已更改的缓冲区，即使是只读的，并退出 Vim。如果有没有文件名的缓冲区或由于其他原因无法写入，Vim 将不会退出。

==============================================================================
6. 对话框						*edit-dialogs*

							*:confirm* *:conf*
:conf[irm] {command}	执行 {command}，并在操作必须确认时使用对话框。可用于 |:edit|、|:restart|、|:q|、|:qa| 和 |:w| 命令（后者覆盖只读设置），以及任何可能因未保存的更改而失败的命令，例如 |:only|、|:buffer|、|:bdelete| 等。

示例：>
  :confirm w foo
<	当 "foo" 已存在时将要求确认。>
  :confirm q
<	当有更改时将要求确认。>
  :confirm qa
<	如果存在任何已修改、未保存的缓冲区，将提示你保存或放弃每个缓冲区。还有"全部保存"或"全部放弃"的选择。

如果你希望始终使用 ":confirm"，请设置 'confirm' 选项。

					*:browse* *:bro* *E338* *E614* *E615* *E616*
:bro[wse] {command}	为 {command} 的参数打开文件选择对话框。目前这适用于 |:e|、|:w|、|:wall|、|:wq|、|:wqall|、|:x|、|:xall|、|:exit|、|:view|、|:sview|、|:r|、|:saveas|、|:sp|、|:mkexrc|、|:mkvimrc|、|:mksession|、|:mkview|、|:split|、|:vsplit|、|:tabe|、|:tabnew|、|:cfile|、|:cgetfile|、|:caddfile|、|:lfile|、|:lgetfile|、|:laddfile|、|:diffsplit|、|:diffpatch|、|:pedit|、|:redir|、|:source|、|:update|、|:visual|、|:vsplit|、和 |:qall| 如果设置了 'confirm'。
			注意：仅在 Win32 GUI 中；在控制台中，如果 FileExplorer 自动命令组存在，`:browse edit` 有效。
			当 ":browse" 不可能时，你会得到错误消息。如果 {command} 不支持浏览，则执行 {command} 而不使用对话框。
			":browse set" 工作方式类似 |:options|。
			另请参阅 |:oldfiles| 对于 ":browse oldfiles"。

语法最好通过一些示例来展示：>
	:browse e $vim/foo
<		在 $vim/foo 目录中打开浏览器，并编辑选择的文件。>
	:browse e
<		在 'browsedir' 指定的目录中打开浏览器，并编辑选择的文件。>
	:browse w
<		在当前缓冲区的目录中打开浏览器，以当前缓冲区文件名作为默认值，并将缓冲区保存在选择的文件名下。>
	:browse w C:/bar
<		在 C:/bar 目录中打开浏览器，以当前缓冲区文件名作为默认值，并将缓冲区保存在选择的文件名下。
另请参阅 'browsedir' 选项。
对于不支持浏览的 Vim 版本，命令未经修改执行。

							*browsefilter*
对于 MS-Windows，你可以修改浏览对话框中使用的过滤器。通过设置 g:browsefilter 或 b:browsefilter 变量，你可以全局或本地更改缓冲区的过滤器。变量设置为格式为 "{filter label}\t{pattern};{pattern}\n" 的字符串，其中 "{filter label}" 是出现在"文件类型"组合框中的文本，而 {pattern} 是过滤文件名的模式。可以给出几个模式，用 ';' 分隔。

例如，要在对话框中仅显示 Vim 文件，你可以使用以下命令：>

     let g:browsefilter = "Vim scripts\t*.vim\nVim Startup Files\t*vimrc\n"

你可以通过设置 b:browsefilter 变量来基于每个缓冲区覆盖过滤器设置。你很可能在文件类型插件中设置 b:browsefilter，以便浏览对话框包含与当前编辑的文件类型相关的条目。缺点：这使得开始编辑不同类型的文件变得困难。为了克服这一点，你可以在 Windows 上添加以下作为最终过滤器：>

	All Files\t(*.*)\t*\n
<
或者在其他平台上添加以下内容，以便用户仍然可以访问任何所需的文件：>

	All Files\t(*)\t*\n
<

为了避免在 Vim 实际上不支持 browsefilter 时设置它，你可以使用 has("browsefilter")：>

	if has("browsefilter")
	   let g:browsefilter = "whatever"
	endif

==============================================================================
7. 当前目录				*current-directory*

你可以使用 |:cd|、|:tcd| 和 |:lcd| 切换到另一个目录，这样你就不必在文件名前键入该目录名。它对于执行外部命令也有影响，例如 ":!ls" 或 ":te ls"。

有三种当前目录"作用域"：全局、标签页和窗口。窗口本地工作目录优先于标签页本地工作目录，而标签页本地工作目录又优先于全局工作目录。如果本地工作目录（标签页或窗口）不存在，则应用层次结构中的下一个更高作用域。

							*:cd* *E747* *E472*
:cd[!]			在非 Unix 系统上当 'cdhome' 关闭时：打印当前目录名称。
			否则：将当前目录更改为主目录。清除任何窗口本地目录。
			在所有系统上使用 |:pwd| 打印当前目录。

:cd[!] {path}		将当前目录更改为 {path}。
			如果 {path} 是相对的，则在 'cdpath' 列出的目录中搜索它。
			清除任何窗口本地目录。
			不更改已打开文件的含义，因为其完整路径名被记住。但来自 |arglist| 的文件可能会更改！
			在 MS-Windows 上，这也会更改活动驱动器。
			要更改为当前文件的目录：>
				:cd %:h
<
							*:cd-* *E186*
:cd[!] -		更改为先前的当前目录（在之前的 ":cd {path}" 命令之前）。

							*:chd* *:chdir*
:chd[ir][!] [path]	与 |:cd| 相同。

							*:tc* *:tcd*
:tc[d][!] {path}	类似 |:cd|，但仅设置当前标签页的目录。当前窗口也将使用此目录。
			其他标签页中的窗口和当前标签页中具有自己的窗口本地目录的窗口的当前目录不会更改。

							*:tcd-*
:tc[d][!] -		更改为先前的当前目录（在之前的 ":tcd {path}" 命令之前）。

							*:tch* *:tchdir*
:tch[dir][!]		与 |:tcd| 相同。

							*:lc* *:lcd*
:lc[d][!] {path}	类似 |:cd|，但仅设置当前窗口的当前目录。其他窗口或标签页的当前目录不会更改。

							*:lch* *:lchdir*
:lch[dir][!]		与 |:lcd| 相同。

							*:lcd-*
:lc[d][!] -		更改为先前的当前目录（在之前的 ":lcd {path}" 命令之前）。

							*:pw* *:pwd* *E187*
:pw[d]			打印当前目录名称。
			另请参阅 |getcwd()|。
							*:pwd-verbose*
			当 'verbose' 非零时，|:pwd| 还将显示当前目录的设置作用域。示例：>

				" 由 :cd 设置
				:verbose pwd
				[global] /path/to/current

				" 由 :lcd 设置
				:verbose pwd
				[window] /path/to/current

				" 由 :tcd 设置
				:verbose pwd
				[tabpage] /path/to/current

只要没有使用 |:lcd| 或 |:tcd| 命令，所有窗口共享相同的当前目录。使用命令跳转到另一个窗口不会更改当前目录的任何内容。

当对窗口使用了 |:lcd| 时，指定的目录成为该窗口的当前目录。未使用 |:lcd| 命令的窗口坚持使用全局或标签页本地目录。当跳转到另一个窗口时，当前目录更改为最后指定的本地当前目录。如果未指定，则使用全局或标签页本地目录。当创建新窗口时，它继承当前窗口的本地目录。

更改标签页时应用相同的行为。如果当前标签页没有本地工作目录，则使用全局工作目录。

当使用 |:cd| 命令时，当前窗口和标签页将丢失其本地当前目录，并从此使用全局当前目录。当使用 |:tcd| 命令时，仅当前窗口将丢失其本地工作目录。

使用 |:cd| 后，完整路径名将用于读取和写入文件。在某些网络文件系统上，这可能会导致问题。使用完整路径名的结果是，当前使用的文件名将保持引用同一文件。示例：如果你有一个文件 a:test 和一个目录 a:vim，命令 ":e test" ":cd vim" ":w" 将覆盖文件 a:test 而不是写入 a:vim/test。但是如果你执行 ":w test"，文件 a:vim/test 将被写入，因为你给出了一个新文件名并且没有引用 ":cd" 之前的文件名。

==============================================================================
8. 编辑二进制文件					*edit-binary*

虽然 Vim 是为编辑文本文件而制作的，但也可以编辑二进制文件。Vim 参数 |-b|（b 代表二进制）使 Vim 以二进制模式进行文件 I/O，并设置一些用于编辑二进制文件的选项（'binary' 打开，'textwidth' 为 0，'modeline' 关闭，'expandtab' 关闭）。设置 'binary' 选项具有相同的效果。不要忘记在读取文件之前执行此操作。

编辑二进制文件时要记住几件事：
- 编辑可执行文件时，字节数不得更改。
  仅使用 "R" 或 "r" 命令更改文本。不要使用 "x" 或退格键删除字符。
- 将 'textwidth' 选项设置为 0。否则行将意外拆分为二。
- 当没有很多 <EOL> 时，行将变得非常长。如果你想编辑不适合屏幕的行，请重置 'wrap' 选项。
  然后使用水平滚动。如果行变得太长（参见 |limits|），你将无法编辑该行。读取文件时，该行将被拆分。也可能在读取文件时出现"内存不足"错误。
- 确保在加载文件之前设置 'binary' 选项。
  否则 <CR><NL> 和 <NL> 都被视为结束一行，并且在写入文件时 <NL> 将被替换为 <CR><NL>。
- <Nul> 字符在屏幕上显示为 ^@。你可以使用 "CTRL-V CTRL-@" 或 "CTRL-V 000" 输入它们。
- 要在文件中插入 <NL> 字符，请拆分一行。当将缓冲区写入文件时，将为 <EOL> 写入 <NL>。
- Vim 通常在没有时在文件末尾附加一个 <EOL>。设置 'binary' 选项可防止这种情况。如果你想添加最终的 <EOL>，请设置 'endofline' 选项。你也可以读取此选项的值以查看最后一行是否有 <EOL>（你无法在文本中看到这一点）。

==============================================================================
9. 加密						*encryption*

					                *:X* *E817* *E818* *E819* *E820*
对编辑加密文件的支持已被移除。
	https://github.com/neovim/neovim/issues/694
	https://github.com/neovim/neovim/issues/701

==============================================================================
10. 时间戳					*timestamp* *timestamps*

Vim 在你开始编辑文件时记住文件的修改时间戳、模式和大小。这用于避免你拥有同一文件的两个不同版本（而你不知道这一点）。

在运行 shell 命令后（|:!cmd| |suspend| |:read!| |K|），检查窗口中所有缓冲区的时间戳、文件模式和文件大小。Vim 将对任何已更改的文件运行任何关联的 |FileChangedShell| 自动命令或显示警告。在 GUI 中，这发生在 Vim 重新获得输入焦点时。

							*E321* *E462*
如果你想在文件在 Vim 外部更改时自动重新加载它，请设置 'autoread' 选项。但这在你写入文件时不起作用，仅当文件在 Vim 内部未更改时。
							*ignore-timestamp*
如果你不希望被询问或自动重新加载文件，你可以使用：>
	set buftype=nofile

或者，从 shell 启动 gvim 时：>
	gvim file.log -c "set buftype=nofile"

请注意，如果定义了 FileChangedShell 自动命令，你将不会收到警告消息或提示。期望自动命令处理此问题。

没有针对目录的警告。但是如果你开始编辑一个新文件并且它后来被创建为目录，你会收到警告。

当 Vim 注意到文件的时间戳已更改，并且文件正在缓冲区中编辑但未更改时，Vim 检查文件内容是否相等。这是通过再次读取文件（到隐藏缓冲区中，该缓冲区立即被再次删除）并比较文本来完成的。如果文本相等，你将不会收到警告。

如果你不经常收到警告，你可以使用以下命令。

							*:checkt* *:checktime*
:checkt[ime]		检查是否有任何缓冲区在 Vim 外部被更改。
			这检查并警告你是否最终会得到文件的两个版本。
			如果从自动命令、":global" 命令调用此命令或未键入，则实际检查将推迟到副作用（重新加载文件）无害的时刻。
			检查每个加载的缓冲区的关联文件是否被更改。如果文件被更改，Vim 将采取行动。如果缓冲区中没有更改并且设置了 'autoread'，则重新加载缓冲区。否则，将提供重新加载文件的选择。如果文件被删除，你将收到错误消息。
			如果文件先前不存在，现在存在，你会收到警告。
			一旦文件被检查，时间戳被重置，你将不会再次被警告。
			语法高亮、标记、差异状态、'fileencoding'、'fileformat' 和 'binary' 选项不会更改。请参阅 |v:fcs_choice| 以也重新加载这些（例如，如果代码格式化工具更改了文件）。

:[N]checkt[ime] {filename}
:[N]checkt[ime] [N]
			检查特定缓冲区的时间戳。缓冲区可以通过名称、编号或模式指定。


							*E813* *E814*
如果你选择重新加载缓冲区，Vim 将重新加载它。如果存在包含此缓冲区的可见窗口，重新加载将在该窗口的上下文中进行。否则使用特殊窗口，以便大多数自动命令工作。你不能关闭此窗口。适用一些其他限制。最好确保当前缓冲区之外不会发生任何事情。例如，设置窗口本地选项可能最终出现在错误的窗口中。分割窗口，在那里做一些事情然后关闭它应该没问题（如果没有来自其他自动命令的副作用）。关闭不相关的窗口和缓冲区会给你带来麻烦。

在写入文件之前，检查时间戳（除非使用了 "!"）。如果它已更改，Vim 将询问你是否确实要覆盖文件：

	WARNING: The file has been changed since reading it!!!
	Do you really want to write to it (y/n)?

如果你按 'y'，Vim 将继续写入文件。如果你按 'n'，写入中止。如果你使用 ":wq" 或 "ZZ"，Vim 不会退出，你将获得另一个写入文件的机会。

该消息通常意味着有人在编辑会话开始后已写入文件。这可能是另一个人，在这种情况下，你可能需要检查你对文件的更改和另一个人的更改是否应该合并。以另一个名称写入文件并检查差异（"diff" 程序可用于此）。

也可能是你自己修改了文件，从另一个编辑会话或使用另一个命令（例如，过滤器命令）。然后你将知道要保留文件的哪个版本。

时间检查的准确性取决于文件系统。在 Unix 上，它通常是亚秒级的。对于旧文件系统和在 MS-Windows 上，它通常是一秒。使用 `has('nanotime')` 检查是否支持亚秒时间戳检查。

有一种情况你会收到消息而没有任何问题：在夏令时开始的当天在 Win32 系统上。Win32 库中的某些内容使 Vim 对一小时的时间差感到困惑。第二天问题就会消失。

==============================================================================
11. 文件搜索					*file-searching*

文件搜索当前用于 'path'、'cdpath' 和 'tags' 选项，用于 |finddir()| 和 |findfile()|。

其他命令使用 |wildcards|，这略有不同。

有三种不同类型的搜索：

1) 向下搜索：					*starstar*
   向下搜索使用通配符 "*"、"**" 以及你的操作系统可能支持的其他通配符。"*" 和 "**" 在 Vim 内部处理，因此它们在所有操作系统上都有效。请注意，"**" 仅当它位于名称开头时才作为特殊通配符。

   "*" 的用法非常简单：它匹配 0 个或多个字符。在搜索模式中，这将是 ".*"。请注意，文件搜索不使用 "."。

   "**" 更复杂：
      - 它仅匹配目录。
      - 它默认匹配最多 30 层目录，因此你可以使用它搜索整个目录树
      - 可以通过在 "**" 后附加数字来给出匹配的最大层数。
	因此 '/usr/**2' 可以匹配：>
		/usr
		/usr/include
		/usr/include/sys
		/usr/include/g++
		/usr/lib
		/usr/lib/X11
		....
<	它不匹配 '/usr/include/g++/std'，因为这将是三层。
	允许的数字范围是 0（"**0" 被移除）到 100
	如果给定的数字小于 0，则默认为 30，如果大于 100，则使用 100。系统对路径长度也有限制，通常为 256 或 1024 字节。
      - "**" 只能在路径的末尾，或者后跟路径分隔符或数字和路径分隔符。

   你可以以任何顺序组合 "*" 和 "**"：>
	/usr/**/sys/*
	/usr/*tory/sys/**
	/usr/**2/sys/*

2) 向上搜索：
   在这里，你可以给出一个目录，然后在目录树中向上搜索文件。你可以给出停止目录来限制向上搜索。停止目录附加到路径（对于 'path' 选项）或文件名（对于 'tags' 选项），并带有 ';'。如果你想要几个停止目录，用 ';' 分隔它们。如果你不想要停止目录（"向上搜索直到根目录"），只需使用 ';'。>
	/usr/include/sys;/usr
<   将搜索：>
	   /usr/include/sys
	   /usr/include
	   /usr
<
   如果你使用相对路径，向上搜索从 Vim 的当前目录或当前文件的目录开始（如果相对路径以 './' 开头且 'd' 不包含在 'cpoptions' 中）。

   如果 Vim 的当前路径是 /u/user_x/work/release 并且你执行 >
	:set path=include;/u/user_x
<   然后使用 |gf| 搜索文件，文件将在以下位置搜索：>
	/u/user_x/work/release/include
	/u/user_x/work/include
	/u/user_x/include

<   注意：如果你的 'path' 设置包含不存在的目录，Vim 将跳过不存在的目录，并且如果使用向上搜索，也不会在不存在的目录的父目录中搜索。

3) 组合向上/向下搜索：
   如果 Vim 的当前路径是 /u/user_x/work/release 并且你执行 >
	set path=**;/u/user_x
<   然后使用 |gf| 搜索文件，文件将在以下位置搜索：>
	/u/user_x/work/release/**
	/u/user_x/work/**
	/u/user_x/**
<
   小心！这可能会消耗大量时间，因为 '/u/user_x/**' 的搜索包括 '/u/user_x/work/**' 和 '/u/user_x/work/release/**'。因此 '/u/user_x/work/release/**' 被搜索三次，'/u/user_x/work/**' 被搜索两次。

   在上面的示例中，你可能希望将 path 设置为：>
	:set path=**,/u/user_x/**
<   这搜索：>
	/u/user_x/work/release/**
	/u/user_x/**
<   这搜索相同的目录，但顺序不同。

   请注意，":find"、":sfind" 和 ":tabfind" 命令的补全当前不适用于包含 URL 或使用带深度限制器的双星 (/usr/**2) 或向上搜索 (;) 表示法的 'path' 项。

==============================================================================
12. 受信任的文件						*trust*

如果启用了 'exrc'，Nvim 会执行在文件系统上找到的任意代码。为防止执行恶意代码，仅执行"受信任的文件"。你可以使用 |:trust| 命令或 |vim.secure.read()| 函数将文件标记为受信任或不受信任。

							*:trust* *E5570*
:trust [++deny] [++remove] [file]

			管理受信任的文件。没有 ++ 选项时，:trust 将当前缓冲区标记为受信任，基于其内容的哈希值。信任列表存储在磁盘上，Nvim 在重启后会重用它。

			[++deny] 将 [file]（或如果没有 [file] 则为当前缓冲区）标记为不受信任：它将永远不会被执行，'exrc' 将忽略它。

			[++remove] 从信任列表中移除 [file]（或如果没有 [file] 则为当前缓冲区）。当 'exrc' 或 |vim.secure.read()| 发现该文件时，将询问用户是否信任或拒绝该文件。

 vim:tw=78:ts=8:noet:ft=help:norl:
