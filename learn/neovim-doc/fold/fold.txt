*fold.txt*      Nvim


		  VIM 参考手册	  by Bram Moolenaar


折叠						*Folding* *folding* *folds*

你可以在用户手册第28章找到关于折叠的介绍。
|usr_28.txt|

                                      输入 |gO| 查看目录。

==============================================================================
1. 折叠方法					*fold-methods*

折叠方法可以通过 'foldmethod' 选项设置。

当将 'foldmethod' 设置为 "manual" 以外的值时，所有折叠都会被删除并创建新的折叠。切换到 "manual" 方法不会移除现有的折叠。这可以用于先自动定义折叠，然后手动更改它们。

有六种方法选择折叠：
	manual		手动定义折叠
	indent		缩进越多表示折叠级别越高
	expr		指定一个表达式来定义折叠
	syntax		通过语法高亮定义折叠
	diff		用于未更改文本的折叠
	marker		通过文本中的标记定义折叠


手动						*fold-manual*

使用命令手动定义折叠区域。这也可以被解析文本以查找折叠的脚本使用。

折叠的级别仅由其嵌套定义。要增加一系列行的折叠级别，请在其中定义一个具有相同行的折叠。

当你放弃文件时，手动折叠会丢失。要保存折叠，请使用 |:mkview| 命令。之后可以使用 |:loadview| 恢复视图。


缩进						*fold-indent*

折叠由行的缩进自动定义。

折叠级别根据行的缩进计算，除以 'shiftwidth'（向下取整）。具有相同或更高折叠级别的一系列行形成一个折叠，具有更高级别的行形成嵌套折叠。

折叠的嵌套受 'foldnestmax' 限制。

某些行会被忽略，并获得其上方或下方行的折叠级别（取较低者）。这些是空行或空白行以及以 'foldignore' 中字符开头的行。在检查 'foldignore' 中的字符之前会跳过空白。对于 C，使用 "#" 来忽略预处理行。

当你想以另一种方式忽略行时，请使用 "expr" 方法。|indent()| 函数可以在 'foldexpr' 中使用以获取行的缩进。


表达式						*fold-expr*

折叠由其折叠级别自动定义，类似于 "indent" 方法。'foldexpr' 选项的值被评估以获取行的折叠级别。示例：
这将为所有以制表符开头的连续行创建一个折叠： >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
这将使由空行分隔的段落形成折叠： >
	:set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
这做同样的事情： >
	:set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1

注意必须使用反斜杠来转义 "：set" 不同处理的字符（空格、反斜杠、双引号等，参见 |option-backslash|）。

最有效的是调用不带参数的函数： >
	:set foldexpr=MyFoldLevel()
该函数必须使用 v:lnum。参见 |expr-option-function|。

表达式在以下条件下被评估：

- 当前缓冲区和窗口已为该行设置。
- 变量 "v:lnum" 被设置为行号。

foldexpr 的结果然后按如下方式确定折叠级别：
  值			含义 ~
  0			该行不在折叠中
  1, 2, ..		该行在具有此级别的折叠中
  -1			折叠级别未定义，使用此行之前或之后行的折叠级别，取较低者。
  "="			使用前一行的折叠级别
  "a1", "a2", ..	将前一行的折叠级别加一、二..，对当前行使用结果
  "s1", "s2", ..	将前一行的折叠级别减一、二..，对下一行使用结果
  "<1", "<2", ..	具有此级别的折叠在此行结束
  ">1", ">2", ..	具有此级别的折叠在此行开始

结果值 "="、"s" 和 "a" 开销更大，请参见 |fold-expr-slow|。

不需要用 ">1"（"<1"）标记折叠的开始（结束），当折叠级别高于（低于）前一行的折叠级别时，折叠也会开始（结束）。

表达式不得有副作用。缓冲区中的文本、光标位置、搜索模式、选项等不得更改。如果你小心，可以更改并恢复它们。

如果表达式中有错误，或者结果值无法识别，则不会有错误消息，折叠级别将为零。对于调试，可以将 'debug' 选项设置为 "msg"，错误消息将可见。

如果 'foldexpr' 表达式以 s: 或 |<SID>| 开头，则它将被替换为脚本 ID（|local-function|）。示例： >
		set foldexpr=s:MyFoldExpr()
		set foldexpr=<SID>SomeFoldExpr()
<
使用 "a1" 和 "s1" 的示例：对于多行 C 注释，包含 "/*" 的行将返回 "a1" 以开始折叠，包含 "*/" 的行将返回 "s1" 以在该行之后结束折叠： >
  if match(thisline, '/\*') >= 0
    return 'a1'
  elseif match(thisline, '\*/') >= 0
    return 's1'
  else
    return '='
  endif
然而，这不适用于单行注释、字符串等。

|foldlevel()| 可用于计算相对于先前折叠级别的折叠级别。但请注意，如果级别尚不知道，foldlevel() 可能返回 -1。并且它返回行开始时的级别，而折叠可能在该行结束。

可能发生折叠未正确更新的情况。你可以使用 |zx| 或 |zX| 强制更新折叠。

最小化计算成本				*fold-expr-slow*

由于其计算成本，这种折叠方法可能使 Vim 无响应，特别是在必须初始计算所有行的折叠级别时。之后，每次更改后，Vim 将折叠级别的计算限制在受其影响的那些行（并重用所有其他行的已知折叠级别）。

因此，折叠表达式应努力最小化计算给定行所需的依赖行数：例如，尽量避免使用 "="、"a" 和 "s" 返回值，因为这些将需要评估前一行的折叠级别，直到找到独立的折叠级别。

如果这很困难，次优的方法可能是将所有折叠级别缓存在缓冲区局部变量（b:foldlevels）中，该变量仅在 |b:changedtick| 时更新：
>vim
  func MyFoldFunc()
    if b:lasttick == b:changedtick
      return b:foldlevels[v:lnum - 1]
    endif
    let b:lasttick = b:changedtick
    let b:foldlevels = []
    " 计算折叠级别 ...
    return b:foldlevels[v:lnum - 1]
  enddef
  set foldexpr=s:MyFoldFunc()
<
在上面的示例中，通过使用不带参数的函数（该函数仍必须使用 v:lnum）获得了进一步的加速。参见 |expr-option-function|。

语法						*fold-syntax*

折叠由具有 "fold" 参数的语法项定义。|:syn-fold|

折叠级别由嵌套折叠定义。折叠的嵌套受 'foldnestmax' 限制。

注意指定适当的语法同步。如果未正确完成，折叠可能与显示的高亮不同。这在使用的模式匹配多行时尤其相关。如有疑问，尝试使用暴力同步： >
	:syn sync fromstart


差异						*fold-diff*

折叠自动定义为不属于更改或接近更改的文本。

此方法仅当当前窗口设置了 'diff' 选项并且正在显示更改时才正常工作。否则整个缓冲区将是一个大折叠。

'diffopt' 选项可用于指定上下文。即，折叠和更改之间未包含在折叠中的行数。例如，要使用 8 行的上下文： >
	:set diffopt=filler,context:8
默认上下文是六行。

当还设置了 'scrollbind' 时，Vim 将尝试在其他差异窗口中保持相同的折叠打开，以便显示相同的文本。


标记						*fold-marker*

文本中的标记告诉折叠的开始和结束位置。这允许你精确指定折叠。这将允许删除和放置折叠，而不会有包含错误行的风险。'foldtext' 选项通常设置使得标记前的文本显示在折叠行中。这使得可以为折叠命名。

标记可以包含级别，也可以使用匹配对。包含级别更容易，你不必添加结束标记并避免不匹配标记对的问题。示例： >
	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
<							*{{{* *}}}*
折叠在 "{{{" 标记处开始。后面的数字指定折叠级别。发生的情况取决于当前折叠级别与标记给出的级别之间的差异：
1. 如果遇到具有相同折叠级别的标记，则前一个折叠结束，另一个具有相同级别的折叠开始。
2. 如果找到具有更高折叠级别的标记，则开始嵌套折叠。
3. 如果找到具有更低折叠级别的标记，则结束直到并包括此级别的所有折叠，并开始具有指定级别的折叠。

数字表示折叠级别。不能使用零（级别为零的标记被忽略）。你可以使用带数字的 "}}}" 表示结束折叠的级别。下一行的折叠级别将比指示的级别少一。注意 Vim 不会回溯到匹配标记的级别（那将花费太多时间）。示例： >

	{{{1
	此处折叠级别为 1
	{{{3
	此处折叠级别为 3
	}}}3
	此处折叠级别为 2

你也可以使用匹配的 "{{{" 和 "}}}" 标记对来定义折叠。每个 "{{{" 将折叠级别增加一，每个 "}}}" 将折叠级别减少一。注意保持标记匹配！示例： >

	{{{
	此处折叠级别为 1
	{{{
	此处折叠级别为 2
	}}}
	此处折叠级别为 1

你可以混合使用带数字和不带数字的标记。一种有用的方法是使用编号标记用于大折叠，并在函数内部局部使用未编号标记。例如，对文件的各个部分使用一级折叠，如"结构定义"、"局部变量"和"函数"。对每个定义和函数使用二级标记。在函数内部使用未编号标记。当你在函数中进行更改以拆分折叠时，不必重新编号标记。

标记可以通过 'foldmarker' 选项设置。建议保持默认值 "{{{,}}}"，以便文件可以在 Vim 用户之间交换。仅当文件需要时才更改它（例如，它包含来自另一个折叠编辑器的标记，或者默认标记导致文件语言问题）。

							*fold-create-marker*
"zf" 可用于创建由标记定义的折叠。Vim 将为你插入标记。Vim 将附加开始和结束标记，如 'foldmarker' 所指定。标记附加到行的末尾。如果 'commentstring' 不为空，则使用它。
这在以下情况下无法正常工作：
- 该行已包含带级别数字的标记。Vim 然后不知道该怎么办。
- 附近的折叠在其标记中使用级别数字，这会造成干扰。
- 该行在注释内，'commentstring' 不为空，并且嵌套注释不起作用。例如在 C 中：在注释内添加 `/* {{{ */` 将截断现有注释。要么将标记放在注释之前或之后，要么手动添加标记。
通常，当你已经有带级别数字的标记时，让 Vim 创建标记不是一个好主意。

							*fold-delete-marker*
"zd" 可用于删除由标记定义的折叠。Vim 将为你删除标记。Vim 将在折叠的开始和结束处搜索开始和结束标记，如 'foldmarker' 所指定。当标记周围的文本与 'commentstring' 匹配时，该文本也会被删除。
这在以下情况下无法正常工作：
- 一行包含多个标记，其中一个指定了级别。仅删除第一个，而不检查这是否会产生删除折叠的预期效果。
- 标记包含级别数字并用于同时开始或结束多个折叠。

==============================================================================
2. 折叠命令				*fold-commands* *E490*

所有折叠命令都以 "z" 开头。提示：如果你从侧面看，"z" 看起来像一张折叠的纸。


创建和删除折叠 ~
							*zf* *E350*
zf{motion}  或
{Visual}zf	创建折叠的操作符。
		这仅在 'foldmethod' 为 "manual" 或 "marker" 时有效。
		对于 "manual" 方法，新折叠将关闭。
		将设置 'foldenable'。
		另见 |fold-create-marker|。

							*zF*
zF		为 [count] 行创建折叠。工作方式类似 "zf"。

:{range}fo[ld]						*:fold* *:fo*
		为 {range} 中的行创建折叠。工作方式类似 "zf"。

							*zd* *E351*
zd		删除光标处的一个折叠。当光标在折叠行上时，该折叠被删除。嵌套折叠向上移动一级。
		在可视模式中，所选区域中所有折叠（部分）的一级被删除。
		小心：这很容易删除比你预期更多的折叠，并且手动折叠没有撤销。
		这仅在 'foldmethod' 为 "manual" 或 "marker" 时有效。
		另见 |fold-delete-marker|。

							*zD*
zD		递归删除光标处的折叠。在可视模式中，所选区域中所有折叠（部分）及其中的所有嵌套折叠被删除。
		这仅在 'foldmethod' 为 "manual" 或 "marker" 时有效。
		另见 |fold-delete-marker|。

							*zE* *E352*
zE		消除窗口中的所有折叠。
		这仅在 'foldmethod' 为 "manual" 或 "marker" 时有效。
		另见 |fold-delete-marker|。


打开和关闭折叠 ~

小于 'foldminlines' 的折叠将始终像打开一样显示。因此下面的命令可能在小的折叠上工作方式不同。

							*zo*
zo		打开光标下的一个折叠。当给出计数时，将打开那么多层深度的折叠。
		在可视模式中，为所选区域中的所有行打开一级折叠。

							*zO*
zO		递归打开光标下的所有折叠。不包含光标行的折叠保持不变。
		在可视模式中，它打开所选区域中的所有折叠，包括那些仅部分选中的折叠。

							*zc*
zc		关闭光标下的一个折叠。当给出计数时，将关闭那么多层深度的折叠。
		在可视模式中，为所选区域中的所有行关闭一级折叠。
		将设置 'foldenable'。

							*zC*
zC		递归关闭光标下的所有折叠。不包含光标行的折叠保持不变。
		在可视模式中，它关闭所选区域中的所有折叠，包括那些仅部分选中的折叠。
		将设置 'foldenable'。

							*za*
za		摘要：切换光标下的折叠。
		在关闭的折叠上时：打开它。当折叠嵌套时，你可能需要使用 "za" 多次。当给出计数时，打开那么多关闭的折叠。
		在打开的折叠上时：关闭它并设置 'foldenable'。这只会关闭一级，因为再次使用 "za" 将打开折叠。当给出计数时，将关闭那么多折叠（这与重复 "za" 那么多次不同）。

							*zA*
zA		在关闭的折叠上时：递归打开它。
		在打开的折叠上时：递归关闭它并设置 'foldenable'。

							*zv*
zv		查看光标行：打开足够的折叠以使光标所在的行不被折叠。

							*zx*
zx		更新折叠：撤销手动打开和关闭的折叠：重新应用 'foldlevel'，然后执行 "zv"：查看光标行。
		还强制重新计算折叠。这在 'foldexpr' 且缓冲区以导致折叠未正确更新的方式更改时很有用。

							*zX*
zX		撤销手动打开和关闭的折叠：重新应用 'foldlevel'。
		还强制重新计算折叠，类似 |zx|。

							*zm*
zm		更多折叠：从 'foldlevel' 减去 |v:count1|。如果 'foldlevel' 已经为零，则不发生任何事。
		将设置 'foldenable'。

							*zM*
zM		关闭所有折叠：将 'foldlevel' 设置为 0。
		将设置 'foldenable'。

							*zr*
zr		减少折叠：将 |v:count1| 加到 'foldlevel'。

							*zR*
zR		打开所有折叠。这将 'foldlevel' 设置为最高折叠级别。

							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		打开 {range} 中的折叠。当添加 [!] 时，所有折叠都被打开。用于查看 {range} 中的所有文本。没有 [!] 时，打开一级折叠。

							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		关闭 {range} 中的折叠。当添加 [!] 时，所有折叠都被关闭。用于隐藏 {range} 中的所有文本。没有 [!] 时，关闭一级折叠。

							*zn*
zn		无折叠：重置 'foldenable'。所有折叠都将打开。

							*zN*
zN		正常折叠：设置 'foldenable'。所有折叠将恢复原样。

							*zi*
zi		反转 'foldenable'。


在折叠上移动 ~
							*[z*
[z		移动到当前打开折叠的开始。如果已经在开始处，则移动到包含它的折叠的开始处。如果没有包含折叠，则命令失败。
		当使用计数时，重复命令 [count] 次。

							*]z*
]z		移动到当前打开折叠的结束。如果已经在结束处，则移动到包含它的折叠的结束处。如果没有包含折叠，则命令失败。
		当使用计数时，重复命令 [count] 次。

							*zj*
zj		向下移动到下一个折叠的开始。关闭的折叠计为一个折叠。
		当使用计数时，重复命令 [count] 次。
		此命令可以在 |operator| 之后使用。

							*zk*
zk		向上移动到上一个折叠的结束。关闭的折叠计为一个折叠。
		当使用计数时，重复命令 [count] 次。
		此命令可以在 |operator| 之后使用。


在折叠上执行命令 ~

:[range]foldd[oopen] {cmd}		*:foldd* *:folddo* *:folddoopen*
		对所有不在关闭折叠中的行执行 {cmd}。
		当给出 [range] 时，仅使用这些行。
		每次执行 {cmd} 时，光标定位在执行它的行上。
		这工作方式类似 "：global" 命令：首先标记所有不在关闭折叠中的行。然后为所有标记行执行 {cmd}。因此当 {cmd} 更改折叠时，这对它在何处执行没有影响（当然，除非行被删除）。
		示例： >
			:folddoopen s/end/loop_end/ge
<		注意使用 "e" 标志以避免在 "end" 不匹配时出现错误消息。

:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		对所有在关闭折叠中的行执行 {cmd}。
		其他方面类似 "：folddoopen"。

==============================================================================
3. 折叠选项					*fold-options*

颜色							*fold-colors*

关闭折叠的颜色通过 Folded 组 |hl-Folded| 设置。折叠列的颜色通过 FoldColumn 组 |hl-FoldColumn| 设置。
设置颜色的示例： >

	:highlight Folded guibg=grey guifg=blue
	:highlight FoldColumn guibg=darkgrey guifg=white


折叠级别						*fold-foldlevel*

'foldlevel' 是一个数字选项：越高，打开的折叠区域越多。
当 'foldlevel' 为 0 时，所有折叠都关闭。
当 'foldlevel' 为正时，一些折叠关闭。
当 'foldlevel' 非常高时，所有折叠都打开。
'foldlevel' 在更改时应用。之后可以手动打开和关闭折叠。
当增加时，高于新级别的折叠被打开。不会关闭手动打开的折叠。
当减少时，高于新级别的折叠被关闭。不会打开手动关闭的折叠。


折叠文本						*fold-foldtext*

'foldtext' 是指定表达式的字符串选项。此表达式被评估以获取为关闭折叠显示的文本。示例： >

    :set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|{{{\\d\\=','','g')

这显示折叠的第一行，并删除了 "/*"、"*/" 和 "{{{"。
注意使用反斜杠以避免某些字符被 "：set" 命令解释。定义函数并调用它要简单得多： >

    :set foldtext=MyFoldText()
    :function MyFoldText()
    :  let line = getline(v:foldstart)
    :  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
    :  return v:folddashes .. sub
    :endfunction

评估 'foldtext' 在 |sandbox| 中完成。当前窗口设置为显示该行的窗口。

错误被忽略。对于调试，将 'debug' 选项设置为 "throw"。

默认值是 |foldtext()|。这对大多数类型的折叠返回合理的文本。如果你不喜欢它，可以指定自己的 'foldtext' 表达式。它可以使用这些特殊的 Vim 变量：
	v:foldstart	折叠中第一行的行号
	v:foldend	折叠中最后一行的行号
	v:folddashes	包含破折号的字符串，表示折叠级别。
	v:foldlevel	折叠的折叠级别

如果结果是 |List|，则它被解析并绘制为"覆盖"虚拟文本（参见 |nvim_buf_set_extmark()|），否则结果被转换为字符串，其中 TAB 被替换为空格，不可打印字符被转换为可打印字符。

结果行被截断以适合窗口，它从不换行。
当文本后有空间时，它用 'fillchars' 指定的字符填充。

如果 'foldtext' 表达式以 s: 或 |<SID>| 开头，则它被替换为脚本 ID（|local-function|）。示例： >
		set foldtext=s:MyFoldText()
		set foldtext=<SID>SomeFoldText()
<
注意对于 "：set" 命令不同处理的字符需要使用反斜杠：空格、反斜杠和双引号。|option-backslash|


折叠列						*fold-foldcolumn*

'foldcolumn' 是一个数字，它设置窗口侧面列的宽度以指示折叠。当它为零时，没有折叠列。正常值是 auto:9。最大值是 9。

打开的折叠用顶部有 '-' 且下面有 '|' 字符的列指示。此列在打开的折叠结束处停止。当折叠嵌套时，嵌套折叠位于包含它的折叠右侧一个字符处。

关闭的折叠用 '+' 指示。

这些字符可以通过 'fillchars' 选项更改。

当折叠列太窄无法显示所有嵌套折叠时，会显示数字以指示嵌套级别。要覆盖此行为，可以使用 'fillchars' 选项的 "foldinner" 字符。

鼠标也可以用于通过点击折叠列来打开和关闭折叠：
- 点击 '+' 打开此行的关闭折叠。
- 点击任何其他非空白字符关闭此行的打开折叠。


其他选项

'foldenable'  'fen':	未设置时打开所有折叠。
'foldexpr'    'fde':	用于 "expr" 折叠的表达式。
'foldignore'  'fdi':	用于 "indent" 折叠的字符。
'foldmarker'  'fmr':	用于 "marker" 折叠的定义标记。
'foldmethod'  'fdm':	当前折叠方法的名称。
'foldminlines' 'fml':	折叠显示为关闭所需的最小屏幕行数。
'foldnestmax' 'fdn':	"indent" 和 "syntax" 折叠的最大嵌套。
'foldopen'    'fdo':	哪些类型的命令打开关闭的折叠。
'foldclose'   'fcl':	何时关闭不在光标下的折叠。

==============================================================================
4. 折叠行为					*fold-behavior*

当向上或向下移动光标以及滚动时，光标将移动到一系列折叠行的第一行。当光标已经在折叠行上时，它移动到下一个未折叠行或下一个关闭折叠。

当光标在折叠行上时，光标始终显示在第一列。标尺确实显示实际光标位置，但由于该行已折叠，无法在那里显示。

许多移动命令将一系列折叠行视为空行。例如，"w" 命令在第一列停止一次。

当在关闭折叠中开始搜索时，它不会在当前折叠中找到匹配项。就像向前搜索总是从关闭折叠的结束处开始，而向后搜索从关闭折叠的开始处开始。

在插入模式中，光标行从不折叠。这允许你看到你输入的内容！

当使用操作符时，关闭折叠作为一个整体包含。因此 "dl" 删除光标下的整个关闭折叠。

对于操作缓冲区行的 Ex 命令，范围被调整以始终从关闭折叠的第一行开始并在关闭折叠的最后一行结束。因此，此命令： >
	:s/foo/bar/g
当在关闭折叠上使用光标时，将替换折叠中所有行的 "foo" 为 "bar"。
这对 |:folddoopen| 和 |:folddoclosed| 不会发生。

注意对于某些 Ex 命令如 |:source|，仅在使用两行说明符 [range] 时调整范围。

当编辑先前编辑过的缓冲区时，将再次使用最后使用的折叠设置。对于手动折叠，定义的折叠将被恢复。对于所有折叠方法，手动打开和关闭的折叠将被恢复。如果此缓冲区曾在此窗口中编辑过，则使用那时的值。否则使用缓冲区最后编辑的窗口中的值。

 vim:tw=78:ts=8:noet:ft=help:norl:
