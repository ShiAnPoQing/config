*motion.txt*    Nvim

		  VIM 参考手册    作者：Bram Moolenaar

光标移动					*cursor-motions* *navigation*

这些命令用于移动光标位置。如果新位置不在屏幕上，屏幕会滚动以显示光标（另见 'scrolljump' 和 'scrolloff' 选项）。

一般说明：

如果你想知道自己在文件中的位置，可以使用 "CTRL-G" 命令
|CTRL-G| 或 "g CTRL-G" 命令 |g_CTRL-G|。如果你设置了 'ruler' 选项，
光标位置会持续显示在状态栏上（这会让 Vim 稍微变慢）。

有经验的用户更喜欢 hjkl 键，因为它们总是在手指下方。初学者通常更喜欢方向键，因为他们不知道 hjkl 键的作用。hjkl 的助记意义可以从键盘上看出来。可以把 j 看作是向下的箭头。

可以设置 'virtualedit' 选项，使光标可以移动到没有字符的位置，或多列字符（如 Tab）内部。

                                      输入 |gO| 查看目录。

==============================================================================
1. 动作与操作符				*operator*

动作命令可以在操作符命令后使用，使该命令作用于移动经过的文本。也就是光标移动前后之间的文本。操作符通常用于删除或更改文本。可用的操作符如下：

	|c|	c	更改
	|d|	d	删除
	|y|	y	复制到寄存器（不更改文本）
	|~|	~	切换大小写（仅当设置了 'tildeop' 时）
	|g~|	g~	切换大小写
	|gu|	gu	转为小写
	|gU|	gU	转为大写
	|!|	!	通过外部程序过滤
	|=|	=	通过 'equalprg' 过滤，若为空则为 C 语言缩进
	|gq|	gq	文本格式化
	|gw|	gw	文本格式化但不移动光标
	|g?|	g?	ROT13 编码
	|>|	>	右移
	|<|	<	左移
	|zf|	zf	定义折叠
	|g@|	g@	调用 'operatorfunc' 选项设置的函数
						*motion-count-multiplied*
如果动作包含计数，且操作符前也有计数，则两个计数相乘。例如："2d3w" 会删除六个单词。
						*operator-doubled*
当操作符重复时，它作用于整行。使用计数时，无论在第一个字符前还是后，都会作用于指定行数。因此 `3dd` 会删除三行。第一个字符前后都有计数时，计数相乘，因此 `2y3y` 会复制六行。
						*operator-resulting-pos*
应用操作符后，光标通常会停留在被操作文本的起始处。例如，"yfe" 不会移动光标，但 "yFe" 会将光标左移到 yank 开始的 "e" 上。
'startofline' 选项仅对 "d"、"<<"、"==" 和 ">>" 行操作生效。

						*linewise* *charwise* *characterwise*
操作符要么作用于整行，要么作用于起始和结束位置之间的字符。通常，跨行移动的动作是行操作（linewise），行内移动的动作是字符操作（charwise）。但也有一些例外。

						*exclusive* *inclusive*
字符移动要么是包含式（inclusive），要么是排除式（exclusive）。包含式时，动作的起始和结束位置都包含在操作中。排除式时，缓冲区末尾的最后一个字符不包含在内。行操作总是包含起始和结束位置。插件可以检查 |TextYankPost| 事件的 v:event.inclusive 标志。

每个动作是行操作、包含式还是排除式，会在命令说明中提到。不过有两个通用例外：
1. 如果动作是排除式，且动作结束在第1列，则动作结束会移到前一行末尾，并变为包含式。例如：" } " 移动到段落后的第一行，但 "d}" 不会包含那一行。
						*exclusive-linewise*
2. 如果动作是排除式，动作结束在第1列，且起始点在该行第一个非空白字符处或之前，则动作变为行操作。例如：如果段落以空白开头，你在第一个非空白处执行 "d}"，则会删除段落的所有行，包括空白。如果现在粘贴，被删除的行会插入到光标下方。

注意，当操作符处于等待状态（已输入操作符命令，但未输入动作命令）时，可以使用一组特殊映射。见 |:omap|。

你也可以先输入操作符再输入动作，也可以用可视模式：用 "v" 标记文本起点，移动光标到要操作的文本终点，然后按操作符。起点和光标之间的文本会高亮显示，你可以看到将要操作的内容。这种方式更灵活，但需要更多按键，且 redo 功能有限。见可视模式章节 |Visual-mode|。

你可以用 ":" 命令作为动作。例如 "d:call FindEnd()"。但如果命令超过一行，不能用 "." 重复。
可以重复的例子：>
	d:call search("f")<CR>
不能重复的例子：>
	d:if 1<CR>
	   call search("f")<CR>
	endif<CR>
注意，使用 ":" 时，任何动作都变为字符排除式。

					*inclusive-motion-selection-exclusive*
当 'selection' 为 "exclusive" 时，|Visual| 模式下使用包含式动作，光标会再向右移动一个字符，以便可视选择包含预期文本并可操作。

								*forced-motion*
强制动作为行、字符或块

当动作类型不是你想要的，可以在操作符后、动作命令前用 "v"、"V" 或 CTRL-V 强制类型。
例子：>
	dj
删除两行 >
	dvj
从光标位置删除到下方字符 >
	d<C-V>j
删除光标下和下方的字符 >

强制将行操作变为字符或块操作时要小心，列可能未定义。

							*o_v*
v		在操作符后、动作命令前使用：强制操作符按字符操作，即使动作是行操作。如果动作本来是行操作，会变为 |exclusive|。
		如果动作本来是字符操作，则切换包含/排除。这可用于将排除式动作变为包含式，反之亦然。

							*o_V*
V		在操作符后、动作命令前使用：强制操作符按行操作，即使动作是字符操作。

							*o_CTRL-V*
CTRL-V		在操作符后、动作命令前使用：强制操作符按块操作。这类似于可视块模式选择，块的角由动作前后的光标位置定义。

==============================================================================  
2. 左右移动					*left-right-motions*

这些命令将光标移动到当前行的指定列。它们会在第一列和行尾停止，除了 "$"，它可能会移动到下一行。参见 'whichwrap' 选项，可使部分命令跨越行边界移动。

h		或					*h*
<Left>		或					*<Left>*
CTRL-H		或					*CTRL-H* *<BS>*
<BS>			向左移动 [count] 个字符。|exclusive| 动作。
			注意：如果你希望 <BS> 删除字符，请使用如下映射：>
				:map CTRL-V<BS>		X
<			（输入 "CTRL-V<BS>" 时，先按 CTRL-V，再按 <BS>）

l		或					*l*
<Right>		或					*<Right>* *<Space>*
<Space>			向右移动 [count] 个字符。|exclusive| 动作。
			参见 'whichwrap' 选项，可调整在行尾的行为。

							*0*
0			移动到行首第一个字符。|exclusive| 动作。

							*<Home>* *<kHome>*
<Home>			移动到行首第一个字符。|exclusive| 动作。接下来上下移动时，保持在同一文本列（如可能）。大多数其他命令保持在同一屏幕列。<Home> 类似于 "1|"，与 "0" 不同之处在于行首为 <Tab> 时。

							*^*
^			移动到行首第一个非空白字符。|exclusive| 动作。任何计数都会被忽略。

							*$* *<End>* *<kEnd>*
$  或 <End>		移动到行尾。当有计数时，同时向下移动 [count - 1] 行，或尽可能多。|inclusive| 动作。如果计数为2或更大且光标在最后一行，则为错误，光标不移动。
			在可视模式下，光标移动到行尾后一个字符。
			当启用 'virtualedit' 时，"$" 可能会将光标从行尾后移到行尾最后一个字符。

							*g_*
g_			移动到行尾最后一个非空白字符，并向下 [count - 1] 行 |inclusive|。

							*g0* *g<Home>*
g0 或 g<Home>		当行换行（'wrap' 开）时：移动到屏幕行首字符。|exclusive| 动作。与 "0" 不同，当一行宽于屏幕时。
			当行不换行（'wrap' 关）时：移动到当前行在屏幕上的最左字符。与 "0" 不同，当行首字符不在屏幕上时。

							*g^*
g^			当行换行（'wrap' 开）时：移动到屏幕行首第一个非空白字符。|exclusive| 动作。与 "^" 不同，当一行宽于屏幕时。
			当行不换行（'wrap' 关）时：移动到当前行在屏幕上的最左非空白字符。与 "^" 不同，当行首非空白字符不在屏幕上时。

							*gm*
gm			类似 "g0"，但向右半个屏幕宽度（或尽可能多）。

							*gM*
gM			类似 "g0"，但移动到行文本的中间。
			带计数：移动到该百分比位置。例如 "10gM" 靠近行首，"90gM" 靠近行尾。

							*g$*
g$			当行换行（'wrap' 开）时：移动到屏幕行尾字符，并向下 [count - 1] 屏幕行 |inclusive|。与 "$" 不同，当一行宽于屏幕时。
			当行不换行（'wrap' 关）时：移动到当前行在屏幕上可见的最右字符。与 "$" 不同，当行尾字符不在屏幕上或使用计数时。
			此外，垂直移动时保持列不变，而不是移动到行尾。
			启用 'virtualedit' 时，移动到屏幕行尾。

							*g<End>* *g<kEnd>*
g<End>			类似 |g$|，但移动到最后一个非空白字符。

							*bar*
|			移动到当前行第 [count] 屏幕列。|exclusive| 动作。Ceci n'est pas une pipe.

							*f*
f{char}			向右移动到第 [count] 次出现的 {char}。光标停在 {char} 上 |inclusive|。
			{char} 可作为二合字母输入 |digraph-arg|。
			当 'encoding' 为 Unicode 时，可用组合字符，见 |utf-8-char-arg|。
			|:lmap| 映射对 {char} 生效。插入模式下可用 CTRL-^ 开关 |i_CTRL-^|。

							*F*
F{char}			向左移动到第 [count] 次出现的 {char}。光标停在 {char} 上 |exclusive|。
			{char} 输入方式同 |f| 命令。

							*t*
t{char}			向右移动到第 [count] 次出现的 {char} 之前。光标停在 {char} 左侧字符上 |inclusive|。
			{char} 输入方式同 |f| 命令。

							*T*
T{char}			向左移动到第 [count] 次出现的 {char} 之后。光标停在 {char} 右侧字符上 |exclusive|。
			{char} 输入方式同 |f| 命令。

							*;*
;			重复上次 f、t、F 或 T 命令 [count] 次。见 |cpo-;|

							*,*
,			反方向重复上次 f、t、F 或 T 命令 [count] 次。另见 |cpo-;|

==============================================================================
3. 上下移动					*up-down-motions*

k		或					*k*
<Up>		或					*<Up>* *CTRL-P*
CTRL-P			向上移动 [count] 行 |linewise|。

j		或					*j*
<Down>		或					*<Down>*
CTRL-J		或					*CTRL-J*
<NL>		或					*<NL>* *CTRL-N*
CTRL-N			向下移动 [count] 行 |linewise|。

gk		或					*gk* *g<Up>*
g<Up>			向上移动 [count] 显示行。|exclusive| 动作。
			与 'k' 不同，当行换行时，以及与操作符一起用时，因为不是行操作。

gj		或					*gj* *g<Down>*
g<Down>			向下移动 [count] 显示行。|exclusive| 动作。
			与 'j' 不同，当行换行时，以及与操作符一起用时，因为不是行操作。

							*-*
`-`  <减号>		向上移动 [count] 行，停在第一个非空白字符 |linewise|。

`+`		或					*+*
CTRL-M		或					*CTRL-M* *<CR>*
<CR>			向下移动 [count] 行，停在第一个非空白字符 |linewise|。

							*_*
_  <下划线>		向下移动 [count] - 1 行，停在第一个非空白字符 |linewise|。

							*G*
G			跳转到第 [count] 行，默认为最后一行，停在第一个非空白字符 |linewise|。如果未设置 'startofline'，则保持同一列。
			G 是 |jump-motions| 之一。

							*<C-End>*
<C-End>			跳转到第 [count] 行，默认为最后一行，停在最后一个字符 |inclusive|。

<C-Home>	或					*gg* *<C-Home>*
gg			跳转到第 [count] 行，默认为第一行，停在第一个非空白字符 |linewise|。如果未设置 'startofline'，则保持同一列。

							*:[range]*
:[range]		将光标定位在 [range] 的最后一行号。
			在 Ex 模式下，打印 [range] 内的行。
			[range] 也可以只是一个行号，如 ":1" 或 ":'m"。
			与 |G| 不同，此命令不会修改 |jumplist|。
							*N%*
{count}%		跳转到文件的 {count} 百分比处，停在该行第一个非空白字符 |linewise|。新行号的计算公式为：
			    ({count} * number-of-lines + 99) / 100
			另见 'startofline' 选项。

:[range]go[to] [count]					*:go* *:goto* *go*
[count]go		跳转到缓冲区的第 [count] 个字节。|exclusive| 动作。
			默认 [count] 为 1，即文件开头。给定 [range] 时，使用其中最后一个数字作为字节数。行尾字符的计数取决于当前 'fileformat' 设置。
			另见 |line2byte()| 函数，以及 'o' 选项在 'statusline' 中的用法。

这些命令用于跳转到指定行。它们在到达第一行或最后一行时停止。前两个命令会将光标放在与上次更改列后相同的列（如可能），除了 "$" 命令后，光标会放在行尾。

==============================================================================
4. 单词移动						*word-motions*

<S-Right>	或					*<S-Right>* *w*
w			向前移动 [count] 个单词。|exclusive| 动作。

<C-Right>	或					*<C-Right>* *W*
W			向前移动 [count] 个 WORD。|exclusive| 动作。

							*e*
e			向前移动到第 [count] 个单词结尾 |inclusive|。
			不会在空行停下。

							*E*
E			向前移动到第 [count] 个 WORD 结尾 |inclusive|。
			不会在空行停下。

<S-Left>	或					*<S-Left>* *b*
b			向后移动 [count] 个单词。|exclusive| 动作。

<C-Left>	或					*<C-Left>* *B*
B			向后移动 [count] 个 WORD。|exclusive| 动作。

							*ge*
ge			向后移动到第 [count] 个单词结尾 |inclusive|。

							*gE*
gE			向后移动到第 [count] 个 WORD 结尾 |inclusive|。

这些命令用于在单词或 WORD 之间移动。
							*word*
单词由一串字母、数字和下划线组成，或一串其他非空白字符，由空白（空格、Tab、<EOL>）分隔。可通过 'iskeyword' 选项更改。空行也视为一个单词。
							*WORD*
WORD 由一串非空白字符组成，由空白分隔。空行也视为一个 WORD。

一组折叠行计为一个字符的单词。
"w" 和 "W"、"e" 和 "E" 会在一组折叠行后移动到第一个单词或 WORD 的起始/结尾。"b" 和 "B" 会移动到折叠前的第一个单词或 WORD 的起始。

特殊情况："cw" 和 "cW" 在光标位于非空白处时等同于 "ce" 和 "cE"。这是 Vi 兼容行为，见 |cpo-_ | 可更改。

另一个特殊情况：当 "w" 与操作符结合使用，且最后一个单词在行尾时，操作文本的结尾为该单词结尾，而不是下一行的第一个单词。

Vi 的 "e" 实现有 bug。例如，"e" 命令在前一行为空时会停在新行首字符。但 "2e" 不会。在 Vim 中，"ee" 和 "2e" 行为一致，更为合理。但这与 Vi 有小的不兼容。

==============================================================================
5. 文本对象移动					*object-motions*

							*(*
(			向后移动 [count] 个 |句子|。|exclusive| 动作。

							*)*
)			向前移动 [count] 个 |句子|。|exclusive| 动作。

							*{*
{			向后移动 [count] 个 |段落|。|exclusive| 动作。

							*}*
}			向前移动 [count] 个 |段落|。|exclusive| 动作。

							*]]*
]]			向前移动 [count] 个 |节|，或到下一个首列的 "{"。与操作符结合用时，也会在首列的 "}" 下方停止。|exclusive| 注意 |exclusive-linewise| 通常适用。
			在 :terminal 缓冲区中，每个 shell 提示符视为一个节。|terminal_]]|

							*][*
][			向前移动 [count] 个 |节|，或到下一个首列的 '}'。|exclusive| 
			注意 |exclusive-linewise| 通常适用。

							*[[*
[[			向后移动 [count] 个 |节|，或到上一个首列的 "{"。|exclusive| 
			注意 |exclusive-linewise| 通常适用。
			在 :terminal 缓冲区中，每个 shell 提示符视为一个节。|terminal_]]|

							*[]*
[]			向后移动 [count] 个 |节|，或到上一个首列的 '}'。|exclusive| 
			注意 |exclusive-linewise| 通常适用。

这些命令用于在三种文本对象间移动。

							*sentence*
句子定义为以 '.'、'!' 或 '?' 结尾，后跟行尾或空格/Tab。结尾标点后可有任意数量的 ')'、']'、'"' 和 '''，再跟空格、Tab 或行尾。段落和节边界也是句子边界。
如果 'cpoptions' 有 'J' 标志，结尾标点后至少要有两个空格；<Tab> 不视为空白。
句子的定义不可更改。

							*paragraph*
段落在每个空行后开始，也可在 'paragraphs' 选项指定的一组段落宏处开始。默认值为 "IPLPPPQPP TPHPLIPpLpItpplpipbp"，对应 nroff 宏 ".IP"、".LP" 等（点必须在首列）。节边界也是段落边界。
注意，仅含空白的空行不是段落边界。
注意：这不包括首列的 '{' 或 '}'。

							*section*
节在首列的换页符（<C-L>）后开始，也可在 'sections' 选项指定的一组节宏处开始。默认值为 "SHNHH HUnhsh"，定义节从 nroff 宏 ".SH"、".NH"、".H"、".HU"、".nh" 和 ".sh" 开始。
在 :terminal 缓冲区中，每个 shell 提示符视为一个节。|terminal_]]|

" ]]" 和 "[[" 命令会停在首列的 '{'。这有助于在 C 程序中找到函数起始。要查找首列的 '}'（C 函数结尾），用 "]["（向前）或 "[]"（向后）。注意命令的第一个字符决定搜索方向。

如果你的 '{' 或 '}' 不在首列，仍想用 "[[" 和 "]]"，可尝试如下映射：>
   :map [[ ?{<CR>w99[{
   :map ][ /}<CR>b99]}
   :map ]] j0[[%/{<CR>
   :map [] k$][%?}<CR>
<（请按字面输入，见 |<>|）
==============================================================================
6. 文本对象选择			*object-select* *text-objects*
						*v_a* *v_i*

这是一组只能在可视模式下或操作符后使用的命令。以 "a" 开头的命令选择“一个”对象（包括空白），以 "i" 开头的命令选择“内部”对象（不含空白，或只选空白）。因此，“内部”命令总是选择的文本比 "a" 命令少。

另见 `gn` 和 `gN`，作用于上次搜索模式。

							*v_aw* *aw*
aw			“一个单词”，选择 [count] 个单词（见 |word|）。
			包括前导或尾随空白，但不计入单词数。
			在可视行模式下使用 "aw" 会切换为可视字符模式。

							*v_iw* *iw*
iw			“内部单词”，选择 [count] 个单词（见 |word|）。
			单词间的空白也会被计入。
			在可视行模式下使用 "iw" 会切换为可视字符模式。

							*v_aW* *aW*
aW			“一个 WORD”，选择 [count] 个 WORD（见 |WORD|）。
			包括前导或尾随空白，但不计入 WORD 数。
			在可视行模式下使用 "aW" 会切换为可视字符模式。

							*v_iW* *iW*
iW			“内部 WORD”，选择 [count] 个 WORD（见 |WORD|）。
			单词间的空白也会被计入。
			在可视行模式下使用 "iW" 会切换为可视字符模式。

							*v_as* *as*
as			“一个句子”，选择 [count] 个句子（见
			|sentence|）。
			在可视模式下为字符模式。

							*v_is* *is*
is			“内部句子”，选择 [count] 个句子（见
			|sentence|）。
			在可视模式下为字符模式。

							*v_ap* *ap*
ap			“一个段落”，选择 [count] 个段落（见
			|paragraph|）。
			例外：仅含空白的空行也视为段落边界。
			在可视模式下为行模式。

							*v_ip* *ip*
ip			“内部段落”，选择 [count] 个段落（见
			|paragraph|）。
			例外：仅含空白的空行也视为段落边界。
			在可视模式下为行模式。

a]						*v_a]* *v_a[* *a]* *a[*
a[			“一个 [] 块”，选择 [count] 个 '[' ']' 块。向后查找 [count] 个未闭合的 '['，并找到匹配的 ']'。所选文本包括 '[' 和 ']'。|cpo-M| 选项用于处理转义括号。
			在可视模式下为字符模式。

i]						*v_i]* *v_i[* *i]* *i[*
i[			“内部 [] 块”，选择 [count] 个 '[' ']' 块。向后查找 [count] 个未闭合的 '['，并找到匹配的 ']'。所选文本不包括 '[' 和 ']'。选择空的内部块如 "[]" 会报错。|cpo-M| 选项用于处理转义括号。
			在可视模式下为字符模式。

a)							*v_a)* *a)* *a(*
a(							*vab* *v_ab* *v_a(* *ab*
ab			“一个块”，选择 [count] 个块，从 "[count] [(" 到匹配的 ')'，包括 '(' 和 ')'（见 |[(|）。不包括括号外的空白。|cpo-M| 选项用于处理转义括号。
			在可视模式下为字符模式。

i)							*v_i)* *i)* *i(*
i(							*vib* *v_ib* *v_i(* *ib*
ib			“内部块”，选择 [count] 个块，从 "[count] [(" 到匹配的 ')'，不包括 '(' 和 ')'（见 |[(|）。如果光标不在 () 块内，则查找下一个 "("。选择空的内部块如 "()" 会报错。|cpo-M| 选项用于处理转义括号。
			在可视模式下为字符模式。

a>						*v_a>* *v_a<* *a>* *a<*
a<			“一个 <> 块”，选择 [count] 个 <> 块，从第 [count] 个未匹配的 '<' 向后到匹配的 '>'，包括 '<' 和 '>'。|cpo-M| 选项用于处理转义符号。
			在可视模式下为字符模式。

i>						*v_i>* *v_i<* *i>* *i<*
i<			“内部 <> 块”，选择 [count] 个 <> 块，从第 [count] 个未匹配的 '<' 向后到匹配的 '>'，不包括 '<' 和 '>'。选择空的内部块如 "<>" 会报错。|cpo-M| 选项用于处理转义符号。
			在可视模式下为字符模式。

						*v_at* *at*
at			“一个标签块”，选择 [count] 个标签块，从第 [count] 个未匹配的 "<aaa>" 向后到匹配的 "</aaa>"，包括 "<aaa>" 和 "</aaa>"。
			详见 |tag-blocks|。
			在可视模式下为字符模式。

						*v_it* *it*
it			“内部标签块”，选择 [count] 个标签块，从第 [count] 个未匹配的 "<aaa>" 向后到匹配的 "</aaa>"，不包括 "<aaa>" 和 "</aaa>"。
			详见 |tag-blocks|。
			在可视模式下为字符模式。

a}							*v_a}* *a}* *a{*
a{							*v_aB* *v_a{* *aB*
aB			“一个 Block”，选择 [count] 个 Block，从 "[count] [{" 到匹配的 "}"，包括 "{" 和 "}"（见 |[{|）。|cpo-M| 选项用于处理转义大括号。
			在可视模式下为字符模式。

i}							*v_i}* *i}* *i{*
i{							*v_iB* *v_i{* *iB*
iB			“内部 Block”，选择 [count] 个 Block，从 "[count] [{" 到匹配的 "}"，不包括 "{" 和 "}"（见 |[{|）。选择空的内部块如 "{}" 会报错。|cpo-M| 选项用于处理转义大括号。
			在可视模式下为字符模式。

a"							*v_aquote* *aquote*
a'							*v_a'* *a'*
a`							*v_a`* *a`*
			“一个引号字符串”。选择从上一个引号到下一个引号的文本。'quoteescape' 选项用于跳过转义引号。
			仅限单行内使用。
			当光标在引号上时，Vim 会从行首查找确定哪对引号组成字符串。
			如有尾随空白则包含，否则包含前导空白。
			在可视模式下为字符模式。
			在可视模式下重复此对象会包含下一个字符串。计数目前无效。

i"							*v_iquote* *iquote*
i'							*v_i'* *i'*
i`							*v_i`* *i`*
			类似 a"、a' 和 a`，但不包括引号，重复不会扩展可视选择。
			特殊情况：计数为2时会包含引号，但不会像 a"/a'/a` 那样包含额外空白。

							*o_object-select*
操作符后使用时：
非块对象：
	"a" 命令：操作符作用于对象及其后的空白。如果对象后无空白或光标在对象前的空白中，则包括对象前的空白。
	"inner" 命令：如果光标在对象上，操作符作用于对象；如果光标在空白上，操作符作用于空白。
块对象：
	操作符作用于光标所在的块，或光标在括号上的块。"inner" 命令不包括括号，"a" 命令包括括号。

							*v_object-select*
可视模式下使用时：
可视区域起止相同时（刚按下 "v"）：
	选择一个对象，行为同操作符。
可视区域起止不同：
	非块对象时，区域会扩展一个对象或到下一个对象的空白，"a" 对象则两者都扩展。扩展方向取决于光标在可视区域哪一侧。块对象则向外扩展一层。

举例，以下是按对象从小到大分组的删除命令。注意，单个字符和整行用已有的 vi 移动命令。
	"dl"	删除字符（别名："x"）		|dl|
	"diw"	删除内部单词			*diw*
	"daw"	删除一个单词			*daw*
	"diW"	删除内部 WORD（见 |WORD|）		*diW*
	"daW"	删除一个 WORD（见 |WORD|）		*daW*
	"dgn"   删除下一个搜索模式匹配项    *dgn*
	"dd"	删除一行				|dd|
	"dis"	删除内部句子			*dis*
	"das"	删除一个句子			*das*
	"dib"	删除内部 '(' ')' 块		*dib*
	"dab"	删除一个 '(' ')' 块			*dab*
	"dip"	删除内部段落			*dip*
	"dap"	删除一个段落			*dap*
	"diB"	删除内部 '{' '}' 块		*diB*
	"daB"	删除一个 '{' '}' 块		*daB*

注意移动命令和对象的区别。移动命令从当前位置到移动终点；对象命令无论光标在对象哪里，都会操作整个对象。例如，比较 "dw" 和 "daw"："dw" 从光标到下一个单词起始删除，"daw" 删除光标下的整个单词及其前后空白。

标签块						*tag-blocks*

"it" 和 "at" 文本对象会尝试选中 HTML 和 XML 标签之间的块。但由于两者并不完全兼容，有一些限制。

通常方法是选中 <tag> 到匹配的 </tag>。"at" 包含标签，"it" 不包含。但重复 "it" 时会包含标签（否则不会变化）。"it" 用于无内容的标签块时会选中前导标签。

"<aaa/>" 项会被跳过。大小写不敏感，XML 也如此。

在 HTML 中，<br> 或 <meta ...> 这类无闭合标签会被忽略。

文本对象对错误较为宽容。多余的结束标签会被忽略。

==============================================================================
7. 标记					*mark-motions* *E20* *E78*

跳转到标记有两种方式：
1. 用 `（反引号）：光标定位到指定位置，动作为 |exclusive|。
2. 用 '（单引号）：光标定位到指定位置所在行的第一个非空白字符，动作为行操作（linewise）。
						*mark-view*
3. 如果 'jumpoptions' 包含 "view"，还会尝试恢复标记视图。即设置标记时，光标与窗口顶部行（窗口显示的第一行）之间的行数。

						*m* *mark* *Mark*
m{a-zA-Z}		在光标处设置标记 {a-zA-Z}（不移动光标，这不是移动命令）。

						*m'* *m`*
m'  或  m`		设置上一个上下文标记。可用 "''" 或 "``" 跳转到该标记（不移动光标，这不是移动命令）。

						*m[* *m]*
m[  或  m]		设置 |'[| 或 |']| 标记。用于模拟多个命令的操作符。（不移动光标，这不是移动命令）。

						*m<* *m>*
m<  或  m>		设置 |'<| 或 |'>| 标记。用于更改 `gv` 命令的选择范围。（不移动光标，这不是移动命令）。
			注意：不能设置可视模式，只能设置起止位置。

						*:ma* *:mark* *E191*
:[range]ma[rk] {a-zA-Z'}
			在 [range] 的最后一行号、列0处设置标记 {a-zA-Z'}。默认是光标所在行。

						*:k*
:[range]k{a-zA-Z'}	同 :mark，但标记名前的空格可省略。

						*'* *'a* *`* *`a*
'{a-z}  `{a-z}		跳转到当前缓冲区的标记 {a-z}。

						*'A* *'0* *`A* *`0*
'{A-Z0-9}  `{A-Z0-9}	跳转到设置该标记的文件中的标记 {A-Z0-9}（若在其他文件则不是移动命令）。

						*g'* *g'a* *g`* *g`a*
g'{mark}  g`{mark}
			跳转到 {mark}，但在当前缓冲区内跳转时不更改跳转列表。例如：>
				g`"
<			跳转到文件中最后已知位置。
			另见 |:keepjumps|。

						*:marks*
:marks			列出所有当前标记（不是移动命令）。
			|'( |、|')|、|'{| 和 |'}| 标记不会列出。
			第一列编号为零。
						*E283*
:marks {arg}		列出 {arg} 中提到的标记（不是移动命令）。例如：>
				:marks aB
<			列出标记 'a' 和 'B'。

							*:delm* *:delmarks*
:delm[arks] {marks}	删除指定标记。可删除的标记包括 A-Z 和 0-9。不能删除 ' 标记。
			可通过列出标记名或用范围（用 - 分隔）指定，空格会被忽略。例如：>
			   :delmarks a	      删除标记 a
			   :delmarks a b 1    删除标记 a、b 和 1
			   :delmarks Aa       删除标记 A 和 a
			   :delmarks p-z      删除 p 到 z 的标记
			   :delmarks ^.[]     删除标记 ^ . [ ]
			   :delmarks \"	      删除标记 "
<

:delm[arks]!		删除当前缓冲区的所有标记，但不包括 A-Z 和 0-9。也会清空 |changelist|。

标记在任何地方都不可见。它只是文件中记住的位置。不要将标记与命名寄存器混淆，两者完全无关。

'a - 'z		小写标记，仅在一个文件内有效
'A - 'Z		大写标记，也称为文件标记，可跨文件有效
'0 - '9		数字标记，从 |shada| 文件设置

小写标记 'a 到 'z 只要文件还在缓冲区列表中就会被记住。如果你将文件从缓冲区列表中移除，所有标记都会丢失。如果你删除包含标记的行，该标记也会被删除。

小写标记可与操作符结合使用。例如："d't" 会删除从光标到标记 't' 的行。提示：用 't' 表示顶部，'b' 表示底部等。小写标记在撤销和重做时会恢复。

大写标记 'A 到 'Z 包含文件名。你可以用它们在文件间跳转。只有当标记在当前文件时，才能与操作符一起用。标记的行号会自动调整，即使你插入/删除行或临时编辑其他文件。当 'shada' 选项非空时，大写标记会保存在 .shada 文件中。见 |shada-file-marks|。

数字标记 '0 到 '9 完全不同。不能直接设置。只有使用 shada 文件 |shada-file| 时才有。基本上，'0 是你上次退出 Vim 时的光标位置，'1 是倒数第二次，依此类推。用 'shada' 的 "r" 标志可指定不存储数字标记的文件。见 |shada-file-marks|。

							*'[* *`[*
'[  `[			跳转到上次更改或复制文本的第一个字符。

							*']* *`]*
']  `]			跳转到上次更改或复制文本的最后一个字符。

执行操作符后，光标会放在被操作文本的起始处。执行粘贴命令（"p" 或 "P"）后，光标有时会在插入的第一行，有时在最后一个插入字符上。上述四个命令可将光标定位到任一端。例如：复制10行后想跳到最后一行："10Y']"。插入多行后想跳到最下方插入行："p']"。块模式下也适用。

注意：删除文本后，起止位置相同，除非用块可视模式。这些命令在当前文件未做更改时无效。

							*'<* *`<*
'<  `<			跳转到当前缓冲区上次可视选择区域的第一行或字符。块模式下也可能是第一行的最后一个字符（用于定义块）。

							*'>* *`>*
'>  `>			跳转到当前缓冲区上次可视选择区域的最后一行或字符。块模式下也可能是最后一行的第一个字符（用于定义块）。注意 'selection' 设置，位置可能正好在可视区域之后。

							*''* *``*
''  ``			跳转到上次跳转前的位置，或上次执行 "m'" 或 "m`" 命令的位置。用 |:keepjumps| 命令修饰时不会设置。
			另见 |restore-position|。

							*'quote* *`quote*
'"  `"			跳转到上次退出当前缓冲区时的光标位置。默认为第一行第一个字符。见 |last-position-jump|，可用于每次打开文件时跳转。
			每个缓冲区只记住一个位置，不是每个窗口。只要缓冲区在窗口中可见，位置不会改变。|:wshada| 时也会重置标记。

							*'^* *`^*
'^  `^			跳转到上次退出插入模式时的位置。用于 |gi| 命令。用 |:keepjumps| 命令修饰时不会设置。

							*'.* *`.*
'.  `.			跳转到上次更改的位置。位置在更改开始处或附近。有时一个命令会分多次更改，位置可能在更改末尾。例如插入单词时，位置会在最后一个字符上。用 |g;| 跳转到更早的更改。

							*'(* *`(*
'(  `(			跳转到当前句子的起始，类似 |(| 命令。

							*')* *`)*
')  `)			跳转到当前句子的结尾，类似 |)| 命令。

							*'{* *`{*
'{  `{			跳转到当前段落的起始，类似 |{| 命令。

							*'}* *`}*
'}  `}			跳转到当前段落的结尾，类似 |}| 命令。

以下命令不是标记本身，但可跳转到标记：

							*]'*
]'			向下跳转 [count] 次到下方有小写标记的行，停在该行第一个非空白字符。

							*]`*
]`			向下跳转 [count] 次到光标后的小写标记。

							*['*
['			向上跳转 [count] 次到上方有小写标记的行，停在该行第一个非空白字符。

							*[`*
[`			向上跳转 [count] 次到光标前的小写标记。

:loc[kmarks] {command}				*:loc* *:lock* *:lockmarks*
			执行 {command} 时不调整标记。当以某种方式更改文本且更改完成后行数不变时很有用。
			警告：如果行数发生变化，更改下方的标记会保持原行号，因此会移动到其他文本行。
			以下项目不会因删除/插入行而调整：
			- 小写字母标记 'a - 'z
			- 大写字母标记 'A - 'Z
			- 数字标记 '0 - '9
			- 上次插入位置 '^
			- 上次更改位置 '.
			- 上次影响的文本区域 '[ 和 ']
			- 可视区域 '< 和 '>
			- 标记在已放置标志中的行号
			- 快速修复位置中的行号
			- |jumplist| 中的位置
			- |tagstack| 中的位置
			以下项目仍会调整：
			- 上下文标记 ''
			- 光标位置
			- 窗口在缓冲区中的视图
			- 折叠
			- diff

:kee[pmarks] {command}				*:kee* *:keep* *:keepmarks*
			目前只对过滤命令 |:range!| 有效：
			- 过滤后行数等于或多于原来时，所有标记保持在原行号。
			- 行数减少时，消失行中的标记会被删除。
			无论如何，更改下方的标记行号会自动调整，始终跟随文本。
			'cpoptions' 缺少 'R' 标志时，效果同 ":keepmarks"。

							*:keepj* *:keepjumps*
:keepj[umps] {command}
			{command} 中的移动不会更改 |''|、|'.| 和 |'^| 标记、|jumplist| 或 |changelist|。
			用于自动更改或插入文本时不想跳转到该位置。例如，更新第一行的 "Last change" 时间戳：>

				:let lnum = line(".")
				:keepjumps normal gg
				:call SetLastChange()
				:keepjumps exe "normal " .. lnum .. "G"
<
			注意：每个命令都要用 ":keepjumps"。调用函数时，函数内的命令仍可能更改跳转列表。对于 `:keepjumps exe 'command '`，"command" 不会保持跳转。应使用：`:exe 'keepjumps command'`
==============================================================================
8. 跳转					*jump-motions*

“跳转”是指通常会将光标移动到相距多行位置的命令。当你进行“跳转”时，跳转前的光标位置会被记住。你可以用 "''" 和 "``" 返回该位置，除非该行已被更改或删除。以下命令属于“跳转”命令："'"、"`"、"G"、"/"、"?"、"n"、"N"、"%"、"("、")"、"[["、"]]"、"{"、"}"、":s"、":tag"、"L"、"M"、"H" 以及开始编辑新文件的命令。

							*CTRL-O*
CTRL-O			跳转到跳转列表中较旧的 [count] 个光标位置
			（不是移动命令）。

<Tab>		或					*CTRL-I* *<Tab>*
CTRL-I			跳转到跳转列表中较新的 [count] 个光标位置
			（不是移动命令）。

			注意：在 GUI 和支持 |tui-modifyOtherKeys| 或 |tui-csiu| 的终端中，CTRL-I 可与 <Tab> 分别映射，前提是两者都已映射，否则映射会同时作用于两者。tmux 例外：https://github.com/tmux/tmux/issues/2705

							*:ju* *:jumps*
:ju[mps]		打印跳转列表（不是移动命令）。

							*:cle* *:clearjumps*
:cle[arjumps]		清空当前窗口的跳转列表。

							*jumplist*
跳转会被记录在跳转列表中。用 CTRL-O 和 CTRL-I 可以在跳转前后的位置间切换。每个窗口有独立的跳转列表。最大条目数为100。

例如，三次跳转命令后，跳转列表如下：>

    jump line  col file/text
      3     1    0 some text
      2    70    0 another line
      1  1154   23 end.
   >
<
"file/text" 列显示文件名，或跳转点的文本（若在当前文件）（会去除缩进，长行会截断以适应窗口）。

">" 表示跳转列表中的当前位置。用 |:jumps| 过滤时可能不显示。

假设你当前在第1167行。用 CTRL-O 后，光标会到第1154行，结果如下：>

    jump line  col file/text
      2     1    0 some text
      1    70    0 another line
   >  0  1154   23 end.
      1  1167    0 foo bar
<
指针会指向上次使用的跳转位置。下次 CTRL-O 会用上方条目，CTRL-I 会用下方条目。如果指针在最后一条下方，表示你还没用过 CTRL-I 或 CTRL-O。这时用 CTRL-O 会把当前位置加入跳转列表，这样你可以回到 CTRL-O 前的位置。此例中为第1167行。

多次 CTRL-O 会依次跳到70行和1行。用 CTRL-I 可回到1154和1167行。注意 "jump" 列的数字表示用 CTRL-O 或 CTRL-I 跳到该位置所需的次数。

用跳转命令时，当前行号会插入到跳转列表末尾。如果该行已在跳转列表中，会被移除。这样多次 CTRL-O 只会回到旧位置一次。

用 |:keepjumps| 命令修饰时，跳转不会被记录到跳转列表。其他情况也不会记录，如 |:global| 命令。可用 "m'" 显式添加跳转。注意 setpos() 不会这样做。

用 CTRL-O 跳到1154行后再用跳转命令（如 "G"），跳转列表会变为：>

    jump line  col file/text
      4     1    0 some text
      3    70    0 another line
      2  1167    0 foo bar
      1  1154   23 end.
   >
<
行号会因插入/删除行自动调整。如果用 ":n!" 退出文件而不保存，则会失效。

分割窗口时，跳转列表会复制到新窗口。

如果 'shada' 选项包含 ' 项，跳转列表会保存在 ShaDa 文件中并在启动 Vim 时恢复。

							*jumplist-stack*
当 'jumpoptions' 包含 "stack" 时，跳转列表行为类似标签栈。从跳转列表中间跳到新位置时，当前位置后的条目会被丢弃。这样你可以在跳转树中上下移动。回到分支上再下到另一分支时，CTRL-O 仍会继续向上。

假设跳转列表如下，已用 CTRL-O 回到 X 位置三次：>

     jump line  col file/text
       2  1260    8 mark.c		<-- 位置 X-2
       1   685    0 eval.c		<-- 位置 X-1
    >  0   462   36 eval.c		<-- 位置 X
       1   479   39 eval.c
       2   213    2 mark.c
       3   181    0 mark.c
<
跳转到新位置 Y 后，当前位置后的条目会被移除：>

     jump line  col file/text
       3  1260    8 mark.c		<-- 位置 X-2
       2   685    0 eval.c		<-- 位置 X-1
       1   462   36 eval.c		<-- 位置 X
    >
<
再跳到新位置 Z，Y 会直接出现在 X 后，X 相对 X-1、X-2 的位置不变：>

     jump line  col file/text
       4  1260    8 mark.c		<-- 位置 X-2
       3   685    0 eval.c		<-- 位置 X-1
       2   462   36 eval.c		<-- 位置 X
       1   100    0 buffer.c		<-- 位置 Y
    >
<
更改列表跳转			*changelist* *change-list-jumps* *E664*

每次更改时，光标位置会被记住。每个可撤销的更改都会记住一个位置，除非与前一次更改很近。有两个命令可跳转到更改位置，包括已撤销的更改：

							*g;* *E662*
g;			跳转到更改列表中较旧的 [count] 个位置。
			[count] 大于可用更改数时跳到最早的更改。
			无更早更改时会报错。
			（不是移动命令）

							*g,* *E663*
g,			跳转到更改列表中较新的 [count] 个位置。
			与 |g;| 相反方向。
			（不是移动命令）

用计数时会尽可能远地跳转。可用 "999g;" 跳到最早记住的更改。更改列表条目数固定，与 |jumplist| 相同。

同一行内两个可撤销更改，且列位置小于 'textwidth'，只记住最后一个。这样一行内连续小改动不会在更改列表中添加太多位置。"textwidth" 为0时用 'wrapmargin'，都未设置则用79。注意：计算用字节而非字符，以避免多字节编码的性能损失（仅极少数情况有影响）。

插入或删除文本后，光标位置可能与更改位置略有不同，尤其是删除行时。

用 `:keepjumps` 命令修饰时，更改位置不会被记住。

							*:changes*
:changes		打印更改列表。">" 表示当前位置。更改后刚好在最新条目下，表示 `g;` 会跳到最新更改位置。第一列为跳到该位置所需的计数。例如：

				change line  col text ~
				    3     9    8 bla bla bla
				    2    11   57 foo is a bar
				    1    14   54 the latest changed line
				>

			"3g;" 跳到第9行。此时 `:changes` 输出为：

				change line  col text ~
				>   0     9    8 bla bla bla
				    1    11   57 foo is a bar
				    2    14   54 the latest changed line

			现在可用 "g," 跳到第11行，用 "2g," 跳到第14行。
==============================================================================
9. 其他移动				*various-motions*

							*%*
%			查找本行中光标下或之后的下一个项目，并跳转到其匹配项。|inclusive| 动作。
			项目可以是：
			([{}])		括号或（大/中/小）括号
					（可通过 'matchpairs' 选项更改）
			`/* */`		C 风格注释的起止
			#if, #ifdef, #else, #elif, #endif
					C 预处理条件（当光标在 # 上或后面没有 ([{ 时）
			其他项目可用 matchit 插件，见 |matchit|。该插件也可跳过注释中的匹配项。

			当 'cpoptions' 包含 "M" |cpo-M| 时，括号和大括号前的反斜杠会被忽略。否则，反斜杠数量有影响：偶数与偶数匹配，奇数与奇数匹配。因此 "( \) )" 和 "\( ( \)" 中，首尾括号匹配。

			'cpoptions' 不含 '%' |cpo-%| 时，双引号内的括号和大括号会被忽略，除非本行和前一行的括号/大括号数量不等且本行和前一行末尾都不是反斜杠。'(', '{', '[', ']', '}' 和 ')' 也会被忽略（单引号内的括号和大括号）。这种方式适合 C，不适合 Perl（Perl 用单引号表示字符串）。

			注释内的匹配项不会特殊处理。可用 |matchit| 插件或在匹配项外加引号。

			不允许计数，{count}% 跳转到文件的 {count} 百分比行 |N%|。在 #if/#else/#endif 上用 '%' 会变为行操作。

						*[(*
[(			跳转到前 [count] 个未匹配的 '('。
			|exclusive| 动作。

						*[{*
[{			跳转到前 [count] 个未匹配的 '{'。
			|exclusive| 动作。

						*])*
])			跳转到后 [count] 个未匹配的 ')'。
			|exclusive| 动作。

						*]}*
]}			跳转到后 [count] 个未匹配的 '}'。
			|exclusive| 动作。

上述四个命令可用于跳转到当前代码块的起始或结尾。类似于在另一端的 "(", ")", "{", "}" 上用 "%"。可在代码块任意位置使用，非常适合 C 程序。例如，光标在 "case x:" 上，`[{` 会跳回 switch 语句。

						*]m*
]m			跳转到后 [count] 个方法起始（适用于 Java 或类似结构语言）。若不在方法起始前，则跳到类的起始或结尾。|exclusive| 动作。
						*]M*
]M			跳转到后 [count] 个方法结尾（适用于 Java 或类似结构语言）。若不在方法结尾前，则跳到类的起始或结尾。|exclusive| 动作。
						*[m*
[m			跳转到前 [count] 个方法起始（适用于 Java 或类似结构语言）。若不在方法起始后，则跳到类的起始或结尾。若光标前无 '{'，则报错。|exclusive| 动作。
						*[M*
[M			跳转到前 [count] 个方法结尾（适用于 Java 或类似结构语言）。若不在方法结尾后，则跳到类的起始或结尾。若光标前无 '}'，则报错。|exclusive| 动作。

上述两个命令假定文件包含带方法的类。类定义被 '{' 和 '}' 包围，每个方法也被 '{' 和 '}' 包围。适用于 Java 语言。文件结构如下：>

	// 注释
	class foo {
		int method_one() {
			body_one();
		}
		int method_two() {
			body_two();
		}
	}

[可将上述文本复制到新缓冲区试用，帮助文本会干扰跳转命令]

光标在 "body_two()" 时，用 "[m" 会跳到 "method_two()" 的 '{'（方法很长时尤其有用！）。用 "2[m" 会跳到 "method_one()" 的起始。用 "3[m" 会跳到类的起始。

						*[#*
[#			跳转到前 [count] 个未匹配的 "#if" 或 "#else"。
			|exclusive| 动作。

						*]#*
]#			跳转到后 [count] 个未匹配的 "#else" 或 "#endif"。
			|exclusive| 动作。

这两个命令适用于包含 #if/#else/#endif 结构的 C 程序。可跳到当前行所属的 #if/#else/#endif 起始或结尾。然后可用 "%" 跳到匹配行。

						*[star* *[/*
[*  或  [/		跳转到前 [count] 个 C 注释 "/*" 的起始。
			|exclusive| 动作。

						*]star* *]/*
]*  或  ]/		跳转到后 [count] 个 C 注释 "*/" 的结尾。
			|exclusive| 动作。

						*H*
H			跳转到窗口顶部第 [count] 行（Home），默认窗口第一行，停在第一个非空白字符 |linewise|。另见 'startofline' 选项。光标会根据 'scrolloff' 调整，操作符等待时文本可能滚动。例如 "yH" 会复制从窗口首行到光标行（包含）。

						*M*
M			跳转到窗口中间行，停在第一个非空白字符 |linewise|。另见 'startofline' 选项。

						*L*
L			跳转到窗口底部第 [count] 行，默认窗口最后一行，停在第一个非空白字符 |linewise|。另见 'startofline' 选项。光标会根据 'scrolloff' 调整，操作符等待时文本可能滚动。例如 "yL" 会复制从光标到窗口最后一行。

<LeftMouse>		移动到鼠标点击的屏幕位置 |exclusive|。另见 |<LeftMouse>|。若点击状态栏，则该窗口变为活动窗口，光标不移动。

 vim:tw=78:ts=8:noet:ft=help:norl:
