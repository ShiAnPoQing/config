*luaref.txt*           Nvim
                                                                *luaref*

                             LUA 参考手册


                                 版本 0.3.0
                                2022年8月7日


                    Vimdoc 版本 (c) 2006 by Luis Carvalho
                         <lexcarvalho at gmail dot com>

                    改编自 "Lua: 5.1 参考手册"
                 R. Ierusalimschy, L. H. de Figueiredo, W. Celes
                      版权所有 (c) 2006 Lua.org, PUC-Rio.


                 查看 |lua-ref-doc| 获取此手册的信息。
                 查看 |lua-ref-copyright| 获取版权和许可证。


输入 |gO| 查看目录。

==============================================================================
1  介绍                                                      *luaref-intro*

Lua 是一种扩展编程语言，设计用于支持具有数据描述功能的通用过程化编程。它还为面向对象编程、函数式编程和数据驱动编程提供了良好的支持。Lua 的目标是作为任何需要脚本语言的程序的强大、轻量级脚本语言。Lua 以库的形式实现，用干净的 C 语言编写（即，ANSI C 和 C++ 的公共子集）。

作为一种扩展语言，Lua 没有"主"程序的概念：它只能嵌入在宿主客户端中工作，称为嵌入程序或简称宿主。这个宿主程序可以调用函数来执行一段 Lua 代码，可以写入和读取 Lua 变量，并可以注册被 Lua 代码调用的 C 函数。通过使用 C 函数，Lua 可以扩展来处理广泛的不同领域，从而创建共享语法框架的定制编程语言。

Lua 是自由软件，通常按其许可证中所述不提供保证。本手册中描述的实现可在 Lua 的官方网站 www.lua.org 获得。

像任何其他参考手册一样，本文档在某些地方比较枯燥。有关 Lua 设计决策的讨论，请参见 |lua-ref-bibliography| 中的参考资料。有关 Lua 编程的详细介绍，请参见

Roberto 的书《Programming in Lua》。

Lua 在葡萄牙语中意思是"月亮"，发音为 LOO-ah。

==============================================================================
2  语言                                                    *lua-language*

本节描述 Lua 的词法、语法和语义。换句话说，本节描述哪些标记是有效的，它们如何组合，以及它们的组合意味着什么。

语言结构将使用通常的扩展 BNF 表示法进行解释，其中 `{ a }` 表示 0 个或多个 `a`，`[ a ]` 表示可选的 `a`。

==============================================================================
2.1  词法约定                                              *lua-lexical*

                                               *lua-names* *lua-identifiers*
Lua 中的名称（也称为标识符）可以是任何字母、数字和下划线的字符串，不以数字开头。这与大多数语言中标识符的定义一致。（字母的定义取决于当前区域设置：当前区域设置认为是字母的任何字符都可以在标识符中使用。）标识符用于命名变量和表字段。

以下关键字是保留的，不能用作名称：
>
       and       break     do        else      elseif
       end       false     for       function  if
       in        local     nil       not       or
       repeat    return    then      true      until     while
<
Lua 是大小写敏感的语言：`and` 是保留字，但 `And` 和 `AND` 是两个不同的有效名称。按照惯例，以下划线开头后跟大写字母的名称（如 `_VERSION`）保留给 Lua 使用的内部全局变量。

以下字符串表示其他标记：
>
       +     -     *     /     %     ^     #
       ==    ~=    <=    >=    <     >     =
       (     )     {     }     [     ]
       ;     :     ,     .     ..    ...
<
                                                                *lua-literal*
字面字符串可以用匹配的单引号或双引号分隔，并且可以包含以下类似 C 的转义序列：

    - `\a`  响铃
    - `\b`  退格
    - `\f`  换页
    - `\n`  换行
    - `\r`  回车
    - `\t`  水平制表符
    - `\v`  垂直制表符
    - `\\`  反斜杠
    - `\"`  引号（双引号）
    - `\'`  撇号（单引号）

此外，反斜杠后跟实际换行符在字符串中产生换行符。字符串中的字符也可以通过使用转义序列 `\ddd` 来按其数值指定，其中 `ddd` 是最多三个十进制数字的序列。（注意，如果数字转义后面要跟一个数字，则必须使用恰好三个数字来表示。）Lua 中的字符串可以包含任何 8 位值，包括嵌入的零，可以指定为 `\0`。

要在双（单）引号包围的字面字符串中放入双（单）引号、换行符、反斜杠或嵌入零，必须使用转义序列。任何其他字符都可以直接插入到字面字符串中。（某些控制字符可能会对文件系统造成问题，但 Lua 对它们没有问题。）

字面字符串也可以使用由长括号包围的长格式定义。我们将级别 n 的开放长括号定义为一个开放方括号，后跟 n 个等号，再后跟另一个开放方括号。因此，级别 0 的开放长括号写作 `[[`，级别 1 的开放长括号写作 `[=[`，依此类推。
闭合长括号的定义类似；例如，级别 4 的闭合长括号写作 `]====]`。长字符串以任何级别的开放长括号开始，并在第一个相同级别的闭合长括号处结束。这种括号形式的字面值可以跨越多行，不解释任何转义序列，并忽略任何其他级别的长括号。它们可以包含除适当级别的闭合括号之外的任何内容。

为了方便起见，当开放长括号紧跟换行符时，换行符不包含在字符串中。例如，在使用 ASCII 的系统中（其中 `a` 编码为 97，换行符编码为 10，`1` 编码为 49），下面五个字面值表示相同的字符串：
>lua
       a = 'alo\n123"'
       a = "alo\n123\""
       a = '\97lo\10\04923"'
       a = [[alo
       123"]]
       a = [==[
       alo
       123"]==]
<
                                                            *lua-numconstant*
数字常量可以用可选的小数部分和可选的十进制指数编写。Lua 还接受整数十六进制常量，通过在它们前面加上 `0x`。有效数字常量的示例有
>
     3     3.0     3.1416  314.16e-2   0.31416E1   0xff   0x56
<
                                                                *lua-comment*
注释以双连字符（`--`）开始，在字符串外的任何地方。如果 `--` 之后的文本不是开放长括号，则注释是短注释，一直运行到行尾。否则，它是长注释，运行到相应的闭合长括号。长注释经常用于临时禁用代码。

==============================================================================
2.2  值和类型                                               *lua-values*

Lua 是一种动态类型语言。这意味着变量没有类型；只有值有。语言中没有类型定义。所有值都携带自己的类型。

Lua 中的所有值都是一等值。这意味着所有值都可以存储在变量中，作为参数传递给其他函数，并作为结果返回。

                                                *lua-types* *lua-nil*
                                                *lua-true* *lua-false*
                                                *lua-number* *lua-string*
Lua 中有八种基本类型：`nil`、`boolean`、`number`、`string`、`function`、`userdata`、`thread` 和 `table`。Nil 是值 `nil` 的类型，其主要属性是与任何其他值不同；它通常表示有用值的缺失。Boolean 是值 `false` 和 `true` 的类型。`nil` 和 `false` 都使条件为假；任何其他值都使其为真。Number 表示实数（双精度浮点数）。（很容易构建使用其他内部数字表示的 Lua 解释器，如单精度浮点数或长整数；参见文件 `luaconf.h`。）String 表示字符数组。Lua 是 8 位干净的：字符串可以包含任何 8 位字符，包括嵌入的零（`\0`）（参见 |lua-literal|）。

Lua 可以调用（和操作）用 Lua 编写的函数和用 C 编写的函数（参见 |lua-function|）。

                                                            *lua-userdatatype*
提供 userdata 类型是为了允许将任意 C 数据存储在 Lua 变量中。此类型对应于原始内存块，除了赋值和标识测试外，在 Lua 中没有预定义操作。但是，通过使用元表，程序员可以为 userdata 值定义操作（参见 |lua-metatable|）。Userdata 值不能在 Lua 中创建或修改，只能通过 C API。这保证了宿主程序拥有的数据的完整性。

                                                                 *lua-thread*
类型 `thread` 表示独立的执行线程，用于实现协程（参见 |lua-coroutine|）。不要将 Lua 线程与操作系统线程混淆。Lua 在所有系统上都支持协程，即使那些不支持线程的系统。

                                                                  *lua-table*
类型 `table` 实现关联数组，即不仅可以用数字索引，还可以用任何值（除了 `nil`）索引的数组。表可以是异构的；即，它们可以包含所有类型的值（除了 `nil`）。表是 Lua 中唯一的数据结构机制；它们可以用来表示普通数组、符号表、集合、记录、图、树等。为了表示记录，Lua 使用字段名作为索引。语言通过提供 `a.name` 作为 `a["name"]` 的语法糖来支持这种表示。在 Lua 中有几种方便的方法来创建表（参见 |lua-tableconstructor|）。

像索引一样，表字段的值可以是任何类型（除了 `nil`）。特别是，因为函数是一等值，表字段可以包含函数。因此表也可以携带方法（参见 |lua-function-define|）。

表、函数、线程和（完整）userdata 值是对象：变量实际上不包含这些值，只包含对它们的引用。赋值、参数传递和函数返回总是操作对这些值的引用；这些操作不暗示任何类型的复制。

库函数 `type` 返回描述给定值类型的字符串（参见 |lua-type()|）。

------------------------------------------------------------------------------
2.2.1  强制转换                                            *lua-coercion*

Lua 在运行时提供字符串和数字值之间的自动转换。任何应用于字符串的算术操作都试图将该字符串转换为数字，遵循通常的转换规则。相反，每当在期望字符串的地方使用数字时，数字就会以合理的格式转换为字符串。要完全控制数字如何转换为字符串，请使用字符串库中的 `format` 函数（参见 |string.format()|）。

==============================================================================
2.3  变量                                                  *lua-variables*

变量是存储值的地方。Lua 中有三种变量：全局变量、局部变量和表字段。

单个名称可以表示全局变量或局部变量（或函数的形式参数，这是局部变量的一种特殊形式）：
>
       var ::= Name
<
Name 表示标识符，如 |lua-lexical| 中定义的。

除非显式声明为局部变量，否则任何变量都被假定为全局变量（参见 |lua-local|）。局部变量是词法作用域的：局部变量可以被定义在其作用域内的函数自由访问（参见 |lua-visibility|）。

在第一次赋值给变量之前，其值为 `nil`。

方括号用于索引表：
>
       var ::= prefixexp [ exp ]
<
第一个表达式（`prefixexp`）应该产生表值；第二个表达式（`exp`）标识该表内的特定条目。表示要被索引的表的表达式具有受限语法；详见 |lua-expressions|。

语法 `var.NAME` 只是 `var["NAME"]` 的语法糖：
>
       var ::= prefixexp . Name
<
所有全局变量作为字段存在于普通 Lua 表中，称为环境表或简称环境（参见 |lua-environments|）。每个函数都有自己对环境的引用，因此此函数中的所有全局变量都将引用此环境表。当创建函数时，它从创建它的函数继承环境。要获取 Lua 函数的环境表，调用 `getfenv`（参见 |lua_getfenv()|）。要替换它，调用 `setfenv`（参见 |setfenv()|）。（您只能通过调试库操作 C 函数的环境；参见 |lua-lib-debug|。）

访问全局变量 `x` 等价于 `_env.x`，这又等价于
>lua
       gettable_event(_env, "x")
<
其中 `_env` 是运行函数的环境。（`_env` 变量在 Lua 中未定义。我们在这里仅用于解释目的。）

对全局变量和表字段的访问的含义可以通过元表更改。对索引变量 `t[i]` 的访问等价于调用 `gettable_event(t,i)`。（参见 |lua-metatable| 了解 `gettable_event` 函数的完整描述。此函数在 Lua 中未定义或不可调用。我们在这里仅用于解释目的。）

==============================================================================
2.4  语句                                                   *lua-statement*

Lua 支持一套几乎传统的语句，类似于 Pascal 或 C 中的语句。这套语句包括赋值、控制结构、函数调用和变量声明。

------------------------------------------------------------------------------
2.4.1  块                                                   *lua-chunk*

Lua 的执行单元称为块。块只是一个语句序列，按顺序执行。每个语句可以可选地后跟分号：
>
       chunk ::= {stat [ ; ]}
<
没有空语句，因此 `;;` 是不合法的。

Lua 将块作为具有可变数量参数的匿名函数的主体处理（参见 |lua-function-define|）。因此，块可以定义局部变量、接收参数和返回值。

块可以存储在文件中或宿主程序内的字符串中。当执行块时，首先将其预编译为虚拟机的指令，然后由虚拟机的解释器执行编译后的代码。

块也可以预编译为二进制形式；详见程序 `luac`。源代码和编译形式的程序是可互换的；Lua 自动检测文件类型并相应地处理。

------------------------------------------------------------------------------
2.4.2  语句块                                               *lua-block*

语句块是语句列表；在语法上，语句块与块相同：
>
       block ::= chunk
<
                                                *lua-do* *lua-end*
语句块可以显式分隔以产生单个语句：
>
       stat ::= do block end
<
显式语句块对于控制变量声明的作用域很有用。显式语句块有时也用于在另一个语句块中间添加 `return` 或 `break` 语句（参见 |lua-control|）。

------------------------------------------------------------------------------
2.4.3  赋值                                                 *lua-assign*

Lua 允许多重赋值。因此，赋值的语法在左侧定义变量列表，在右侧定义表达式列表。两个列表中的元素都用逗号分隔：
>
       stat ::= varlist1 = explist1
       varlist1 ::= var { , var }
       explist1 ::= exp { , exp }
<
表达式在 |lua-expressions| 中讨论。

在赋值之前，值列表调整为变量列表的长度。如果值多于需要，多余的值会被丢弃。如果值少于需要，列表会用所需数量的 `nil` 扩展。如果表达式列表以函数调用结束，那么此调用返回的所有值都会进入值列表，在调整之前（除非调用被括号包围；参见 |lua-expressions|）。

赋值语句首先计算所有其表达式，然后才执行赋值。因此代码
>lua
       i = 3
       i, a[i] = i+1, 20
<
将 `a[3]` 设置为 20，而不影响 `a[4]`，因为 `a[i]` 中的 `i` 在被赋值为 4 之前被求值（为 3）。类似地，行
>lua
       x, y = y, x
<
交换 `x` 和 `y` 的值。

对全局变量和表字段的赋值的含义可以通过元表更改。对索引变量 `t[i] = val` 的赋值等价于 `settable_event(t,i,val)`。（参见 |lua-metatable| 了解 `settable_event` 函数的完整描述。此函数在 Lua 中未定义或不可调用。我们在这里仅用于解释目的。）

对全局变量 `x = val` 的赋值等价于赋值 `_env.x = val`，这又等价于
>lua
       settable_event(_env, "x", val)
<
其中 `_env` 是运行函数的环境。（`_env` 变量在 Lua 中未定义。我们在这里仅用于解释目的。）

------------------------------------------------------------------------------
2.4.4  控制结构                                             *lua-control*

                                   *lua-if* *lua-then* *lua-else* *lua-elseif*
                                   *lua-while* *lua-repeat* *lua-until*
控制结构 `if`、`while` 和 `repeat` 具有通常的含义和熟悉的语法：
>
       stat ::=  while  exp do block end
       stat ::=  repeat  block until exp
       stat ::=  if  exp then block { elseif exp then block }
                 [ else block ] end
<
Lua 还有 `for` 语句，有两种形式（参见 |lua-for|）。

控制结构的条件表达式可以返回任何值。`false` 和 `nil` 都被认为是假。所有不同于 `nil` 和 `false` 的值都被认为是真（特别是，数字 0 和空字符串也是真）。

在 `repeat-until` 循环中，内部语句块不在 `until` 关键字处结束，而是仅在条件之后。因此，条件可以引用循环语句块内声明的局部变量。

                                                                 *lua-return*
`return` 语句用于从函数或块返回值（块只是一个函数）。函数和块可以返回多个值，因此 `return` 语句的语法是

       `stat ::=`  `return`  `[explist1]`

                                                                  *lua-break*
`break` 语句用于终止 `while`、`repeat` 或 `for` 循环的执行，跳到循环后的下一个语句：

       `stat ::=`  `break`

`break` 结束最内层的封闭循环。

`return` 和 `break` 语句只能作为语句块的`最后`语句编写。如果确实需要在语句块中间 `return` 或 `break`，则可以使用显式内部语句块，如惯用法 `do return end` 和 `do break end`，因为现在 `return` 和 `break` 是它们（内部）语句块中的最后语句。

------------------------------------------------------------------------------
2.4.5  For 语句                                            *for* *lua-for*

`for` 语句有两种形式：一种数字形式和一种通用形式。

数字 `for` 循环在控制变量按算术级数运行时重复代码块。它具有以下语法：
>
       stat ::=  for  Name = exp , exp [ , exp ] do block end
<
从第一个 `exp` 的值开始，`block` 为 `name` 重复，直到它以第三个 `exp` 的步长超过第二个 `exp`。更准确地说，像这样的 `for` 语句

       `for var =  e1, e2, e3  do  block  end`

等价于代码：>lua

       do
         local  var, limit, step  = tonumber(e1), tonumber(e2), tonumber(e3)
         if not (  var  and  limit  and  step  ) then error() end
         while (  step  >0 and  var  <=  limit  )
                 or (  step  <=0 and  var  >=  limit  ) do
            block
            var  =  var  +  step
         end
       end
<

注意以下几点：

 - 所有三个控制表达式只在循环开始前计算一次。它们都必须产生数字。
 - `var`、`limit` 和 `step` 是不可见变量。这些名称在这里仅用于解释目的。
 - 如果第三个表达式（步长）不存在，则使用步长 1。
 - 您可以使用 `break` 退出 `for` 循环。
 - 循环变量 `var` 是循环的局部变量；在 `for` 结束或中断后不能使用其值。如果需要此值，在中断或退出循环之前将其赋值给另一个变量。

                                                                      *for-in*
通用 `for` 语句作用于称为 |iterator| 的函数。在每次迭代中，调用迭代器函数以产生新值，当此新值为 `nil` 时停止。通用 `for` 循环具有以下语法：
>
       stat ::=  for  namelist in explist1 do block end
       namelist ::= Name { , Name }
<
像这样的 `for` 语句

       `for`  `var1, ..., varn`  `in`  `explist`  `do`  `block`  `end`

等价于代码：>lua

       do
         local  f, s, var  =  explist
         while true do
             local  var1, ..., varn  =  f(s, var)
             var  =  var1
             if  var  == nil then break end
             block
         end
       end
<
注意以下几点：

 - `explist` 只计算一次。其结果是迭代器函数、一个 `state` 和第一个迭代器变量的初始值。
 - `f`、`s` 和 `var` 是不可见变量。这些名称在这里仅用于解释目的。
 - 您可以使用 `break` 退出 `for` 循环。
 - 循环变量 `var1, ..., varn` 是循环的局部变量；在 `for` 结束后不能使用它们的值。如果需要这些值，则在中断或退出循环之前将它们赋值给其他变量。

------------------------------------------------------------------------------
2.4.6  函数调用作为语句                                    *lua-funcstatement*

为了允许可能的副作用，函数调用可以作为语句执行：
>
       stat ::= functioncall
<
在这种情况下，所有返回值都被丢弃。函数调用在 |lua-function| 中解释。

------------------------------------------------------------------------------
2.4.7  局部声明                                            *lua-local*

局部变量可以在语句块内的任何地方声明。声明可能包括初始赋值：
>
       stat ::=  local  namelist [ = explist1 ]
       namelist ::= Name { , Name }
<
如果存在，初始赋值具有与多重赋值相同的语义（参见 |lua-assign|）。否则，所有变量都用 `nil` 初始化。

块也是语句块（参见 |lua-chunk|），因此局部变量可以在任何显式语句块之外的块中声明。这种局部变量的作用域延伸到块的末尾。

局部变量的可见性规则在 |lua-visibility| 中解释。

==============================================================================
2.5  表达式                                                *lua-expressions*

Lua 中的基本表达式如下：
>
       exp ::= prefixexp
       exp ::=  nil  |  false  |  true
       exp ::= Number
       exp ::= String
       exp ::= function
       exp ::= tableconstructor
       exp ::= ...
       exp ::= exp binop exp
       exp ::= unop exp
       prefixexp ::= var | functioncall | ( exp )
<
数字和字面字符串在 |lua-lexical| 中解释；变量在 |lua-variables| 中解释；函数定义在 |lua-function-define| 中解释；函数调用在 |lua-function| 中解释；表构造函数在 |lua-tableconstructor| 中解释。由三个点（`...`）表示的变参表达式只能在变参函数内使用；它们在 |lua-function-define| 中解释。

二元运算符包括算术运算符（参见 |lua-arithmetic|）、关系运算符（参见 |lua-relational|）、逻辑运算符（参见 |lua-logicalop|）和连接运算符（参见 |lua-concat|）。一元运算符包括一元减号（参见 |lua-arithmetic|）、一元 `not`（参见 |lua-logicalop|）和一元长度运算符（参见 |lua-length|）。

函数调用和变参表达式都可能产生多个值。如果表达式用作语句（参见 |lua-funcstatement|）（仅对函数调用可能），则其返回列表调整为零个元素，从而丢弃所有返回值。如果表达式用作表达式列表的最后（或唯一）元素，则不进行调整（除非调用被括号包围）。在所有其他上下文中，Lua 将结果列表调整为一个元素，丢弃除第一个之外的所有值。

以下是一些示例：
>lua
       f()                -- 调整为 0 个结果
       g(f(), x)          -- f() 调整为 1 个结果
       g(x, f())          -- g 获取 x 加上 f() 的所有结果
       a,b,c = f(), x     -- f() 调整为 1 个结果（c 获取 nil）
       a,b = ...          -- a 获取第一个变参参数，b 获取
                          -- 第二个（如果没有对应的变参参数，a 和 b 都可能获取 nil）

       a,b,c = x, f()     -- f() 调整为 2 个结果
       a,b,c = f()        -- f() 调整为 3 个结果
       return f()         -- 返回 f() 的所有结果
       return ...         -- 返回所有接收到的变参参数
       return x,y,f()     -- 返回 x、y 和 f() 的所有结果
       {f()}              -- 创建包含 f() 所有结果的列表
       {...}              -- 创建包含所有变参参数的列表
       {f(), nil}         -- f() 调整为 1 个结果
<
括号中的表达式总是只产生一个值。因此，`(f(x,y,z))` 总是单个值，即使 `f` 返回多个值。（`(f(x,y,z))` 的值是 `f` 返回的第一个值，如果 `f` 不返回任何值则为 `nil`。）

------------------------------------------------------------------------------
2.5.1  算术运算符                                          *lua-arithmetic*

Lua 支持通常的算术运算符：二元 `+`（加法）、`-`（减法）、`*`（乘法）、`/`（除法）、`%`（取模）和 `^`（幂运算）；以及一元 `-`（否定）。如果操作数是数字，或者是可以转换为数字的字符串（参见 |lua-coercion|），则所有操作都具有通常的含义。幂运算适用于任何指数。例如，`x^(-0.5)` 计算 `x` 的平方根的倒数。取模定义为
>lua
       a % b == a - math.floor(a/b)*b
<
即，它是将商向负无穷舍入的除法的余数。

------------------------------------------------------------------------------
2.5.2  关系运算符                                          *lua-relational*

Lua 中的关系运算符是
>
                    ==    ~=    <     >     <=    >=
<
这些运算符总是产生 `false` 或 `true`。

等等（`==`）首先比较其操作数的类型。如果类型不同，则结果为 `false`。否则，比较操作数的值。数字和字符串以通常的方式比较。对象（表、userdata、线程和函数）按引用比较：只有当两个对象是同一个对象时，才认为它们相等。每次创建新对象（表、userdata 或函数）时，此新对象都与任何先前存在的对象不同。

您可以使用"eq"元方法更改 Lua 比较表和 userdata 的方式（参见 |lua-metatable|）。

强制转换的转换规则 |lua-coercion| 不适用于等式比较。因此，`"0"==0` 求值为 `false`，`t[0]` 和 `t["0"]` 表示表中的不同条目。

运算符 `~=` 正好是等式（`==`）的否定。

顺序运算符的工作如下。如果两个参数都是数字，则按如下方式比较它们。否则，如果两个参数都是字符串，则根据当前区域设置比较它们的值。否则，Lua 尝试调用"lt"或"le"元方法（参见 |lua-metatable|）。

------------------------------------------------------------------------------
2.5.3  逻辑运算符                                          *lua-logicalop*

Lua 中的逻辑运算符是
>
       and    or    not
<
像控制结构一样（参见 |lua-control|），所有逻辑运算符都将 `false` 和 `nil` 视为假，将其他任何东西视为真。

                                                  *lua-not* *lua-and* *lua-or*
否定运算符 `not` 总是返回 `false` 或 `true`。合取运算符 `and` 如果其第一个参数为 `false` 或 `nil`，则返回其第一个参数；否则，`and` 返回其第二个参数。析取运算符 `or` 如果其第一个参数不同于 `nil` 和 `false`，则返回其第一个参数；否则，`or` 返回其第二个参数。`and` 和 `or` 都使用短路求值，即只有在必要时才求值第二个操作数。以下是一些示例：
>
       10 or 20            --> 10
       10 or error()       --> 10
       nil or "a"          --> "a"
       nil and 10          --> nil
       false and error()   --> false
       false and nil       --> false
       false or nil        --> nil
       10 and 20           --> 20
<
（在本手册中，`-->` 表示前面表达式的结果。）

------------------------------------------------------------------------------
2.5.4  连接                                                *lua-concat*

Lua 中的字符串连接运算符用两个点（`..`）表示。如果两个操作数都是字符串或数字，则根据 |lua-coercion| 中提到的规则将它们转换为字符串。否则，调用"concat"元方法（参见 |lua-metatable|）。

------------------------------------------------------------------------------
2.5.5  长度运算符                                          *lua-#* *lua-length*

长度运算符用一元运算符 `#` 表示。字符串的长度是其字节数（即，当每个字符是一个字节时字符串长度的通常含义）。

表 `t` 的长度定义为任何整数索引 `n`，使得 `t[n]` 不是 `nil` 且 `t[n+1]` 是 `nil`；此外，如果 `t[1]` 是 `nil`，`n` 可能为零。对于具有从 1 到给定 `n` 的非 nil 值的常规数组，其长度恰好是该 `n`，即其最后一个值的索引。如果数组有"洞"（即在其他非 nil 值之间有 `nil` 值），则 `#t` 可能是直接在 `nil` 值之前的任何索引（即，它可能将任何这样的 `nil` 值视为数组的结尾）。

------------------------------------------------------------------------------
2.5.6  优先级                                              *lua-precedence*

Lua 中的运算符优先级遵循下表，从低到高优先级：
>
       or
       and
       <     >     <=    >=    ~=    ==
       ..
       +     -
       *     /
       not   #     - (unary)
       ^
<
通常，您可以使用括号来更改表达式中的优先级。连接（`..`）和幂运算（`^`）运算符是右结合的。所有其他二元运算符都是左结合的。

------------------------------------------------------------------------------
2.5.7  表构造函数                                          *lua-tableconstructor*

表构造函数是创建表的表达式。每次求值构造函数时，都会创建一个新表。构造函数可以用于创建空表，或创建表并初始化其某些字段。构造函数的一般语法是
>
       tableconstructor ::= { [ fieldlist ] }
       fieldlist ::= field { fieldsep field } [ fieldsep ]
       field ::= [ exp ]  = exp | Name = exp | exp
       fieldsep ::=  , |  ;
<
形式为 `[exp1] = exp2` 的每个字段向新表添加一个键为 `exp1` 值为 `exp2` 的条目。形式为 `name = exp` 的字段等价于 `["name"] = exp`。最后，形式为 `exp` 的字段等价于 `[i] = exp`，其中 `i` 是从 1 开始的连续数字整数。其他格式的字段不影响此计数。例如，
>lua
       a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
<
等价于
>lua
       do
         local t = {}
         t[f(1)] = g
         t[1] = "x"         -- 第 1 个 exp
         t[2] = "y"         -- 第 2 个 exp
         t.x = 1            -- temp["x"] = 1
         t[3] = f(x)        -- 第 3 个 exp
         t[30] = 23
         t[4] = 45          -- 第 4 个 exp
         a = t
       end
<
如果列表中的最后一个字段具有形式 `exp` 且表达式是函数调用，则调用返回的所有值都连续进入列表（参见 |lua-function|）。要避免这种情况，请将函数调用括在括号中（参见 |lua-expressions|）。

字段列表可能有可选的尾随分隔符，作为机器生成代码的便利。

------------------------------------------------------------------------------
2.5.8  函数调用                                            *lua-function*

Lua 中的函数调用具有以下语法：
>
       functioncall ::= prefixexp args
<
在函数调用中，首先求值 `prefixexp` 和 `args`。如果 `prefixexp` 的值具有类型 `function`，则使用给定参数调用此函数。否则，调用 `prefixexp` "call"元方法，将 `prefixexp` 的值作为第一个参数，然后是原始调用参数（参见 |lua-metatable|）。

形式
>
       functioncall ::= prefixexp : Name args
<
可用于调用"方法"。调用 `v:name(` `args` `)` 是 `v.name(v,` `args` `)` 的语法糖，除了 `v` 只求值一次。

参数具有以下语法：
>
       args ::=  ( [ explist1 ] )
       args ::= tableconstructor
       args ::= String
<
所有参数表达式在调用之前都会被求值。形式为 `f{` `fields` `}` 的调用是 `f({` `fields` `})` 的语法糖，即参数列表是单个新表。形式为 `f'` `string` `'`（或 `f"` `string` `"` 或 `f[[` `string` `]]`）的调用是 `f('` `string` `')` 的语法糖，即参数列表是单个字面字符串。

作为 Lua 自由格式语法的例外，您不能在函数调用中的 `(` 之前放置换行符。此限制避免了语言中的一些歧义。如果您写
>lua
       a = f
       (g).x(a)
<
Lua 会将其视为单个语句 `a = f(g).x(a)`。因此，如果您想要两个语句，必须在它们之间添加分号。如果您实际上想调用 `f`，必须删除 `(g)` 之前的换行符。

                                                               *lua-tailcall*
形式为 `return` `functioncall` 的调用称为尾调用。Lua 实现适当的尾调用（或适当的尾递归）：在尾调用中，被调用函数重用调用函数的堆栈条目。因此，程序可以执行的嵌套尾调用数量没有限制。但是，尾调用会擦除有关调用函数的任何调试信息。注意，尾调用只在特定语法下发生，其中 `return` 有一个单一函数调用作为参数；此语法使调用函数恰好返回被调用函数的返回值。因此，以下示例都不是尾调用：
>lua
       return (f(x))        -- 结果调整为 1
       return 2 * f(x)
       return x, f(x)       -- 额外结果
       f(x); return         -- 结果被丢弃
       return x or f(x)     -- 结果调整为 1
<

------------------------------------------------------------------------------
2.5.9  函数定义                                            *lua-function-define*

函数定义的语法是
>
       function ::= function funcbody
       funcbody ::= ( [ parlist1 ] ) block end
<
以下语法糖简化了函数定义：
>
       stat ::= function funcname funcbody
       stat ::= local function Name funcbody
       funcname ::= Name { . Name } [ : Name ]
<
语句

       `function f ()`  `body`  `end`

转换为

       `f = function ()`  `body`  `end`

语句

       `function t.a.b.c.f ()`  `body`  `end`

转换为

       `t.a.b.c.f = function ()`  `body`  `end`

语句

       `local function f ()`  `body`  `end`

转换为

       `local f; f = function f ()`  `body`  `end`

而不是

       `local f = function f ()`  `body`  `end`

（这只在函数体包含对 `f` 的引用时才有所不同。）

                                                                *lua-closure*
函数定义是可执行表达式，其值具有类型 `function`。当 Lua 预编译块时，其所有函数体也会被预编译。然后，每当 Lua 执行函数定义时，函数就会被实例化（或关闭）。此函数实例（或闭包）是表达式的最终值。同一函数的不同实例可能引用不同的外部局部变量，并可能具有不同的环境表。

参数充当用参数值初始化的局部变量：
>
       parlist1 ::= namelist [ , ... ] | ...
<
                                                                 *lua-vararg*
当调用函数时，参数列表调整为参数列表的长度，除非函数是可变参数或变参函数，这由其参数列表末尾的三个点（`...`）指示。变参函数不调整其参数列表；相反，它收集所有额外参数并通过变参表达式将它们提供给函数，变参表达式也写作三个点。此表达式的值是所有实际额外参数的列表，类似于具有多个结果的函数。如果变参表达式在另一个表达式内或在表达式列表中间使用，则其返回列表调整为一个元素。如果表达式用作表达式列表的最后一个元素，则不进行调整（除非调用被括号包围）。

作为示例，考虑以下定义：
>lua
       function f(a, b) end
       function g(a, b, ...) end
       function r() return 1,2,3 end
<
然后，我们有从参数到参数和变参表达式的以下映射：
>
       CALL            PARAMETERS

       f(3)             a=3, b=nil
       f(3, 4)          a=3, b=4
       f(3, 4, 5)       a=3, b=4
       f(r(), 10)       a=1, b=10
       f(r())           a=1, b=2

       g(3)             a=3, b=nil, ... -->  (nothing)
       g(3, 4)          a=3, b=4,   ... -->  (nothing)
       g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8
       g(5, r())        a=5, b=1,   ... -->  2  3
<
结果使用 `return` 语句返回（参见 |lua-control|）。如果控制到达函数末尾而没有遇到 `return` 语句，则函数不返回结果。

                                                            *lua-colonsyntax*
冒号语法用于定义方法，即具有隐式额外参数 `self` 的函数。因此，语句

       `function t.a.b.c:f (`  `params`  `)`  `body`  `end`

是以下的语法糖

       `t.a.b.c:f = function (`  `self`,  `params`  `)`  `body`  `end`
