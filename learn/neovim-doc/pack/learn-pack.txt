*pack.txt*                            Nvim

                            NVIM 参考手册

                                扩展 Nvim


                                       输入 |gO| 查看目录。

==============================================================================
使用 Vim 包                                                *packages*

Vim "包"是一个包含 |plugin| 的目录。与普通插件相比，包可以...
- 作为存档下载并在其自己的目录中解包，因此文件不会与其他插件的文件混合。
- 是一个 git、mercurial 等仓库，因此易于更新。
- 包含多个相互依赖的插件。
- 包含在启动时自动加载的插件（"start" 包，位于 "pack/*/start/*"）和仅在需要时通过 |:packadd| 加载的插件（"opt" 包，位于 "pack/*/opt/*"）。

                                                        *runtime-search-path*
Nvim 在以下位置搜索 |:runtime| 文件：
- 1. 'runtimepath' 中的所有路径
- 2. 所有 "pack/*/start/*" 目录

注意："pack/*/start/*" 路径并未明确包含在 'runtimepath' 中，因此它们不会被 ":set rtp" 或 "echo &rtp" 报告。
脚本可以使用 |nvim_list_runtime_paths()| 列出所有使用的目录，并使用 |nvim_get_runtime_file()| 查询运行时路径中的特定文件或子文件夹。示例：>
    " 列出所有运行时目录和带有 Lua 路径的包。
    :echo nvim_get_runtime_file("lua/", v:true)

使用包并自动加载 ~

假设你的 Nvim 文件在 "~/.local/share/nvim/site" 中，并且你想从 zip 存档 "/tmp/foopack.zip" 添加一个包：>
    % mkdir -p ~/.local/share/nvim/site/pack/foo
    % cd ~/.local/share/nvim/site/pack/foo
    % unzip /tmp/foopack.zip

目录名 "foo" 是任意的，你可以选择任何你喜欢的名称。

你现在在 ~/.local/share/nvim/site 下会有这些文件：>
    pack/foo/README.txt
    pack/foo/start/foobar/plugin/foo.vim
    pack/foo/start/foobar/syntax/some.vim
    pack/foo/opt/foodebug/plugin/debugger.vim

在处理完你的 |config| 后启动时，Nvim 会扫描 'packpath' 中所有 "pack/*/start/*" 中的插件，然后加载这些插件。

为了允许在解析你的 |vimrc| 时调用包功能，|:colorscheme| 和 |autoload| 都会自动搜索 'packpath' 以及 'runtimepath'。有关详细信息，请参阅各自的文档。

在示例中，Nvim 将找到 "pack/foo/start/foobar/plugin/foo.vim" 并加载它。

如果 "foobar" 插件生效并将 'filetype' 设置为 "some"，Nvim 将找到 syntax/some.vim 文件，因为它的目录在运行时搜索路径中。

如果有任何 ftdetect 文件，Nvim 也会加载它们。

注意："pack/foo/opt" 下的文件不会自动加载，只有 "pack/foo/start" 下的文件会自动加载。有关如何使用 "opt" 目录的信息，请参阅下面的 |pack-add|。

如果禁用了加载插件，则不会自动加载包，请参阅 |load-plugins|。

要更早地加载包，以便加载 plugin/ 文件：
    :packloadall
即使禁用了加载插件，这也有效。自动加载只会发生一次。

如果包有一个 "after" 目录，该目录将被添加到 'runtimepath' 的末尾，以便那里的任何内容都会在之后加载。


使用单个插件并自动加载它 ~

如果你没有包而只有一个插件，你需要创建额外的目录层级：>
    % mkdir -p ~/.local/share/nvim/site/pack/foo/start/foobar
    % cd ~/.local/share/nvim/site/pack/foo/start/foobar
    % unzip /tmp/someplugin.zip

你现在会有这些文件：>
    pack/foo/start/foobar/plugin/foo.vim
    pack/foo/start/foobar/syntax/some.vim

从这里开始，它的工作方式与上面相同。


可选插件 ~
                                                        *pack-add*
要加载包中的可选插件，请使用 `:packadd` 命令：>
    :packadd foodebug
这将在 'packpath' 中搜索 "pack/*/opt/foodebug"，并找到 ~/.local/share/nvim/site/pack/foo/opt/foodebug/plugin/debugger.vim 并加载它。

这可以在满足某些条件时完成。例如，取决于 Nvim 是否支持某个功能或是否缺少某个依赖项。

你也可以在启动时加载可选插件，通过将此命令放入你的 |config| 中：>
    :packadd! foodebug
额外的 "!" 是为了确保如果 Nvim 以 |--noplugin| 启动，则不会加载该插件。

一个包只包含 "opt" 目录中的文件是完全正常的。然后你需要在想要使用每个插件时加载它。


什么放在哪里 ~

由于通过 `:colorscheme` 加载的颜色方案可以在 "pack/*/start" 和 "pack/*/opt" 下找到，你可以将它们放在任何地方。我们建议你将它们放在 "pack/*/opt" 下，例如 "~/.config/nvim/pack/mycolors/opt/dark/colors/very_dark.vim"。

文件类型插件应该放在 "pack/*/start" 下，以便它们总是能被找到。除非你有一个文件类型有多个插件，并且想通过 `:packadd` 选择加载哪一个。例如，取决于编译器版本：>
    if foo_compiler_version > 34
      packadd foo_new
    else
      packadd foo_old
    endif

"after" 目录在包中很可能没有用。不过它并没有被禁止。

==============================================================================
创建 Vim 包                                              *package-create*

这里假设你编写一个或多个插件，并将它们作为包分发。

如果你有两个不相关的插件，你会使用两个包，这样 Vim 用户可以选择包含什么或不包含什么。或者你可以决定使用一个带有可选插件的包，并告诉用户使用 `:packadd` 添加他们喜欢的插件。

决定你希望如何分发包。你可以创建一个存档，或者你可以使用一个仓库。存档可以被更多用户使用，但更新到新版本有点困难。仓库通常可以轻松保持最新，但它需要像 "git" 这样的程序可用。你可以两者都做，github 可以自动为发布创建存档。

你的目录布局将如下所示：>
   start/foobar/plugin/foo.vim          " 总是加载，定义命令
   start/foobar/plugin/bar.vim          " 总是加载，定义命令
   start/foobar/autoload/foo.vim        " 当使用 foo 命令时加载
   start/foobar/doc/foo.txt             " foo.vim 的帮助
   start/foobar/doc/tags                " 帮助标签
   opt/fooextra/plugin/extra.vim        " 可选插件，定义命令
   opt/fooextra/autoload/extra.vim      " 当使用 extra 命令时加载
   opt/fooextra/doc/extra.txt           " extra.vim 的帮助
   opt/fooextra/doc/tags                " 帮助标签
<
这允许用户执行：>
    mkdir ~/.local/share/nvim/site/pack
    cd ~/.local/share/nvim/site/pack
    git clone https://github.com/you/foobar.git myfoobar

这里 "myfoobar" 是用户可以选择的名称，唯一的条件是它与其他包不同。

在你的文档中，你解释插件的作用，并告诉用户如何加载可选插件：>
    :packadd! fooextra

你可以在你的一个插件中添加这个 packadd 命令，以便在需要可选插件时执行。

运行 `:helptags` 命令来生成 doc/tags 文件。在包中包含这个生成的文件意味着用户可以将包放入 pack 目录，帮助命令即可立即工作。更改插件帮助后不要忘记重新运行该命令：>
    :helptags path/start/foobar/doc
    :helptags path/opt/fooextra/doc


插件之间的依赖关系 ~
                                                        *packload-two-steps*
假设你有两个插件依赖于相同的功能。你可以将通用功能放在一个 autoload 目录中，这样它就会被自动找到。你的包将包含这些文件：

pack/foo/start/one/plugin/one.vim  >
    call foolib#getit()
pack/foo/start/two/plugin/two.vim >
    call foolib#getit()
pack/foo/start/lib/autoload/foolib.vim >
    func foolib#getit()

这可以工作，因为在加载插件时，会自动搜索 start 包中的 autoload 文件。

==============================================================================
插件管理器                                                      *vim.pack*

进行中的内置插件管理器！欢迎对现有功能进行早期测试，但请注意可能会有不另行通知的重大更改。

仅在专用的 *vim.pack-directory* 中管理插件（参见 |packages|）：
`$XDG_DATA_HOME/nvim/site/pack/core/opt`。`$XDG_DATA_HOME/nvim/site` 需要是 'packpath' 的一部分。它通常是，但在像 |--clean| 或在启动期间设置 |$XDG_DATA_HOME| 的情况下可能不是。插件的子目录名称与规范中的插件名称匹配。假定目录中的所有插件都由 `vim.pack` 独占管理。

使用 Git 管理插件，并要求存在至少版本 2.36 的 `git` 可执行文件。目标插件应该是 Git 仓库，其版本为命名标签，遵循 semver 约定 `v<major>.<minor>.<patch>`。

所有被管理插件的最新状态存储在位于 `$XDG_CONFIG_HOME/nvim/nvim-pack-lock.json` 的 *vim.pack-lockfile* 中。

它是一个 JSON 文件，用于持久跟踪插件的数据。

为了更健壮的配置，请将锁文件视为其一部分：进行版本控制等。

在这种情况下，初始安装优先使用锁文件中的修订版本，而不是从 `version` 推断。不应手动编辑或删除。

示例工作流 ~

基本安装和管理：
• 将 |vim.pack.add()| 调用添加到 'init.lua'：>lua

    vim.pack.add({
      -- 安装 "plugin1" 并使用默认分支（通常是 `main` 或 `master`）
      'https://github.com/user/plugin1',

      -- 同上，但使用表（允许设置其他选项）
      { src = 'https://github.com/user/plugin1' },

      -- 指定插件名称（这里插件将被称为 "plugin2" 而不是 "generic-name"）
      { src = 'https://github.com/user/generic-name', name = 'plugin2' },

      -- 指定在安装和更新期间要遵循的版本
      {
        src = 'https://github.com/user/plugin3',
        -- 版本约束，参见 |vim.version.range()|
        version = vim.version.range('1.0'),
      },
      {
        src = 'https://github.com/user/plugin4',
        -- Git 分支、标签或提交哈希
        version = 'main',
      },
    })

    -- 插件代码可以在 `add()` 之后直接使用
    plugin1 = require('plugin1')
<
• 重启 Nvim（例如，使用 |:restart|）。

尚未安装的插件将在 `add()` 调用后在磁盘上可用。

它们的修订版本取自 |vim.pack-lockfile|（如果存在）或从 `version` 推断。

• 要使用新更改更新所有插件：
  • 执行 |vim.pack.update()|。这将从源下载更新并在单独的标签页中显示确认缓冲区。
  • 查看更改。要确认所有更新，执行 |:write|。要丢弃更新，执行 |:quit|。
  • （可选）|:restart| 以开始使用更新后插件中的代码。

切换插件版本：
• 更新 'init.lua' 中插件的 `version` 为所需版本。假设名为 'plugin1' 的插件已更改为 `vim.version.range('*')`。
• |:restart|。插件在磁盘上的实际状态尚未更改。只有 |vim.pack-lockfile| 中插件的 `version` 被更新。
• 执行 `vim.pack.update({ 'plugin1' })`。
• 查看更改并确认或丢弃它们。如果丢弃，也要恢复 'init.lua' 中的任何更改，否则下次运行 |vim.pack.update()| 时你会再次被提示。

冻结插件不被更新：
• 更新 'init.lua' 中插件的 `version` 为当前修订版本。从 |vim.pack-lockfile| 获取它（插件的 `rev` 字段；看起来像 `abc12345`）。
• |:restart|。

解冻插件以开始接收更新：
• 更新 'init.lua' 中插件的 `version` 设置为任何你希望它更新到的版本。
• |:restart|。

从磁盘移除插件：
• 使用 |vim.pack.del()| 并提供一个要移除的插件名称列表。确保它们的规范未包含在 'init.lua' 的 |vim.pack.add()| 调用中，否则它们将被重新安装。

可用的用于挂钩的事件 ~
• *PackChangedPre* - 在尝试更改插件状态之前。
• *PackChanged* - 在插件状态已更改之后。

每个事件都会填充以下 |event-data| 字段：
• `kind` - 其中之一："install"（在磁盘上安装）、"update"（更新现有插件）、"delete"（从磁盘删除）。
• `spec` - 插件的规范，默认值已显式化。
• `path` - 插件目录的完整路径。


*vim.pack.Spec*

    字段：~
      • {src}       (`string`) 用于安装和拉取更新的 URI。允许 `git clone` 支持的任何格式。
      • {name}?     (`string`) 插件名称。将用作目录名。默认：`src` 仓库名称。
      • {version}?  (`string|vim.VersionRange`) 用于安装和更新的版本。可以是：
                    • `nil`（无值，默认）以使用仓库的默认分支（通常是 `main` 或 `master`）。
                    • 字符串以使用特定分支、标签或提交哈希。
                    • |vim.version.range()| 的输出，以安装版本约束内最大/最后的 semver 标签。
      • {data}?     (`any`) 与插件关联的任意数据。


add({specs}, {opts})                                          *vim.pack.add()*
    将插件添加到当前会话
    • 对于每个规范，检查插件是否存在于 |vim.pack-directory| 磁盘上：
      • 如果存在，此步骤不执行任何操作。
      • 如果不存在，则通过从 `src` 下载到 `name` 子目录（通过 `git clone`）来安装它，并更新状态以匹配 `version`（通过 `git checkout`）。
    • 对于每个插件，执行 |:packadd|（或可自定义的 `load` 函数），使其可被 Nvim 访问。

    注意：
    • 安装是并行完成的，但在继续执行下一个代码之前等待所有安装完成。
    • 如果插件已存在于磁盘上，则不会检查其当前状态。指定的 `version` 可能与磁盘上实际存在的版本不同。
       执行 |vim.pack.update()| 以同步。
    • 在单个会话中第二次及以后添加插件不执行任何操作：只有第一次添加的数据被注册。

    参数：~
      • {specs}  (`(string|vim.pack.Spec)[]`) 插件规范列表。字符串项被视为 `src`。
      • {opts}   (`table?`) 具有以下字段的表：
                 • {load}?
                   (`boolean|fun(plug_data: {spec: vim.pack.Spec, path: string})`)
                   加载 `plugin/` 文件和 `ftdetect/` 脚本。如果为 `false`，则工作方式类似于 `:packadd!`。
                   如果是函数，则使用插件数据调用，并完全负责加载插件。在启动期间默认为 `false`，之后为 `true`。
                 • {confirm}? (`boolean`) 是否要求用户确认初始安装。默认为 `true`。

del({names})                                                  *vim.pack.del()*
    从磁盘移除插件

    参数：~
      • {names}  (`string[]`) 要从磁盘移除的插件名称列表。必须由 |vim.pack| 管理，不一定已添加到当前会话。

get({names}, {opts})                                          *vim.pack.get()*
    获取 |vim.pack| 插件信息，可选择按 `names` 过滤。

    参数：~
      • {names}  (`string[]?`) 插件名称列表。默认：所有由 |vim.pack| 管理的插件。
      • {opts}   (`table?`) 具有以下字段的表：
                 • {info} (`boolean`) 是否包含额外的插件信息。默认为 `true`。

    返回：~
        (`table[]`) 对象列表，具有以下字段：
        • {active} (`boolean`) 插件是否已通过 |vim.pack.add()| 添加到当前会话。
        • {branches}? (`string[]`) 可用的 Git 分支（第一个是默认分支）。如果 `info=false` 则缺失。
        • {path} (`string`) 插件在磁盘上的路径。
        • {rev} (`string`) 当前 Git 修订版本。
        • {spec} (`vim.pack.SpecResolved`) 一个带有已解析 `name` 的 |vim.pack.Spec|。
        • {tags}? (`string[]`) 可用的 Git 标签。如果 `info=false` 则缺失。

update({names}, {opts})                                    *vim.pack.update()*
    更新插件
    • 从源下载新更改。
    • 推断更新信息（当前/目标状态、变更日志等）。
    • 取决于 `force`：
      • 如果为 `false`，显示确认缓冲区。它列出了所有设置为更新的插件的数据。以 `>` 开头的待处理更改将被应用，而以 `<` 开头的将被还原。它具有专用的缓冲区本地映射：
        • |]]| 和 |[[| 在插件部分之间导航。
        一些功能通过 LSP 提供：
        • 'textDocument/documentSymbol'（通过 |lsp-defaults| 的 `gO` 或 |vim.lsp.buf.document_symbol()|）- 显示缓冲区的结构。
        • 'textDocument/hover'（通过 |lsp-defaults| 的 `K` 或 |vim.lsp.buf.hover()|）- 在光标处显示更多信息。例如特定待处理更改的详细信息或更新的标签。
        • 'textDocument/codeAction'（通过 |lsp-defaults| 的 `gra` 或 |vim.lsp.buf.code_action()|）- 显示可用于"光标处插件"的代码操作。例如"删除"、"更新"或"跳过更新"。
        执行 |:write| 以确认更新，执行 |:quit| 以丢弃更新。
      • 如果为 `true`，立即进行更新。

    注意：
    • 每个实际更新都会记录在 "log" |stdpath()| 中的 "nvim-pack.log" 文件中。

    参数：~
      • {names}  (`string[]?`) 要更新的插件名称列表。必须由 |vim.pack| 管理，不一定已添加到当前会话。默认：所有由 |vim.pack| 管理的插件的名称。
      • {opts}   (`table?`) 具有以下字段的表：
                 • {force}? (`boolean`) 是否跳过确认并立即进行更新。默认为 `false`。


 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
