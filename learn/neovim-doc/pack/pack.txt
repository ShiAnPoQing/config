*pack.txt*                            Nvim

                            NVIM 参考手册

                                扩展 Nvim


                                       输入 |gO| 查看目录。

==============================================================================
使用 Vim 包                                              *packages*

一个 Vim "包" 是一个包含 |plugin|s 的目录。与普通插件相比，一个包可以...
- 作为归档文件下载并在自己的目录中解包，因此文件不会与其他插件的文件混合。
- 是一个 git、mercurial 等仓库，因此易于更新。
- 包含多个相互依赖的插件。
- 包含在启动时自动加载的插件（"start" 包，
  位于 "pack/*/start/*"）和仅在需要时通过
  |:packadd| 加载的插件（"opt" 包，位于 "pack/*/opt/*"）。

                                                        *runtime-search-path*
Nvim 在以下位置搜索 |:runtime| 文件：
- 1. 'runtimepath' 中的所有路径
- 2. 所有 "pack/*/start/*" 目录

注意，"pack/*/start/*" 路径没有显式包含在
'runtimepath' 中，因此它们不会通过 ":set rtp" 或 "echo &rtp" 报告。
脚本可以使用 |nvim_list_runtime_paths()| 列出所有使用的目录，以及
|nvim_get_runtime_file()| 来查询运行时路径中的特定文件或子文件夹。示例：>
    " 列出所有运行时目录和带有 Lua 路径的包。
    :echo nvim_get_runtime_file("lua/", v:true)

使用包并自动加载 ~

假设你的 Nvim 文件在 "~/.local/share/nvim/site" 中，你想要
从 zip 归档 "/tmp/foopack.zip" 添加一个包：>
    % mkdir -p ~/.local/share/nvim/site/pack/foo
    % cd ~/.local/share/nvim/site/pack/foo
    % unzip /tmp/foopack.zip

目录名 "foo" 是任意的，你可以选择任何你喜欢的名称。

你现在在 ~/.local/share/nvim/site 下会有这些文件：>
    pack/foo/README.txt
    pack/foo/start/foobar/plugin/foo.vim
    pack/foo/start/foobar/syntax/some.vim
    pack/foo/opt/foodebug/plugin/debugger.vim

在处理完你的 |config| 后启动时，Nvim 扫描 'packpath' 中的所有目录
中的 "pack/*/start/*" 插件，然后加载这些插件。

为了允许在解析你的 |vimrc| 时调用包功能，
|:colorscheme| 和 |autoload| 都会自动搜索 'packpath'
以及 'runtimepath'。有关详细信息，请参阅每个的文档。

在示例中，Nvim 将找到 "pack/foo/start/foobar/plugin/foo.vim" 并加载
它。

如果 "foobar" 插件启动并将 'filetype' 设置为 "some"，Nvim 将
找到 syntax/some.vim 文件，因为它的目录在运行时搜索路径中。

Nvim 也会加载 ftdetect 文件，如果有的话。

注意，"pack/foo/opt" 下的文件不会自动加载，只有
"pack/foo/start" 下的文件会被加载。有关 "opt" 目录
的用法，请参阅下面的 |pack-add|。

如果禁用了插件加载，自动加载包将不会发生，
参见 |load-plugins|。

要更早地加载包，以便 plugin/ 文件被源入：
    :packloadall
这在禁用插件加载时也有效。自动加载只会发生一次。

如果包有一个 "after" 目录，该目录会被添加到 'runtimepath' 的末尾，
以便那里的任何内容都会在稍后被加载。


使用单个插件并自动加载它 ~

如果你没有包而只有一个插件，你需要创建额外的
目录层级：>
    % mkdir -p ~/.local/share/nvim/site/pack/foo/start/foobar
    % cd ~/.local/share/nvim/site/pack/foo/start/foobar
    % unzip /tmp/someplugin.zip

你现在会有这些文件：>
    pack/foo/start/foobar/plugin/foo.vim
    pack/foo/start/foobar/syntax/some.vim

从这里开始，它的工作方式如上所述。


可选插件 ~
                                                        *pack-add*
要从包中加载可选插件，使用 `:packadd` 命令：>
    :packadd foodebug
这会在 'packpath' 中搜索 "pack/*/opt/foodebug" 并会找到
~/.local/share/nvim/site/pack/foo/opt/foodebug/plugin/debugger.vim 并源入
它。

这可以在满足某些条件时完成。例如，取决于
Nvim 是否支持某个功能或是否缺少依赖项。

你也可以在启动时加载可选插件，通过将此命令放入
你的 |config| 中：>
    :packadd! foodebug
额外的 "!" 是为了在 Nvim 以 |--noplugin| 启动时不加载插件。

一个包只有 "opt" 目录中的文件是完全正常的。
然后你需要在想要使用每个插件时加载它们。


什么放在哪里 ~

由于通过 `:colorscheme` 加载的颜色方案可以在
"pack/*/start" 和 "pack/*/opt" 下找到，你可以将它们放在任何地方。我们建议
你将它们放在 "pack/*/opt" 下，例如
"~/.config/nvim/pack/mycolors/opt/dark/colors/very_dark.vim"。

文件类型插件应该放在 "pack/*/start" 下，以便它们总是
被找到。除非你有一个文件类型有多个插件并想要
通过 `:packadd` 选择加载哪一个。例如，取决于编译器
版本：>
    if foo_compiler_version > 34
      packadd foo_new
    else
      packadd foo_old
    endif

"after" 目录在包中很可能没有用。不过
并不禁止。

==============================================================================
创建 Vim 包                                           *package-create*

这假设你编写一个或多个作为包分发的插件。

如果你有两个不相关的插件，你会使用两个包，这样 Vim
用户可以选择他们包含什么或不包含什么。或者你可以决定使用一个
带有可选插件的包，并告诉用户使用
`:packadd` 添加首选的插件。

决定你想要如何分发包。你可以创建一个归档文件或者
你可以使用一个仓库。归档文件可以被更多用户使用，但
更新到新版本有点困难。仓库通常可以轻松保持
最新，但它需要像 "git" 这样的程序可用。
你可以两者都做，github 可以自动为发布创建归档。

你的目录布局会是这样的：>
   start/foobar/plugin/foo.vim          " 总是加载，定义命令
   start/foobar/plugin/bar.vim          " 总是加载，定义命令
   start/foobar/autoload/foo.vim        " 当使用 foo 命令时加载
   start/foobar/doc/foo.txt             " foo.vim 的帮助
   start/foobar/doc/tags                " 帮助标签
   opt/fooextra/plugin/extra.vim        " 可选插件，定义命令
   opt/fooextra/autoload/extra.vim      " 当使用 extra 命令时加载
   opt/fooextra/doc/extra.txt           " extra.vim 的帮助
   opt/fooextra/doc/tags                " 帮助标签
<
这允许用户这样做：>
    mkdir ~/.local/share/nvim/site/pack
    cd ~/.local/share/nvim/site/pack
    git clone https://github.com/you/foobar.git myfoobar

这里 "myfoobar" 是用户可以选择的一个名称，唯一的条件是它
与其他包不同。

在你的文档中，你解释插件的作用，并告诉用户如何
加载可选插件：>
    :packadd! fooextra

你可以在你的一个插件中添加这个 packadd 命令，以便在
需要可选插件时执行。

运行 `:helptags` 命令来生成 doc/tags 文件。在包中包含这个
生成的文件意味着用户可以将包放入 pack 目录
并且帮助命令立即工作。更改插件帮助后不要忘记重新运行
该命令：>
    :helptags path/start/foobar/doc
    :helptags path/opt/fooextra/doc


插件之间的依赖关系 ~
                                                        *packload-two-steps*
假设你有两个插件依赖于相同的功能。你可以
将通用功能放在一个 autoload 目录中，以便它会被
自动找到。你的包会有这些文件：

pack/foo/start/one/plugin/one.vim  >
    call foolib#getit()
pack/foo/start/two/plugin/two.vim >
    call foolib#getit()
pack/foo/start/lib/autoload/foolib.vim >
    func foolib#getit()

这是有效的，因为当源入插件时，start 包将被搜索以查找 autoload 文件。

==============================================================================
插件管理器                                                      *vim.pack*

进行中的内置插件管理器！欢迎对现有功能进行早期测试，
但请注意可能会有破坏性更改而不另行通知。

仅在专用的 *vim.pack-directory* 中管理插件（参见 |packages|）：
`$XDG_DATA_HOME/nvim/site/pack/core/opt`。`$XDG_DATA_HOME/nvim/site` 需要
是 'packpath' 的一部分。它通常是，但在像 |--clean| 或启动期间设置 |$XDG_DATA_HOME| 的情况下可能不是。插件的子目录名称匹配
规范中的插件名称。假设目录中的所有插件都由 `vim.pack` 独占管理。

使用 Git 管理插件，需要至少版本 2.36 的 `git` 可执行文件。目标插件应该是具有遵循 semver 约定 `v<major>.<minor>.<patch>` 的命名标签版本的 Git 仓库。

示例工作流 ~

基本安装和管理：
• 将 |vim.pack.add()| 调用添加到 'init.lua'：>lua

    vim.pack.add({
      -- 安装 "plugin1" 并使用默认分支（通常是 `main` 或 `master`）
      'https://github.com/user/plugin1',

      -- 同上，但使用表（允许设置其他选项）
      { src = 'https://github.com/user/plugin1' },

      -- 指定插件名称（这里插件将被称为 "plugin2"
      -- 而不是 "generic-name"）
      { src = 'https://github.com/user/generic-name', name = 'plugin2' },

      -- 指定在安装和更新期间要遵循的版本
      {
        src = 'https://github.com/user/plugin3',
        -- 版本约束，参见 |vim.version.range()|
        version = vim.version.range('1.0'),
      },
      {
        src = 'https://github.com/user/plugin4',
        -- Git 分支、标签或提交哈希
        version = 'main',
      },
    })

    -- 插件代码可以在 `add()` 后直接使用
    plugin1 = require('plugin1')
<
• 重启 Nvim（例如，使用 |:restart|）。尚未安装的插件将在 `add()` 调用后以目标状态在磁盘上可用。
• 要使用新更改更新所有插件：
  • 执行 |vim.pack.update()|。这将从源下载更新并在单独的标签页中显示确认缓冲区。
  • 查看更改。要确认所有更新，执行 |:write|。要丢弃更新，执行 |:quit|。

切换插件版本：
• 更新 'init.lua' 中插件的所需 `version`。假设名为 'plugin1' 的插件已更改为 `vim.version.range('*')`。
• |:restart|。插件在磁盘上的实际状态尚未更改。
• 执行 `vim.pack.update({ 'plugin1' })`。
• 查看更改并确认或丢弃它们。如果丢弃，也要还原 'init.lua' 中的任何更改，否则下次运行 |vim.pack.update()| 时你会再次被提示。

冻结插件不被更新：
• 更新 'init.lua' 中插件的 `version` 设置为当前提交哈希。你可以通过运行 `vim.pack.update({ 'plugin-name' })` 并拉取描述当前状态的单词（看起来像 `abc12345`）来获取它。
• |:restart|。

解冻插件以开始接收更新：
• 更新 'init.lua' 中插件的 `version` 设置为任何你希望它更新的版本。
• |:restart|。

从磁盘删除插件：
• 使用 |vim.pack.del()| 并附带要删除的插件名称列表。确保它们的规范未包含在 'init.lua' 的 |vim.pack.add()| 调用中，否则它们将被重新安装。

可用的挂钩事件 ~
• *PackChangedPre* - 在尝试更改插件状态之前。
• *PackChanged* - 在插件状态已更改之后。

每个事件填充以下 |event-data| 字段：
• `kind` - 其中之一："install"（在磁盘上安装）、"update"（更新现有插件）、"delete"（从磁盘删除）。
• `spec` - 插件的规范，默认值已显式化。
• `path` - 插件目录的完整路径。


*vim.pack.Spec*

    字段：~
      • {src}       (`string`) 从中安装和拉取更新的 URI。允许 `git clone` 支持的任何格式。
      • {name}?     (`string`) 插件名称。将用作目录名称。默认：`src` 仓库名称。
      • {version}?  (`string|vim.VersionRange`) 用于安装和更新的版本。可以是：
                    • `nil`（无值，默认）以使用仓库的默认分支（通常是 `main` 或 `master`）。
                    • 字符串以使用特定分支、标签或提交哈希。
                    • |vim.version.range()| 的输出以安装版本约束内最大/最后的 semver 标签。
      • {data}?     (`any`) 与插件关联的任意数据。


add({specs}, {opts})                                          *vim.pack.add()*
    添加插件到当前会话
    • 对于每个规范，检查插件是否存在于 |vim.pack-directory| 磁盘上：
      • 如果存在，在此步骤中不执行任何操作。
      • 如果不存在，通过从 `src` 下载到 `name` 子目录（通过 `git clone`）来安装它，并更新状态以匹配 `version`（通过 `git checkout`）。
    • 对于每个插件，执行 |:packadd|（或可自定义的 `load` 函数）使其可被 Nvim 访问。

    注意：
    • 安装是并行完成的，但在继续下一个代码执行之前等待所有安装完成。
    • 如果插件已存在于磁盘上，则不会检查其当前状态。指定的 `version` 可能不是磁盘上实际存在的版本。执行 |vim.pack.update()| 以同步。
    • 在单个会话中第二次及以后添加插件不执行任何操作：只有第一次添加的数据被注册。

    参数：~
      • {specs}  (`(string|vim.pack.Spec)[]`) 插件规范列表。字符串项被视为 `src`。
      • {opts}   (`table?`) 具有以下字段的表：
                 • {load}?
                   (`boolean|fun(plug_data: {spec: vim.pack.Spec, path: string})`)
                   加载 `plugin/` 文件和 `ftdetect/` 脚本。
                   如果 `false`，工作方式类似 `:packadd!`。
                   如果是函数，则使用插件数据调用，并完全负责加载插件。
                   在启动期间默认 `false`，之后默认 `true`。
                 • {confirm}? (`boolean`) 是否要求用户确认初始安装。默认 `true`。

del({names})                                                  *vim.pack.del()*
    从磁盘删除插件

    参数：~
      • {names}  (`string[]`) 要从磁盘删除的插件名称列表。必须由 |vim.pack| 管理，不一定已添加到当前会话。

get()                                                         *vim.pack.get()*
    获取有关 |vim.pack| 管理的所有插件的数据

    返回：~
        (`table[]`) 具有以下字段的对象列表：
        • {spec} (`vim.pack.SpecResolved`) 一个 |vim.pack.Spec|，默认值已显式化。
        • {path} (`string`) 插件在磁盘上的路径。
        • {active} (`boolean`) 插件是否通过 |vim.pack.add()| 添加到当前会话。

update({names}, {opts})                                    *vim.pack.update()*
    更新插件
    • 从源下载新更改。
    • 推断更新信息（当前/目标状态、变更日志等）。
    • 取决于 `force`：
      • 如果 `false`，显示确认缓冲区。它列出所有设置要更新的插件的数据。以 `>` 开头的待处理更改将被应用，而以 `<` 开头的更改将被还原。它附加了特殊的进程中 LSP 服务器以提供更多交互功能。当前支持的方法：
        • 'textDocument/documentSymbol'（通过 |lsp-defaults| 的 `gO` 或 |vim.lsp.buf.document_symbol()|）- 显示缓冲区的结构。
        • 'textDocument/hover'（通过 |lsp-defaults| 的 `K` 或 |vim.lsp.buf.hover()|）- 在光标处显示更多信息。例如特定待处理更改或更新标签的详细信息。
        执行 |:write| 以确认更新，执行 |:quit| 以丢弃更新。
      • 如果 `true`，立即进行更新。

    注意：
    • 每个实际更新都记录在 "log" |stdpath()| 中的 "nvim-pack.log" 文件中。

    参数：~
      • {names}  (`string[]?`) 要更新的插件名称列表。必须由 |vim.pack| 管理，不一定已添加到当前会话。默认：通过 |vim.pack.add()| 添加到当前会话的所有插件的名称。
      • {opts}   (`table?`) 具有以下字段的表：
                 • {force}? (`boolean`) 是否跳过确认并立即进行更新。默认 `false`。


 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
