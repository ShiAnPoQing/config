*vimfn.txt*	Nvim


		  NVIM 参考手册


Vimscript 函数			*vimscript-functions* *builtin.txt*

关于按用途分组的函数，请参阅 |function-list|。

				      输入 |gO| 查看目录。
==============================================================================
1. 详情					*vimscript-functions-details*

abs({expr})                                                              *abs()*
		返回 {expr} 的绝对值。当 {expr} 求值为 |Float| 时，abs() 返回一个 |Float|。
		当 {expr} 可转换为 |Number| 时，abs() 返回一个 |Number|。
		否则 abs() 给出错误消息并返回 -1。
		示例: >vim
			echo abs(1.456)
<			1.456  >vim
			echo abs(-5.456)
<			5.456  >vim
			echo abs(-4)
<			4

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`数值`)

acos({expr})                                                            *acos()*
		返回以弧度测量的 {expr} 的反余弦值，作为范围在 [0, pi] 内的 |Float|。
		{expr} 必须求值为 |Float| 或在范围 [-1, 1] 内的 |Number|。
		如果 {expr} 超出范围 [-1, 1]，返回 NaN。如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo acos(0)
<			1.570796 >vim
			echo acos(-0.5)
<			2.094395

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`数值`)

add({object}, {expr})                                                    *add()*
		将项 {expr} 追加到 |List| 或 |Blob| {object}。返回结果 |List| 或 |Blob|。
		示例: >vim
			let alist = add([1, 2, 3], item)
			call add(mylist, "woodstock")
<		注意当 {expr} 是 |List| 时，它作为单个项被追加。使用 |extend()| 来连接 |List|。
		当 {object} 是 |Blob| 时，{expr} 必须是数字。
		使用 |insert()| 在另一个位置添加项。
		如果 {object} 不是 |List| 或 |Blob|，返回 1。

                参数: ~
                  • {object} (`任意`)
                  • {expr} (`任意`)

                返回值: ~
                  (`任意`) 结果 |List| 或 |Blob|，或如果 {object} 不是 |List| 或 |Blob| 则为 1。

and({expr}, {expr})                                                      *and()*
		对两个参数进行按位与运算。参数被转换为数字。
		List、Dict 或 Float 参数会导致错误。
		另见 `or()` 和 `xor()`。
		示例: >vim
			let flag = and(bits, 0x80)
<

                参数: ~
                  • {expr} (`数值`)
                  • {expr1} (`数值`)

                返回值: ~
                  (`整数`)

api_info()                                                          *api_info()*
		返回 |api-metadata| 的字典。

		以美观的人类可读格式查看: >vim
		       lua vim.print(vim.fn.api_info())
<

                返回值: ~
                  (`表格`)

append({lnum}, {text})                                                *append()*
		当 {text} 是 |List| 时：将 |List| 的每个项作为文本行追加到当前缓冲区中行 {lnum} 下方。
		否则将 {text} 作为一个文本行追加到当前缓冲区中行 {lnum} 下方。
		接受任何类型的项并转换为字符串。
		{lnum} 可以为零以在第一行之前插入一行。
		{lnum} 的用法同 |getline()|。
		失败返回 1（{lnum} 超出范围或内存不足），成功返回 0。
		当 {text} 是空列表时返回零，无论 {lnum} 的值如何。
		示例: >vim
			let failed = append(line('$'), "# THE END")
			let failed = append(0, ["Chapter 1", "the beginning"])
<

                参数: ~
                  • {lnum} (`整数|字符串`)
                  • {text} (`字符串|字符串[]`)

                返回值: ~
                  (`0|1`)

appendbufline({buf}, {lnum}, {text})                           *appendbufline()*
		类似 |append()|，但在缓冲区 {expr} 中追加文本。

		此函数仅对已加载的缓冲区有效。如果需要，首先调用 |bufload()|。

		关于 {buf} 的使用，参见 |bufname()|。

		{lnum} 是要在下方追加的行号。注意使用 |line()| 会使用当前缓冲区，而不是要追加的缓冲区。
		使用 "$" 追加到缓冲区末尾。不支持其他字符串值。

		成功返回 0，失败返回 1。

		如果 {buf} 不是有效的缓冲区或 {lnum} 无效，会给出错误消息。
		示例: >vim
			let failed = appendbufline(13, 0, "# THE START")
<		但是，当 {text} 是空列表时，对于无效的 {lnum} 不会给出错误，因为 {lnum} 实际上并未使用。

                参数: ~
                  • {buf} (`整数|字符串`)
                  • {lnum} (`整数`)
                  • {text} (`字符串`)

                返回值: ~
                  (`0|1`)

argc([{winid}])                                                         *argc()*
		结果是参数列表中的文件数。参见 |arglist|。
		如果不提供 {winid}，则使用当前窗口的参数列表。
		如果 {winid} 是 -1，则使用全局参数列表。
		否则 {winid} 指定使用哪个窗口的参数列表：可以是窗口编号或窗口 ID。
		如果 {winid} 参数无效，返回 -1。

                参数: ~
                  • {winid} (`整数?`)

                返回值: ~
                  (`整数`)

argidx()                                                              *argidx()*
		结果是参数列表中的当前索引。0 是第一个文件。argc() - 1 是最后一个。参见 |arglist|。

                返回值: ~
                  (`整数`)

arglistid([{winnr} [, {tabnr}]])                                   *arglistid()*
		返回参数列表 ID。这是一个标识正在使用的参数列表的数字。零用于全局参数列表。参见 |arglist|。
		如果参数无效，返回 -1。

		不带参数时使用当前窗口。
		带 {winnr} 时仅使用当前标签页中的该窗口。
		带 {winnr} 和 {tabnr} 时使用指定标签页中的窗口。
		{winnr} 可以是窗口编号或 |window-ID|。

                参数: ~
                  • {winnr} (`整数?`)
                  • {tabnr} (`整数?`)

                返回值: ~
                  (`整数`)

argv([{nr} [, {winid}]])                                                *argv()*
		结果是参数列表中的第 {nr} 个文件。参见 |arglist|。"argv(0)" 是第一个。
		示例: >vim
			let i = 0
			while i < argc()
			  let f = escape(fnameescape(argv(i)), '.')
			  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'
			  let i = i + 1
			endwhile
<		如果没有 {nr} 参数，或者当 {nr} 是 -1 时，返回包含整个 |arglist| 的 |List|。

		{winid} 参数指定窗口 ID，参见 |argc()|。
		关于 Vim 命令行参数，参见 |v:argv|。

		如果第 {nr} 个参数不在参数列表中，返回空字符串。
		如果 {winid} 参数无效，返回空列表。

                参数: ~
                  • {nr} (`整数?`)
                  • {winid} (`整数?`)

                返回值: ~
                  (`字符串|字符串[]`)

asin({expr})                                                            *asin()*
		返回以弧度测量的 {expr} 的反正弦值，作为范围在 [-pi/2, pi/2] 内的 |Float|。
		{expr} 必须求值为 |Float| 或在范围 [-1, 1] 内的 |Number|。
		如果 {expr} 超出范围 [-1, 1]，返回 NaN。如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo asin(0.8)
<			0.927295 >vim
			echo asin(-0.5)
<			-0.523599

                参数: ~
                  • {expr} (`任意`)

                返回值: ~
                  (`数值`)

assert_beeps({cmd})                                             *assert_beeps()*
		运行 {cmd} 并在它不产生蜂鸣或可视响铃时向 |v:errors| 添加错误消息。
		另见 |assert_fails()|、|assert_nobeep()| 和 |assert-return|。

                参数: ~
                  • {cmd} (`字符串`)

                返回值: ~
                  (`0|1`)

assert_equal({expected}, {actual} [, {msg}])                    *assert_equal()*
		当 {expected} 和 {actual} 不相等时，向 |v:errors| 添加错误消息并返回 1。否则返回零。|assert-return|
		错误的形式为 "Expected {expected} but got {actual}"。
		当存在 {msg} 时，它会作为前缀，并附带从脚本运行断言时的位置。

		没有自动转换，字符串 "4" 与数字 4 不同。数字 4 与浮点数 4.0 不同。
		这里不使用 'ignorecase' 的值，大小写总是有区别的。
		示例: >vim
			call assert_equal('foo', 'bar', 'baz')
<		将向 |v:errors| 添加以下内容:
			test.vim line 12: baz: Expected 'foo' but got 'bar' ~

                参数: ~
                  • {expected} (`任意`)
                  • {actual} (`任意`)
                  • {msg} (`任意?`)

                返回值: ~
                  (`0|1`)

assert_equalfile({fname_one}, {fname_two})                  *assert_equalfile()*
		当文件 {fname_one} 和 {fname_two} 不包含完全相同的文本时，向 |v:errors| 添加错误消息。
		另见 |assert-return|。
		如果 {fname_one} 或 {fname_two} 不存在，错误将提及这一点。

                参数: ~
                  • {fname_one} (`字符串`)
                  • {fname_two} (`字符串`)

                返回值: ~
                  (`0|1`)

assert_exception({error} [, {msg}])                         *assert_exception()*
		当 v:exception 不包含字符串 {error} 时，向 |v:errors| 添加错误消息。另见 |assert-return|。
		这可用于断言命令抛出异常。
		使用错误号，后跟冒号，可以避免翻译问题: >vim
			try
			  commandthatfails
			  call assert_false(1, 'command should have failed')
			catch
			  call assert_exception('E492:')
			endtry
<

                参数: ~
                  • {error} (`任意`)
                  • {msg} (`任意?`)

                返回值: ~
                  (`0|1`)

                                                                *assert_fails()*
assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])
		运行 {cmd} 并在它不产生错误或未在错误消息中找到 {error} 时向 |v:errors| 添加错误消息。
		另见 |assert-return|。

		当 {error} 是字符串时，它必须字面出现在第一个报告的错误中。通常这是错误代码，包括冒号，例如 "E123:"。>vim
			call assert_fails('bad cmd', 'E987:')
<
		当 {error} 是包含一个或两个字符串的 |List| 时，这些字符串用作模式。
		第一个模式与第一个报告的错误匹配: >vim
			call assert_fails('cmd', ['E987:.*expected bool'])
<		第二个模式（如果存在）与最后一个报告的错误匹配。要仅匹配最后一个错误，对第一个错误使用空字符串: >vim
			call assert_fails('cmd', ['', 'E987:'])
<
		如果 {msg} 为空，则不使用它。在传递 {lnum} 参数时这样做以获取默认消息。
							*E1115*
		当存在 {lnum} 且不为负，并且存在 {error} 参数且匹配时，将其与报告错误的行号进行比较。
		这可以是函数或脚本中的行号。
							*E1116*
		当存在 {context} 时，它用作模式并与 {lnum} 所在位置的上下文（脚本名或函数名）匹配。

		注意蜂鸣不被视为错误，一些失败的命令只会蜂鸣。对这些命令使用 |assert_beeps()|。

                参数: ~
                  • {cmd} (`字符串`)
                  • {error} (`任意?`)
                  • {msg} (`任意?`)
                  • {lnum} (`整数?`)
                  • {context} (`任意?`)

                返回值: ~
                  (`0|1`)

assert_false({actual} [, {msg}])                                *assert_false()*
		当 {actual} 不为假时，向 |v:errors| 添加错误消息，类似 |assert_equal()|。
		错误的形式为 "Expected False but got {actual}"。
		当存在 {msg} 时，它会作为前缀，并附带从脚本运行断言时的位置。
		另见 |assert-return|。

		当值为零时为假。当 {actual} 不是数字时断言失败。

                参数: ~
                  • {actual} (`任意`)
                  • {msg} (`任意?`)

                返回值: ~
                  (`0|1`)

assert_inrange({lower}, {upper}, {actual} [, {msg}])          *assert_inrange()*
		此断言针对数字和 |Float| 值。当 {actual} 低于 {lower} 或高于 {upper} 时，向 |v:errors| 添加错误消息。
		另见 |assert-return|。
		错误的形式为 "Expected range {lower} - {upper}, but got {actual}"。
		当存在 {msg} 时，它会作为前缀。

                参数: ~
                  • {lower} (`数值`)
                  • {upper} (`数值`)
                  • {actual} (`数值`)
                  • {msg} (`字符串?`)

                返回值: ~
                  (`0|1`)

assert_match({pattern}, {actual} [, {msg}])                     *assert_match()*
		当 {pattern} 不匹配 {actual} 时，向 |v:errors| 添加错误消息。另见 |assert-return|。
		错误的形式为 "Pattern {pattern} does not match {actual}"。
		当存在 {msg} 时，它会作为前缀，并附带从脚本运行断言时的位置。

		{pattern} 的用法同 |expr-=~|：匹配总是像设置了 'magic' 且 'cpoptions' 为空一样进行，无论 'magic' 或 'cpoptions' 的实际值如何。

		{actual} 用作字符串，应用自动转换。
		使用 "^" 和 "$" 来匹配文本的开头和结尾。同时使用两者来匹配整个文本。

		示例: >vim
			call assert_match('^f.*o$', 'foobar')
<		将导致向 |v:errors| 添加字符串:
			test.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~

                参数: ~
                  • {pattern} (`字符串`)
                  • {actual} (`字符串`)
                  • {msg} (`字符串?`)

                返回值: ~
                  (`0|1`)

assert_nobeep({cmd})                                           *assert_nobeep()*
		运行 {cmd} 并在它产生蜂鸣或可视响铃时向 |v:errors| 添加错误消息。
		另见 |assert_beeps()|。

                参数: ~
                  • {cmd} (`字符串`)

                返回值: ~
                  (`0|1`)

assert_notequal({expected}, {actual} [, {msg}])              *assert_notequal()*
		`assert_equal()` 的反义：当 {expected} 和 {actual} 相等时向 |v:errors| 添加错误消息。
		另见 |assert-return|。

                参数: ~
                  • {expected} (`任意`)
                  • {actual} (`任意`)
                  • {msg} (`任意?`)

                返回值: ~
                  (`0|1`)

assert_notmatch({pattern}, {actual} [, {msg}])               *assert_notmatch()*
		`assert_match()` 的反义：当 {pattern} 匹配 {actual} 时向 |v:errors| 添加错误消息。
		另见 |assert-return|。

                参数: ~
                  • {pattern} (`字符串`)
                  • {actual} (`字符串`)
                  • {msg} (`字符串?`)

                返回值: ~
                  (`0|1`)

assert_report({msg})                                           *assert_report()*
		直接报告测试失败，使用字符串 {msg}。
		总是返回一。

                参数: ~
                  • {msg} (`字符串`)

                返回值: ~
                  (`0|1`)

assert_true({actual} [, {msg}])                                  *assert_true()*
		当 {actual} 不为真时，向 |v:errors| 添加错误消息，类似 |assert_equal()|。
		另见 |assert-return|。
		当值为非零数字或 |v:true| 时为 |TRUE|。
		当 {actual} 不是数字或 |v:true| 时断言失败。
		当给出 {msg} 时，它会作为前缀，并附带从脚本运行断言时的位置。

                参数: ~
                  • {actual} (`任意`)
                  • {msg} (`字符串?`)

                返回值: ~
                  (`0|1`)

atan({expr})                                                            *atan()*
		返回 {expr} 的反正切主值，范围在 [-pi/2, +pi/2] 弧度内，作为 |Float|。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo atan(100)
<			1.560797 >vim
			echo atan(-4.01)
<			-1.326405

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`数值`)

atan2({expr1}, {expr2})                                                *atan2()*
		返回 {expr1} / {expr2} 的反正切，以弧度测量，作为范围在 [-pi, pi] 内的 |Float|。
		{expr1} 和 {expr2} 必须求值为 |Float| 或 |Number|。
		如果 {expr1} 或 {expr2} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo atan2(-1, 1)
<			-0.785398 >vim
			echo atan2(1, -1)
<			2.356194

                参数: ~
                  • {expr1} (`数值`)
                  • {expr2} (`数值`)

                返回值: ~
                  (`数值`)

blob2list({blob})                                                  *blob2list()*
		返回一个包含 Blob {blob} 中每个字节数值的列表。
		示例: >vim
			blob2list(0z0102.0304)	" 返回 [1, 2, 3, 4]
			blob2list(0z)		" 返回 []
<		出错时返回空列表。|list2blob()| 执行相反操作。

                参数: ~
                  • {blob} (`任意`)

                返回值: ~
                  (`任意[]`)

browse({save}, {title}, {initdir}, {default})                         *browse()*
		弹出文件请求器。这仅在 "has("browse")" 返回 |TRUE| 时有效（仅在某些 GUI 版本中）。
		输入字段为:
		    {save}	当 |TRUE| 时，选择要写入的文件
		    {title}	请求器的标题
		    {initdir}	开始浏览的目录
		    {default}	默认文件名
		当点击“取消”按钮、出现错误或无法浏览时，返回空字符串。

                参数: ~
                  • {save} (`任意`)
                  • {title} (`字符串`)
                  • {initdir} (`字符串`)
                  • {default} (`字符串`)

                返回值: ~
                  (`0|1`)

browsedir({title}, {initdir})                                      *browsedir()*
		弹出目录请求器。这仅在 "has("browse")" 返回 |TRUE| 时有效（仅在某些 GUI 版本中）。
		在不支持目录浏览器的系统上，使用文件浏览器。在这种情况下：选择要使用的目录中的文件。
		输入字段为:
		    {title}	请求器的标题
		    {initdir}	开始浏览的目录
		当点击“取消”按钮、出现错误或无法浏览时，返回空字符串。

                参数: ~
                  • {title} (`字符串`)
                  • {initdir} (`字符串`)

                返回值: ~
                  (`0|1`)

bufadd({name})                                                        *bufadd()*
		使用名称 {name}（必须是字符串）向缓冲区列表添加缓冲区。
		如果文件 {name} 的缓冲区已存在，返回该缓冲区编号。否则返回新创建的缓冲区的编号。
		当 {name} 是空字符串时，总是创建新缓冲区。
		缓冲区将不设置 'buflisted' 且尚未加载。
		要向缓冲区添加一些文本，使用: >vim
			let bufnr = bufadd('someName')
			call bufload(bufnr)
			call setbufline(bufnr, 1, ['some', 'text'])
<		出错时返回 0。

                参数: ~
                  • {name} (`字符串`)

                返回值: ~
                  (`整数`)

bufexists({buf})                                                   *bufexists()*
		结果是一个数字，如果名为 {buf} 的缓冲区存在，则为 |TRUE|。
		如果 {buf} 参数是数字，则使用缓冲区编号。数字零是当前窗口的备用缓冲区。

		如果 {buf} 参数是字符串，它必须完全匹配缓冲区名称。名称可以是:
		- 相对于当前目录。
		- 完整路径。
		- 'buftype' 设置为 "nofile" 的缓冲区名称。
		- URL 名称。
		将找到未列出的缓冲区。
		注意帮助文件在 |:buffers| 的输出中以其短名称列出，但 bufexists() 需要使用其长名称才能找到它们。
		bufexists() 可能报告缓冲区存在，但要使用 |:buffer| 命令使用该名称，可能需要使用 |expand()|。
		特别是对于 MS-Windows 8.3 名称，形式为 "c:\DOCUME~1"。
		使用 "bufexists(0)" 来测试备用文件名是否存在。

                参数: ~
                  • {buf} (`任意`)

                返回值: ~
                  (`0|1`)

buflisted({buf})                                                   *buflisted()*
		结果是一个数字，如果名为 {buf} 的缓冲区存在且已列出（设置了 'buflisted' 选项），则为 |TRUE|。
		{buf} 参数的用法同 |bufexists()|。

                参数: ~
                  • {buf} (`任意`)

                返回值: ~
                  (`0|1`)

bufload({buf})                                                       *bufload()*
		确保缓冲区 {buf} 已加载。当缓冲区名称引用现有文件时，读取该文件。否则缓冲区将为空。
		如果缓冲区已加载，则没有变化。如果缓冲区与文件无关，则不读取文件（例如，当 'buftype' 为 "nofile" 时）。
		如果缓冲区文件存在交换文件，不会有对话框，缓冲区仍会被加载。
		{buf} 参数的用法同 |bufexists()|。

                参数: ~
                  • {buf} (`任意`)

bufloaded({buf})                                                   *bufloaded()*
		结果是一个数字，如果名为 {buf} 的缓冲区存在且已加载（显示在窗口中或隐藏），则为 |TRUE|。
		{buf} 参数的用法同 |bufexists()|。

                参数: ~
                  • {buf} (`任意`)

                返回值: ~
                  (`0|1`)

bufname([{buf}])                                                     *bufname()*
		结果是缓冲区的名称。大多如 `:ls` 命令显示的那样，但不使用特殊名称如 "[No Name]"。
		如果省略 {buf}，使用当前缓冲区。
		如果 {buf} 是数字，则给出该缓冲区编号的名称。数字零是当前窗口的备用缓冲区。
		如果 {buf} 是字符串，它用作 |file-pattern| 来匹配缓冲区名称。
		这总是像设置了 'magic' 且 'cpoptions' 为空一样进行。当有多个匹配时返回空字符串。
		"" 或 "%" 可用于当前缓冲区，"#" 用于备用缓冲区。
		优先完全匹配，否则接受在缓冲区名称的开头、结尾或中间的匹配。
		如果只想要完全匹配，则在模式的开头加上 "^"，结尾加上 "$"。
		首先找到列出的缓冲区。如果有一个列出的缓冲区匹配，则返回该缓冲区。
		接下来搜索未列出的缓冲区。
		如果 {buf} 是字符串，但想将其用作缓冲区编号，通过加零强制其为数字: >vim
			echo bufname("3" + 0)
<		如果缓冲区不存在或没有名称，返回空字符串。>vim
			echo bufname("#")	" 备用缓冲区名称
			echo bufname(3)		" 缓冲区 3 的名称
			echo bufname("%")	" 当前缓冲区的名称
			echo bufname("file2")	" 缓冲区名称匹配 "file2" 的名称。
<

                参数: ~
                  • {buf} (`整数|字符串?`)

                返回值: ~
                  (`字符串`)

bufnr([{buf} [, {create}]])                                            *bufnr()*
		结果是缓冲区的编号，如 `:ls` 命令显示的那样。关于 {buf} 的使用，参见上面的 |bufname()|。
		如果缓冲区不存在，返回 -1。或者，如果存在 {create} 参数且为 TRUE，则创建新的未列出的缓冲区并返回其编号。
		bufnr("$") 是最后一个缓冲区: >vim
			let last_buffer = bufnr("$")
<		结果是一个数字，它是现有缓冲区的最高缓冲区编号。
		注意并非所有编号较小的缓冲区一定存在，因为 ":bwipeout" 可能已移除它们。
		使用 bufexists() 来测试缓冲区是否存在。

                参数: ~
                  • {buf} (`整数|字符串?`)
                  • {create} (`任意?`)

                返回值: ~
                  (`整数`)

bufwinid({buf})                                                     *bufwinid()*
		结果是一个数字，它是与缓冲区 {buf} 关联的第一个窗口的 |window-ID|。
		关于 {buf} 的使用，参见上面的 |bufname()|。
		如果缓冲区 {buf} 不存在或没有这样的窗口，返回 -1。
		示例: >vim

			echo "A window containing buffer 1 is " .. (bufwinid(1))
<
		仅处理当前标签页。参见 |win_findbuf()| 以查找更多。

                参数: ~
                  • {buf} (`任意`)

                返回值: ~
                  (`整数`)

bufwinnr({buf})                                                     *bufwinnr()*
		类似 |bufwinid()|，但返回窗口编号而不是 |window-ID|。
		如果缓冲区 {buf} 不存在或没有这样的窗口，返回 -1。
		示例: >vim

			echo "A window containing buffer 1 is " .. (bufwinnr(1))

<		该编号可与 |CTRL-W_w| 和 ":wincmd w" |:wincmd| 一起使用。

                参数: ~
                  • {buf} (`任意`)

                返回值: ~
                  (`整数`)

byte2line({byte})                                                  *byte2line()*
		返回当前缓冲区中包含字节计数 {byte} 处的字符的行号。
		这包括行尾字符，取决于当前缓冲区的 'fileformat' 选项。
		第一个字符的字节计数为一。
		另见 |line2byte()|、|go| 和 |:goto|。

		如果 {byte} 值无效，返回 -1。

                参数: ~
                  • {byte} (`任意`)

                返回值: ~
                  (`整数`)

byteidx({expr}, {nr} [, {utf16}])                                    *byteidx()*
		返回字符串 {expr} 中第 {nr} 个字符的字节索引。对第一个字符使用零，则返回零。
		如果没有多字节字符，返回值等于 {nr}。
		组合字符不单独计数，它们的字节长度添加到前一个基字符。
		关于单独计数组合字符，参见下面的 |byteidxcomp()|。
		当存在 {utf16} 且为 TRUE 时，{nr} 用作字符串 {expr} 中的 UTF-16 索引而不是字符索引。
		UTF-16 索引是字符串编码为 16 位字时的索引。
		如果指定的 UTF-16 索引在字符的中间（例如在 4 字节字符中），则返回该字符第一个字节的字节索引。
		更多信息请参考 |string-offset-encoding|。
		示例: >vim
			echo matchstr(str, ".", byteidx(str, 3))
<		将显示第四个字符。另一种做法: >vim
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		另见 |strgetchar()| 和 |strcharpart()|。

		如果字符少于 {nr} 个，返回 -1。
		如果正好有 {nr} 个字符，返回字符串的字节长度。
		关于从字节索引获取字符和 UTF-16 索引，参见 |charidx()| 和 |utf16idx()|。
		示例: >vim
			echo byteidx('a😊😊', 2)	" 返回 5
			echo byteidx('a😊😊', 2, 1)	" 返回 1
			echo byteidx('a😊😊', 3, 1)	" 返回 5
<

                参数: ~
                  • {expr} (`任意`)
                  • {nr} (`整数`)
                  • {utf16} (`任意?`)

                返回值: ~
                  (`整数`)

byteidxcomp({expr}, {nr} [, {utf16}])                            *byteidxcomp()*
		类似 byteidx()，但组合字符被计为单独的字符。
		示例: >vim
			let s = 'e' .. nr2char(0x301)
			echo byteidx(s, 1)
			echo byteidxcomp(s, 1)
			echo byteidxcomp(s, 2)
<		第一个和第三个 echo 结果为 3（'e' 加组合字符是 3 字节），第二个 echo 结果为 1（'e' 是一字节）。

                参数: ~
                  • {expr} (`任意`)
                  • {nr} (`整数`)
                  • {utf16} (`任意?`)

                返回值: ~
                  (`整数`)

call({func}, {arglist} [, {dict}])                                 *call()* *E699*
		使用 |List| {arglist} 中的项作为参数调用函数 {func}。
		{func} 可以是 |Funcref| 或函数名称。
		a:firstline 和 a:lastline 设置为光标行。
		返回被调用函数的返回值。
		{dict} 用于具有 "dict" 属性的函数。它将用于设置局部变量 "self"。|Dictionary-function|

                参数: ~
                  • {func} (`任意`)
                  • {arglist} (`任意`)
                  • {dict} (`任意?`)

                返回值: ~
                  (`任意`)

ceil({expr})                                                            *ceil()*
		返回大于或等于 {expr} 的最小整数值，作为 |Float|（向上取整）。
		{expr} 必须求值为 |Float| 或 |Number|。
		示例: >vim
			echo ceil(1.456)
<			2.0  >vim
			echo ceil(-5.456)
<			-5.0  >vim
			echo ceil(4.0)
<			4.0

		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`数值`)

chanclose({id} [, {stream}])                                       *chanclose()*
		关闭通道或与其关联的特定流。
		对于作业，{stream} 可以是 "stdin"、"stdout"、"stderr" 或 "rpc"（关闭以 `"rpc":v:true` 启动的作业的 stdin/stdout）
		如果省略 {stream}，则关闭所有流。如果通道是 pty，这将关闭 pty 主设备，向作业进程发送 SIGHUP。
		对于套接字，只有一个流，应省略 {stream}。

                参数: ~
                  • {id} (`整数`)
                  • {stream} (`字符串?`)

                返回值: ~
                  (`0|1`)

changenr()                                                          *changenr()*
		返回最近更改的编号。这与 |:undolist| 显示的数字相同，可与 |:undo| 命令一起使用。
		进行更改时，它是该更改的编号。重做后，它是重做更改的编号。撤销后，它比被撤销更改的编号小一。
		如果撤销列表为空，返回 0。

                返回值: ~
                  (`整数`)

chansend({id}, {data})                                              *chansend()*
		向通道 {id} 发送数据。对于作业，它写入进程的 stdin。
		对于 stdio 通道 |channel-stdio|，它写入 Nvim 的 stdout。
		如果写入成功，返回写入的字节数，否则返回 0。
		更多信息参见 |channel-bytes|。

		{data} 可以是字符串、可转换为字符串的对象、|Blob| 或列表。
		如果 {data} 是列表，项将由换行符连接；项中的任何换行符将作为 NUL 发送。
		要发送最终的换行符，包括一个最终的空字符串。
		示例: >vim
			call chansend(id, ["abc", "123\n456", ""])
<		将发送 "abc<NL>123<NUL>456<NL>"。

		chansend() 写入原始数据，而不是 RPC 消息。
		如果通道是用 `"rpc":v:true` 创建的，则通道期望 RPC 消息，请改用 |rpcnotify()| 和 |rpcrequest()|。

                参数: ~
                  • {id} (`数字`)
                  • {data} (`字符串|字符串[]`)

                返回值: ~
                  (`0|1`)

char2nr({string} [, {utf8}])                                         *char2nr()*
		返回 {string} 中第一个字符的数字值。
		示例: >vim
			echo char2nr(" ")	" 返回 32
			echo char2nr("ABC")	" 返回 65
			echo char2nr("á")	" 返回 225
			echo char2nr("á"[0])	" 返回 195
			echo char2nr("\<M-x>")	" 返回 128
<		非 ASCII 字符总是被视为 UTF-8 字符。
		{utf8} 被忽略，它仅用于向后兼容。
		组合字符是单独的字符。
		|nr2char()| 执行相反操作。

		如果 {string} 不是 |String|，返回 0。

                参数: ~
                  • {string} (`字符串`)
                  • {utf8} (`任意?`)

                返回值: ~
                  (`0|1`)

charclass({string})                                                *charclass()*
		返回 {string} 中第一个字符的字符类别。
		字符类别是以下之一:
			0	空白
			1	标点符号
			2	单词字符（取决于 'iskeyword'）
			3	表情符号
			other	特定 Unicode 类别
		该类别用于模式和单词移动。
		如果 {string} 不是 |String|，返回 0。

                参数: ~
                  • {string} (`字符串`)

                返回值: ~
                  (`0|1|2|3|'other'`)

charcol({expr} [, {winid}])                                          *charcol()*
		与 |col()| 相同，但返回 {expr} 给出的列位置的字符索引而不是字节位置。

		示例:
		光标位于第 5 行文本 "여보세요" 的 '세' 上时: >vim
			echo charcol('.')	" 返回 3
			echo col('.')		" 返回 7
<

                参数: ~
                  • {expr} (`字符串|任意[]`)
                  • {winid} (`整数?`)

                返回值: ~
                  (`整数`)

charidx({string}, {idx} [, {countcc} [, {utf16}]])                   *charidx()*
		返回 {string} 中字节 {idx} 处的字符索引。
		第一个字符的索引为零。
		如果没有多字节字符，返回值等于 {idx}。

		当 {countcc} 被省略或为 |FALSE| 时，组合字符不单独计数，它们的字节长度添加到前一个基字符。
		当 {countcc} 为 |TRUE| 时，组合字符被计为单独的字符。

		当存在 {utf16} 且为 TRUE 时，{idx} 用作字符串 {expr} 中的 UTF-16 索引而不是字节索引。

		如果参数无效或字节数少于 {idx}，返回 -1。如果正好有 {idx} 字节，返回字符串的字符长度。

		如果第一个参数不是字符串，第二个参数不是数字，或者第三个参数存在且不是零或一，会给出错误并返回 -1。

		关于从字符索引获取字节索引，参见 |byteidx()| 和 |byteidxcomp()|，关于从字符索引获取 UTF-16 索引，参见 |utf16idx()|。
		更多信息请参考 |string-offset-encoding|。
		示例: >vim
			echo charidx('áb́ć', 3)		" 返回 1
			echo charidx('áb́ć', 6, 1)	" 返回 4
			echo charidx('áb́ć', 16)		" 返回 -1
			echo charidx('a😊😊', 4, 0, 1)	" 返回 2
<

                参数: ~
                  • {string} (`字符串`)
                  • {idx} (`整数`)
                  • {countcc} (`布尔值?`)
                  • {utf16} (`布尔值?`)

                返回值: ~
                  (`整数`)

chdir({dir} [, {scope}])                                               *chdir()*
		将当前工作目录更改为 {dir}。更改的范围如下确定:
		如果 {scope} 不存在，当前工作目录更改为当前目录的范围:
		    - 如果设置了窗口本地目录 (|:lcd|)，则更改该范围的当前工作目录。
		    - 否则，如果设置了标签页本地目录 (|:tcd|)，则更改该范围的当前目录。
		    - 否则，更改该范围的全局目录。

		如果 {scope} 存在，更改指定范围的当前工作目录:
		    "window"	更改窗口本地目录。|:lcd|
		    "tabpage"	更改标签页本地目录。|:tcd|
		    "global"	更改全局目录。|:cd|

		{dir} 必须是字符串。
		如果成功，返回先前的工作目录。将其传递给另一个 chdir() 以恢复目录。
		失败时返回空字符串。

		示例: >vim
			let save_dir = chdir(newdir)
			if save_dir != ""
			   " ... 做一些工作
			   call chdir(save_dir)
			endif
<

                参数: ~
                  • {dir} (`字符串`)
                  • {scope} (`字符串?`)

                返回值: ~
                  (`字符串`)

cindent({lnum})                                                      *cindent()*
		根据 |C-indenting| 规则获取行 {lnum} 的缩进量，如同 'cindent'。
		缩进以空格计数，'tabstop' 的值是相关的。
		{lnum} 的用法同 |getline()|。
		当 {lnum} 无效时返回 -1。

		要获取或设置字符串中行的缩进，参见 |vim.text.indent()|。

                参数: ~
                  • {lnum} (`整数|字符串`)

                返回值: ~
                  (`整数`)

clearmatches([{win}])                                           *clearmatches()*
		清除之前通过 |matchadd()| 和 |:match| 命令为当前窗口定义的所有匹配。
		如果指定了 {win}，则使用具有此编号或窗口 ID 的窗口而不是当前窗口。

                参数: ~
                  • {win} (`整数?`)

cmdcomplete_info()                                          *cmdcomplete_info()*
		返回包含有关命令行完成信息的 |Dictionary|。参见 |cmdline-completion|。
		项为:
		   cmdline_orig	完成开始前的原始命令行字符串。
		   pum_visible	如果弹出菜单可见则为 |TRUE|。
				参见 |pumvisible()|。
		   matches	所有完成候选的列表。每个项是一个字符串。
		   selected	选中的项索引。第一个索引为零。
				如果没有选中任何项（仅显示键入的文本，或在使用 <Up> 或 <Down> 键后没有选中任何项时的最后完成），索引为 -1。

		如果没有尝试完成，只有一个候选且已完全完成，或发生错误，返回空 |Dictionary|。

                返回值: ~
                  (`表格<字符串,任意>`)

col({expr} [, {winid}])                                                  *col()*
		结果是一个数字，它是 {expr} 给出的列位置的字节索引。
		关于可接受的位置，参见 |getpos()|。
		当 {expr} 是 "$" 时，表示光标行的末尾，因此结果是光标行的字节数加一。
		此外 {expr} 可以是 [lnum, col]：包含行号和列号的 |List|。当列是 "$" 时最有用，以获取特定行的最后一列。
		当 "lnum" 或 "col" 超出范围时，col() 返回零。

		使用可选的 {winid} 参数，获取该窗口的值而不是当前窗口。

		要获取行号，使用 |line()|。要同时获取两者，使用 |getpos()|。

		对于屏幕列位置，使用 |virtcol()|。对于字符位置，使用 |charcol()|。

		注意只能使用当前文件中的标记。

		示例: >vim
			echo col(".")			" 光标的列
			echo col("$")			" 光标行的长度加一
			echo col("'t")			" 标记 t 的列
			echo col("'" .. markname)	" 标记 markname 的列
<
		第一列是 1。如果 {expr} 无效或找不到 ID 为 {winid} 的窗口，返回 0。
		对于大写标记，列实际上可能在另一个缓冲区中。
		对于光标位置，当 'virtualedit' 激活时，如果光标在行尾之后，列会高一。
		另外，当使用 <Cmd> 映射时，光标不会移动，这可用于在插入模式中获取列: >vim
			imap <F2> <Cmd>echo col(".").."\n"<CR>
<

                参数: ~
                  • {expr} (`字符串|任意[]`)
                  • {winid} (`整数?`)

                返回值: ~
                  (`整数`)

complete({startcol}, {matches})                                *complete()* *E785*
		设置插入模式完成的匹配项。
		只能在插入模式中使用。需要使用带有 CTRL-R = 的映射（参见 |i_CTRL-R|）。
		在 CTRL-O 之后或使用表达式映射时不起作用。
		{startcol} 是行中完成文本开始的字节偏移量。
		光标之前的文本是将被匹配项替换的原始文本。对于空字符串使用 col('.')。
		"col('.') - 1" 将用一个匹配项替换一个字符。
		{matches} 必须是 |List|。每个 |List| 项是一个匹配项。
		关于可能的项类型，参见 |complete-items|。
		'completeopt' 中的 "longest" 被忽略。
		注意调用此函数后，需要避免插入任何会导致完成停止的内容。
		匹配项可以像插入模式完成一样使用 CTRL-N 和 CTRL-P 选择。
		如果指定，弹出菜单会出现，参见 |ins-completion-menu|。
		示例: >vim
			inoremap <F5> <C-R>=ListMonths()<CR>

			func ListMonths()
			  call complete(col('.'), ['January', 'February', 'March',
			    \ 'April', 'May', 'June', 'July', 'August', 'September',
			    \ 'October', 'November', 'December'])
			  return ''
			endfunc
<		这不太有用，但它展示了如何工作。注意返回空字符串以避免插入零。

                参数: ~
                  • {startcol} (`整数`)
                  • {matches} (`任意[]`)

complete_add({expr})                                            *complete_add()*
		将 {expr} 添加到匹配项列表中。仅由 'completefunc' 选项指定的函数使用。
		失败返回 0（空字符串或内存不足），当匹配项被添加时返回 1，当匹配项已在列表中时返回 2。
		关于 {expr} 的解释，参见 |complete-functions|。它与 'omnifunc' 返回的列表中的一个项相同。

                参数: ~
                  • {expr} (`任意`)

                返回值: ~
                  (`0|1|2`)

complete_check()                                              *complete_check()*
		检查在查找完成匹配项时是否键入了键。
		当查找匹配项需要一些时间时使用此函数。
		当需要中止搜索匹配项时返回 |TRUE|，否则返回零。
		仅由 'completefunc' 选项指定的函数使用。

                返回值: ~
                  (`0|1`)

complete_info([{what}])                                        *complete_info()*
		返回包含有关插入模式完成信息的 |Dictionary|。参见 |ins-completion|。
		项为:
		   mode		当前完成模式名称字符串。
				参见 |complete_info_mode| 了解值。
		   pum_visible	如果弹出菜单可见则为 |TRUE|。
				参见 |pumvisible()|。
		   items	所有完成候选的列表。每个项是一个包含条目 "word"、"abbr"、"menu"、"kind"、"info" 和 "user_data" 的字典。
				参见 |complete-items|。
		   matches	与 "items" 相同，但仅返回与当前查询匹配的项。如果 "matches" 和 "items" 都在 "what" 中，返回的列表仍将命名为 "items"，但每个项将有一个额外的 "match" 字段。
		   selected	选中的项索引。第一个索引为零。
				如果没有选中任何项（仅显示键入的文本，或在使用 <Up> 或 <Down> 键后没有选中任何项时的最后完成），索引为 -1。
		   completed	返回包含当前选中索引项条目的字典。
		   preview_winid     信息浮动预览窗口 ID。
		   preview_bufnr     信息浮动预览缓冲区 ID。

							*complete_info_mode*
		模式值为:
		   ""		     不在完成模式中
		   "keyword"	     关键字完成 |i_CTRL-X_CTRL-N|
		   "ctrl_x"	     刚按下 CTRL-X |i_CTRL-X|
		   "scroll"	     使用 |i_CTRL-X_CTRL-E| 或 |i_CTRL-X_CTRL-Y| 滚动
		   "whole_line"	     整行 |i_CTRL-X_CTRL-L|
		   "files"	     文件名 |i_CTRL-X_CTRL-F|
		   "tags"	     标签 |i_CTRL-X_CTRL-]|
		   "path_defines"    定义完成 |i_CTRL-X_CTRL-D|
		   "path_patterns"   包含完成 |i_CTRL-X_CTRL-I|
		   "dictionary"	     字典 |i_CTRL-X_CTRL-K|
		   "thesaurus"	     同义词词典 |i_CTRL-X_CTRL-T|
		   "cmdline"	     Vim 命令行 |i_CTRL-X_CTRL-V|
		   "function"	     用户定义完成 |i_CTRL-X_CTRL-U|
		   "omni"	     全能完成 |i_CTRL-X_CTRL-O|
		   "spell"	     拼写建议 |i_CTRL-X_s|
		   "eval"	     |complete()| 完成
		   "register"	     来自寄存器的单词 |i_CTRL-X_CTRL-R|
		   "unknown"	     其他内部模式

		如果提供了可选的 {what} 列表参数，则仅返回 {what} 中列出的项。{what} 中不支持的项被静默忽略。

		要获取弹出菜单的位置和大小，参见 |pum_getpos()|。在 |CompleteChanged| 事件期间，它也可在 |v:event| 中使用。

		出错时返回空 |Dictionary|。

		示例: >vim
			" 获取所有项
			call complete_info()
			" 仅获取 'mode'
			call complete_info(['mode'])
			" 仅获取 'mode' 和 'pum_visible'
			call complete_info(['mode', 'pum_visible'])
<

                参数: ~
                  • {what} (`任意[]?`)

                返回值: ~
                  (`表格`)

complete_match([{lnum}, {col}])                               *complete_match()*
		从给定位置向后搜索，并根据 'isexpand' 选项返回匹配项的列表。
		当没有提供参数时，使用当前光标位置。

		每个匹配项表示为一个包含 [startcol, trigger_text] 的列表，其中:
		- startcol: 完成应该开始的列位置，如果未找到触发位置则为 -1。对于多字符触发器，返回第一个字符的列。
		- trigger_text: 来自 'isexpand' 的匹配触发器字符串，如果未找到匹配或使用默认 'iskeyword' 模式则为空字符串。

		当 'isexpand' 为空时，使用 'iskeyword' 模式 "\k\+$" 查找当前关键字开头。

		示例: >vim
		  set isexpand=.,->,/,/*,abc
		  func CustomComplete()
		    let res = complete_match()
		    if res->len() == 0 | return | endif
		    let [col, trigger] = res[0]
		    let items = []
		    if trigger == '/*'
		      let items = ['/** */']
		    elseif trigger == '/'
		      let items = ['/*! */', '// TODO:', '// fixme:']
		    elseif trigger == '.'
		      let items = ['length()']
		    elseif trigger =~ '^\->'
		      let items = ['map()', 'reduce()']
		    elseif trigger =~ '^\abc'
		      let items = ['def', 'ghk']
		    endif
		    if items->len() > 0
		      let startcol = trigger =~ '^/' ? col : col + len(trigger)
		      call complete(startcol, items)
		    endif
		  endfunc
		  inoremap <Tab> <Cmd>call CustomComplete()<CR>
<

                参数: ~
                  • {lnum} (`整数?`)
                  • {col} (`整数?`)

                返回值: ~
                  (`表格`)

confirm({msg} [, {choices} [, {default} [, {type}]]])                *confirm()*
		confirm() 向用户提供一个对话框，可以从中做出选择。
		它返回选择的编号。对于第一个选择，这是 1。

		{msg} 显示在对话框中，{choices} 作为备选项。
		当 {choices} 缺失或为空时，使用 "&OK"（并翻译）。
		{msg} 是字符串，使用 '\n' 包含换行符。仅在某些系统上，当字符串不适合时会自动换行。

		{choices} 是字符串，各个选择用 '\n' 分隔，例如: >vim
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		'&' 后的字母是该选择的快捷键。
		因此可以键入 'c' 来选择 "Cancel"。快捷键不必是第一个字母: >vim
			confirm("file has been modified", "&Save\nSave &All")
<		对于控制台，每个选择的第一个字母用作默认快捷键。大小写被忽略。

		可选的 {type} 字符串参数给出对话框的类型。
		它可以是以下值之一: "Error"、"Question"、"Info"、"Warning" 或 "Generic"。仅第一个字符相关。
		当 {type} 被省略时，使用 "Generic"。

		可选的 {type} 参数给出对话框的类型。这仅用于 Win32 GUI 的图标。
		它可以是以下值之一: "Error"、"Question"、"Info"、"Warning" 或 "Generic"。仅第一个字符相关。
		当 {type} 被省略时，使用 "Generic"。

		如果用户通过按 <Esc>、CTRL-C 或其他有效中断键中止对话框，confirm() 返回 0。

		示例: >vim
		   let choice = confirm("What do you want?",
					\ "&Apples\n&Oranges\n&Bananas", 2)
		   if choice == 0
			echo "make up your mind!"
		   elseif choice == 3
			echo "tasteful"
		   else
			echo "I prefer bananas myself."
		   endif
<		在 GUI 对话框中，使用按钮。按钮的布局取决于 'guioptions' 中的 'v' 标志。
		如果包含它，按钮总是垂直放置。否则，confirm() 尝试将按钮放在一条水平线上。
		如果它们不合适，则使用垂直布局。对于某些系统，总是使用水平布局。

                参数: ~
                  • {msg} (`字符串`)
                  • {choices} (`字符串?`)
                  • {default} (`整数?`)
                  • {type} (`字符串?`)

                返回值: ~
                  (`整数`)

copy({expr})                                                            *copy()*
		创建 {expr} 的副本。对于数字和字符串，这与直接使用 {expr} 没有区别。
		当 {expr} 是 |List| 时，创建浅拷贝。这意味着原始 |List| 可以更改而不更改副本，反之亦然。
		但是项是相同的，因此更改项会更改两个 |List| 的内容。
		|Dictionary| 的复制方式与 |List| 类似。
		另见 |deepcopy()|。

                参数: ~
                  • {expr} (`T`)

                返回值: ~
                  (`T`)

cos({expr})                                                              *cos()*
		返回 {expr} 的余弦值，以弧度测量，作为 |Float|。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo cos(100)
<			0.862319 >vim
			echo cos(-4.01)
<			-0.646043

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`数值`)

cosh({expr})                                                            *cosh()*
		返回 {expr} 的双曲余弦值，作为范围在 [1, inf] 内的 |Float|。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo cosh(0.5)
<			1.127626 >vim
			echo cosh(-0.5)
<			-1.127626

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`数值`)

count({comp}, {expr} [, {ic} [, {start}]])                        *count()* *E706*
		返回值为 {expr} 的项在 |String|、|List| 或 |Dictionary| {comp} 中出现的次数。

		如果给出了 {start}，则从具有此索引的项开始。
		{start} 只能与 |List| 一起使用。

		当给出 {ic} 且为 |TRUE| 时，忽略大小写。

		当 {comp} 是字符串时，返回 {expr} 的非重叠出现次数。
		当 {expr} 是空字符串时返回零。

                参数: ~
                  • {comp} (`字符串|表格|任意[]`)
                  • {expr} (`任意`)
                  • {ic} (`布尔值?`)
                  • {start} (`整数?`)

                返回值: ~
                  (`整数`)

ctxget([{index}])                                                     *ctxget()*
		返回一个 |Dictionary|，表示 |context-stack| 顶部 {index} 处的 |context|（参见 |context-dict|）。
		如果未给出 {index}，则假定为 0（即：顶部）。

                参数: ~
                  • {index} (`整数?`)

                返回值: ~
                  (`表格`)

ctxpop()                                                              *ctxpop()*
		弹出并恢复 |context-stack| 顶部的 |context|。

                返回值: ~
                  (`任意`)

ctxpush([{types}])                                                   *ctxpush()*
		将当前编辑器状态 (|context|) 推入 |context-stack|。
		如果给出了 {types} 并且它是 |String| 的 |List|，它指定要包含在推送的上下文中的 |context-types|。
		否则，包含所有上下文类型。

                参数: ~
                  • {types} (`字符串[]?`)

                返回值: ~
                  (`任意`)

ctxset({context} [, {index}])                                         *ctxset()*
		将 |context-stack| 顶部 {index} 处的 |context| 设置为 {context} 表示的内容。
		{context} 是包含上下文数据的字典 (|context-dict|)。
		如果未给出 {index}，则假定为 0（即：顶部）。

                参数: ~
                  • {context} (`表格`)
                  • {index} (`整数?`)

                返回值: ~
                  (`整数`)

ctxsize()                                                            *ctxsize()*
		返回 |context-stack| 的大小。

                返回值: ~
                  (`任意`)

cursor({lnum}, {col} [, {off}])                                       *cursor()*
cursor({list})
		将光标定位在行 {lnum} 中的列（字节计数）{col}。第一列为一。

		当有一个参数 {list} 时，它用作包含两个、三个或四个项的 |List|:
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		这类似于 |getpos()| 或 |getcurpos()| 的返回值，但没有第一项。

		要使用 {col} 作为字符计数来定位光标，使用 |setcursorcharpos()|。

		不更改跳转列表。
		{lnum} 的用法同 |getline()|，但如果 {lnum} 为零，光标将停留在当前行。
		如果 {lnum} 大于缓冲区中的行数，光标将定位在缓冲区的最后一行。
		如果 {col} 大于行中的字节数，光标将定位在行的最后一个字符。
		如果 {col} 为零，光标将停留在当前列。
		如果给出了 {curswant}，它用于设置垂直移动的首选列。否则使用 {col}。

		当使用 'virtualedit' 时，{off} 指定从字符开始的屏幕列偏移量。
		例如，<Tab> 内的位置或最后一个字符之后的位置。
		当位置可以设置时返回 0，否则返回 -1。

                参数: ~
                  • {list} (`整数[]`)

                返回值: ~
                  (`任意`)

debugbreak({pid})                                                 *debugbreak()*
		专门用于中断正在调试的程序。
		它将导致进程 {pid} 收到 SIGTRAP。对其他进程的行为未定义。参见 |terminal-debug|。
		（在非 MS-Windows 系统上向进程 {pid} 发送 SIGINT）

		如果成功中断程序，返回 |TRUE|。
		否则返回 |FALSE|。

                参数: ~
                  • {pid} (`整数`)

                返回值: ~
                  (`任意`)

deepcopy({expr} [, {noref}])                                   *deepcopy()* *E698*
		创建 {expr} 的副本。对于数字和字符串，这与直接使用 {expr} 没有区别。
		当 {expr} 是 |List| 时，创建完整副本。这意味着原始 |List| 可以更改而不更改副本，反之亦然。
		当项是 |List| 时，会为其创建副本，递归进行。
		因此更改副本中的项不会更改原始 |List| 的内容。

		当 {noref} 被省略或为零时，包含的 |List| 或 |Dictionary| 仅复制一次。
		所有引用都指向这个单一副本。
		当 {noref} 设置为 1 时，每次出现 |List| 或 |Dictionary| 都会产生一个新副本。
		这也意味着循环引用会导致 deepcopy() 失败。
								*E724*
		嵌套最多可达 100 层。
		当存在引用回更高层的项时，使用 {noref} 设置为 1 进行深拷贝将失败。
		另见 |copy()|。

                参数: ~
                  • {expr} (`T`)
                  • {noref} (`布尔值?`)

                返回值: ~
                  (`T`)

delete({fname} [, {flags}])                                           *delete()*
		没有 {flags} 或 {flags} 为空时：删除名为 {fname} 的文件。

		当 {fname} 是符号链接时也有效。符号链接本身被删除，而不是它指向的内容。

		当 {flags} 是 "d" 时：删除名为 {fname} 的目录。当目录 {fname} 不为空时失败。

		当 {flags} 是 "rf" 时：递归删除名为 {fname} 的目录及其中的所有内容。小心！
		注意：在 MS-Windows 上无法删除正在使用的目录。

		结果是一个数字，如果删除操作成功则为 0/假，当删除失败或部分失败时为 -1/真。

                参数: ~
                  • {fname} (`字符串`)
                  • {flags} (`字符串?`)

                返回值: ~
                  (`整数`)

deletebufline({buf}, {first} [, {last}])                       *deletebufline()*
		从缓冲区 {buf} 中删除 {first} 到 {last}（包含）的行。
		如果省略 {last}，则仅删除行 {first}。
		成功返回 0，失败返回 1。

		此函数仅对已加载的缓冲区有效。如果需要，首先调用 |bufload()|。

		关于 {buf} 的使用，参见上面的 |bufname()|。

		{first} 和 {last} 的用法同 |getline()|。
		注意使用 |line()| 时指的是当前缓冲区。使用 "$" 指代缓冲区 {buf} 的最后一行。

                参数: ~
                  • {buf} (`整数|字符串`)
                  • {first} (`整数|字符串`)
                  • {last} (`整数|字符串?`)

                返回值: ~
                  (`任意`)

dictwatcheradd({dict}, {pattern}, {callback})                 *dictwatcheradd()*
		向字典添加监视器。字典监视器由三个组件标识:

		- 一个字典({dict});
		- 一个键模式({pattern})。
		- 一个函数({callback})。

		调用此函数后，{dict} 上的每次更改以及匹配 {pattern} 的键上的更改都将导致调用 {callback}。

		例如，要监视所有全局变量: >vim
			silent! call dictwatcherdel(g:, '*', 'OnDictChanged')
			function! OnDictChanged(d,k,z)
			  echomsg string(a:k) string(a:z)
			endfunction
			call dictwatcheradd(g:, '*', 'OnDictChanged')
<
		目前 {pattern} 仅接受非常简单的模式，可以在字符串末尾包含 "*"，在这种情况下它将匹配以 "*" 之前子字符串开头的每个键。
		这意味着如果 "*" 不是 {pattern} 的最后一个字符，则只有与 {pattern} 完全相等的键才会匹配。

		{callback} 接收三个参数:

		- 被监视的字典。
		- 更改的键。
		- 包含键的新值和旧值的字典。

		可以通过检查第三个参数上存在的键来确定更改类型:

		- 如果同时包含 `old` 和 `new`，则键已更新。
		- 如果仅包含 `new`，则键已添加。
		- 如果仅包含 `old`，则键已删除。

		此函数可由插件用于实现具有验证和解析逻辑的选项。

                参数: ~
                  • {dict} (`表格`)
                  • {pattern} (`字符串`)
                  • {callback} (`函数`)

                返回值: ~
                  (`任意`)

dictwatcherdel({dict}, {pattern}, {callback})                 *dictwatcherdel()*
		移除通过 |dictwatcheradd()| 添加的监视器。
		所有三个参数必须与传递给 |dictwatcheradd()| 的参数匹配，才能成功删除监视器。

                参数: ~
                  • {dict} (`任意`)
                  • {pattern} (`字符串`)
                  • {callback} (`函数`)

                返回值: ~
                  (`任意`)

did_filetype()                                                  *did_filetype()*
		当正在执行自动命令且 FileType 事件至少触发过一次时返回 |TRUE|。
		可用于在检测文件类型的脚本中避免再次触发 FileType 事件。|FileType|
		当使用 `:setf FALLBACK` 时返回 |FALSE|。
		当编辑另一个文件时，计数器被重置，因此这实际上检查是否已为当前缓冲区触发了 FileType 事件。
		这允许开始编辑另一个缓冲区的自动命令设置 'filetype' 并加载语法文件。

                返回值: ~
                  (`整数`)

diff_filler({lnum})                                              *diff_filler()*
		返回行 {lnum} 上方的填充行数。
		这些是在另一个差异比较窗口中在此点插入的行。
		这些填充行在显示中显示但不存在于缓冲区中。
		{lnum} 的用法同 |getline()|。因此 "." 是当前行，"'m" 是标记 m，等等。
		如果当前窗口不在差异模式，返回 0。

                参数: ~
                  • {lnum} (`整数|字符串`)

                返回值: ~
                  (`整数`)

diff_hlID({lnum}, {col})                                           *diff_hlID()*
		返回差异模式下行 {lnum} 列 {col}（字节索引）的高亮 ID。
		当当前行没有差异更改时返回零。
		{lnum} 的用法同 |getline()|。因此 "." 是当前行，"'m" 是标记 m，等等。
		{col} 对于最左边的列是 1，{lnum} 对于第一行是 1。
		高亮 ID 可与 |synIDattr()| 一起使用以获取有关高亮的语法信息。

                参数: ~
                  • {lnum} (`整数|字符串`)
                  • {col} (`整数`)

                返回值: ~
                  (`任意`)

digraph_get({chars})                                       *digraph_get()* *E1214*
		返回 {chars} 的合字。这应该是一个恰好包含两个字符的字符串。
		如果 {chars} 不是恰好两个字符，或者 {chars} 的合字不存在，会给出错误并返回空字符串。

		另见 |digraph_getlist()|。

		示例: >vim
		" 获取内置合字
		echo digraph_get('00')		" 返回 '∞'

		" 获取用户定义的合字
		call digraph_set('aa', 'あ')
		echo digraph_get('aa')		" 返回 'あ'
<

                参数: ~
                  • {chars} (`字符串`)

                返回值: ~
                  (`字符串`)

digraph_getlist([{listall}])                                 *digraph_getlist()*
		返回合字列表。如果给出了 {listall} 参数且为 TRUE，返回所有合字，包括默认合字。
		否则，仅返回用户定义的合字。

		另见 |digraph_get()|。

		示例: >vim
		" 获取用户定义的合字
		echo digraph_getlist()

		" 获取所有合字，包括默认合字
		echo digraph_getlist(1)
<

                参数: ~
                  • {listall} (`布尔值?`)

                返回值: ~
                  (`字符串[][]`)

digraph_set({chars}, {digraph})                                  *digraph_set()*
		向列表添加合字 {chars}。{chars} 必须是包含两个字符的字符串。
		{digraph} 是一个 UTF-8 编码字符的字符串。*E1215*
		小心，组合字符不被忽略。
		此函数类似于 |:digraphs| 命令，但可用于添加以空白开头的合字。

		如果 |digraph| 已注册，函数结果为 v:true。
		如果失败，会给出错误消息并返回 v:false。

		如果要一次定义多个合字，可以使用 |digraph_setlist()|。

		示例: >vim
			call digraph_set('  ', 'あ')
<

                参数: ~
                  • {chars} (`字符串`)
                  • {digraph} (`字符串`)

                返回值: ~
                  (`任意`)

digraph_setlist({digraphlist})                               *digraph_setlist()*
		类似于 |digraph_set()|，但此函数可以一次添加多个合字。
		{digraphlist} 是由列表组成的列表，其中每个列表包含两个字符串，{chars} 和 {digraph}，如同 |digraph_set()| 中一样。*E1216*
		示例: >vim
		    call digraph_setlist([['aa', 'あ'], ['ii', 'い']])
<
		它类似于以下内容: >vim
		    for [chars, digraph] in [['aa', 'あ'], ['ii', 'い']]
			  call digraph_set(chars, digraph)
		    endfor
<		除了函数在第一个错误后返回，后续的合字不会被添加。

                参数: ~
                  • {digraphlist} (`表格<整数,字符串[]>`)

                返回值: ~
                  (`任意`)

empty({expr})                                                          *empty()*
		如果 {expr} 为空，返回数字 1，否则返回零。
		- 当 |List| 或 |Dictionary| 没有任何项时为空。
		- 当 |String| 的长度为零时为空。
		- 当 |Number| 和 |Float| 的值为零时为空。
		- |v:false| 和 |v:null| 为空，|v:true| 不为空。
		- 当 |Blob| 的长度为零时为空。

                参数: ~
                  • {expr} (`任意`)

                返回值: ~
                  (`整数`)

environ()                                                            *environ()*
		以字典形式返回所有环境变量。可以这样检查环境变量是否存在: >vim
			echo has_key(environ(), 'HOME')
<		注意变量名可能是 CamelCase 形式；要忽略大小写，使用: >vim
			echo index(keys(environ()), 'HOME', 0, 1) != -1
<

                返回值: ~
                  (`任意`)

escape({string}, {chars})                                             *escape()*
		使用反斜杠转义 {string} 中出现的 {chars} 中的字符。
		示例: >vim
			echo escape('c:\program files\vim', ' \')
<		结果为: >
			c:\\program\ files\\vim
<		另见 |shellescape()| 和 |fnameescape()|。

                参数: ~
                  • {string} (`字符串`)
                  • {chars} (`字符串`)

                返回值: ~
                  (`字符串`)

eval({string})                                                          *eval()*
		求值 {string} 并返回结果。
		特别适用于将 |string()| 的结果转回原始值。
		适用于数字、浮点数、字符串、二进制大对象及其复合类型。
		也适用于引用现有函数的 |Funcref|。

                参数: ~
                  • {string} (`字符串`)

                返回值: ~
                  (`任意`)

eventhandler()                                                  *eventhandler()*
		在事件处理程序内部时返回 1。
		即 Vim 在等待用户键入字符时被中断，例如在 Vim 上拖放文件时。
		这意味着无法使用交互式命令。否则返回零。

                返回值: ~
                  (`任意`)

executable({expr})                                                *executable()*
		此函数检查名为 {expr} 的可执行文件是否存在。
		{expr} 必须是程序的名称，不带任何参数。

		executable() 使用 $PATH 的值和/或程序的正常搜索路径。
							*PATHEXT*
		在 MS-Windows 上，可以选择包含 ".exe"、".bat" 等。
		然后尝试 $PATHEXT 中的扩展名。
		因此如果 "foo.exe" 不存在，可以找到 "foo.exe.bat"。
		如果未设置 $PATHEXT，则使用 ".com;.exe;.bat;.cmd"。
		在 $PATHEXT 中可以使用单独的点来尝试使用没有扩展名的名称。
		当 'shell' 看起来像 Unix shell 时，也会尝试不添加扩展名的名称。
		在 MS-Windows 上，它只检查文件是否存在且不是目录，而不检查它是否真正可执行。
		在 MS-Windows 上，与 Vim 可执行文件在同一目录中的可执行文件总是被找到（它在 |startup| 时被添加到 $PATH 中）。
					*NoDefaultCurrentDirectoryInExePath*
		在 MS-Windows 上，Vim 当前工作目录中的可执行文件通常也会被找到，但可以通过设置 $NoDefaultCurrentDirectoryInExePath 环境变量来禁用此行为。

		结果是一个数字:
			1	存在
			0	不存在
		|exepath()| 可用于获取可执行文件的完整路径。

                参数: ~
                  • {expr} (`字符串`)

                返回值: ~
                  (`0|1`)

execute({command} [, {silent}])                                      *execute()*
		执行 {command} 并捕获其输出。
		如果 {command} 是 |String|，返回 {command} 的输出。
		如果 {command} 是 |List|，返回连接后的输出。
		不识别 {command} 中的行继续符。
		示例: >vim
			echo execute('echon "foo"')
<			foo >vim
			echo execute(['echon "foo"', 'echon "bar"'])
<			foobar

		可选的 {silent} 参数可以有以下值:
			""		不使用 `:silent`
			"silent"	使用 `:silent`
			"silent!"	使用 `:silent!`
		默认为 "silent"。注意与 `:redir` 不同，使用 "silent!" 时错误消息会被丢弃。

		要获取行列表，对结果使用 `split()`: >vim
			execute('args')->split("\n")

<		此函数在 |sandbox| 中不可用。
		注意：如果嵌套，外部的 execute() 不会观察到内部调用的输出。
		注意：不捕获文本属性（高亮）。
		要在当前窗口之外的另一个窗口中执行命令，使用 `win_execute()`。

                参数: ~
                  • {command} (`字符串|字符串[]`)
                  • {silent} (`''|'silent'|'silent!'?`)

                返回值: ~
                  (`字符串`)

exepath({expr})                                                      *exepath()*
		如果 {expr} 是可执行文件且作为（部分或完整）路径给出或在 $PATH 中找到，则返回其完整路径。
		否则返回空字符串。
		如果 {expr} 以 "./" 开头，则使用 |current-directory|。

                参数: ~
                  • {expr} (`字符串`)

                返回值: ~
                  (`字符串`)

exists({expr})                                                        *exists()*
		结果是一个数字，如果 {expr} 已定义则为 |TRUE|，否则为零。

		检查支持的功能使用 |has()|。
		检查文件是否存在使用 |filereadable()|。

		{expr} 参数是一个字符串，包含以下之一:
			varname		内部变量（参见 |internal-variables|）。
			dict.key	也适用于 |curly-braces-names|、|Dictionary|
			list[i]		条目、|List| 项等。
					注意计算索引可能会因表达式无效而导致错误消息。
					例如: >vim
					   let l = [1, 2, 3]
					   echo exists("l[5]")
<					   0 >vim
					   echo exists("l[xx]")
<					   E121: 未定义的变量: xx
					   0
			&option-name	Vim 选项（仅检查是否存在，不检查是否真正工作）
			+option-name	有效的 Vim 选项。
			$ENVNAME	环境变量（也可以通过与空字符串比较来完成）
			`*funcname`	内置函数（参见 |functions|）
					或用户定义函数（参见 |user-function|）。
					也适用于作为 Funcref 的变量。
			:cmdname	Ex 命令：内置命令、用户命令或命令修饰符 |:command|。
					返回:
					1  匹配命令的开头
					2  完全匹配命令
					3  匹配多个用户命令
					要检查支持的命令，始终检查返回值是否为 2。
			:2match		|:2match| 命令。
			:3match		|:3match| 命令（但您可能不应使用它，它保留供内部使用）
			#event		为此事件定义的自动命令
			#event#pattern	为此事件和模式定义的自动命令（模式按字面意义处理并与自动命令模式逐字符比较）
			#group		自动命令组存在
			#group#event	为此组和事件定义的自动命令。
			#group#event#pattern
					为此组、事件和模式定义的自动命令。
			##event		支持此事件的自动命令。

		示例: >vim
			echo exists("&mouse")
			echo exists("$HOSTNAME")
			echo exists("*strftime")
			echo exists("*s:MyFunc")
			echo exists("*MyFunc")
			echo exists("*v:lua.Func")
			echo exists("bufcount")
			echo exists(":Make")
			echo exists("#CursorHold")
			echo exists("#BufReadPre#*.gz")
			echo exists("#filetypeindent")
			echo exists("#filetypeindent#FileType")
			echo exists("#filetypeindent#FileType#*")
			echo exists("##ColorScheme")
<		符号 (&/$/*/#) 和名称之间不能有空格。
		名称之后不能有额外字符，尽管在少数情况下这被忽略。
		未来可能会更严格，因此不要依赖它！
		工作示例: >vim
			echo exists(":make")
<		不工作示例: >vim
			echo exists(":make install")

<		注意参数必须是字符串，而不是变量本身的名称。
		例如: >vim
			echo exists(bufcount)
<		这不是检查 "bufcount" 变量是否存在，而是获取 "bufcount" 的值，并检查该值是否存在。

                参数: ~
                  • {expr} (`字符串`)

                返回值: ~
                  (`0|1`)

exp({expr})                                                              *exp()*
		返回 {expr} 的指数值，作为范围在 [0, inf] 内的 |Float|。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo exp(2)
<			7.389056 >vim
			echo exp(-1)
<			0.367879

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`任意`)

expand({string} [, {nosuf} [, {list}]])                               *expand()*
		在 {string} 中展开通配符和以下特殊关键字。
		应用 'wildignorecase'。

		如果给出了 {list} 且为 |TRUE|，将返回一个 List。
		否则结果是一个 String，当有多个匹配项时，它们由 <NL> 字符分隔。

		如果展开失败，结果是一个空字符串。
		不存在的文件的名称不包括在内，除非 {string} 不以 '%'、'#' 或 '<' 开头，见下文。

		当 {string} 以 '%'、'#' 或 '<' 开头时，展开方式类似于 |cmdline-special| 变量及其相关修饰符。
		以下是简要概述:

			%		当前文件名
			#		备用文件名
			#n		备用文件名 n
			<cfile>		光标下的文件名
			<afile>		自动命令文件名
			<abuf>		自动命令缓冲区编号（作为字符串！）
			<amatch>	自动命令匹配名称
			<cexpr>		光标下的 C 表达式
			<sfile>		已弃用，使用 <script> 或 <stack>
			<slnum>		源脚本行号或函数行号
			<sflnum>	脚本文件行号，在函数中时也是如此
			<SID>		"<SNR>123_" 其中 "123" 是当前脚本 ID |<SID>|
			<script>	源脚本文件，或定义当前函数的脚本文件。
					对于 Lua 参见 |lua-script-location|。
			<stack>		调用堆栈
			<cword>		光标下的单词
			<cWORD>		光标下的 WORD
			<client>	最后接收消息的 {clientid}
		修饰符:
			:p		展开为完整路径
			:h		头部（移除最后一个路径组件）
			:t		尾部（仅最后一个路径组件）
			:r		根（移除一个扩展名）
			:e		仅扩展名

		示例: >vim
			let &tags = expand("%:p:h") .. "/tags"
<		注意当展开以 '%'、'#' 或 '<' 开头的字符串时，任何后续文本都被忽略。
		这不起作用: >vim
			let doesntwork = expand("%:h.bak")
<		使用这个: >vim
			let doeswork = expand("%:h") .. ".bak"
<		还要注意展开 "<cfile>" 和其他项仅返回引用的文件名而不进一步展开。
		如果 "<cfile>" 是 "~/.cshrc"，您需要执行另一个 expand() 来将 "~/" 展开为主目录的路径: >vim
			echo expand(expand("<cfile>"))
<
		变量和后续修饰符之间不能有空白。
		|fnamemodify()| 函数可用于修改普通文件名。

		当使用 '%' 或 '#' 时，如果当前或备用文件名未定义，则使用空字符串。
		在无名称的缓冲区中使用 "%:p" 会导致当前目录，并添加一个 '/'。
		当设置 'verbose' 时，如果参数无法展开，展开 '%'、'#' 和 <> 项将导致错误消息。

		当 {string} 不以 '%'、'#' 或 '<' 开头时，它像命令行上的文件名一样展开。
		使用 'suffixes' 和 'wildignore'，除非给出可选的 {nosuf} 参数且为 |TRUE|。
		包括不存在的文件的名称。
		"**" 项可用于在目录树中搜索。
		例如，查找当前目录及以下的所有 "README" 文件: >vim
			echo expand("**/README")
<
		expand() 也可用于展开仅在 shell 中已知的变量和环境变量。
		但这可能很慢，因为可能使用 shell 进行展开。
		参见 |expr-env-expand|。
		展开的变量仍像文件名列表一样处理。
		当环境变量无法展开时，它保持不变。
		因此 ":echo expand('$FOOBAR')" 结果为 "$FOOBAR"。

		查找现有文件参见 |glob()|。
		获取外部命令的原始输出参见 |system()|。

                参数: ~
                  • {string} (`字符串`)
                  • {nosuf} (`布尔值?`)
                  • {list} (`nil|false?`)

                返回值: ~
                  (`字符串`)

expandcmd({string} [, {options}])                                  *expandcmd()*
		展开字符串 {string} 中的特殊项，就像对 Ex 命令（如 `:edit`）所做的那样。
		这会在 {string} 中的任何位置展开特殊关键字（如 |expand()|）和环境变量。
		"~user" 和 "~/path" 仅在开头展开。

		{options} Dict 参数支持以下项:
		    errmsg	如果设置为 TRUE，在展开过程中遇到错误时显示错误消息。
				默认情况下，不显示错误消息。

		返回展开后的字符串。
		如果在展开过程中遇到错误，返回未修改的 {string}。

		示例: >vim
			echo expandcmd('make %<.o')
<		 >
			make /path/runtime/doc/builtin.o
<		 >vim
			echo expandcmd('make %<.o', {'errmsg': v:true})
<

                参数: ~
                  • {string} (`字符串`)
                  • {options} (`表格?`)

                返回值: ~
                  (`任意`)

extend({expr1}, {expr2} [, {expr3}])                                  *extend()*
		{expr1} 和 {expr2} 必须都是 |Lists| 或都是 |Dictionaries|。

		如果它们是 |Lists|：将 {expr2} 追加到 {expr1}。
		如果给出 {expr3}，在 {expr1} 中索引为 {expr3} 的项之前插入 {expr2} 的项。
		当 {expr3} 为零时，插入到第一项之前。
		当 {expr3} 等于 len({expr1}) 时，{expr2} 被追加。
		示例: >vim
			echo sort(extend(mylist, [7, 5]))
			call extend(mylist, [2, 3], 1)
<		当 {expr1} 与 {expr2} 是同一个 List 时，复制的项数等于 List 的原始长度。
		例如，当 {expr3} 为 1 时，您会得到第一项的 N 个新副本（其中 N 是 List 的原始长度）。
		使用 |add()| 将一个项连接到列表。
		要将两个列表连接成一个新列表，使用 + 运算符: >vim
			let newlist = [1, 2, 3] + [4, 5]
<
		如果它们是 |Dictionaries|：
		将所有条目从 {expr2} 添加到 {expr1}。
		如果键在 {expr1} 和 {expr2} 中都存在，则使用 {expr3} 决定要做什么:
		{expr3} = "keep": 保留 {expr1} 的值
		{expr3} = "force": 使用 {expr2} 的值
		{expr3} = "error": 给出错误消息		*E737*
		当省略 {expr3} 时，假定为 "force"。

		当 {expr2} 不为空时，{expr1} 被更改。
		如有必要，首先制作 {expr1} 的副本或使用 |extendnew()| 返回新的 List/Dictionary。
		{expr2} 保持不变。
		当 {expr1} 被锁定且 {expr2} 不为空时，操作失败。
		返回 {expr1}。出错时返回 0。

                参数: ~
                  • {expr1} (`表格`)
                  • {expr2} (`表格`)
                  • {expr3} (`表格?`)

                返回值: ~
                  (`任意`)

extendnew({expr1}, {expr2} [, {expr3}])                            *extendnew()*
		类似 |extend()|，但不是将项添加到 {expr1}，而是创建并返回新的 List 或 Dictionary。
		{expr1} 保持不变。

                参数: ~
                  • {expr1} (`表格`)
                  • {expr2} (`表格`)
                  • {expr3} (`表格?`)

                返回值: ~
                  (`任意`)

feedkeys({string} [, {mode}])                                       *feedkeys()*
		{string} 中的字符被排队处理，就像它们来自映射或由用户键入一样。

		默认情况下，字符串被添加到 typeahead 缓冲区的末尾，因此如果映射仍在执行，字符会在它们之后出现。
		使用 'i' 标志在其他字符之前插入，它们将在下一个执行，在任何来自映射的字符之前。

		该函数不等待处理 {string} 中包含的键。

		要将特殊键包含到 {string} 中，使用双引号和 "\..." 表示法 |expr-quote|。
		例如，feedkeys("\<CR>") 模拟按下 <Enter> 键。
		但是 feedkeys('\<CR>') 推送 5 个字符。
		|<Ignore>| 键码可用于退出等待字符而不做任何事情。

		{mode} 是一个字符串，可以包含这些字符标志:
		'm'	重映射键。这是默认值。如果 {mode} 不存在，键被重映射。
		'n'	不重映射键。
		't'	将键视为键入；否则它们被视为来自映射。
			这对于撤销、打开折叠等很重要。
		'L'	低级输入。不使用其他标志。
		'i'	插入字符串而不是追加（见上文）。
		'x'	执行命令直到 typeahead 为空。
			这类似于使用 ":normal!"。
			您可以多次调用不带 'x' 的 feedkeys()，然后一次带 'x'（可能使用空 {string}）来执行所有 typeahead。
			注意当 Vim 以插入模式结束时，它将表现为键入了 <Esc>，以避免卡住，等待键入字符后再继续脚本。
			注意如果您在执行命令时设法调用 feedkeys()，从而递归调用它，那么所有 typeahead 将被最后一次调用消耗。
		'!'	当与 'x' 一起使用时，不会结束插入模式。
			可用于测试中，当设置计时器稍后退出插入模式时。
			用于测试 CursorHoldI。

		返回值总是 0。

                参数: ~
                  • {string} (`字符串`)
                  • {mode} (`字符串?`)

                返回值: ~
                  (`任意`)

filecopy({from}, {to})                                              *filecopy()*
		将名称 {from} 指向的文件复制到 {to}。
		结果是一个数字，如果文件复制成功则为 |TRUE|，失败则为 |FALSE|。
		如果名称 {to} 的文件已存在，它将失败。
		注意它不处理目录（尚）。

		此函数在 |sandbox| 中不可用。

                参数: ~
                  • {from} (`字符串`)
                  • {to} (`字符串`)

                返回值: ~
                  (`0|1`)

filereadable({file})                                            *filereadable()*
		结果是一个数字，当名称 {file} 的文件存在且可读时为 |TRUE|。
		如果 {file} 不存在或是目录，结果为 |FALSE|。
		{file} 是任何表达式，用作字符串。
		如果您不关心文件是否可读，可以使用 |glob()|。
		{file} 按原样使用，您可能希望先展开通配符: >vim
			echo filereadable('~/.vimrc')
<		 >
			0
<		 >vim
			echo filereadable(expand('~/.vimrc'))
<		 >
			1
<

                参数: ~
                  • {file} (`字符串`)

                返回值: ~
                  (`0|1`)

filewritable({file})                                            *filewritable()*
		结果是一个数字，当名称 {file} 的文件存在且可写时为 1。
		如果 {file} 不存在或不可写，结果为 0。
		如果 {file} 是目录且我们可以写入它，结果为 2。

                参数: ~
                  • {file} (`字符串`)

                返回值: ~
                  (`0|1`)

filter({expr1}, {expr2})                                              *filter()*
		{expr1} 必须是 |List|、|String|、|Blob| 或 |Dictionary|。
		对于 {expr1} 中的每个项，求值 {expr2}，当结果为零或假时从 |List| 或 |Dictionary| 中移除该项。
		对于 |Blob| 中的每个字节和 |String| 中的每个字符类似。

		{expr2} 必须是 |string| 或 |Funcref|。

		如果 {expr2} 是 |string|，在 {expr2} 内部 |v:val| 具有当前项的值。
		对于 |Dictionary|，|v:key| 具有当前项的键，对于 |List|，|v:key| 具有当前项的索引。
		对于 |Blob|，|v:key| 具有当前字节的索引。
		对于 |String|，|v:key| 具有当前字符的索引。
		示例: >vim
			call filter(mylist, 'v:val !~ "OLD"')
<		移除出现 "OLD" 的项。 >vim
			call filter(mydict, 'v:key >= 8')
<		移除键低于 8 的项。 >vim
			call filter(var, 0)
<		移除所有项，从而清除 |List| 或 |Dictionary|。

		注意 {expr2} 是表达式的结果，然后再次用作表达式。
		通常使用 |literal-string| 以避免双反斜杠。

		如果 {expr2} 是 |Funcref|，它必须接受两个参数:
			1. 当前项的键或索引。
			2. 当前项的值。
		该函数必须返回 |TRUE| 如果应保留该项。
		保留列表奇数项的示例: >vim
			func Odd(idx, val)
			  return a:idx % 2 == 1
			endfunc
			call filter(mylist, function('Odd'))
<		使用 |lambda| 时更短: >vim
			call filter(myList, {idx, val -> idx * val <= 42})
<		如果不使用 "val"，可以省略它: >vim
			call filter(myList, {idx -> idx % 2 == 1})
<
		对于 |List| 和 |Dictionary|，操作是就地完成的。
		如果您希望它保持未修改，请先制作副本: >vim
			let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		返回 {expr1}，被过滤的 |List| 或 |Dictionary|，或新的 |Blob| 或 |String|。
		当求值 {expr2} 时遇到错误，不处理 {expr1} 中的进一步项。
		当 {expr2} 是 Funcref 时，函数内部的错误被忽略，除非它是用 "abort" 标志定义的。

                参数: ~
                  • {expr1} (`字符串|表格`)
                  • {expr2} (`字符串|函数`)

                返回值: ~
                  (`任意`)

finddir({name} [, {path} [, {count}]])                               *finddir()*
		在 {path} 中查找目录 {name}。
		支持向下和向上的递归目录搜索。
		关于 {path} 的语法，参见 |file-searching|。

		返回第一个找到的匹配的路径。
		当找到的目录在当前目录下方时，返回相对路径。
		否则返回完整路径。
		如果 {path} 被省略或为空，则使用 'path'。

		如果给出可选的 {count}，在 {path} 中查找 {name} 的第 {count} 次出现，而不是第一次。
		当 {count} 为负时，返回 |List| 中的所有匹配项。

		如果未找到目录，返回空字符串。

		这与 ex-command `:find` 非常相似。

                参数: ~
                  • {name} (`字符串`)
                  • {path} (`字符串?`)
                  • {count} (`整数?`)

                返回值: ~
                  (`字符串|字符串[]`)

findfile({name} [, {path} [, {count}]])                             *findfile()*
		就像 |finddir()|，但查找文件而不是目录。
		使用 'suffixesadd'。
		示例: >vim
			echo findfile("tags.vim", ".;")
<		从当前文件的目录向上搜索，直到找到文件 "tags.vim"。

                参数: ~
                  • {name} (`字符串`)
                  • {path} (`字符串?`)
                  • {count} (`整数?`)

                返回值: ~
                  (`字符串|字符串[]`)

flatten({list} [, {maxdepth}])                                       *flatten()*
		将 {list} 展平最多 {maxdepth} 层。
		没有 {maxdepth} 时，结果是一个没有嵌套的 |List|，就像 {maxdepth} 是一个非常大的数字。
		{list} 被就地更改，如果您不希望这样，使用 |flattennew()|。
								*E900*
		{maxdepth} 表示在嵌套列表中更改的深度。
		当 {maxdepth} 为 0 时，不修改 {list}。
		{maxdepth} 必须是正数。

		如果有错误，返回数字零。

		示例: >vim
			echo flatten([1, [2, [3, 4]], 5])
<			[1, 2, 3, 4, 5] >vim
			echo flatten([1, [2, [3, 4]], 5], 1)
<			[1, 2, [3, 4], 5]

                参数: ~
                  • {list} (`任意[]`)
                  • {maxdepth} (`整数?`)

                返回值: ~
                  (`任意[]|0`)

flattennew({list} [, {maxdepth}])                                 *flattennew()*
		类似 |flatten()|，但首先制作 {list} 的副本。

                参数: ~
                  • {list} (`任意[]`)
                  • {maxdepth} (`整数?`)

                返回值: ~
                  (`任意[]|0`)

float2nr({expr})                                                    *float2nr()*
		通过省略小数点后的部分将 {expr} 转换为数字。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0。
		当 {expr} 的值超出 |Number| 的范围时，结果被截断为 0x7fffffff 或 -0x7fffffff（或当启用 64 位数字支持时，0x7fffffffffffffff 或 -0x7fffffffffffffff）。
		NaN 导致 -0x80000000（或当启用 64 位数字支持时，-0x8000000000000000）。
		示例: >vim
			echo float2nr(3.95)
<			3  >vim
			echo float2nr(-23.45)
<			-23  >vim
			echo float2nr(1.0e100)
<			2147483647  (或 9223372036854775807) >vim
			echo float2nr(-1.0e150)
<			-2147483647 (或 -9223372036854775807) >vim
			echo float2nr(1.0e-100)
<			0

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`任意`)

floor({expr})                                                          *floor()*
		返回小于或等于 {expr} 的最大整数值，作为 |Float|（向下取整）。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo floor(1.856)
<			1.0  >vim
			echo floor(-5.456)
<			-6.0  >vim
			echo floor(4.0)
<			4.0

                参数: ~
                  • {expr} (`数值`)

                返回值: ~
                  (`任意`)

fmod({expr1}, {expr2})                                                  *fmod()*
		返回 {expr1} / {expr2} 的余数，即使除法不可表示。
		返回 {expr1} - i * {expr2}，对于某个整数 i，使得如果 {expr2} 非零，结果具有与 {expr1} 相同的符号且量级小于 {expr2} 的量级。
		如果 {expr2} 为零，返回的值为零。
		返回的值是一个 |Float|。
		{expr1} 和 {expr2} 必须求值为 |Float| 或 |Number|。
		如果 {expr1} 或 {expr2} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >vim
			echo fmod(12.33, 1.22)
<			0.13 >vim
			echo fmod(-12.33, 1.22)
<			-0.13

                参数: ~
                  • {expr1} (`数值`)
                  • {expr2} (`数值`)

                返回值: ~
                  (`任意`)

fnameescape({string})                                            *fnameescape()*
		转义 {string} 以用作文件名命令参数。
		所有具有特殊含义的字符，如 `'%'` 和 `'|'`，都用反斜杠转义。
		对于大多数系统，转义的字符是
		" \t\n*?[{`$\\%#'\"|!<"。
		对于在文件名中出现反斜杠的系统，它取决于 'isfname' 的值。
		前导 '+' 和 '>' 也被转义（在 |:edit| 和 |:write| 之后特殊）。
		单独的 "-" 也是（在 |:cd| 之后特殊）。
		出错时返回空字符串。
		示例: >vim
			let fname = '+some str%nge|name'
			exe "edit " .. fnameescape(fname)
<		导致执行: >vim
			edit \+some\ str\%nge\|name
<

                参数: ~
                  • {string} (`字符串`)

                返回值: ~
                  (`字符串`)

fnamemodify({fname}, {mods})                                     *fnamemodify()*
		根据 {mods} 修改文件名 {fname}。
		{mods} 是一个字符串，就像在命令行上用于文件名一样。
		参见 |filename-modifiers|。
		示例: >vim
			echo fnamemodify("main.c", ":p:h")
<		结果为: >
			/home/user/vim/vim/src
<		如果 {mods} 为空或使用了不支持的修饰符，则返回 {fname}。
		当 {fname} 为空时，使用 {mods} ":h" 返回 "."，以便可以将其用于 `:cd`。
		这与没有缓冲区名称的 expand('%:h') 不同，后者返回空字符串。
		注意：环境变量在 {fname} 中不起作用，请先使用 |expand()|。

                参数: ~
                  • {fname} (`字符串`)
                  • {mods} (`字符串`)

                返回值: ~
                  (`字符串`)

foldclosed({lnum})                                                *foldclosed()*
		结果是一个数字。
		如果行 {lnum} 在关闭的折叠中，结果是该折叠中第一行的行号。
		如果行 {lnum} 不在关闭的折叠中，返回 -1。
		{lnum} 的用法同 |getline()|。因此 "." 是当前行，"'m" 是标记 m，等等。

                参数: ~
                  • {lnum} (`整数|字符串`)

                返回值: ~
                  (`整数`)

foldclosedend({lnum})                                          *foldclosedend()*
		结果是一个数字。
		如果行 {lnum} 在关闭的折叠中，结果是该折叠中最后一行的行号。
		如果行 {lnum} 不在关闭的折叠中，返回 -1。
		{lnum} 的用法同 |getline()|。因此 "." 是当前行，"'m" 是标记 m，等等。

                参数: ~
                  • {lnum} (`整数|字符串`)

                返回值: ~
                  (`整数`)

foldlevel({lnum})                                                  *foldlevel()*
		结果是一个数字，它是当前缓冲区中行 {lnum} 的折叠级别。
		对于嵌套折叠，返回最深层级。
		如果行 {lnum} 没有折叠，返回零。
		折叠是打开还是关闭无关紧要。
		在更新折叠时（来自 'foldexpr'）使用，对于尚未更新且折叠级别未知的行返回 -1。
		作为一种特殊情况，前一行的级别通常可用。
		{lnum} 的用法同 |getline()|。因此 "." 是当前行，"'m" 是标记 m，等等。

                参数: ~
                  • {lnum} (`整数|字符串`)

                返回值: ~
                  (`整数`)

foldtext()                                                          *foldtext()*
		返回一个字符串，用于显示关闭的折叠。
		这是用于 'foldtext' 选项的默认函数，应仅从求值 'foldtext' 中调用。
		它使用 |v:foldstart|、|v:foldend| 和 |v:folddashes| 变量。
		返回的字符串看起来像这样: >
			+-- 45 lines: abcdef
<		前导破折号的数量取决于折叠级别。
		"45" 是折叠中的行数。
		"abcdef" 是折叠中第一个非空白行的文本。
		移除前导空白、"//" 或 "/*" 以及来自 'foldmarker' 和 'commentstring' 选项的文本。
		当用于绘制实际的 foldtext 时，行的其余部分将用 'fillchars' 设置中的折叠字符填充。
		当没有折叠时返回空字符串。

                返回值: ~
                  (`字符串`)

foldtextresult({lnum})                                        *foldtextresult()*
		返回为行 {lnum} 处的关闭折叠显示的文本。
		在适当的上下文中求值 'foldtext'。
		当 {lnum} 处没有关闭的折叠时，返回空字符串。
		{lnum} 的用法同 |getline()|。因此 "." 是当前行，"'m" 是标记 m，等等。
		在导出折叠文本时有用，例如到 HTML。

                参数: ~
                  • {lnum} (`整数|字符串`)

                返回值: ~
                  (`字符串`)

foreach({expr1}, {expr2})                                            *foreach()*
		{expr1} 必须是 |List|、|String|、|Blob| 或 |Dictionary|。
		对于 {expr1} 中的每个项执行 {expr2}。{expr1} 不被修改；其值可能被修改，如 |:lockvar| 1。|E741|
		要修改 {expr1}，参见 |map()| 和 |filter()|。

		{expr2} 必须是 |string| 或 |Funcref|。

		如果 {expr2} 是 |string|，在 {expr2} 内部 |v:val| 具有当前项的值。
		对于 |Dictionary|，|v:key| 具有当前项的键，对于 |List|，|v:key| 具有当前项的索引。
		对于 |Blob|，|v:key| 具有当前字节的索引。
		对于 |String|，|v:key| 具有当前字符的索引。
		示例: >vim
			call foreach(mylist, 'let used[v:val] = v:true')
<		这记录在 {expr1} 列表中的项。

		注意 {expr2} 是表达式的结果，然后用作命令。
		通常使用 |literal-string| 以避免双反斜杠。

		如果 {expr2} 是 |Funcref|，它必须接受两个参数:
			1. 当前项的键或索引。
			2. 当前项的值。
		使用 lambda 时，如果它只接受一个参数，不会出错。
		如果函数返回值，它被忽略。

		在所有情况下返回 {expr1}。
		当执行 {expr2} 时遇到错误，不处理 {expr1} 中的进一步项。
		当 {expr2} 是 Funcref 时，函数内部的错误被忽略，除非它是用 "abort" 标志定义的。

                参数: ~
                  • {expr1} (`字符串|表格`)
                  • {expr2} (`字符串|函数`)

                返回值: ~
                  (`字符串|表格`)

fullcommand({name})                                              *fullcommand()*
		从简写的命令名称获取完整的命令名称；有关命令缩写的详细信息，参见 |20.2|。

		字符串参数 {name} 可以以 `:` 开头，并且可以包含 [range]，这些被跳过且不返回。
		如果命令不存在或模糊（对于用户定义的命令），返回空字符串。

		例如 `fullcommand('s')`、`fullcommand('sub')`、`fullcommand(':%substitute')` 都返回 "substitute"。

                参数: ~
                  • {name} (`字符串`)

                返回值: ~
                  (`字符串`)

funcref({name} [, {arglist}] [, {dict}])                             *funcref()*
		就像 |function()|，但返回的 Funcref 将通过引用查找函数，而不是通过名称。
		当函数 {name} 后来被重新定义时，这很重要。

		与 |function()| 不同，{name} 必须是现有的用户函数。
		对于自动加载函数，仅当它已被加载时才工作（为了避免在仅打算使用函数名称时错误地加载自动加载脚本，请改用 |function()|）。
		{name} 不能是内置函数。
		出错时返回 0。

                参数: ~
                  • {name} (`字符串`)
                  • {arglist} (`任意?`)
                  • {dict} (`任意?`)

                返回值: ~
                  (`任意`)


function({name} [, {arglist}] [, {dict}])         *function()* *partial* *E700* *E923*
		返回一个指向函数 {name} 的 |Funcref| 变量。
		{name} 可以是用户定义函数的名称或内部函数的名称。

		{name} 也可以是 Funcref 或 partial。当它是 partial 时，将使用其中存储的字典，并且不允许使用 {dict} 参数。例如： >vim
			let FuncWithArg = function(dict.Func, [arg])
			let Broken = function(dict.Func, [arg], dict)
<
		使用 Funcref 时，将通过 {name} 找到该函数，即使它后来被重新定义。使用 |funcref()| 来保持相同的函数。

		当存在 {arglist} 或 {dict} 时，会创建一个 partial。
		这意味着参数列表和/或字典存储在 Funcref 中，并在调用 Funcref 时使用。

		参数会传递给函数，放在其他参数之前，但在任何来自 |method| 的参数之后。 示例： >vim
			func Callback(arg1, arg2, name)
			"...
			endfunc
			let Partial = function('Callback', ['one', 'two'])
			"...
			call Partial('name')
<		调用函数的方式如同： >vim
			call Callback('one', 'two', 'name')

<		使用 |method|： >vim
			func Callback(one, two, three)
			"...
			endfunc
			let Partial = function('Callback', ['two'])
			"...
			eval 'one'->Partial('three')
<		调用函数的方式如同： >vim
			call Callback('one', 'two', 'three')

<		function() 调用可以嵌套以向 Funcref 添加更多参数。
		额外的参数会附加到参数列表的末尾。 示例： >vim
			func Callback(arg1, arg2, name)
			"...
			endfunc
			let Func = function('Callback', ['one'])
			let Func2 = function(Func, ['two'])
			"...
			call Func2('name')
<		调用函数的方式如同： >vim
			call Callback('one', 'two', 'name')

<		字典仅在使用 "dict" 函数时有用。
		在这种情况下，{dict} 会作为 "self" 传入。示例： >vim
			function Callback() dict
			   echo "called for " .. self.name
			endfunction
			"...
			let context = {"name": "example"}
			let Func = function('Callback', context)
			"...
			call Func()	" 将回显：called for example
<		当没有额外参数时，不需要使用 function()，如果 Callback() 被定义为 context.Callback()，则以下两种方式是等价的： >vim
			let Func = function('Callback', context)
			let Func = context.Callback

<		参数列表和字典可以组合使用： >vim
			function Callback(arg1, count) dict
			"...
			endfunction
			let context = {"name": "example"}
			let Func = function('Callback', ['one'], context)
			"...
			call Func(500)
<		调用函数的方式如同： >vim
			call context.Callback('one', 500)
<
		出错时返回 0。

                参数： ~
                  • {name} (`字符串`)
                  • {arglist} (`任意?`)
                  • {dict} (`任意?`)

                返回： ~
                  (`任意`)

garbagecollect([{atexit}])                                    *garbagecollect()*
		清理具有循环引用的未使用的 |列表| 和 |字典|。

		几乎不需要调用此函数，因为当 Vim 内存不足或在 'updatetime' 后等待用户按键时会自动执行此操作。
		没有循环引用的项在不再使用时总是会被释放。
		如果您在运行时间很长的脚本中删除了一个非常大的具有循环引用的 |列表| 和/或 |字典|，这会很有用。

		当可选的 {atexit} 参数为 1 时，如果之前未进行垃圾收集，则在退出 Vim 时也会进行垃圾收集。
		这在检查内存泄漏时很有用。

		垃圾收集不会立即执行，只有在安全的情况下才会执行。这是在等待用户输入字符时。

                参数： ~
                  • {atexit} (`布尔值?`)

                返回： ~
                  (`任意`)

get({list}, {idx} [, {default}])                              *get()* *get()-list*
		从 |列表| {list} 中获取第 {idx} 项。当此项不可用时返回 {default}。当省略 {default} 时返回零。

                参数： ~
                  • {list} (`任意[]`)
                  • {idx} (`整数`)
                  • {default} (`任意?`)

                返回： ~
                  (`任意`)

get({blob}, {idx} [, {default}])                                    *get()-blob*
		从 |Blob| {blob} 中获取字节 {idx}。当此字节不可用时返回 {default}。当省略 {default} 时返回 -1。

                参数： ~
                  • {blob} (`字符串`)
                  • {idx} (`整数`)
                  • {default} (`任意?`)

                返回： ~
                  (`任意`)

get({dict}, {key} [, {default}])                                    *get()-dict*
		从 |字典| {dict} 中获取键为 {key} 的项。当此项不可用时返回 {default}。当省略 {default} 时返回零。
		有用的示例： >vim
			let val = get(g:, 'var_name', 'default')
<		如果 g:var_name 存在，则获取其值，如果不存在则使用 "default"。

                参数： ~
                  • {dict} (`表<字符串,任意>`)
                  • {key} (`字符串`)
                  • {default} (`任意?`)

                返回： ~
                  (`任意`)

get({func}, {what})                                                 *get()-func*
		从 |Funcref| {func} 中获取项 {what}。{what} 的可能值为：
		  "name"    函数名
		  "func"    函数
		  "dict"    字典
		  "args"    参数列表
		  "arity"   一个包含函数接受的参数数量（减去 {arglist}）信息的字典，包含以下字段：
				required    位置参数的数量
				optional    可选参数的数量（在必需参数之外）
				varargs     如果函数接受可变数量的参数 |...|，则为 |TRUE|

				注意：如果 Funcref 的 {arglist} 包含的参数多于 Funcref 所期望的，不会报错，它不会被验证。

		出错时返回零。

                参数： ~
                  • {func} (`函数`)
                  • {what} (`字符串`)

                返回： ~
                  (`任意`)

getbufinfo([{buf}])                                               *getbufinfo()*
getbufinfo([{dict}])
		获取关于缓冲区的信息，作为字典的列表。

		没有参数时，返回所有缓冲区的信息。

		当参数是 |字典| 时，仅返回符合指定条件的缓冲区。
		可以在 {dict} 中指定以下键：
			buflisted	仅包含列出的缓冲区。
			bufloaded	仅包含已加载的缓冲区。
			bufmodified	仅包含已修改的缓冲区。

		否则，{buf} 指定要返回信息的特定缓冲区。
		关于 {buf} 的使用，请参见上面的 |bufname()|。
		如果找到缓冲区，返回的列表包含一个项。否则结果是一个空列表。

		每个返回的列表项是一个包含以下条目的字典：
			bufnr		缓冲区编号。
			changed		如果缓冲区已修改，则为 TRUE。
			changedtick	对缓冲区所做的更改次数。
			command		如果缓冲区属于命令行窗口 |cmdwin|，则为 TRUE。
			hidden		如果缓冲区是隐藏的，则为 TRUE。
			lastused	时间戳（秒），类似 |localtime()|，表示缓冲区最后一次使用的时间。
			listed		如果缓冲区已列出，则为 TRUE。
			lnum		在当前窗口中打开缓冲区时使用的行号。
					仅当缓冲区过去曾在此窗口中显示过时才有效。
					如果你想获取给定窗口中最后已知光标位置的行号，请使用 |line()|： >vim
						echo line('.', {winid})
<
			linecount	缓冲区中的行数（仅在加载时有效）
			loaded		如果缓冲区已加载，则为 TRUE。
			name		缓冲区中文件的完整路径。
			signs		放置在缓冲区中的标志列表。
					每个列表项是一个包含以下字段的字典：
					    id	  标志标识符
					    lnum  行号
					    name  标志名称
			variables	对包含缓冲区局部变量的字典的引用。
			windows		显示此缓冲区的 |窗口-ID| 列表

		示例： >vim
			for buf in getbufinfo()
			    echo buf.name
			endfor
			for buf in getbufinfo({'buflisted':1})
			    if buf.changed
				" ....
			    endif
			endfor
<
		要获取缓冲区局部选项，请使用： >vim
			getbufvar({bufnr}, '&option_name')
<

                参数： ~
                  • {dict} (`vim.fn.getbufinfo.dict?`)

                返回： ~
                  (`vim.fn.getbufinfo.ret.item[]`)

getbufline({buf}, {lnum} [, {end}])                               *getbufline()*
		返回一个 |列表|，包含缓冲区 {buf} 中从 {lnum} 行到 {end} 行（包含）的行。
		如果省略 {end}，则返回一个仅包含 {lnum} 行的 |列表|。
		参见 `getbufoneline()` 以仅获取一行。

		关于 {buf} 的使用，请参见上面的 |bufname()|。

		对于 {lnum} 和 {end}，可以使用 "$" 表示缓冲区的最后一行。否则必须使用数字。

		当 {lnum} 小于 1 或大于缓冲区中的行数时，返回一个空 |列表|。

		当 {end} 大于缓冲区中的行数时，它会被视为 {end} 设置为缓冲区中的行数。
		当 {end} 在 {lnum} 之前时，返回一个空 |列表|。

		此函数仅对已加载的缓冲区有效。对于未加载和不存在的缓冲区，返回一个空 |列表|。

		示例： >vim
			let lines = getbufline(bufnr("myfile"), 1, "$")
<

                参数： ~
                  • {buf} (`整数|字符串`)
                  • {lnum} (`整数`)
                  • {end} (`整数?`)

                返回： ~
                  (`字符串[]`)

getbufoneline({buf}, {lnum})                                   *getbufoneline()*
		类似于 `getbufline()`，但只获取一行并将其作为字符串返回。

                参数： ~
                  • {buf} (`整数|字符串`)
                  • {lnum} (`整数`)

                返回： ~
                  (`字符串`)

getbufvar({buf}, {varname} [, {def}])                              *getbufvar()*
		结果是缓冲区 {buf} 中的选项或局部缓冲区变量 {varname} 的值。
		注意：必须使用不带 "b:" 的名称。
		{varname} 参数是一个字符串。
		当 {varname} 为空时，返回一个包含所有缓冲区局部变量的 |字典|。
		当 {varname} 等于 "&" 时，返回一个包含所有缓冲区局部选项的 |字典|。
		否则，当 {varname} 以 "&" 开头时，返回缓冲区局部选项的值。
		这也适用于全局或缓冲区局部选项，但它不适用于全局变量、窗口局部变量或窗口局部选项。
		关于 {buf} 的使用，请参见上面的 |bufname()|。
		当缓冲区或变量不存在时，返回 {def} 或空字符串，没有错误消息。
		示例： >vim
			let bufmodified = getbufvar(1, "&mod")
			echo "todo myvar = " .. getbufvar("todo", "myvar")
<

                参数： ~
                  • {buf} (`整数|字符串`)
                  • {varname} (`字符串`)
                  • {def} (`任意?`)

                返回： ~
                  (`任意`)

getcellwidths()                                                *getcellwidths()*
		返回一个 |列表|，包含由 |setcellwidths()| 覆盖的字符范围的单元格宽度。
		格式与 |setcellwidths()| 的参数相同。
		如果没有字符范围的单元格宽度被覆盖，则返回一个空列表。

                返回： ~
                  (`任意`)

getchangelist([{buf}])                                         *getchangelist()*
		返回缓冲区 {buf} 的 |变更列表|。
		关于 {buf} 的使用，请参见上面的 |bufname()|。
		如果缓冲区 {buf} 不存在，则返回一个空列表。

		返回的列表包含两个条目：一个包含变更位置的列表和列表中的当前位置。
		变更列表中的每个条目是一个包含以下条目的字典：
			col		列号
			coladd		'virtualedit' 的列偏移
			lnum		行号
		如果缓冲区 {buf} 是当前缓冲区，则当前位置指的是列表中的位置。
		对于其他缓冲区，它被设置为列表的长度。

                参数： ~
                  • {buf} (`整数|字符串?`)

                返回： ~
                  (`表[]`)

getchar([{expr} [, {opts}]])                                         *getchar()*
		从用户或输入流获取单个字符。
		如果 {expr} 被省略或是 -1，则等待直到有字符可用。
		如果 {expr} 是 0，仅当有字符可用时才获取一个字符。
			否则返回零。
		如果 {expr} 是 1，仅检查是否有字符可用，不消耗它。如果没有字符可用则返回零。
		要始终获取字符串，请在 {opts} 中将 "number" 指定为 |FALSE|。

		没有 {expr} 且当 {expr} 为 0 时，返回一个完整的字符或特殊键。
		如果它是单个字符，则结果是一个数字。使用 |nr2char()| 将其转换为字符串。
		否则返回一个包含编码字符的字符串。
		对于特殊键，它是一个以 0x80（十进制：128）开头的字节序列的字符串。
		这与字符串 "\<Key>" 的值相同，例如 "\<Left>"。
		当使用了字符中未包含的修饰符（shift, control, alt）时，返回值也是一个字符串。
		|keytrans()| 也可以用于将返回的字符串转换为可读形式。

		当 {expr} 为 0 且键入了 Esc 时，会有一个短暂的延迟，因为 Vim 等待查看这是否是转义序列的开始。

		当 {expr} 为 1 时，仅返回第一个字节。
		对于单字节字符，它是字符本身作为数字。
		使用 nr2char() 将其转换为字符串。

		使用 getcharmod() 获取任何额外的修饰符。

		可选参数 {opts} 是一个字典，支持以下项：

			cursor		一个字符串，指定等待字符时的光标行为。
					"hide": 隐藏光标。
					"keep": 保持当前光标不变。
					"msg": 将光标移动到消息区域。
					（默认：自动在 "keep" 和 "msg" 之间决定）

			number		如果为 |TRUE|，则在获取单个字符时返回数字。
					如果为 |FALSE|，则返回值总是转换为字符串，并且当没有字符可用时返回空字符串（而不是 0）。
					（默认：|TRUE|）

			simplify	如果为 |TRUE|，则尽可能在字符中包含修饰符。例如，对 CTRL-I 和 <Tab> 返回相同的值。
					如果为 |FALSE|，则不在字符中包含修饰符。
					（默认：|TRUE|）

		当用户点击鼠标按钮时，将返回鼠标事件。
		然后可以在 |v:mouse_col|、|v:mouse_lnum|、|v:mouse_winid| 和 |v:mouse_win| 中找到位置。
		也可以使用 |getmousepos()|。
		鼠标移动事件将被忽略。
		此示例按通常的方式定位鼠标： >vim
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win .. "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " .. v:mouse_col .. "|"
			endif
<
		没有提示，您必须以某种方式向用户表明需要键入一个字符。
		屏幕不会重画，例如在调整窗口大小时。

		没有字符的映射。
		键码会被替换，因此当用户按下 <Del> 键时，您会得到 <Del> 键的代码，而不是原始的字符序列。
		示例： >vim
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		此示例重新定义 "f" 以忽略大小写： >vim
			nmap f :call FindChar()<CR>
			function FindChar()
			  let c = nr2char(getchar())
			  while col('.') < col('$') - 1
			    normal l
			    if getline('.')[col('.') - 1] ==? c
			      break
			    endif
			  endwhile
			endfunction
<

                参数： ~
                  • {expr} (`-1|0|1?`)
                  • {opts} (`表?`)

                返回： ~
                  (`整数|字符串`)

getcharmod()                                                      *getcharmod()*
		结果是一个数字，表示通过 getchar() 或其他方式获取的最后一个字符的修饰符状态。
		这些值相加在一起：
			2	shift
			4	control
			8	alt (meta)
			16	meta (当它与 ALT 不同时)
			32	鼠标双击
			64	鼠标三击
			96	鼠标四击 (== 32 + 64)
			128	command (Mac) 或 super
		仅获取未包含在字符本身的修饰符。
		因此 Shift-a 导致 "A" 而没有修饰符。如果未使用任何修饰符，则返回 0。

                返回： ~
                  (`整数`)

getcharpos({expr})                                                *getcharpos()*
		获取字符串 {expr} 的位置。与 |getpos()| 相同，但返回列表中的列号是字符索引而不是字节索引。
		如果 |getpos()| 返回一个非常大的列号，等于 |v:maxcol|，那么 getcharpos() 将返回最后一个字符的字符索引。

		示例：
		光标在第 5 行的文本 "여보세요" 中的 '세' 上： >vim
			getcharpos('.')		返回 [0, 5, 3, 0]
			getpos('.')		返回 [0, 5, 7, 0]
<

                参数： ~
                  • {expr} (`字符串`)

                返回： ~
                  (`整数[]`)


getcharsearch()                                                *getcharsearch()*
		将当前的字符搜索信息作为 {dict} 返回，包含以下条目：

		    char	先前用于字符搜索的字符（|t|、|f|、|T| 或 |F|）；如果未执行过字符搜索，则为空字符串
		    forward	字符搜索的方向；1 表示向前，0 表示向后
		    until	字符搜索的类型；1 表示 |t| 或 |T| 字符搜索，0 表示 |f| 或 |F| 字符搜索

		这对于始终让 |;| 和 |,| 向前/向后搜索而不管先前字符搜索的方向很有用： >vim
			nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		另见 |setcharsearch()|。

                返回： ~
                  (`表`)

getcharstr([{expr} [, {opts}]])                                   *getcharstr()*
		与 |getchar()| 相同，只是此函数始终返回字符串，并且 {opts} 中不允许使用 "number"。

                参数： ~
                  • {expr} (`-1|0|1?`)
                  • {opts} (`表?`)

                返回： ~
                  (`字符串`)

getcmdcomplpat()                                              *getcmdcomplpat()*
		返回当前命令行的补全模式。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、|getcmdprompt()|、|getcmdcompltype()| 和 |setcmdline()|。
		当未定义补全时返回空字符串。

                返回： ~
                  (`字符串`)

getcmdcompltype()                                            *getcmdcompltype()*
		返回当前命令行补全的类型。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		关于返回字符串，请参见 |:command-completion|。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、|getcmdprompt()|、|getcmdcomplpat()| 和 |setcmdline()|。
		当未定义补全时返回空字符串。

		要获取指定字符串的命令行补全类型，请使用 |getcompletiontype()|。

                返回： ~
                  (`字符串`)

getcmdline()                                                      *getcmdline()*
		返回当前命令行输入。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		示例： >vim
			cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		另见 |getcmdtype()|、|getcmdpos()|、|setcmdpos()|、|getcmdprompt()| 和 |setcmdline()|。
		在输入密码或使用 |inputsecret()| 时返回空字符串。

                返回： ~
                  (`字符串`)

getcmdpos()                                                        *getcmdpos()*
		以字节计数返回命令行中光标的位置。第一列是 1。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=| 或表达式映射。
		否则返回 0。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、|getcmdprompt()| 和 |setcmdline()|。

                返回： ~
                  (`整数`)

getcmdprompt()                                                  *getcmdprompt()*
		返回使用 |input()| 或 |confirm()| 等函数时的当前命令行提示符。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=|。
		另见 |getcmdtype()|、|getcmdline()|、|getcmdpos()|、|setcmdpos()| 和 |setcmdline()|。

                返回： ~
                  (`字符串`)

getcmdscreenpos()                                            *getcmdscreenpos()*
		以字节计数返回命令行中光标的屏幕位置。第一列是 1。
		与 |getcmdpos()| 不同，它添加了提示符位置。
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=| 或表达式映射。
		否则返回 0。
		另见 |getcmdpos()|、|setcmdpos()|、|getcmdline()| 和 |setcmdline()|。

                返回： ~
                  (`整数`)

getcmdtype()                                                      *getcmdtype()*
		返回当前命令行类型。可能的返回值有：
		    :	普通 Ex 命令
		    >	调试模式命令 |debug-mode|
		    /	向前搜索命令
		    ?	向后搜索命令
		    @	|input()| 命令
		    `-`	|:insert| 或 |:append| 命令
		    =	|i_CTRL-R_=|
		仅在编辑命令行时有效，因此需要使用 |c_CTRL-\_e| 或 |c_CTRL-R_=| 或表达式映射。
		否则返回空字符串。
		另见 |getcmdpos()|、|setcmdpos()| 和 |getcmdline()|。

                返回： ~
                  (`':'|'>'|'/'|'?'|'@'|'-'|'='`)

getcmdwintype()                                                *getcmdwintype()*
		返回当前 |command-line-window| 类型。可能的返回值与 |getcmdtype()| 相同。
		当不在命令行窗口中时返回空字符串。

                返回： ~
                  (`':'|'>'|'/'|'?'|'@'|'-'|'='`)

getcompletion({pat}, {type} [, {filtered}])                    *getcompletion()*
		返回命令行补全匹配的列表。字符串 {type} 参数指定补全类型。
		支持以下补全类型：

		arglist		参数列表中的文件名
		augroup		自动命令组
		buffer		缓冲区名
		breakpoint	|:breakadd| 和 |:breakdel| 子选项
		cmdline		|cmdline-completion| 结果
		color		配色方案
		command		Ex 命令
		compiler	编译器
		custom,{func}	自定义补全，通过 {func} 定义
		customlist,{func} 自定义补全，通过 {func} 定义
		diff_buffer	|:diffget| 和 |:diffput| 补全
		dir		目录名
		dir_in_path	'cdpath' 中的目录名
		environment	环境变量名
		event		自动命令事件
		expression	Vim 表达式
		file		文件和目录名
		file_in_path	'path' 中的文件和目录名
		filetype	文件类型名 'filetype'
		filetypecmd	|:filetype| 子选项
		function	函数名
		help		帮助主题
		highlight	高亮组
		history		|:history| 子选项
		keymap		键盘映射
		locale		区域设置名（locale -a 的输出）
		mapclear	缓冲区参数
		mapping		映射名
		menu		菜单
		messages	|:messages| 子选项
		option		选项
		packadd		可选包 |pack-add| 名称
		retab		|:retab| 子选项
		runtime		|:runtime| 补全
		scriptnames	已源脚本名 |:scriptnames|
		shellcmd	Shell 命令
		shellcmdline	带文件名参数的 Shell 命令行
		sign		|:sign| 子选项
		syntax		语法文件名 'syntax'
		syntime		|:syntime| 子选项
		tag		标签
		tag_listfiles	标签，文件名
		user		用户名
		var		用户变量

		如果 {pat} 是空字符串，则返回所有匹配项。
		否则仅返回与 {pat} 匹配的项。
		关于 {pat} 中特殊字符的使用，请参见 |wildcards|。

		如果可选的 {filtered} 标志设置为 1，则应用 'wildignore' 来过滤结果。
		否则返回所有匹配项。'wildignorecase' 选项总是适用。

		如果 'wildoptions' 选项包含 "fuzzy"，则使用模糊匹配来获取补全匹配项。
		否则使用正则表达式匹配。
		因此此函数遵循用户偏好，就像在命令行上发生的那样。
		如果您不希望这样，可以在调用 getcompletion() 之前将 'wildoptions' 置空，并在之后恢复它。

		如果 {type} 是 "cmdline"，则返回 |cmdline-completion| 结果。
		例如，要补全 ":call" 命令后的可能值： >vim
			echo getcompletion('call ', 'cmdline')
<
		如果没有匹配项，则返回空列表。
		{type} 的无效值会产生错误。

                参数： ~
                  • {pat} (`字符串`)
                  • {type} (`字符串`)
                  • {filtered} (`布尔值?`)

                返回： ~
                  (`字符串[]`)

getcompletiontype({pat})                                   *getcompletiontype()*
		使用 {pat} 返回命令行补全的类型。
		当未找到相应的补全类型时，返回空字符串。
		要获取当前命令行补全类型，请使用 |getcmdcompltype()|。

                参数： ~
                  • {pat} (`字符串`)

                返回： ~
                  (`字符串`)

getcurpos([{winid}])                                               *getcurpos()*
		获取光标的位置。
		这类似于 getpos('.')，但在列表中包含一个额外的 "curswant" 项：
		    [0, lnum, col, off, curswant] ~
		"curswant" 数字是垂直移动光标时的首选列。
		执行 |$| 命令后，它将是一个非常大的数字，等于 |v:maxcol|。
		另见 |getcursorcharpos()| 和 |getpos()|。
		第一个 "bufnum" 项总是零。
		光标的字节位置在 "col" 中返回。要获取字符位置，请使用 |getcursorcharpos()|。

		可选的 {winid} 参数可以指定窗口。它可以是窗口编号或 |window-ID|。
		返回最后已知的光标位置，如果它不是当前窗口，则此位置对于缓冲区的当前值可能无效。
		如果 {winid} 无效，则返回一个包含零的列表。

		这可用于保存和恢复光标位置： >vim
			let save_cursor = getcurpos()
			MoveTheCursorAround
			call setpos('.', save_cursor)
<		注意，这仅在窗口内有效。要恢复更多状态，请参见 |winrestview()|。

                参数： ~
                  • {winid} (`整数?`)

                返回： ~
                  (`[整数, 整数, 整数, 整数, 整数]`)

getcursorcharpos([{winid}])                                 *getcursorcharpos()*
		与 |getcurpos()| 相同，但返回列表中的列号是字符索引而不是字节索引。

		示例：
		光标在第 3 行的文本 "여보세요" 中的 '보' 上： >vim
			getcursorcharpos()	" 返回 [0, 3, 2, 0, 3]
			getcurpos()		" 返回 [0, 3, 4, 0, 3]
<

                参数： ~
                  • {winid} (`整数?`)

                返回： ~
                  (`任意`)

getcwd([{winnr} [, {tabnr}]])                                         *getcwd()*
		没有参数时，返回有效 |current-directory| 的名称。
		使用 {winnr} 或 {tabnr} 时，返回该作用域的工作目录，并忽略 'autochdir'。
		标签页和窗口由其各自的编号标识，0 表示当前标签页或窗口。
		省略标签页编号意味着 0。
		因此以下内容是等价的： >vim
			getcwd(0)
			getcwd(0, 0)
<		如果 {winnr} 是 -1，则忽略它，仅解析标签页。
		{winnr} 可以是窗口编号或 |window-ID|。
		如果 {winnr} 和 {tabnr} 都是 -1，则返回全局工作目录。
		如果参数无效，则抛出错误。|E5000| |E5001| |E5002|

                参数： ~
                  • {winnr} (`整数?`)
                  • {tabnr} (`整数?`)

                返回： ~
                  (`字符串`)

getenv({name})                                                        *getenv()*
		返回环境变量 {name} 的值。
		{name} 参数是一个字符串，不带前导 '$'。
		示例： >vim
			myHome = getenv('HOME')

<		当变量不存在时，返回 |v:null|。
		这与设置为空字符串的变量不同。
		另见 |expr-env|。

                参数： ~
                  • {name} (`字符串`)

                返回： ~
                  (`字符串`)

getfontname([{name}])                                            *getfontname()*
		没有参数时，返回正在使用的正常字体的名称。
		类似于用于 Normal 高亮组 |hl-Normal| 的字体。
		带参数时，检查字符串 {name} 是否是有效的字体名称。
		如果不是，则返回空字符串。
		否则返回实际字体名称，或者如果 GUI 不支持获取真实名称，则返回 {name}。
		仅在 GUI 运行时有效，因此在您的 vimrc 或 gvimrc 文件中无效。
		使用 |GUIEnter| 自动命令在 GUI 启动后立即使用此函数。

                参数： ~
                  • {name} (`字符串?`)

                返回： ~
                  (`字符串`)

getfperm({fname})                                                   *getfperm()*
		结果是一个字符串，它是给定文件 {fname} 的读、写和执行权限。
		如果 {fname} 不存在或其目录无法读取，则返回空字符串。
		结果的形式为 "rwxrwxrwx"，其中每组 "rwx" 标志依次表示文件所有者、文件所属组和其他用户的权限。
		如果用户没有给定权限，则该标志替换为字符串 "-"。
		示例： >vim
			echo getfperm("/etc/passwd")
			echo getfperm(expand("~/.config/nvim/init.vim"))
<		这有望（从安全角度）显示字符串 "rw-r--r--" 甚至 "rw-------"。

		要设置权限，请使用 |setfperm()|。

                参数： ~
                  • {fname} (`字符串`)

                返回： ~
                  (`字符串`)

getfsize({fname})                                                   *getfsize()*
		结果是一个数字，它是给定文件 {fname} 的大小（字节）。
		如果 {fname} 是目录，则返回 0。
		如果找不到文件 {fname}，则返回 -1。
		如果 {fname} 的大小太大无法放入数字中，则返回 -2。

                参数： ~
                  • {fname} (`字符串`)

                返回： ~
                  (`整数`)

getftime({fname})                                                   *getftime()*
		结果是一个数字，它是给定文件 {fname} 的最后修改时间。
		该值测量自 1970 年 1 月 1 日以来的秒数，可以传递给 strftime()。
		另见 |localtime()| 和 |strftime()|。
		如果找不到文件 {fname}，则返回 -1。

                参数： ~
                  • {fname} (`字符串`)

                返回： ~
                  (`整数`)

getftype({fname})                                                   *getftype()*
		结果是一个字符串，它是对给定文件 {fname} 的文件类型的描述。
		如果 {fname} 不存在，则返回空字符串。
		以下是不同文件类型及其结果的表格：
			普通文件		"file"
			目录			"dir"
			符号链接		"link"
			块设备			"bdev"
			字符设备		"cdev"
			套接字			"socket"
			FIFO			"fifo"
			其他			"other"
		示例： >vim
			getftype("/home")
<		注意，诸如 "link" 之类的类型仅在支持它的系统上返回。
		在某些系统上，仅返回 "dir" 和 "file"。

                参数： ~
                  • {fname} (`字符串`)

                返回： ~
                  (`'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'`)

getjumplist([{winnr} [, {tabnr}]])                               *getjumplist()*
		返回指定窗口的 |jumplist|。

		没有参数时使用当前窗口。
		使用 {winnr} 时仅使用当前标签页中的此窗口。
		{winnr} 也可以是 |window-ID|。
		使用 {winnr} 和 {tabnr} 时，使用指定标签页中的窗口。
		如果 {winnr} 或 {tabnr} 无效，则返回空列表。

		返回的列表包含两个条目：一个包含跳转位置的列表和列表中最后使用的跳转位置编号。
		跳转位置列表中的每个条目是一个包含以下条目的字典：
			bufnr		缓冲区编号
			col		列号
			coladd		'virtualedit' 的列偏移
			filename	文件名（如果可用）
			lnum		行号

                参数： ~
                  • {winnr} (`整数?`)
                  • {tabnr} (`整数?`)

                返回： ~
                  (`vim.fn.getjumplist.ret`)

getline({lnum} [, {end}])                                            *getline()*
		没有 {end} 时，结果是一个字符串，它是当前缓冲区中的第 {lnum} 行。
		示例： >vim
			getline(1)
<		当 {lnum} 是一个不以数字开头的字符串时，调用 |line()| 将字符串转换为数字。
		要获取光标下的行： >vim
			getline(".")
<		当 {lnum} 是小于 1 或大于缓冲区行数的数字时，返回空字符串。

		当给出 {end} 时，结果是一个 |列表|，其中每个项是当前缓冲区中从 {lnum} 到 {end} 范围的行，包括第 {end} 行。
		{end} 的使用方式与 {lnum} 相同。
		不存在的行被静默忽略。
		当 {end} 在 {lnum} 之前时，返回空 |列表|。
		示例： >vim
			let start = line('.')
			let end = search("^$") - 1
			let lines = getline(start, end)

<		要获取另一个缓冲区的行，请参见 |getbufline()| 和 |getbufoneline()|

                参数： ~
                  • {lnum} (`整数|字符串`)
                  • {end} (`nil|false?`)

                返回： ~
                  (`字符串`)

getloclist({nr} [, {what}])                                       *getloclist()*
		返回一个 |列表|，其中包含窗口 {nr} 的位置列表中的所有条目。
		{nr} 可以是窗口编号或 |window-ID|。
		当 {nr} 为零时使用当前窗口。

		对于位置列表窗口，返回显示的位置列表。
		对于无效的窗口编号 {nr}，返回空列表。
		否则，与 |getqflist()| 相同。

		如果提供了可选的 {what} 字典参数，则返回 {what} 中列出的项作为字典。
		有关 {what} 中支持的项，请参考 |getqflist()|。

		除了 |getqflist()| 在 {what} 中支持的项之外，|getloclist()| 还支持以下项：

			filewinid	用于显示位置列表中文件的窗口 ID。
					仅当从位置列表窗口调用时，此字段才适用。
					有关更多详细信息，请参见 |location-list-file-window|。

		如果窗口 {nr} 没有位置列表，则返回带有默认值的 |字典|。
		如果窗口 {nr} 不存在，则返回空字典。

		示例（另见 |getqflist-examples|）： >vim
			echo getloclist(3, {'all': 0})
			echo getloclist(5, {'filewinid': 0})
<

                参数： ~
                  • {nr} (`整数`)
                  • {what} (`表?`)

                返回： ~
                  (`任意`)

getmarklist([{buf}])                                             *getmarklist()*
		没有 {buf} 参数时，返回一个 |列表|，其中包含有关所有全局标记的信息。|mark|

		如果指定了可选的 {buf} 参数，则返回在缓冲区 {buf} 中定义的局部标记。
		关于 {buf} 的使用，请参见 |bufname()|。
		如果 {buf} 无效，则返回空列表。

		返回列表中的每个项是一个 |字典|，包含以下内容：
		    mark   标记名称，前缀为 "'"
		    pos	   一个 |列表|，包含标记的位置：
				[bufnum, lnum, col, off]
			   有关更多信息，请参考 |getpos()|。
		    file   文件名

		有关获取特定标记的信息，请参考 |getpos()|。

                参数： ~
                  • {buf} (`整数??`)

                返回： ~
                  (`vim.fn.getmarklist.ret.item[]`)

getmatches([{win}])                                               *getmatches()*
		返回一个 |列表|，其中包含之前为当前窗口通过 |matchadd()| 和 |:match| 命令定义的所有匹配。
		|getmatches()| 与 |setmatches()| 结合使用很有用，因为 |setmatches()| 可以恢复由 |getmatches()| 保存的匹配列表。
		如果指定了 {win}，则使用此编号或窗口 ID 的窗口而不是当前窗口。
		如果 {win} 无效，则返回空列表。
		示例： >vim
			echo getmatches()
<		 >
			[{"group": "MyGroup1", "pattern": "TODO",
			"priority": 10, "id": 1}, {"group": "MyGroup2",
			"pattern": "FIXME", "priority": 10, "id": 2}]
<		 >vim
			let m = getmatches()
			call clearmatches()
			echo getmatches()
<		 >
			[]
<		 >vim
			call setmatches(m)
			echo getmatches()
<		 >
			[{"group": "MyGroup1", "pattern": "TODO",
			"priority": 10, "id": 1}, {"group": "MyGroup2",
			"pattern": "FIXME", "priority": 10, "id": 2}]
<		 >vim
			unlet m
<

                参数： ~
                  • {win} (`整数?`)

                返回： ~
                  (`vim.fn.getmatches.ret.item[]`)

getmousepos()                                                    *getmousepos()*
		返回一个 |字典|，其中包含鼠标的最后已知位置。
		这可用于映射鼠标点击。
		项包括：
			screenrow	屏幕行
			screencol	屏幕列
			winid		点击的窗口 ID
			winrow		"winid" 内的行
			wincol		"winid" 内的列
			line		"winid" 内的文本行
			column		"winid" 内的文本列
			coladd		从点击字符开始的偏移（以屏幕列为单位）
		所有数字都是 1-based。

		如果不在窗口上方，例如在命令行中，则只有 "screenrow" 和 "screencol" 有效，其他为零。

		当在窗口下方的状态行或窗口右侧的垂直分隔符上时，"line" 和 "column" 值为零。

		当位置在文本之后时，"column" 是文本长度（字节）加一。

		如果鼠标在可聚焦的浮动窗口上方，则使用该窗口。

		使用 |getchar()| 时，Vim 变量 |v:mouse_lnum|、|v:mouse_col| 和 |v:mouse_winid| 也提供这些值。

                返回： ~
                  (`vim.fn.getmousepos.ret`)

getpid()                                                              *getpid()*
		返回一个数字，它是 Vim 进程的进程 ID。
		这是一个唯一的数字，直到 Vim 退出。

                返回： ~
                  (`整数`)

getpos({expr})                                                        *getpos()*
		获取字符串 {expr} 的位置。
		{expr} 的可接受值为：
		    .	    光标位置。
		    $	    当前缓冲区中的最后一行。
		    'x	    标记 x 的位置（如果未设置标记，则所有值返回 0）。
		    w0	    当前窗口中可见的第一行（如果显示未更新，例如在静默 Ex 模式下，则为 1）。
		    w$	    当前窗口中可见的最后一行（如果没有行可见，则比 "w0" 小一）。
		    v	    不在可视模式时，返回光标位置。
				在可视模式时，返回可视区域的另一端。
				思考这一点的一个好方法是，在可视模式中 "v" 和 "." 是互补的。
				当 "." 指的是光标位置时，"v" 指的是 |v_o| 会移动光标的位置。
				因此，您可以在字符方式可视模式中一起使用 "v" 和 "." 来处理整个选择。
				如果光标在字符方式可视区域的末尾，"v" 指的是同一可视区域的开始。
				如果光标在字符方式可视区域的开始，"v" 指的是同一可视区域的末尾。
				"v" 与 |'<| 和 |'>| 的不同之处在于它会立即更新。
		注意，可以使用另一个文件中的标记。行号然后应用于另一个缓冲区。

		结果是一个包含四个数字的 |列表|：
		    [bufnum, lnum, col, off]
		"bufnum" 是零，除非使用了像 '0 或 'A 这样的标记，那么它是标记的缓冲区编号。
		"lnum" 和 "col" 是缓冲区中的位置。第一列是 1。
		"off" 数字是零，除非使用了 'virtualedit'。那么它是从字符开始处的屏幕列偏移。
		例如，<Tab> 内的位置或最后一个字符之后的位置。

		要获取光标位置，请参见 |getcurpos()|。
		返回列表中的列号是行内的字节位置。要获取行内的字符位置，请使用 |getcharpos()|。

		注意对于 '< 和 '>，可视模式很重要：当它是 "V"（可视行模式）时，'< 的列为零，'> 的列是一个等于 |v:maxcol| 的大数字。
		可以返回一个等于 |v:maxcol| 的非常大的列号，在这种情况下，它意味着“在行尾之后”。
		如果 {expr} 无效，则返回一个全零的列表。

		这可用于保存和恢复标记的位置： >vim
			let save_a_mark = getpos("'a")
			" ...
			call setpos("'a", save_a_mark)
<
		另见 |getcharpos()|、|getcurpos()| 和 |setpos()|。

                参数： ~
                  • {expr} (`字符串`)

                返回： ~
                  (`[整数, 整数, 整数, 整数]`)

getqflist([{what}])                                                *getqflist()*
		返回一个 |列表|，其中包含所有当前快速修复错误。
		每个列表项是一个包含以下条目的字典：
			bufnr	具有文件名的缓冲区编号，使用 bufname() 获取名称
			module	模块名
			lnum	缓冲区中的行号（第一行是 1）
			end_lnum
				如果项是多行的，则为结束行号
			col	列号（第一列是 1）
			end_col	如果项有范围，则为结束列号
			vcol	|TRUE|："col" 是可视列
				|FALSE|："col" 是字节索引
			nr	错误编号
			pattern	用于定位错误的搜索模式
			text	错误描述
			type	错误类型，'E'、'1' 等。
			valid	|TRUE|：识别的错误消息
			user_data
				与项关联的自定义数据，可以是任何类型。

		当没有错误列表或为空时，返回空列表。
		缓冲区编号不存在的快速修复列表项返回时 "bufnr" 设置为零（注意：一些函数接受零作为交替缓冲区的缓冲区编号，您可能需要显式检查零）。

		有用的应用：在多个文件中查找模式匹配并对它们执行操作： >vim
			vimgrep /theword/jg *.c
			for d in getqflist()
			   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			endfor
<
		如果提供了可选的 {what} 字典参数，则仅返回 {what} 中列出的项作为字典。
		{what} 中支持以下字符串项：
			changedtick	获取对列表所做的更改总数 |quickfix-changedtick|
			context	获取 |quickfix-context|
			efm	解析 "lines" 时使用的 errorformat。
				如果不存在，则使用 'errorformat' 选项值。
			id	获取具有 |quickfix-ID| 的快速修复列表的信息；零表示当前列表或由 "nr" 指定的列表的 ID
			idx	获取由 "id" 或 "nr" 指定的列表中此索引处的快速修复项的信息。
				如果设置为零，则使用当前项。
				参见 |quickfix-index|
			items	快速修复列表项
			lines	使用 'efm' 解析行列表并返回结果项。
				仅接受 |列表| 类型。
				不修改当前快速修复列表。
				参见 |quickfix-parse|。
			nr	获取此快速修复列表的信息；零表示当前快速修复列表，"$" 表示最后一个快速修复列表
			qfbufnr	在快速修复窗口中显示的缓冲区的编号。
				如果快速修复缓冲区不存在，则返回 0。
				参见 |quickfix-buffer|。
			size	快速修复列表中的项数
			title	获取列表标题 |quickfix-title|
			winid	获取快速修复 |window-ID|
			all	以上所有快速修复属性
		{what} 中的非字符串项被忽略。
		要获取特定项的值，将其设置为零。
		如果不存在 "nr"，则使用当前快速修复列表。
		如果同时指定了 "nr" 和非零 "id"，则使用由 "id" 指定的列表。
		要获取快速修复堆栈中的列表数，在 {what} 中将 "nr" 设置为 "$"。
				返回字典中的 "nr" 值包含快速修复堆栈大小。
		当指定 "lines" 时，忽略除 "efm" 之外的所有其他项。
				返回的字典包含条目 "items"，其中是项列表。

		返回的字典包含以下条目：
			changedtick	对列表所做的更改总数 |quickfix-changedtick|
			context	快速修复列表上下文。参见 |quickfix-context|
				如果不存在，设置为 ""。
			id	快速修复列表 ID |quickfix-ID|。如果不存在，设置为 0。
			idx	列表中快速修复项的索引。如果不存在，设置为 0。
			items	快速修复列表项。如果不存在，设置为空列表。
			nr	快速修复列表编号。如果不存在，设置为 0
			qfbufnr	在快速修复窗口中显示的缓冲区的编号。如果不存在，设置为 0。
			size	快速修复列表中的项数。如果不存在，设置为 0。
			title	快速修复列表标题文本。如果不存在，设置为 ""。
			winid	快速修复 |window-ID|。如果不存在，设置为 0

		示例（另见 |getqflist-examples|）： >vim
			echo getqflist({'all': 1})
			echo getqflist({'nr': 2, 'title': 1})
			echo getqflist({'lines' : ["F1:10:L10"]})
<

                参数： ~
                  • {what} (`表?`)

                返回： ~
                  (`任意`)

getreg([{regname} [, 1 [, {list}]]])                                  *getreg()*
		结果是一个字符串，它是寄存器 {regname} 的内容。
		示例： >vim
			let cliptext = getreg('*')
<		当寄存器 {regname} 未设置时，结果是一个空字符串。
		{regname} 参数必须是一个字符串。

		getreg('=') 返回表达式寄存器的最后评估值。（用于映射中。）
		getreg('=', 1) 返回表达式本身，以便可以使用 |setreg()| 恢复它。
				对于其他寄存器，额外参数被忽略，因此您总是可以给出它。

		如果 {list} 存在且为 |TRUE|，则结果类型更改为 |列表|。
				每个列表项是一个文本行。
				如果您关心寄存器中可能存在的零字节，请使用它：没有第三个参数时，NL 和零字节都表示为 NL（参见 |NL-used-for-Nul|）。
		当寄存器未设置时，返回空列表。

		如果未指定 {regname}，则使用 |v:register|。

                参数： ~
                  • {regname} (`字符串?`)
                  • {expr} (`任意?`)
                  • {list} (`nil|false?`)

                返回： ~
                  (`字符串`)

getreginfo([{regname}])                                           *getreginfo()*
		返回关于寄存器 {regname} 的详细信息作为字典，包含以下条目：
			regcontents	寄存器 {regname} 中包含的行列表，
					类似于 getreg({regname}, 1, 1)。
			regtype		寄存器 {regname} 的类型，如 |getregtype()|。
			isunnamed	布尔标志，如果此寄存器当前被未命名寄存器指向，则为 v:true。
			points_to	对于未命名寄存器，给出当前指向的寄存器的单字母名称（参见 |quotequote|）。
					例如，使用 `dd` 删除一行后，此字段将为 "1"，这是获得删除文本的寄存器。

		{regname} 参数是一个字符串。
		如果 {regname} 无效或未设置，则返回空字典。
		如果未指定 {regname}，则使用 |v:register|。
		返回的字典可以传递给 |setreg()|。

                参数： ~
                  • {regname} (`字符串?`)

                返回： ~
                  (`表`)


getregion({pos1}, {pos2} [, {opts}])                               *getregion()*
		返回缓冲区中从 {pos1} 到 {pos2} 的字符串列表。

		{pos1} 和 {pos2} 都必须是包含四个数字的 |列表|。
		有关列表格式，请参见 |getpos()|。
		可以指定来自不同缓冲区的位置，但请注意 |getregion-notes| 中的限制。

		可选参数 {opts} 是一个字典，支持以下项：

			type		指定区域的选择类型。
					有关可能的值，请参见 |getregtype()|，但可以省略宽度，并且不能使用空字符串。
					（默认："v"）

			exclusive	如果为 |TRUE|，则对结束位置使用独占选择。
					（默认：遵循 'selection'）

		您可以通过 |visualmode()| 获取最后的选择类型。
		如果可视模式处于活动状态，请使用 |mode()| 获取可视模式（例如，在 |:vmap| 中）。
		此函数对于获取起始和结束于不同列的文本很有用，例如 |charwise-visual| 选择。

							*getregion-notes*
		注意：
		- {pos1} 和 {pos2} 的顺序无关紧要，它将始终返回从左上位置到右下位置的内容。
		- 如果启用了 'virtualedit' 并且区域超出行的末尾，则结果行将用空格填充。
		- 如果区域是块状的，并且它开始或结束于多单元格字符的中间，则该字符不包括在内，但其选中部分将被空格替换。
		- 如果 {pos1} 和 {pos2} 不在同一缓冲区中，则返回空列表。
		- {pos1} 和 {pos2} 必须属于 |bufloaded()| 缓冲区。
		- 它在当前窗口上下文中评估，如果缓冲区显示在具有不同 'virtualedit' 或 'list' 值的窗口中，这会有所不同。
		- 当指定独占选择并且 {pos1} 和 {pos2} 相等时，返回的列表包含单个字符，就好像选择是包含的一样，以匹配可视模式中空独占选择的行为。

		示例： >vim
			xnoremap <CR>
			\ <Cmd>echom getregion(
			\ getpos('v'), getpos('.'), #{ type: mode() })<CR>
<

                参数： ~
                  • {pos1} (`[整数, 整数, 整数, 整数]`)
                  • {pos2} (`[整数, 整数, 整数, 整数]`)
                  • {opts} (`{type?:字符串, exclusive?:布尔值}?`)

                返回： ~
                  (`字符串[]`)

getregionpos({pos1}, {pos2} [, {opts}])                         *getregionpos()*
		与 |getregion()| 相同，但返回描述由 {pos1} 和 {pos2} 限定的缓冲区文本段的位置列表。
		这些段是每行的一对位置： >
			[[{start_pos}, {end_pos}], ...]
<
		位置是一个包含四个数字的 |列表|：
		    [bufnum, lnum, col, off]
		"bufnum" 是缓冲区编号。
		"lnum" 和 "col" 是缓冲区中的位置。第一列是 1。
		如果起始位置的 "off" 数字非零，则是从字符开始处的屏幕列偏移。
		例如，<Tab> 内的位置或最后一个字符之后的位置。
		如果结束位置的 "off" 数字非零，则是未包含在选择中的字符的第一个单元格的偏移，否则包含其所有单元格。

		除了 |getregion()| 支持的选项外，{opts} 还支持以下项：

			eol		如果为 |TRUE|，则使用比行长多一的 "col" 值指示超出行尾的位置。
					如果为 |FALSE|，则位置限制在其行内，并且如果行为空或选择完全超出行尾，则对两个位置使用 "col" 值 0。
					（默认：|FALSE|）

                参数： ~
                  • {pos1} (`[整数, 整数, 整数, 整数]`)
                  • {pos2} (`[整数, 整数, 整数, 整数]`)
                  • {opts}
                    (`{type?:字符串, exclusive?:布尔值, eol?:布尔值}?`)

                返回： ~
                  (`[ [整数, 整数, 整数, 整数], [整数, 整数, 整数, 整数] ][]`)

getregtype([{regname}])                                           *getregtype()*
		结果是一个字符串，它是寄存器 {regname} 的类型。
		值将是以下之一：
		    "v"		用于 |charwise| 文本
		    "V"		用于 |linewise| 文本
		    "<CTRL-V>{width}"	用于 |blockwise-visual| 文本
		    ""		用于空或未知寄存器
		<CTRL-V> 是一个值为 0x16 的字符。
		{regname} 参数是一个字符串。如果未指定 {regname}，则使用 |v:register|。

                参数： ~
                  • {regname} (`字符串?`)

                返回： ~
                  (`字符串`)

getscriptinfo([{opts}])                                        *getscriptinfo()*
		返回一个 |列表|，其中包含有关所有已源 Vim 脚本的信息，按它们被源的顺序排列，就像 `:scriptnames` 显示的那样。

		可选的字典参数 {opts} 支持以下可选项：
		    name	脚本名称匹配模式。如果指定，并且未指定 "sid"，则返回名称与模式 "name" 匹配的脚本的信息。
		    sid		脚本 ID |<SID>|。如果指定，则仅返回具有 ID "sid" 的脚本的信息，并忽略 "name"。

		返回列表中的每个项是一个 |字典|，包含以下项：
		    autoload	始终设置为 FALSE。
		    functions   脚本中定义的脚本局部函数名称列表。
					仅当使用 {opts} 中的 "sid" 项指定特定脚本时存在。
		    name	Vim 脚本文件名。
		    sid		脚本 ID |<SID>|。
		    variables   包含脚本局部变量的字典。
					仅当使用 {opts} 中的 "sid" 项指定特定脚本时存在。
					请注意，这是一个副本，无法使用此字典更改脚本局部变量的值。
		    version	Vim 脚本版本，始终为 1

		示例： >vim
			echo getscriptinfo({'name': 'myscript'})
			echo getscriptinfo({'sid': 15})[0].variables
<

                参数： ~
                  • {opts} (`表?`)

                返回： ~
                  (`vim.fn.getscriptinfo.ret[]`)

getstacktrace()                                                *getstacktrace()*
		返回 Vim 脚本的当前堆栈跟踪。
		堆栈跟踪是一个 |列表|，其中每个项是一个 |字典|，包含以下项：
		    funcref	如果堆栈在函数处，则为 funcref，否则省略此项。
		    event	如果堆栈在自动命令事件处，则为事件描述的字符串，否则省略此项。
		    lnum		堆栈上脚本的行号。
		    filepath	堆栈上脚本的文件路径。

                返回： ~
                  (`表[]`)

gettabinfo([{tabnr}])                                             *gettabinfo()*
		如果未指定 {tabnr}，则返回所有标签页的信息作为 |列表|。每个列表项是一个 |字典|。
		否则，{tabnr} 指定标签页编号，并返回有关该标签页的信息。
		如果标签页不存在，则返回空列表。

		每个列表项是一个 |字典|，包含以下条目：
			tabnr		标签页编号。
			variables	对包含标签页局部变量的字典的引用
			windows		标签页中的 |window-ID| 列表。

                参数： ~
                  • {tabnr} (`整数?`)

                返回： ~
                  (`任意`)

gettabvar({tabnr}, {varname} [, {def}])                            *gettabvar()*
		获取标签页 {tabnr} 中标签页局部变量 {varname} 的值。|t:var|
		标签页从 1 开始编号。
		{varname} 参数是一个字符串。当 {varname} 为空时，返回包含所有标签页局部变量的字典。
		注意必须使用不带 "t:" 的名称。
		当标签页或变量不存在时，返回 {def} 或空字符串，没有错误消息。

                参数： ~
                  • {tabnr} (`整数`)
                  • {varname} (`字符串`)
                  • {def} (`任意?`)

                返回： ~
                  (`任意`)

gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])             *gettabwinvar()*
		获取标签页 {tabnr} 中窗口 {winnr} 的窗口局部变量 {varname} 的值。
		{varname} 参数是一个字符串。当 {varname} 为空时，返回包含所有窗口局部变量的字典。
		当 {varname} 等于 "&" 时，获取所有窗口局部选项的值到一个 |字典| 中。
		否则，当 {varname} 以 "&" 开头时，获取窗口局部选项的值。
		注意 {varname} 必须是不带 "w:" 的名称。
		标签页从 1 开始编号。对于当前标签页，使用 |getwinvar()|。
		{winnr} 可以是窗口编号或 |window-ID|。
		当 {winnr} 为零时，使用当前窗口。
		这也适用于全局选项、缓冲区局部选项和窗口局部选项，但不适用于全局变量或缓冲区局部变量。
		当标签页、窗口或变量不存在时，返回 {def} 或空字符串，没有错误消息。
		示例： >vim
			let list_is_on = gettabwinvar(1, 2, '&list')
			echo "myvar = " .. gettabwinvar(3, 1, 'myvar')
<
		要获取所有窗口局部变量，请使用： >vim
			gettabwinvar({tabnr}, {winnr}, '&')
<

                参数： ~
                  • {tabnr} (`整数`)
                  • {winnr} (`整数`)
                  • {varname} (`字符串`)
                  • {def} (`任意?`)

                返回： ~
                  (`任意`)

gettagstack([{winnr}])                                           *gettagstack()*
		结果是一个字典，它是窗口 {winnr} 的标签堆栈。
		{winnr} 可以是窗口编号或 |window-ID|。
		当未指定 {winnr} 时，使用当前窗口。
		当窗口 {winnr} 不存在时，返回空字典。

		返回的字典包含以下条目：
			curidx		堆栈中的当前索引。当在堆栈顶部时，设置为（长度 + 1）。
					堆栈底部的索引为 1。
			items		堆栈中的项列表。每个项是一个包含下述条目的字典。
			length		堆栈中的条目数。

		堆栈中的每个项是一个包含以下条目的字典：
			bufnr		当前跳转的缓冲区编号
			from		标签跳转前的光标位置。
					有关返回列表的格式，请参见 |getpos()|。
			matchnr		当前匹配的标签编号。当为一个名称找到多个匹配标签时使用。
			tagname		标签名称

		有关标签堆栈的更多信息，请参见 |tagstack|。

                参数： ~
                  • {winnr} (`整数?`)

                返回： ~
                  (`任意`)

gettext({text})                                                      *gettext()*
		如果可能，翻译字符串 {text}。
		这主要用于分发的 Vim 脚本中。
		当生成消息翻译时，{text} 由 xgettext 提取，翻译者可以在 .po 文件中添加翻译后的消息，当调用 gettext() 时，Vim 将查找翻译。
		对于 {text}，首选双引号字符串，因为 xgettext 不理解单引号字符串中的转义。

                参数： ~
                  • {text} (`字符串`)

                返回： ~
                  (`字符串`)

getwininfo([{winid}])                                             *getwininfo()*
		返回有关窗口的信息作为包含字典的 |列表|。

		如果给定了 {winid}，则返回具有该 ID 的窗口的信息，作为一个包含一个项的 |列表|。
		如果窗口不存在，则结果是一个空列表。

		没有 {winid} 时，返回所有标签页中所有窗口的信息。

		每个列表项是一个 |字典|，包含以下条目：
			botline		最后完整显示的缓冲区行
			bufnr		窗口中缓冲区的编号
			height		窗口高度（不包括 winbar）
			leftcol		显示的第一列；仅当 'wrap' 关闭时使用
			loclist		如果显示位置列表则为 1
			quickfix	如果是 quickfix 或位置列表窗口则为 1
			terminal	如果是终端窗口则为 1
			tabnr		标签页编号
			topline		显示的第一条缓冲区行
			variables	对包含窗口局部变量的字典的引用
			width		窗口宽度
			winbar		如果窗口有工具栏则为 1，否则为 0
			wincol		窗口的最左侧屏幕列；来自 |win_screenpos()| 的 "col"
			textoff		文本前任何 'foldcolumn'、'signcolumn' 和行号占用的列数
			winid		|window-ID|
			winnr		窗口编号
			winrow		窗口的最顶部屏幕行；来自 |win_screenpos()| 的 "row"

                参数： ~
                  • {winid} (`整数?`)

                返回： ~
                  (`vim.fn.getwininfo.ret.item[]`)

getwinpos([{timeout}])                                             *getwinpos()*
		结果是一个 |列表|，包含两个数字，|getwinposx()| 和 |getwinposy()| 的结果组合：
			[x-pos, y-pos]
		{timeout} 可用于指定等待终端响应的毫秒数。
		省略时使用 100 毫秒。

		对于远程终端，使用更长时间。
		当使用小于 10 的值且在该时间内未收到响应时，返回先前报告的位置（如果可用）。
		这可用于轮询位置并同时执行一些工作： >vim
			while 1
			  let res = getwinpos(1)
			  if res[0] >= 0
			    break
			  endif
			  " 在此处执行一些工作
			endwhile
<

                参数： ~
                  • {timeout} (`整数?`)

                返回： ~
                  (`任意`)

getwinposx()                                                      *getwinposx()*
		结果是一个数字，它是 GUI Vim 窗口左侧的 X 坐标（像素）。
		如果信息不可用，结果将为 -1。
		该值可用于 `:winpos`。

                返回： ~
                  (`整数`)

getwinposy()                                                      *getwinposy()*
		结果是一个数字，它是 GUI Vim 窗口顶部的 Y 坐标（像素）。
		如果信息不可用，结果将为 -1。
		该值可用于 `:winpos`。

                返回： ~
                  (`整数`)

getwinvar({winnr}, {varname} [, {def}])                            *getwinvar()*
		类似于当前标签页的 |gettabwinvar()|。
		示例： >vim
			let list_is_on = getwinvar(2, '&list')
			echo "myvar = " .. getwinvar(1, 'myvar')
<

                参数： ~
                  • {winnr} (`整数`)
                  • {varname} (`字符串`)
                  • {def} (`任意?`)

                返回： ~
                  (`任意`)

glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])                      *glob()*
		展开 {expr} 中的文件通配符。有关特殊字符的使用，请参见 |wildcards|。

		除非给定了可选的 {nosuf} 参数且为 |TRUE|，否则应用 'suffixes' 和 'wildignore' 选项：
				匹配 'wildignore' 中模式之一的名称将被跳过，并且 'suffixes' 影响匹配的顺序。
		'wildignorecase' 总是适用。

		当 {list} 存在且为 |TRUE| 时，结果是一个包含所有匹配文件的 |列表|。
				使用列表的优点是，您还可以正确获取包含换行符的文件名。
		否则结果是一个字符串，并且当有多个匹配项时，它们由 <NL> 字符分隔。

		如果展开失败，结果是一个空字符串或列表。

		如果您需要做复杂的事情，例如限制匹配的数量，也可以使用 |readdir()|。

		不存在的文件的名称不包括在内。
		符号链接仅当它指向现有文件时才包括在内。
		但是，当 {alllinks} 参数存在且为 |TRUE| 时，所有符号链接都包括在内。

		对于大多数系统，可以使用反引号从任何外部命令获取文件名。
		示例： >vim
			let tagfiles = glob("`find . -name tags -print`")
			let &tags = substitute(tagfiles, "\n", ",", "g")
<		反引号内程序的结果应该每行一个项。项内允许有空格。

		有关扩展特殊 Vim 变量，请参见 |expand()|。
		有关获取外部命令的原始输出，请参见 |system()|。

                参数： ~
                  • {expr} (`字符串`)
                  • {nosuf} (`布尔值?`)
                  • {list} (`布尔值?`)
                  • {alllinks} (`布尔值?`)

                返回： ~
                  (`任意`)

glob2regpat({string})                                            *glob2regpat()*
		将 glob() 使用的文件模式转换为搜索模式。
		结果可用于与作为文件名的字符串匹配。
		例如： >vim
			if filename =~ glob2regpat('Make*.mak')
			  " ...
			endif
<		这等价于： >vim
			if filename =~ '^Make.*\.mak$'
			  " ...
			endif
<		当 {string} 是空字符串时，结果是 "^$"，匹配空字符串。
		注意结果取决于系统。在 MS-Windows 上，反斜杠通常表示路径分隔符。

                参数： ~
                  • {string} (`字符串`)

                返回： ~
                  (`字符串`)

globpath({path}, {expr} [, {nosuf} [, {list} [, {allinks}]]])       *globpath()*
		对 {path} 中的所有目录执行字符串 {expr} 的 glob() 并连接结果。
		示例： >vim
			echo globpath(&rtp, "syntax/c.vim")
<
		{path} 是逗号分隔的目录名列表。
		每个目录名被前置到 {expr} 并像 |glob()| 一样展开。
		需要时插入路径分隔符。
		要在目录名内添加逗号，请用反斜杠转义它。
		注意在 MS-Windows 上目录可能有尾部反斜杠，如果您在其后放置逗号，请删除它。
		如果对某个目录的展开失败，没有错误消息。

		除非给定了可选的 {nosuf} 参数且为 |TRUE|，否则应用 'suffixes' 和 'wildignore' 选项：
				匹配 'wildignore' 中模式之一的名称将被跳过，并且 'suffixes' 影响匹配的顺序。

		当 {list} 存在且为 |TRUE| 时，结果是一个包含所有匹配文件的 |列表|。
				使用列表的优点是，您还可以正确获取包含换行符的文件名。
		否则结果是一个字符串，并且当有多个匹配项时，它们由 <NL> 字符分隔。
		示例： >vim
			echo globpath(&rtp, "syntax/c.vim", 0, 1)
<
		{allinks} 的使用与 |glob()| 相同。

		"**" 项可用于在目录树中搜索。
		例如，在 'runtimepath' 中的目录及其子目录中查找所有 "README.txt" 文件： >vim
			echo globpath(&rtp, "**/README.txt")
<		不支持向上搜索和限制 "**" 的深度，因此使用 'path' 并不总是正常工作。

                参数： ~
                  • {path} (`字符串`)
                  • {expr} (`字符串`)
                  • {nosuf} (`布尔值?`)
                  • {list} (`布尔值?`)
                  • {allinks} (`布尔值?`)

                返回： ~
                  (`任意`)

has({feature})                                                           *has()*
		如果支持 {feature} 则返回 1，否则返回 0。
		{feature} 参数是一个特性名称，如 "nvim-0.2.1" 或 "win32"，详见下文。
		另见 |exists()|。

		要获取系统名称，请在 Lua 中使用 |vim.uv|.os_uname()： >lua
			print(vim.uv.os_uname().sysname)

<		如果代码有语法错误，Vimscript 可能会跳过该行的其余部分。
		将 |:if| 和 |:endif| 放在单独的行上以避免语法错误： >vim
			if has('feature')
			  let x = this_breaks_without_the_feature()
			endif
<
		Vim 的编译时特性名称（前缀为 "+"）不被识别，因为 Nvim 总是编译所有可能的特性。|feature-compile|

		特性名称可以是：
		1.  Nvim 版本。例如，"nvim-0.2.1" 特性表示 Nvim 版本为 0.2.1 或更高： >vim
			if has("nvim-0.2.1")
			  " ...
			endif

<		2.  运行时条件或其他伪特性。例如，"win32" 特性检查当前系统是否为 Windows： >vim
			if has("win32")
			  " ...
			endif
<							*feature-list*
		支持的伪特性名称列表：
			acl		支持 |ACL|。
			bsd		BSD 系统（不是 macOS，使用 "mac" 表示 macOS）。
			clipboard	|clipboard| 提供程序可用。
			fname_case	文件名区分大小写（对于 Darwin 和 MS-Windows，此特性不存在）。
			gui_running	Nvim 具有 GUI。
			hurd		GNU/Hurd 系统。
			iconv		可以使用 |iconv()| 进行转换。
			linux		Linux 系统。
			mac		MacOS 系统。
			nvim		这是 Nvim。
			python3		传统 Vim |python3| 接口。|has-python|
			pythonx		传统 Vim |python_x| 接口。|has-pythonx|
			sun		SunOS 系统。
			ttyin		输入是终端 (tty)。
			ttyout		输出是终端 (tty)。
			unix		Unix 系统。
			*vim_starting*	在 |startup| 期间为真。
			win32		Windows 系统（32 或 64 位）。
			win64		Windows 系统（64 位）。
			wsl		WSL（Windows Subsystem for Linux）系统。

							*has-patch*
		3.  Vim 补丁。例如，"patch123" 特性表示当前 |v:version| 包含了 Vim 补丁 123： >vim
			if v:version > 602 || v:version == 602 && has("patch148")
			  " ...
			endif

<		4.  Vim 版本。例如，"patch-7.4.237" 特性表示 Nvim 与 Vim 7.4.237 或更高版本兼容。 >vim
			if has("patch-7.4.237")
			  " ...
			endif
<

                参数： ~
                  • {feature} (`字符串`)

                返回： ~
                  (`0|1`)

has_key({dict}, {key})                                               *has_key()*
		结果是一个数字，如果 |字典| {dict} 有一个键为 {key} 的条目，则为 TRUE。
		否则为 FALSE。
		{key} 参数是一个字符串。

                参数： ~
                  • {dict} (`表`)
                  • {key} (`字符串`)

                返回： ~
                  (`0|1`)

haslocaldir([{winnr} [, {tabnr}]])                               *haslocaldir()*
		结果是一个数字，当窗口通过 |:lcd| 设置了本地路径，或者当 {winnr} 为 -1 且标签页通过 |:tcd| 设置了本地路径时，为 1。
		否则为 0。

		标签页和窗口由其各自的编号标识，0 表示当前标签页或窗口。
		省略参数意味着 0。
		因此以下内容是等价的： >vim
			echo haslocaldir()
			echo haslocaldir(0)
			echo haslocaldir(0, 0)
<		使用 {winnr} 时，使用当前标签页中的该窗口。
		使用 {winnr} 和 {tabnr} 时，使用该标签页中的窗口。
		{winnr} 可以是窗口编号或 |window-ID|。
		如果 {winnr} 为 -1，则忽略它，仅解析标签页。
		如果参数无效，则抛出错误。|E5000| |E5001| |E5002|

                参数： ~
                  • {winnr} (`整数?`)
                  • {tabnr} (`整数?`)

                返回： ~
                  (`0|1`)

hasmapto({what} [, {mode} [, {abbr}]])                              *hasmapto()*
		结果是一个数字，如果存在一个映射，其 rhs（映射到的内容）中的某处包含 {what}，并且此映射存在于 {mode} 指示的模式之一中，则为 TRUE。
		参数 {what} 和 {mode} 是字符串。
		当 {abbr} 存在且为 |TRUE| 时，使用缩写而不是映射。
		不要忘记指定插入和/或命令行模式。
		全局映射和当前缓冲区的局部映射都会检查匹配。
		如果未找到匹配的映射，则返回 FALSE。
		{mode} 中识别以下字符：
			n	普通模式
			v	可视和选择模式
			x	可视模式
			s	选择模式
			o	操作符待决模式
			i	插入模式
			l	语言参数（"r"、"f"、"t" 等）
			c	命令行模式
		当 {mode} 省略时，使用 "nvo"。

		此函数可用于检查 Vim 脚本中是否已存在到函数的映射。
		示例： >vim
			if !hasmapto('\ABCdoit')
			   map <Leader>d \ABCdoit
			endif
<		这仅在尚未存在到 "\ABCdoit" 的映射时安装到 "\ABCdoit" 的映射。

                参数： ~
                  • {what} (`任意`)
                  • {mode} (`字符串?`)
                  • {abbr} (`布尔值?`)

                返回： ~
                  (`0|1`)

histadd({history}, {item})                                           *histadd()*
		将字符串 {item} 添加到历史记录 {history} 中，{history} 可以是以下之一：					*hist-names*
			"cmd"	 或 ":"	  命令行历史
			"search" 或 "/"   搜索模式历史
			"expr"	 或 "="   键入的表达式历史
			"input"  或 "@"	  输入行历史
			"debug"  或 ">"   调试命令历史
			空		  当前或最后使用的历史
		{history} 字符串不需要是完整名称，一个字符就足够了。
		如果 {item} 已存在于历史记录中，它将被移动成为最新条目。
		结果是一个数字：如果操作成功则为 TRUE，否则返回 FALSE。

		示例： >vim
			call histadd("input", strftime("%Y %b %d"))
			let date=input("Enter date: ")
<		此函数在 |sandbox| 中不可用。

                参数： ~
                  • {history} (`字符串`)
                  • {item} (`任意`)

                返回： ~
                  (`0|1`)

histdel({history} [, {item}])                                        *histdel()*
		清除 {history}，即删除其所有条目。
		有关 {history} 的可能值，请参见 |hist-names|。

		如果参数 {item} 求值为字符串，则将其用作正则表达式。
		所有匹配该表达式的条目将从历史记录中移除（如果有）。
		大小写必须匹配，除非使用 "\c" |/\c|。
		如果 {item} 求值为数字，则将其解释为索引，参见 |:history-indexing|。
		如果存在相应的条目，则将其移除。

		操作成功则结果为 TRUE，否则返回 FALSE。

		示例：
		清除表达式寄存器历史： >vim
			call histdel("expr")
<
		从搜索历史中移除所有以 "*" 开头的条目： >vim
			call histdel("/", '^\*')
<
		以下三者是等价的： >vim
			call histdel("search", histnr("search"))
			call histdel("search", -1)
			call histdel("search", '^' .. histget("search", -1) .. '$')
<
		要删除最后一个搜索模式并为 "n" 命令和 'hlsearch' 使用倒数第二个： >vim
			call histdel("search", -1)
			let @/ = histget("search", -1)
<

                参数： ~
                  • {history} (`字符串`)
                  • {item} (`任意?`)

                返回： ~
                  (`0|1`)

histget({history} [, {index}])                                       *histget()*
		结果是一个字符串，它是 {history} 中编号为 {index} 的条目。
		有关 {history} 的可能值，请参见 |hist-names|，有关 {index}，请参见 |:history-indexing|。
		如果没有这样的条目，则返回空字符串。
		当 {index} 省略时，使用历史记录中最新的项。

		示例：
		重新执行历史记录中倒数第二个搜索。 >vim
			execute '/' .. histget("search", -2)

<		定义一个 Ex 命令 ":H {num}"，支持重新执行 |:history| 输出中的第 {num} 个条目。 >vim
			command -nargs=1 H execute histget("cmd", 0+<args>)
<

                参数： ~
                  • {history} (`字符串`)
                  • {index} (`整数|字符串?`)

                返回： ~
                  (`字符串`)

histnr({history})                                                     *histnr()*
		结果是 {history} 中当前条目的编号。
		有关 {history} 的可能值，请参见 |hist-names|。
		如果发生错误，返回 -1。

		示例： >vim
			let inp_index = histnr("expr")
<

                参数： ~
                  • {history} (`字符串`)

                返回： ~
                  (`整数`)

hlID({name})                                                            *hlID()*
		结果是一个数字，它是名为 {name} 的高亮组的 ID。
		当高亮组不存在时，返回零。
		这可用于检索有关高亮组的信息。
		例如，获取 "Comment" 组的背景颜色： >vim
			echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<

                参数： ~
                  • {name} (`字符串`)

                返回： ~
                  (`整数`)

hlexists({name})                                                    *hlexists()*
		结果是一个数字，如果存在名为 {name} 的高亮组，则为 TRUE。
		这是当组以某种方式被定义时。
		不一定是为其定义了高亮时，它也可能已用于语法项。

                参数： ~
                  • {name} (`字符串`)

                返回： ~
                  (`0|1`)

hostname()                                                          *hostname()*
		结果是一个字符串，它是当前运行 Vim 的机器的名称。
		长度超过 256 个字符的机器名将被截断。

                返回： ~
                  (`字符串`)

iconv({string}, {from}, {to})                                          *iconv()*
		结果是一个字符串，它是文本 {string} 从编码 {from} 转换为编码 {to} 的结果。
		当转换完全失败时，返回空字符串。
		当某些字符无法转换时，它们被替换为 "?"。
		编码名称是 iconv() 库函数可以接受的任何内容，参见 ":!man 3 iconv"。
		注意 Vim 对所有 Unicode 编码使用 UTF-8，从/到 UCS-2 的转换会自动改为使用 UTF-8。
		无论如何，您不能在字符串中使用 UCS-2，因为存在 NUL 字节。

                参数： ~
                  • {string} (`字符串`)
                  • {from} (`字符串`)
                  • {to} (`字符串`)

                返回： ~
                  (`字符串`)

id({expr})                                                                *id()*
		返回一个 |字符串|，它是容器类型（|列表|、|字典|、|Blob| 和 |Partial|）的唯一标识符。
		保证对于提到的类型，`id(v1) ==# id(v2)` 返回真当且仅当 `type(v1) == type(v2) && v1 is v2`。
		注意 `v:_null_string`、`v:_null_list`、`v:_null_dict` 和 `v:_null_blob` 具有相同的 `id()` 但类型不同，因为它们在内部表示为 NULL 指针。
		`id()` 返回指向容器的指针的十六进制表示（例如 `0x994a40`），与 `printf("%p", {expr})` 相同，但不建议依赖返回值的确切格式。

		不保证 `id(no_longer_existing_container)` 不会等于某个其他 `id()`：新容器可能会重用垃圾收集容器的标识符。

                参数： ~
                  • {expr} (`任意`)

                返回： ~
                  (`字符串`)

indent({lnum})                                                        *indent()*
		结果是一个数字，它是当前缓冲区中行 {lnum} 的缩进。
		缩进以空格计数，'tabstop' 的值是相关的。
		{lnum} 的使用方式与 |getline()| 相同。
		当 {lnum} 无效时，返回 -1。

		要获取或设置字符串中行的缩进，请参见 |vim.text.indent()|。

                参数： ~
                  • {lnum} (`整数|字符串`)

                返回： ~
                  (`整数`)

index({object}, {expr} [, {start} [, {ic}]])                           *index()*
		在 {object} 中查找 {expr} 并返回其索引。
		有关使用 lambda 选择项，请参见 |indexof()|。

		如果 {object} 是 |列表|，则返回项值等于 {expr} 的最低索引。
		没有自动转换，因此字符串 "4" 与数字 4 不同。
		数字 4 与浮点数 4.0 不同。
		此处不使用 'ignorecase' 的值，大小写由 {ic} 参数指示。

		如果 {object} 是 |Blob|，则返回字节值等于 {expr} 的最低索引。

		如果给出 {start}，则从索引为 {start} 的项开始查找（对于相对于末尾的项，可以为负数）。

		当给出 {ic} 且为 |TRUE| 时，忽略大小写。
		否则大小写必须匹配。

		当 {expr} 在 {object} 中未找到时，返回 -1。
		示例： >vim
			let idx = index(words, "the")
			if index(numbers, 123) >= 0
			  " ...
			endif
<

                参数： ~
                  • {object} (`任意`)
                  • {expr} (`任意`)
                  • {start} (`整数?`)
                  • {ic} (`布尔值?`)

                返回： ~
                  (`整数`)

indexof({object}, {expr} [, {opts}])                                 *indexof()*
		返回 {object} 中 {expr} 为 v:true 的项的索引。
		{object} 必须是 |列表| 或 |Blob|。

		如果 {object} 是 |列表|，则对列表中的每个项评估 {expr}，直到表达式为 v:true 并返回此项的索引。

		如果 {object} 是 |Blob|，则对 Blob 中的每个字节评估 {expr}，直到表达式为 v:true 并返回此字节的索引。

		{expr} 必须是 |字符串| 或 |Funcref|。

		如果 {expr} 是 |字符串|：如果 {object} 是 |列表|，在 {expr} 内部 |v:key| 具有当前列表项的索引，|v:val| 具有项的值。
		如果 {object} 是 |Blob|，在 {expr} 内部 |v:key| 具有当前字节的索引，|v:val| 具有字节值。

		如果 {expr} 是 |Funcref|，它必须接受两个参数：
			1. 当前项的键或索引。
			2. 当前项的值。
		如果找到项并且搜索应停止，函数必须返回 |TRUE|。

		可选参数 {opts} 是一个字典，支持以下项：
		    startidx	在此索引的项处开始评估 {expr}；对于相对于末尾的项，可以为负数
		当 {expr} 对所有项求值都为 v:false 时，返回 -1。
		示例： >vim
			let l = [#{n: 10}, #{n: 20}, #{n: 30}]
			echo indexof(l, "v:val.n == 20")
			echo indexof(l, {i, v -> v.n == 30})
			echo indexof(l, "v:val.n == 20", #{startidx: 1})
<

                参数： ~
                  • {object} (`任意`)
                  • {expr} (`任意`)
                  • {opts} (`表?`)

                返回： ~
                  (`整数`)

input({prompt} [, {text} [, {completion}]])                            *input()*

                参数： ~
                  • {prompt} (`字符串`)
                  • {text} (`字符串?`)
                  • {completion} (`字符串?`)

                返回： ~
                  (`字符串`)

input({opts})
		结果是一个字符串，它是用户在命令行上键入的内容。
		{prompt} 参数是一个提示字符串，或一个空字符串（无提示）。
		提示中可以使用 '\n' 开始新行。

		在第二种形式中，它接受一个包含以下键的字典，其中任何键都可以省略：

		键          默认值  描述 ~
		prompt        ""       与第一种形式中的 {prompt} 相同。
		default       ""       与第一种形式中的 {text} 相同。
		completion    nothing  与第一种形式中的 {completion} 相同。
		cancelreturn  ""       对话框取消时返回的值。
		highlight     nothing  高亮处理程序：|Funcref|。

		使用 |:echohl| 设置的高亮用于提示。
		输入就像命令行一样输入，具有相同的编辑命令和映射。
		为 input() 键入的行有单独的历史记录。
		示例： >vim
			if input("Coffee or beer? ") == "beer"
			  echo "Cheers!"
			endif
<
		如果可选的 {text} 参数存在且不为空，则将其用作默认回复，就像用户键入了一样。
		示例： >vim
			let color = input("Color? ", "white")

<		可选的 {completion} 参数指定为输入支持的补全类型。
		没有它，则不执行补全。
		支持的补全类型与可以使用 "-complete=" 参数提供给用户定义命令的类型相同。
		有关更多信息，请参考 |:command-completion|。
		示例： >vim
			let fname = input("File: ", "", "file")

<					*input()-highlight* *E5400* *E5402*
		可选的 `highlight` 键允许指定将用于高亮用户输入的函数。
		此函数接收用户输入作为其唯一参数，并且必须返回一个三元组列表 [hl_start_col, hl_end_col + 1, hl_group]，其中
			hl_start_col 是第一个高亮列，
			hl_end_col 是最后一个高亮列（+ 1！），
			hl_group 是用于高亮的 |:hi| 组。
					      *E5403* *E5404* *E5405* *E5406*
		hl_start_col 和 hl_end_col + 1 都必须指向多字节字符的开头（高亮不能破坏多字节字符），hl_end_col + 1 可能等于输入长度。
		起始列必须在范围 [0, len(input)) 内，
		结束列必须在范围 (hl_start_col, len(input)] 内，
		部分必须排序，以便下一个 hl_start_col 大于或等于前一个 hl_end_col。

		示例（尝试一些带括号的输入）： >vim
			highlight RBP1 guibg=Red ctermbg=red
			highlight RBP2 guibg=Yellow ctermbg=yellow
			highlight RBP3 guibg=Green ctermbg=green
			highlight RBP4 guibg=Blue ctermbg=blue
			let g:rainbow_levels = 4
			function! RainbowParens(cmdline)
			  let ret = []
			  let i = 0
			  let lvl = 0
			  while i < len(a:cmdline)
			    if a:cmdline[i] is# '('
			      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])
			      let lvl += 1
			    elseif a:cmdline[i] is# ')'
			      let lvl -= 1
			      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])
			    endif
			    let i += 1
			  endwhile
			  return ret
			endfunction
			call input({'prompt':'>','highlight':'RainbowParens'})
<
		高亮函数至少为每个新显示的输入字符串调用一次，在命令行重绘之前。
		期望函数在一次 input() 调用期间是纯函数，即对于相同的输入产生相同的输出，因此输出可以被记忆。
		函数像在 |:silent| 修饰符下运行。
		如果函数导致任何错误，它将在当前 input() 调用期间被跳过。

		如果命令行包含阿拉伯字符，则禁用高亮。

		注意：此函数不得在启动文件中使用，对于仅在 GUI 模式下运行的版本（例如 Win32 GUI）。
		注意：当从映射中调用 input() 时，它将消耗该映射中的剩余字符，因为映射就像键入字符一样处理。
		在 input() 之前使用 |inputsave()| 和在 input() 之后使用 |inputrestore()| 来避免这种情况。
		另一种解决方案是避免在映射中跟随更多字符，例如通过使用 |:execute| 或 |:normal|。

		带有映射的示例： >vim
			nmap \x :call GetFoo()<CR>:exe "/" .. Foo<CR>
			function GetFoo()
			  call inputsave()
			  let g:Foo = input("enter search pattern: ")
			  call inputrestore()
			endfunction
<

                参数： ~
                  • {opts} (`表`)

                返回： ~
                  (`字符串`)

inputlist({textlist})                                              *inputlist()*
		{textlist} 必须是一个字符串的 |列表|。
		显示此 |列表|，每行一个字符串。
		将提示用户输入一个数字，该数字被返回。
		用户也可以通过单击鼠标选择项，如果鼠标在命令行中启用（'mouse' 是 "a" 或包括 "c"）。
		对于第一个字符串，返回 0。
		当单击第一个项上方时，返回负数。
		当单击提示时，返回比 {textlist} 长度多一。
		确保 {textlist} 的条目少于 'lines'，否则它将无法工作。
		一个好主意是在字符串开头放置条目号。
		并在第一个项中放置提示。
		示例： >vim
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])
<

                参数： ~
                  • {textlist} (`字符串[]`)

                返回： ~
                  (`任意`)

inputrestore()                                                  *inputrestore()*
		恢复之前通过 |inputsave()| 保存的提前输入。
		应调用与 inputsave() 相同次数。
		不过，调用更多次也无害。
		当没有内容可恢复时返回 TRUE，否则返回 FALSE。

                返回： ~
                  (`整数`)

inputsave()                                                        *inputsave()*
		保留提前输入（也来自映射）并清除它，以便后续提示从用户获取输入。
		应在提示后跟随匹配的 inputrestore()。
		可以多次使用，在这种情况下，必须有同样多的 inputrestore() 调用。
		当内存不足时返回 TRUE，否则返回 FALSE。

                返回： ~
                  (`整数`)

inputsecret({prompt} [, {text}])                                 *inputsecret()*
		此函数的行为很像 |input()| 函数，但有两个例外：
		a) 用户的响应将显示为星号序列 ("*")，从而保持输入秘密，
		b) 用户的响应不会记录在输入 |历史| 堆栈上。
		结果是一个字符串，它是用户实际在命令行上键入的内容以响应发出的提示。
		注意：不支持命令行补全。

                参数： ~
                  • {prompt} (`字符串`)
                  • {text} (`字符串?`)

                返回： ~
                  (`字符串`)

insert({object}, {item} [, {idx}])                                    *insert()*
		当 {object} 是 |列表| 或 |Blob| 时，在其开头插入 {item}。

		如果指定了 {idx}，则在索引为 {idx} 的项之前插入 {item}。
		如果 {idx} 为零，它将在第一个项之前，就像省略 {idx} 一样。
		也可以使用负的 {idx}，参见 |list-index|。
		-1 就在最后一个项之前插入。

		返回结果的 |列表| 或 |Blob|。
		示例： >vim
			let mylist = insert([2, 3, 5], 1)
			call insert(mylist, 4, -1)
			call insert(mylist, 6, len(mylist))
<		最后一个示例可以使用 |add()| 更简单地完成。
		注意当 {item} 是 |列表| 时，它作为单个项插入。
		使用 |extend()| 连接 |列表|。

                参数： ~
                  • {object} (`任意`)
                  • {item} (`任意`)
                  • {idx} (`整数?`)

                返回： ~
                  (`任意`)

interrupt()                                                        *interrupt()*
		中断脚本执行。
		它的工作方式或多或少像用户键入 CTRL-C，大多数命令不会执行，控制权返回给用户。
		这对于从较低层中止执行很有用，例如在自动命令中。
		示例： >vim
		function s:check_typoname(file)
		   if fnamemodify(a:file, ':t') == '['
		       echomsg 'Maybe typo'
		       call interrupt()
		   endif
		endfunction
		au BufWritePre * call s:check_typoname(expand('<amatch>'))
<

                返回： ~
                  (`任意`)

invert({expr})                                                        *invert()*
		按位取反。
		参数转换为数字。
		列表、字典或浮点参数会导致错误。
		示例： >vim
			let bits = invert(bits)
<

                参数： ~
                  • {expr} (`整数`)

                返回： ~
                  (`整数`)

isabsolutepath({path})                                        *isabsolutepath()*
		结果是一个数字，当 {path} 是绝对路径时为 |TRUE|。
		在 Unix 上，当路径以 '/' 开头时被认为是绝对路径。
		在 MS-Windows 上，当它以可选的驱动器前缀开头并后跟 '\' 或 '/' 时被认为是绝对路径。
		UNC 路径总是绝对的。
		示例： >vim
			echo isabsolutepath('/usr/share/')	" 1
			echo isabsolutepath('./foobar')		" 0
			echo isabsolutepath('C:\Windows')	" 1
			echo isabsolutepath('foobar')		" 0
			echo isabsolutepath('\\remote\file')	" 1
<

                参数： ~
                  • {path} (`字符串`)

                返回： ~
                  (`0|1`)

isdirectory({directory})                                         *isdirectory()*
		结果是一个数字，当存在名为 {directory} 的目录时为 |TRUE|。
		如果 {directory} 不存在，或者不是目录，则结果为 |FALSE|。
		{directory} 是任何表达式，用作字符串。

                参数： ~
                  • {directory} (`字符串`)

                返回： ~
                  (`0|1`)

isinf({expr})                                                          *isinf()*
		如果 {expr} 是正无穷大则返回 1，如果是负无穷大则返回 -1，否则返回 0。 >vim
			echo isinf(1.0 / 0.0)
<			1 >vim
			echo isinf(-1.0 / 0.0)
<			-1

                参数： ~
                  • {expr} (`数字`)

                返回： ~
                  (`1|0|-1`)

islocked({expr})                                               *islocked()* *E786*
		结果是一个数字，当 {expr} 是锁定变量的名称时为 |TRUE|。
		字符串参数 {expr} 必须是变量、|列表| 项或 |字典| 条目的名称，而不是变量本身！
		示例： >vim
			let alist = [0, ['a', 'b'], 2, 3]
			lockvar 1 alist
			echo islocked('alist')		" 1
			echo islocked('alist[1]')	" 0

<		当 {expr} 是不存在的变量时，您会收到错误消息。
		使用 |exists()| 检查是否存在。

                参数： ~
                  • {expr} (`任意`)

                返回： ~
                  (`0|1`)

isnan({expr})                                                          *isnan()*
		如果 {expr} 是值为 NaN 的浮点数，则返回 |TRUE|。 >vim
			echo isnan(0.0 / 0.0)
<			1

                参数： ~
                  • {expr} (`数字`)

                返回： ~
                  (`0|1`)

items({expr})                                                          *items()*
		返回 {expr} 的所有键/索引和值对的 |列表|。
		每个 |列表| 项是一个包含两个项的列表：
		- 对于 |字典|：键和值
		- 对于 |列表| 或 |字符串|：索引和值
		对于 |字典|，返回的 |列表| 是任意顺序的，
		否则按索引的升序排列。

		另见 |keys()| 和 |values()|。

		示例： >vim
			let mydict = #{a: 'red', b: 'blue'}
			for [key, value] in items(mydict)
			   echo $"{key} = {value}"
			endfor
			echo items([1, 2, 3])
			echo items("foobar")
<

                参数： ~
                  • {expr} (`表|字符串`)

                返回： ~
                  (`任意`)

jobpid({job})                                                         *jobpid()*
		返回 |job-id| {job} 的 PID（进程 id）。

                参数： ~
                  • {job} (`整数`)

                返回： ~
                  (`整数`)

jobresize({job}, {width}, {height})                                *jobresize()*
		将 |job-id| {job} 的伪终端窗口大小调整为 {width} 列和 {height} 行。
		如果作业不是以 `"pty":v:true` 启动的，则失败。

                参数： ~
                  • {job} (`整数`)
                  • {width} (`整数`)
                  • {height} (`整数`)

                返回： ~
                  (`任意`)

jobstart({cmd} [, {opts}])                                          *jobstart()*
		注意：在 Lua 中更推荐使用 |vim.system()|（除非使用 `rpc`、`pty` 或 `term`）。

		将 {cmd} 作为作业（job）启动。
		如果 {cmd} 是一个列表（List），则直接运行（不使用 'shell'）。
		如果 {cmd} 是一个字符串（String），则在 'shell' 中运行，像这样： >vim
		  call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])
<		（详情请参阅 |shell-unquoting|）。

		示例：启动一个作业并处理其输出： >vim
		  call jobstart(['nvim', '-h'], {'on_stdout':{j,d,e->append(line('.'),d)}})
<
		示例：在连接到当前缓冲区的 |terminal| 中启动一个作业： >vim
		  call jobstart(['nvim', '-h'], {'term':v:true})
<
		成功时返回 |job-id|，参数无效（或作业表已满）时返回 0，
		如果 {cmd}[0] 或 'shell' 不可执行则返回 -1。
		返回的 job-id 是一个有效的 |channel-id|，代表作业的 stdio 流。
		使用 |chansend()|（或者如果启用了 "rpc"，则使用 |rpcnotify()| 和
		|rpcrequest()|）向 stdin 发送数据，并使用 |chanclose()|
		在不停止作业的情况下关闭流。

		参阅 |job-control| 和 |RPC|。

		注意：在 Windows 上，如果 {cmd} 是一个列表：
		  - cmd[0] 必须是一个可执行文件（不是“内置命令”）。如果它在
		    $PATH 中，可以通过名称调用，无需扩展名： >vim
		      call jobstart(['ping', 'neovim.io'])
<		    如果它是完整或部分路径，则需要扩展名： >vim
		      call jobstart(['System32\ping.exe', 'neovim.io'])
<		  - {cmd} 会被折叠成一个带引号的参数字符串，正如 CommandLineToArgvW
		    https://msdn.microsoft.com/bb776391 所期望的那样，
		    除非 cmd[0] 是某种形式的 "cmd.exe"。

							*jobstart-env*
		作业环境的初始化如下：
		  $NVIM                设置为父 Nvim 的 |v:servername|
		  $NVIM_LISTEN_ADDRESS 未设置
		  $NVIM_LOG_FILE       未设置
		  $VIM                 未设置
		  $VIMRUNTIME          未设置
		您可以使用 `env` 选项设置这些。

							*jobstart-options*
		{opts} 是一个字典，包含以下键：
		  clear_env:  （布尔值）`env` 精确地定义作业环境，
			      而不是合并当前环境。
		  cwd:	      （字符串，默认=|current-directory|）作业的工作目录。
		  detach:     （布尔值）分离作业进程：当 Nvim 退出时它不会被
			      杀死。如果进程在 Nvim 之前退出，将调用 `on_exit`。
		  env:	      （字典）环境变量名:值对的映射，用于扩展（或使用 "clear_env" 替换）
			      当前环境。|jobstart-env|
		  height:     （数字）`pty` 终端的高度。
		  |on_exit|:    （函数）作业退出时调用的回调。
		  |on_stdout|:  （函数）作业发出 stdout 数据时调用的回调。
		  |on_stderr|:  （函数）作业发出 stderr 数据时调用的回调。
		  overlapped: （布尔值）为传递给子进程的 stdio 设置 FILE_FLAG_OVERLAPPED。
			      仅在 MS-Windows 上有效；在其他平台上被忽略。
		  pty:	      （布尔值）将作业连接到新的伪终端（pseudo terminal），
			      并将其流连接到主文件描述符。`on_stdout` 接收所有输出，
			      `on_stderr` 被忽略。|terminal-start|
		  rpc:	      （布尔值）使用 |msgpack-rpc| 通过 stdio 与作业通信。
			      此时 `on_stdout` 被忽略，但 `on_stderr` 仍可使用。
		  stderr_buffered: （布尔值）在调用 `on_stderr` 之前收集数据直到 EOF（流关闭）。
			      |channel-buffered|
		  stdout_buffered: （布尔值）在调用 `on_stdout` 之前收集数据直到 EOF
			      （流关闭）。|channel-buffered|
		  stdin:      （字符串）可以是 "pipe"（默认）以将作业的 stdin 连接到通道，
			      或 "null" 以断开 stdin 连接。
		  term:	    （布尔值）在新的伪终端会话中生成 {cmd}，该会话连接到
		          当前（未修改的）缓冲区。隐含 "pty"。
		          默认的 "height" 和 "width" 设置为当前窗口的尺寸。
		          |jobstart()|。默认将 $TERM 设置为 "xterm-256color"。
		  width:      （数字）`pty` 终端的宽度。

		{opts} 作为 |self| 字典传递给回调函数；调用者可以设置其他键以传递应用程序特定的数据。

		返回：
		  - 成功时返回 |channel-id|
		  - 参数无效时返回 0
		  - 如果 {cmd}[0] 不可执行则返回 -1。
		另请参阅 |job-control|、|channel|、|msgpack-rpc|。

                参数: ~
                  • {cmd} (`string|string[]`)
                  • {opts} (`table?`)

                返回: ~
                  (`integer`)

jobstop({id})                                                        *jobstop()*
		通过向作业进程发送 SIGTERM 来停止 |job-id| {id}。
		如果进程在超时后仍未终止，则将发送 SIGKILL。
		当作业终止时，将调用其 |on_exit| 处理程序（如果有）。
		参阅 |job-control|。

		对于有效的作业 id 返回 1，对于无效的 id（包括已退出或停止的作业）返回 0。

                参数: ~
                  • {id} (`integer`)

                返回: ~
                  (`integer`)

jobwait({jobs} [, {timeout}])                                        *jobwait()*
		等待作业及其 |on_exit| 处理程序完成。

		{jobs} 是要等待的 |job-id| 列表。
		{timeout} 是最大等待时间（毫秒）。如果省略或为 -1，则永远等待。

		超时值 0 可用于检查作业的状态： >vim
			let running = jobwait([{job-id}], 0)[0] == -1
<
		在 jobwait() 调用期间，可能调用不在 {jobs} 列表中的作业的回调。
		除非回调调用了 |:redraw|，否则屏幕不会重绘。

		返回一个长度为 len({jobs}) 的整数列表，其中每个整数是相应作业的状态：
			退出代码，如果作业已退出
			-1 如果超过超时时间
			-2 如果作业被中断（通过 |CTRL-C|）
			-3 如果 job-id 无效

                参数: ~
                  • {jobs} (`integer[]`)
                  • {timeout} (`integer?`)

                返回: ~
                  (`integer[]`)

join({list} [, {sep}])                                                  *join()*
		将 {list} 中的项目连接成一个字符串。
		当指定 {sep} 时，它被放在项目之间。如果省略 {sep}，则使用单个空格。
		注意 {sep} 不会添加在末尾。您可能也想在那里添加它： >vim
			let lines = join(mylist, "\n") .. "\n"
<		字符串项目按原样使用。|Lists| 和 |Dictionaries| 会像使用 |string()| 一样转换为字符串。
		相反功能的函数是 |split()|。

                参数: ~
                  • {list} (`any[]`)
                  • {sep} (`string?`)

                返回: ~
                  (`string`)

json_decode({expr})                                              *json_decode()*
		将 {expr} 从 JSON 对象转换。接受 |readfile()| 风格的列表作为输入，也接受常规字符串。
		可以输出任何 Vim 值。在以下情况下，它将输出 |msgpack-special-dict|：
		1. 字典包含重复键。
		2. 字符串包含 NUL 字节。如果包含 NUL 字节的字符串是字典键，则会发出两种特殊字典：一种用于字典，一种用于字符串。

		注意：该函数始终将其输入视为 UTF-8。JSON 标准仅允许少数编码，其中推荐 UTF-8 并且是唯一要求支持的编码。
		非 UTF-8 字符是错误的。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`any`)

json_encode({expr})                                              *json_encode()*
		将 {expr} 转换为 JSON 字符串。接受 |msgpack-special-dict| 作为输入。
		不会转换 |Funcref|、具有非字符串键的映射（可以作为 |msgpack-special-dict| 创建）、
		具有自引用容器的值、包含非 UTF-8 字符的字符串、
		包含为代理对保留的码点的伪 UTF-8 字符串（此类字符串不是有效的 UTF-8 字符串）。
		不可打印字符转换为 "\u1234" 转义或特殊转义如 "\t"，其他字符按原样转储。
		|Blob| 被转换为单个字节的数组。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`string`)

keys({dict})                                                            *keys()*
		返回一个包含 {dict} 所有键的 |List|。该 |List| 的顺序是任意的。另请参阅 |items()| 和 |values()|。

                参数: ~
                  • {dict} (`table`)

                返回: ~
                  (`string[]`)

keytrans({string})                                                  *keytrans()*
		将键的内部字节表示形式转换为可用于 |:map| 的形式。例如： >vim
			let xx = "\<C-Home>"
			echo keytrans(xx)
<			<C-Home>

                参数: ~
                  • {string} (`string`)

                返回: ~
                  (`string`)

len({expr})                                                         *len()* *E701*
		结果是一个数字（Number），它是参数的长度。
		当 {expr} 是字符串（String）或数字（Number）时，使用字节长度，如同 |strlen()|。
		当 {expr} 是 |List| 时，返回 |List| 中的项目数。
		当 {expr} 是 |Blob| 时，返回字节数。
		当 {expr} 是 |Dictionary| 时，返回 |Dictionary| 中的条目数。
		否则会给出错误并返回零。

                参数: ~
                  • {expr} (`any[]`)

                返回: ~
                  (`integer`)

libcall({libname}, {funcname}, {argument})                 *libcall()* *E364* *E368*
		使用单个参数 {argument} 调用运行时库 {libname} 中的函数 {funcname}。
		这对于调用您专门为与 Vim 一起使用而制作的库中的函数很有用。
		由于只有一个参数是可能的，调用标准库函数相当受限。
		结果是函数返回的字符串（String）。如果函数返回 NULL，这对 Vim 来说将显示为空字符串 ""。
		如果函数返回一个数字，请使用 libcallnr()！
		如果 {argument} 是一个数字，它作为 int 传递给函数；如果 {argument} 是一个字符串，它作为以 null 结尾的字符串传递。

		libcall() 允许您编写自己的 Vim '插件'扩展，而无需重新编译程序。
		它不是调用系统函数的手段！如果您尝试这样做，Vim 很可能会崩溃。

		对于 Win32，您编写的函数必须放在 DLL 中，并使用正常的 C 调用约定（NOT Windows 系统 DLL 中使用的 Pascal）。
		函数必须恰好接受一个参数，可以是字符指针或长整型，并且必须返回一个字符指针或 NULL。
		返回的字符指针必须指向在函数返回后仍然有效的内存（例如，在 DLL 的静态数据中）。
		如果它指向分配的内存，则该内存将会泄漏。在函数中使用静态缓冲区应该可以工作，它会在 DLL 卸载时释放。

		警告：如果函数返回一个无效指针，Vim 可能会崩溃！如果函数返回一个数字，也会发生这种情况，因为 Vim 认为它是一个指针。
		对于 Win32 系统，{libname} 应该是 DLL 的文件名，不带 ".DLL" 后缀。只有当 DLL 不在通常位置时才需要完整路径。
		对于 Unix：在编译您自己的插件时，请记住目标代码必须编译为位置无关（'PIC'）。
		示例： >vim
			echo libcall("libc.so", "getenv", "HOME")
<

                参数: ~
                  • {libname} (`string`)
                  • {funcname} (`string`)
                  • {argument} (`any`)

                返回: ~
                  (`any`)

libcallnr({libname}, {funcname}, {argument})                       *libcallnr()*
		就像 |libcall()|，但用于返回 int 而不是字符串的函数。
		示例： >vim
			echo libcallnr("/usr/lib/libc.so", "getpid", "")
			call libcallnr("libc.so", "printf", "Hello World!\n")
			call libcallnr("libc.so", "sleep", 10)
<

                参数: ~
                  • {libname} (`string`)
                  • {funcname} (`string`)
                  • {argument} (`any`)

                返回: ~
                  (`any`)

line({expr} [, {winid}])                                                *line()*
		关于接受的位置，请参阅 |getpos()|。

		要获取列号，请使用 |col()|。要同时获取两者，请使用 |getpos()|。

		使用可选的 {winid} 参数，可以获取该窗口的值，而不是当前窗口的值。

		对于 {expr} 和 {winid} 的无效值返回 0。

		示例： >vim
			echo line(".")			" 光标的行号
			echo line(".", winid)		" 同上，在窗口 "winid" 中
			echo line("'t")			" 标记 t 的行号
			echo line("'" .. marker)	" 标记 marker 的行号
<
		关于打开文件时跳转到最后已知位置，请参阅 |last-position-jump|。

                参数: ~
                  • {expr} (`string|integer[]`)
                  • {winid} (`integer?`)

                返回: ~
                  (`integer`)

line2byte({lnum})                                                  *line2byte()*
		返回缓冲区开始处到第 {lnum} 行的字节计数。
		这包括行尾字符，具体取决于当前缓冲区的 'fileformat' 选项。
		第一行返回 1。使用 UTF-8 编码，忽略 'fileencoding'。
		这也可用于获取最后一行下方的行的字节计数： >vim
			echo line2byte(line("$") + 1)
<		这是缓冲区大小加一。如果 'fileencoding' 为空，则是文件大小加一。
		{lnum} 的用法与 |getline()| 相同。当 {lnum} 无效时返回 -1。
		另请参阅 |byte2line()|、|go| 和 |:goto|。

                参数: ~
                  • {lnum} (`integer|string`)

                返回: ~
                  (`integer`)

lispindent({lnum})                                                *lispindent()*
		根据 Lisp 缩进规则（如 'lisp'）获取第 {lnum} 行的缩进量。
		缩进以空格计数，'tabstop' 的值是相关的。{lnum} 的用法与 |getline()| 相同。
		当 {lnum} 无效时，返回 -1。

                参数: ~
                  • {lnum} (`integer|string`)

                返回: ~
                  (`integer`)

list2blob({list})                                                  *list2blob()*
		返回一个连接 {list} 中所有数字值的 Blob。
		示例： >vim
			echo list2blob([1, 2, 3, 4])	" 返回 0z01020304
			echo list2blob([])		" 返回 0z
<		出错时返回一个空的 Blob。如果其中一个数字为负数或大于 255，则给出错误 *E1239*。

		|blob2list()| 执行相反的操作。

                参数: ~
                  • {list} (`any[]`)

                返回: ~
                  (`string`)

list2str({list} [, {utf8}])                                         *list2str()*
		将 {list} 中的每个数字转换为一个字符字符串，并将它们全部连接起来。
		示例： >vim
			echo list2str([32])		" 返回 " "
			echo list2str([65, 66, 67])	" 返回 "ABC"
<		同样可以（缓慢地）通过以下方式完成： >vim
			echo join(map(list, {nr, val -> nr2char(val)}), '')
<		|str2list()| 执行相反的操作。

		始终使用 UTF-8 编码，{utf8} 选项无效，仅为了向后兼容而存在。
		使用 UTF-8 组合字符按预期工作： >vim
			echo list2str([97, 769])	" 返回 "á"
<
		出错时返回空字符串。

                参数: ~
                  • {list} (`any[]`)
                  • {utf8} (`boolean?`)

                返回: ~
                  (`string`)

localtime()                                                        *localtime()*
		返回当前时间，以自 1970 年 1 月 1 日以来的秒数计量。另请参阅 |strftime()|、|strptime()| 和 |getftime()|。

                返回: ~
                  (`integer`)

log({expr})                                                              *log()*
		返回 {expr} 的自然对数（底数 e）作为 |Float|。
		{expr} 必须求值为 |Float| 或范围在 (0, inf] 内的 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo log(10)
<			2.302585 >vim
			echo log(exp(5))
<			5.0

                参数: ~
                  • {expr} (`number`)

                返回: ~
                  (`number`)

log10({expr})                                                          *log10()*
		返回 Float {expr} 的以 10 为底的对数作为 |Float|。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo log10(1000)
<			3.0 >vim
			echo log10(0.01)
<			-2.0

                参数: ~
                  • {expr} (`number`)

                返回: ~
                  (`number`)

luaeval({expr} [, {expr}])                                           *luaeval()*
		评估 Lua 表达式 {expr} 并将其结果转换为 Vim 数据结构。有关详细信息，请参阅 |lua-eval|。

		另请参阅 |v:lua-call|。

                参数: ~
                  • {expr} (`string`)
                  • {expr1} (`any[]?`)

                返回: ~
                  (`any`)

map({expr1}, {expr2})                                                    *map()*
		{expr1} 必须是 |List|、|String|、|Blob| 或 |Dictionary|。
		当 {expr1} 是 |List| 或 |Dictionary| 时，用评估 {expr2} 的结果替换 {expr1} 中的每个项目。
		对于 |Blob|，每个字节都被替换。
		对于 |String|，每个字符（包括组合字符）都被替换。
		如果项目类型更改，您可能需要使用 |mapnew()| 来创建新的 List 或 Dictionary。

		{expr2} 必须是 |String| 或 |Funcref|。

		如果 {expr2} 是 |String|，在 {expr2} 内部 |v:val| 具有当前项目的值。
		对于 |Dictionary|，|v:key| 具有当前项目的键；对于 |List|，|v:key| 具有当前项目的索引。
		对于 |Blob|，|v:key| 具有当前字节的索引。对于 |String|，|v:key| 具有当前字符的索引。
		示例： >vim
			call map(mylist, '"> " .. v:val .. " <"')
<		这将在 "mylist" 中的每个项目之前加上 "> "，之后加上 " <"。

		注意 {expr2} 是表达式的结果，然后再次被用作表达式。通常使用 |literal-string| 以避免双重反斜杠。
		您仍然需要加倍单引号

		如果 {expr2} 是 |Funcref|，则使用两个参数调用它：
			1. 当前项的键或索引。
			2. 当前项的值。
		该函数必须返回项目的新值。
		示例，将每个值更改为 "key-value"： >vim
			func KeyValue(key, val)
			  return a:key .. '-' .. a:val
			endfunc
			call map(myDict, function('KeyValue'))
<		使用 |lambda| 时更短： >vim
			call map(myDict, {key, val -> key .. '-' .. val})
<		如果您不使用 "val"，可以将其省略： >vim
			call map(myDict, {key -> 'item: ' .. key})
<		如果您不使用 "key"，可以使用短名称： >vim
			call map(myDict, {_, val -> 'item: ' .. val})
<
		对于 |List| 和 |Dictionary|，操作是就地完成的。
		如果您希望它保持未修改状态，请先制作一个副本： >vim
			let tlist = map(copy(mylist), ' v:val .. "\t"')

<		返回 {expr1}，即被过滤的 |List| 或 |Dictionary|，或者一个新的 |Blob| 或 |String|。
		在评估 {expr2} 时遇到错误时，不会处理 {expr1} 中的后续项目。
		当 {expr2} 是 Funcref 时，函数内部的错误会被忽略，除非它是用 "abort" 标志定义的。

                参数: ~
                  • {expr1} (`string|table|any[]`)
                  • {expr2} (`string|function`)

                返回: ~
                  (`any`)

maparg({name} [, {mode} [, {abbr} [, {dict}]]])                       *maparg()*
		当 {dict} 被省略或为零时：返回模式 {mode} 中映射 {name} 的 rhs（右侧）。
		返回的字符串（String）中的特殊字符会被转换，就像 ":map" 命令列表的输出一样。
		当 {dict} 为 TRUE 时，返回一个字典（dictionary），详见下文。
		要获取所有映射的列表，请参阅 |maplist()|。

		当没有 {name} 的映射时，如果 {dict} 为 FALSE，则返回空字符串（String），否则返回空字典（Dict）。
		当 {name} 的映射为空时，则返回 "<Nop>"。

		{name} 可以包含特殊键名，就像 ":map" 命令中一样。

		{mode} 可以是以下字符串之一：
			"n"	普通模式（Normal）
			"v"	可视模式（Visual）（包括选择模式 Select）
			"o"	操作符等待模式（Operator-pending）
			"i"	插入模式（Insert）
			"c"	命令行模式（Cmd-line）
			"s"	选择模式（Select）
			"x"	可视模式（Visual）
			"l"	langmap |language-mapping|
			"t"	终端模式（Terminal）
			""		普通模式、可视模式和操作符等待模式
		当 {mode} 被省略时，使用 "" 的模式。

		当 {abbr} 存在且为 |TRUE| 时，使用缩写（abbreviations）而不是映射（mappings）。

		当 {dict} 为 |TRUE| 时，返回一个描述映射的字典，包含以下项： *mapping-dict*
		  "lhs"	     映射的 {lhs}，如同键入的那样
		  "lhsraw"   映射的 {lhs}，原始字节形式
		  "lhsrawalt" 映射的 {lhs}，原始字节形式，替代形式，
			      仅当与 "lhsraw" 不同时存在
		  "rhs"	     映射的 {rhs}，如同键入的那样。
		  "callback" Lua 函数，如果 RHS 被定义为这样的函数。
		  "silent"   1 表示 |:map-silent| 映射，否则为 0。
		  "noremap"  1 表示映射的 {rhs} 不可重映射。
		  "script"   1 表示映射是用 <script> 定义的。
		  "expr"     1 表示表达式映射（|:map-<expr>|）。
		  "buffer"   1 表示缓冲区局部映射（|:map-local|）。
		  "mode"     定义映射的模式。除了上述模式之外，还将使用这些字符：
			     " "     普通模式、可视模式和操作符等待模式
			     "!"     插入模式和命令行模式
				     (|mapmode-ic|)
		  "sid"	     脚本局部 ID，用于 <sid> 映射 (|<SID>|)。对于特殊上下文为负数。
		  "scriptversion"  脚本的版本，始终为 1。
		  "lnum"     在 "sid" 中的行号，未知则为零。
		  "nowait"   不等待其他更长的映射。(|:map-<nowait>|)。
		  "abbr"     如果这是一个 |abbreviation|，则为 True。
		  "mode_bits" Nvim 内部对 "mode" 的二进制表示。
			     |mapset()| 忽略此项；仅使用 "mode"。
			     有关用法示例，请参阅 |maplist()|。这些值来自 src/nvim/state_defs.h，
			     并且将来可能会更改。

		该字典可用于通过 |mapset()| 恢复映射。

		首先检查当前缓冲区的局部映射，然后是全局映射。
		此函数可用于映射一个键，即使它已经被映射，并让它也执行原始映射。草图： >vim
			exe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')
<

                参数: ~
                  • {name} (`string`)
                  • {mode} (`string?`)
                  • {abbr} (`boolean?`)
                  • {dict} (`false?`)

                返回: ~
                  (`string`)

mapcheck({name} [, {mode} [, {abbr}]])                              *mapcheck()*
		检查在模式 {mode} 中是否存在与 {name} 匹配的映射。
		关于 {mode} 和 {name} 中的特殊名称，请参阅 |maparg()|。
		当 {abbr} 存在且非零时，使用缩写（abbreviations）而不是映射（mappings）。
		匹配发生在以 {name} 开头的映射以及与 {name} 开头相等的映射上。

			匹配映射 "a"	"ab"	"abc" ~
		   mapcheck("a")	是	是	 是
		   mapcheck("abc")	是	是	 是
		   mapcheck("ax")	是	否	 否
		   mapcheck("b")	否	否	 否

		与 maparg() 的区别在于，mapcheck() 查找与 {name} 匹配的映射，而 maparg() 只查找与 {name} 完全相同的映射。
		当没有以 {name} 开头的映射时，返回空字符串（String）。如果有一个，则返回该映射的 RHS。
		如果有多个以 {name} 开头的映射，则返回其中一个的 RHS。如果 RHS 为空，则返回 "<Nop>"。
		首先检查当前缓冲区的局部映射，然后是全局映射。
		此函数可用于检查是否可以添加映射而不产生歧义。示例： >vim
			if mapcheck("_vv") == ""
			   map _vv :set guifont=7x13<CR>
			endif
<		这避免了在已经存在 "_v" 或 "_vvv" 的映射时添加 "_vv" 映射。

                参数: ~
                  • {name} (`string`)
                  • {mode} (`string?`)
                  • {abbr} (`boolean?`)

                返回: ~
                  (`any`)

maplist([{abbr}])                                                    *maplist()*
		返回所有映射的 |List|。每个列表项是一个 |Dict|，与 |maparg()| 返回的相同，
		请参阅 |mapping-dict|。当 {abbr} 存在且为 |TRUE| 时，使用缩写而不是映射。

		示例，显示 rhs 中包含 "MultiMatch" 的所有映射： >vim
			echo maplist()->filter({_, m ->
				\ match(get(m, 'rhs', ''), 'MultiMatch') >= 0
				\ })
<		查找特定 |:map-modes| 的映射可能很棘手。|mapping-dict| 的 "mode_bits" 可以简化这一点。
		例如，普通模式、插入模式或命令行模式的 mode_bits 是 0x19。
		要查找这些模式中所有可用的映射，您可以这样做： >vim
			let saved_maps = []
			for m in maplist()
			    if and(m.mode_bits, 0x19) != 0
				eval saved_maps->add(m)
			    endif
			endfor
			echo saved_maps->mapnew({_, m -> m.lhs})
<		mode_bits 的值在 Nvim 的 src/nvim/state_defs.h 文件中定义，并且可以在运行时使用
		|:map-commands| 和 "maplist()" 来发现。示例： >vim
			omap xyzzy <Nop>
			let op_bit = maplist()->filter(
			    \ {_, m -> m.lhs == 'xyzzy'})[0].mode_bits
			ounmap xyzzy
			echo printf("Operator-pending mode bit: 0x%x", op_bit)
<

                参数: ~
                  • {abbr} (`0|1?`)

                返回: ~
                  (`table[]`)

mapnew({expr1}, {expr2})                                              *mapnew()*
		类似于 |map()|，但不是替换 {expr1} 中的项目，而是创建并返回一个新的 List 或 Dictionary。
		{expr1} 保持不变。项目仍然可以被 {expr2} 更改，如果您不希望这样，请先使用 |deepcopy()|。

                参数: ~
                  • {expr1} (`any`)
                  • {expr2} (`any`)

                返回: ~
                  (`any`)

mapset({mode}, {abbr}, {dict})                                        *mapset()*
mapset({dict})
		从字典恢复映射，该字典可能由 |maparg()| 或 |maplist()| 返回。
		当 dict.buffer 为 true 时，缓冲区映射设置在当前缓冲区上；由调用者确保目标缓冲区是当前缓冲区。
		此特性允许将映射从一个缓冲区复制到另一个缓冲区。
		dict.mode 值可能会恢复一个覆盖多个模式的单一映射，例如模式值为 '!', ' ', "nox" 或 'v'。*E1276*

		在第一种形式中，{mode} 和 {abbr} 应与调用 |maparg()| 时相同。*E460*
		{mode} 用于定义设置映射的模式，而不是 {dict} 中的 "mode" 条目。
		保存和恢复映射的示例： >vim
			let save_map = maparg('K', 'n', 0, 1)
			nnoremap K somethingelse
			" ...
			call mapset('n', 0, save_map)
<		请注意，如果您要替换多个模式中的映射，例如使用 `:map!`，当它们可能不同时，需要为所有模式保存/恢复映射。

		在第二种形式中，{dict} 作为唯一参数，模式和缩写取自该字典。
		示例： >vim
			let save_maps = maplist()->filter(
						\ {_, m -> m.lhs == 'K'})
			nnoremap K somethingelse
			cnoremap K somethingelse2
			" ...
			unmap K
			for d in save_maps
			    call mapset(d)
			endfor
<

                参数: ~
                  • {dict} (`table<string,any>`)

                返回: ~
                  (`any`)

match({expr}, {pat} [, {start} [, {count}]])                           *match()*
		当 {expr} 是 |List| 时，返回第一个 {pat} 匹配的项目的索引。
		每个项目被用作字符串（String），|Lists| 和 |Dictionaries| 被用作回显的形式。

		否则，{expr} 被用作字符串（String）。结果是一个数字（Number），
		给出 {expr} 中 {pat} 匹配的索引（字节偏移量）。

		在第一个字符或 |List| 项目处匹配返回零。如果没有匹配，则返回 -1。

		关于获取子匹配，请参阅 |matchlist()|。
		示例： >vim
			echo match("testing", "ing")	" 结果为 4
			echo match([1, 'x'], '\a')	" 结果为 1
<		关于 {pat} 的使用方式，请参阅 |string-match|。
								*strpbrk()*
		Vim 没有 strpbrk() 函数。但您可以这样做： >vim
			let sepidx = match(line, '[.,;: \t]')
<								*strcasestr()*
		Vim 没有 strcasestr() 函数。但您可以在模式中添加 "\c" 来忽略大小写： >vim
			let idx = match(haystack, '\cneedle')
<
		如果给出了 {start}，则搜索从字符串中的字节索引 {start} 或 |List| 中的项目 {start} 开始。
		但是，结果仍然是从第一个字符/项目开始计数的索引。
		示例： >vim
			echo match("testing", "ing", 2)
<		结果再次是 "4"。 >vim
			echo match("testing", "ing", 4)
<		结果再次是 "4"。 >vim
			echo match("testing", "t", 2)
<		结果是 "3"。
		对于字符串（String），如果 {start} > 0，则就像字符串从 {start} 字节之后开始，
		因此 "^" 将在 {start} 处匹配。除非给出了 {count}，那么就像 {start} 字节之前的匹配被忽略
		（这有点复杂，以保持向后兼容）。
		对于字符串（String），如果 {start} < 0，它将被设置为 0。对于列表（List），索引从末尾开始计数。
		如果 {start} 超出范围（对于字符串 {start} > strlen({expr}) 或对于 |List| {start} > len({expr})），
		则返回 -1。

		当给出 {count} 时，使用第 {count} 个匹配。当在字符串中找到匹配时，对下一个匹配的搜索从下一个字符开始。
		因此这个示例的结果是 1： >vim
			echo match("testing", "..", 0, 2)
<		在 |List| 中，搜索在下一个项目中继续。
		注意，当添加了 {count} 时，{start} 的工作方式会改变，见上文。

						*match-pattern*
		关于接受的模式，请参阅 |pattern|。
		'ignorecase' 选项用于设置模式的忽略大小写性。不使用 'smartcase'。
		匹配总是像设置了 'magic' 且 'cpoptions' 为空一样完成。
		注意优先匹配开头，因此当模式使用 "*"（任意数量的匹配）时，它倾向于在开头找到零个匹配，
		而不是在文本更下方找到多个匹配。

                参数: ~
                  • {expr} (`string|any[]`)
                  • {pat} (`string`)
                  • {start} (`integer?`)
                  • {count} (`integer?`)

                返回: ~
                  (`any`)

                                                *matchadd()* *E798* *E799* *E801* *E957*
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
		定义一个在当前窗口中要高亮显示的图案（“匹配”）。它将用 {group} 高亮显示。
		返回一个标识号（ID），可用于使用 |matchdelete()| 删除匹配。该 ID 绑定到窗口。
		匹配是区分大小写和魔法的（magic），除非在 {pattern} 中明确覆盖了大小写敏感性或魔法性。
		不使用 'magic'、'smartcase' 和 'ignorecase' 选项。
		"Conceal" 值是特殊的，它会导致匹配被隐藏（concealed）。

		可选的 {priority} 参数为匹配分配一个优先级。具有高优先级的匹配的高亮显示将覆盖低优先级匹配的高亮显示。
		优先级指定为一个整数（负数也不例外）。如果未指定 {priority} 参数，则默认优先级为 10。
		'hlsearch' 的优先级为零，因此所有优先级大于零的匹配都将覆盖它。
		语法高亮（参见 'syntax'）是一个单独的机制，无论选择的优先级如何，匹配总是会覆盖语法高亮。

		可选的 {id} 参数允许请求特定的匹配 ID。如果指定的 ID 已被占用，将出现错误消息并且不会添加匹配。
		ID 指定为正整数（不包括零）。ID 1、2 和 3 分别保留给 |:match|、|:2match| 和 |:3match|。
		3 保留给 |matchparen| 插件使用。
		如果 {id} 参数未指定或为 -1，|matchadd()| 自动选择一个空闲的 ID，该 ID 至少为 1000。

		可选的 {dict} 参数允许进一步的自定义值。目前这用于指定一个匹配特定的隐藏字符，
		该字符将显示给 |hl-Conceal| 高亮的匹配。字典可以包含以下成员：

			conceal	    要显示的特殊字符，而不是匹配项
				    （仅适用于 |hl-Conceal| 高亮的匹配项，参见 |:syn-cchar|）
			window	    不使用当前窗口，而是使用具有此编号或窗口 ID 的窗口。

		匹配的数量没有限制，就像 |:match| 命令的情况一样。

		出错时返回 -1。

		示例： >vim
			highlight MyGroup ctermbg=green guibg=green
			let m = matchadd("MyGroup", "TODO")
<		删除图案： >vim
			call matchdelete(m)

<		|matchadd()| 和 |:match| 定义的匹配列表可从 |getmatches()| 获取。
		所有匹配可以通过 |clearmatches()| 一次删除。

                参数: ~
                  • {group} (`integer|string`)
                  • {pattern} (`string`)
                  • {priority} (`integer?`)
                  • {id} (`integer?`)
                  • {dict} (`string?`)

                返回: ~
                  (`any`)

matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])   *matchaddpos()*
		与 |matchadd()| 相同，但需要位置列表 {pos} 而不是图案。
		此命令比 |matchadd()| 更快，因为它不处理正则表达式，并且它设置缓冲区行边界来重绘屏幕。
		当需要快速添加和删除匹配时，例如用于高亮匹配的括号，应该使用它。
							*E5030* *E5031*
		{pos} 是一个位置列表。每个位置可以是以下之一：
		- 一个数字。整行将被高亮显示。第一行的编号为 1。
		- 包含一个数字的列表，例如 [23]。具有此编号的整行将被高亮显示。
		- 包含两个数字的列表，例如 [23, 11]。第一个数字是行号，第二个是列号
		  （第一列是 1，该值必须对应于 |col()| 返回的字节索引）。此位置的字符将被高亮显示。
		- 包含三个数字的列表，例如 [23, 11, 3]。同上，但第三个数字给出高亮显示的字节长度。

		包含零和负行号的条目会被静默忽略，包含负列号和长度的条目也是如此。

		出错时返回 -1。

		示例： >vim
			highlight MyGroup ctermbg=green guibg=green
			let m = matchaddpos("MyGroup", [[23, 24], 34])
<		删除图案： >vim
			call matchdelete(m)

<		|matchaddpos()| 添加的匹配由 |getmatches()| 返回。

                参数: ~
                  • {group} (`integer|string`)
                  • {pos} (`any[]`)
                  • {priority} (`integer?`)
                  • {id} (`integer?`)
                  • {dict} (`string?`)

                返回: ~
                  (`any`)

matcharg({nr})                                                      *matcharg()*
		选择第 {nr} 个匹配项，如同使用 |:match|、|:2match| 或 |:3match| 命令设置的那样。
		返回一个包含两个元素的 |List|：
			使用的高亮组的名称
			使用的图案。
		当 {nr} 不是 1、2 或 3 时，返回空 |List|。
		当没有设置匹配项时，返回 ['', '']。
		这对于保存和恢复 |:match| 很有用。
		使用 |:match| 命令进行高亮匹配仅限于三个匹配。|matchadd()| 没有此限制。

                参数: ~
                  • {nr} (`integer`)

                返回: ~
                  (`any`)

matchbufline({buf}, {pat}, {lnum}, {end}, [, {dict}])           *matchbufline()*
		返回缓冲区 {buf} 中从 {lnum} 到 {end} 的行中 {pat} 匹配的 |List|。

		{lnum} 和 {end} 可以是行号或字符串 "$"（引用 {buf} 中的最后一行）。

		{dict} 参数支持以下项：
		    submatches	包括子匹配信息 (|/\(|)

		对于每个匹配，返回一个包含以下项的 |Dict|：
		    byteidx	匹配的起始字节索引
		    lnum	存在匹配的行号
		    text	匹配的字符串
		注意，单行中可以有多个匹配。

		此函数仅对已加载的缓冲区有效。如果需要，首先调用 |bufload()|。

		关于某些选项设置对模式的影响的信息，请参阅 |match-pattern|。

		当 {buf} 不是有效缓冲区、缓冲区未加载或 {lnum} 或 {end} 无效时，
		会给出错误并返回空 |List|。

		示例： >vim
		    " 假设缓冲区 5 的第 3 行包含 "a"
		    echo matchbufline(5, '\<\k\+\>', 3, 3)
<		    `[{'lnum': 3, 'byteidx': 0, 'text': 'a'}]` >vim
		    " 假设缓冲区 10 的第 4 行包含 "tik tok"
		    echo matchbufline(10, '\<\k\+\>', 1, 4)
<		    `[{'lnum': 4, 'byteidx': 0, 'text': 'tik'}, {'lnum': 4, 'byteidx': 4, 'text': 'tok'}]`

		如果 {submatch} 存在且为 v:true，则还会返回子匹配，如 "\1", "\2" 等。
		示例： >vim
		    " 假设缓冲区 2 的第 2 行包含 "acd"
		    echo matchbufline(2, '\(a\)\?\(b\)\?\(c\)\?\(.*\)', 2, 2
						\ {'submatches': v:true})
<		    `[{'lnum': 2, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]`
		"submatches" 列表总是包含 9 个项目。如果未找到子匹配，则该项返回空字符串。

                参数: ~
                  • {buf} (`string|integer`)
                  • {pat} (`string`)
                  • {lnum} (`string|integer`)
                  • {end} (`string|integer`)
                  • {dict} (`table?`)

                返回: ~
                  (`any`)

matchdelete({id} [, {win}])                            *matchdelete()* *E802* *E803*
		删除之前由 |matchadd()| 或某个 |:match| 命令定义的、ID 为 {id} 的匹配。
		成功返回 0，否则返回 -1。参见 |matchadd()| 的示例。
		所有匹配可以通过 |clearmatches()| 一次删除。
		如果指定了 {win}，则使用具有此编号或窗口 ID 的窗口，而不是当前窗口。

                参数: ~
                  • {id} (`integer`)
                  • {win} (`integer?`)

                返回: ~
                  (`any`)

matchend({expr}, {pat} [, {start} [, {count}]])                     *matchend()*
		与 |match()| 相同，但返回匹配之后第一个字符的索引。示例： >vim
			echo matchend("testing", "ing")
<		结果为 "7"。
							*strspn()* *strcspn()*
		Vim 没有 strspn() 或 strcspn() 函数，但您可以使用 matchend() 来实现： >vim
			let span = matchend(line, '[a-zA-Z]')
			let span = matchend(line, '[^a-zA-Z]')
<		不同之处在于没有匹配时返回 -1。

		如果给出 {start}，其含义与 |match()| 相同。 >vim
			echo matchend("testing", "ing", 2)
<		结果为 "7"。 >vim
			echo matchend("testing", "ing", 5)
<		结果为 "-1"。
		当 {expr} 是 |List| 时，结果与 |match()| 相同。

                参数: ~
                  • {expr} (`any`)
                  • {pat} (`string`)
                  • {start} (`integer?`)
                  • {count} (`integer?`)

                返回: ~
                  (`any`)

matchfuzzy({list}, {str} [, {dict}])                              *matchfuzzy()*
		如果 {list} 是字符串列表，则返回一个 |List|，包含 {list} 中所有模糊匹配 {str} 的字符串。
		返回列表中的字符串根据匹配分数排序。

		可选的 {dict} 参数始终支持以下项：
		    matchseq	当存在此项时，仅返回包含 {str} 中字符且顺序相同的匹配项。
		    limit	要返回的 {list} 中的最大匹配数。零表示无限制。

		如果 {list} 是字典列表，则可选的 {dict} 参数支持以下附加项：
		    key		用于对 {str} 进行模糊匹配的项的键。此项的值应为字符串。
		    text_cb	|Funcref|，将为 {list} 中的每个项调用以获取用于模糊匹配的文本。
				它应接受一个字典项作为参数，并返回用于模糊匹配的该项目的文本。

		{str} 被视为字面字符串，不支持正则表达式匹配。支持的 {str} 最大长度为 256。

		当 {str} 有多个由空格分隔的单词时，返回包含所有单词的字符串列表。

		如果没有匹配的字符串或出现错误，则返回空列表。如果 {str} 的长度大于 256，则返回空列表。

		当给出 {limit} 时，matchfuzzy() 将在 {list} 中查找最多此数量的匹配项，并按排序顺序返回它们。

		有关模糊匹配字符串的更多信息，请参阅 |fuzzy-matching|。

		示例： >vim
		   echo matchfuzzy(["clay", "crow"], "cay")
<		结果为 ["clay"]。 >vim
		   echo getbufinfo()->map({_, v -> v.name})->matchfuzzy("ndl")
<		结果为模糊匹配 "ndl" 的缓冲区名称列表。 >vim
		   echo getbufinfo()->matchfuzzy("ndl", {'key' : 'name'})
<		结果为缓冲区名称模糊匹配 "ndl" 的缓冲区信息字典列表。 >vim
		   echo getbufinfo()->matchfuzzy("spl",
						\ {'text_cb' : {v -> v.name}})
<		结果为缓冲区名称模糊匹配 "spl" 的缓冲区信息字典列表。 >vim
		   echo v:oldfiles->matchfuzzy("test")
<		结果为模糊匹配 "test" 的文件名列表。 >vim
		   let l = readfile("buffer.c")->matchfuzzy("str")
<		结果为 "buffer.c" 中模糊匹配 "str" 的行列表。 >vim
		   echo ['one two', 'two one']->matchfuzzy('two one')
<		结果为 `['two one', 'one two']` 。 >vim
		   echo ['one two', 'two one']->matchfuzzy('two one',
						\ {'matchseq': 1})
<		结果为 `['two one']`。

                参数: ~
                  • {list} (`any[]`)
                  • {str} (`string`)
                  • {dict} (`table?`)

                返回: ~
                  (`any`)

matchfuzzypos({list}, {str} [, {dict}])                        *matchfuzzypos()*
		与 |matchfuzzy()| 相同，但返回匹配的字符串列表、{str} 中字符匹配的字符位置列表以及匹配分数列表。
		您可以使用 |byteidx()| 将字符位置转换为字节位置。

		如果 {str} 在一个字符串中多次匹配，则仅返回最佳匹配的位置。

		如果没有匹配的字符串或出现错误，则返回一个包含三个空列表项的列表。

		示例： >vim
			echo matchfuzzypos(['testing'], 'tsg')
<		结果为 [["testing"], [[0, 2, 6]], [99]] >vim
			echo matchfuzzypos(['clay', 'lacy'], 'la')
<		结果为 [["lacy", "clay"], [[0, 1], [1, 2]], [153, 133]] >vim
			echo [{'text': 'hello', 'id' : 10}]
				\ ->matchfuzzypos('ll', {'key' : 'text'})
<		结果为 `[[{"id": 10, "text": "hello"}], [[2, 3]], [127]]`

                参数: ~
                  • {list} (`any[]`)
                  • {str} (`string`)
                  • {dict} (`table?`)

                返回: ~
                  (`any`)

matchlist({expr}, {pat} [, {start} [, {count}]])                   *matchlist()*
		与 |match()| 相同，但返回一个 |List|。列表中的第一项是匹配的字符串，与 matchstr() 返回的相同。
		后续项是子匹配，类似于 |:substitute| 中的 "\1"、"\2" 等。
		当可选的子匹配没有匹配时，使用空字符串。示例： >vim
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		结果为：['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		当没有匹配时返回空列表。

		您可以传入一个 List，但这不太有用。

                参数: ~
                  • {expr} (`any`)
                  • {pat} (`string`)
                  • {start} (`integer?`)
                  • {count} (`integer?`)

                返回: ~
                  (`any`)

matchstr({expr}, {pat} [, {start} [, {count}]])                     *matchstr()*
		与 |match()| 相同，但返回匹配的字符串。示例： >vim
			echo matchstr("testing", "ing")
<		结果为 "ing"。
		当没有匹配时返回 ""。
		如果给出 {start}，其含义与 |match()| 相同。 >vim
			echo matchstr("testing", "ing", 2)
<		结果为 "ing"。 >vim
			echo matchstr("testing", "ing", 5)
<		结果为 ""。
		当 {expr} 是 |List| 时，返回匹配的项目。类型不会改变，不一定是字符串（String）。

                参数: ~
                  • {expr} (`any`)
                  • {pat} (`string`)
                  • {start} (`integer?`)
                  • {count} (`integer?`)

                返回: ~
                  (`any`)

matchstrlist({list}, {pat} [, {dict}])                          *matchstrlist()*
		返回 {list} 中 {pat} 匹配的 |List|。{list} 是字符串的 |List|。{pat} 与 {list} 中的每个字符串进行匹配。

		{dict} 参数支持以下项：
		    submatches	包括子匹配信息 (|/\(|)

		对于每个匹配，返回一个包含以下项的 |Dict|：
		    byteidx	匹配的起始字节索引。
		    idx		{list} 中匹配的索引。
		    text	匹配的字符串
		    submatches	子匹配的列表。仅当 {dict} 中的 "submatches" 设置为 v:true 时存在。

		关于某些选项设置对模式的影响的信息，请参阅 |match-pattern|。

		示例： >vim
		    echo matchstrlist(['tik tok'], '\<\k\+\>')
<		    `[{'idx': 0, 'byteidx': 0, 'text': 'tik'}, {'idx': 0, 'byteidx': 4, 'text': 'tok'}]` >vim
		    echo matchstrlist(['a', 'b'], '\<\k\+\>')
<		    `[{'idx': 0, 'byteidx': 0, 'text': 'a'}, {'idx': 1, 'byteidx': 0, 'text': 'b'}]`

		如果 "submatches" 存在且为 v:true，则还会返回子匹配，如 "\1", "\2" 等。
		示例： >vim
		    echo matchstrlist(['acd'], '\(a\)\?\(b\)\?\(c\)\?\(.*\)',
						\ #{submatches: v:true})
<		    `[{'idx': 0, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]`
		"submatches" 列表总是包含 9 个项目。如果未找到子匹配，则该项返回空字符串。

                参数: ~
                  • {list} (`string[]`)
                  • {pat} (`string`)
                  • {dict} (`table?`)

                返回: ~
                  (`any`)

matchstrpos({expr}, {pat} [, {start} [, {count}]])               *matchstrpos()*
		与 |matchstr()| 相同，但返回匹配的字符串、匹配的开始位置和结束位置。示例： >vim
			echo matchstrpos("testing", "ing")
<		结果为 ["ing", 4, 7]。
		当没有匹配时返回 ["", -1, -1]。
		如果给出 {start}，其含义与 |match()| 相同。 >vim
			echo matchstrpos("testing", "ing", 2)
<		结果为 ["ing", 4, 7]。 >vim
			echo matchstrpos("testing", "ing", 5)
<		结果为 ["", -1, -1]。
		当 {expr} 是 |List| 时，返回匹配的项目、{pat} 匹配的第一个项目的索引、匹配的开始位置和结束位置。 >vim
			echo matchstrpos([1, '__x'], '\a')
<		结果为 ["x", 1, 2, 3]。
		类型不会改变，不一定是字符串（String）。

                参数: ~
                  • {expr} (`any`)
                  • {pat} (`string`)
                  • {start} (`integer?`)
                  • {count} (`integer?`)

                返回: ~
                  (`any`)

max({expr})                                                              *max()*
		返回 {expr} 中所有项目的最大值。示例： >vim
			echo max([apples, pears, oranges])

<		{expr} 可以是 |List| 或 |Dictionary|。对于 Dictionary，它返回 Dictionary 中所有值的最大值。
		如果 {expr} 既不是 List 也不是 Dictionary，或者 {expr} 中的某个项目不能用作数字，则会导致错误。
		空的 |List| 或 |Dictionary| 导致零。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`number`)

menu_get({path} [, {modes}])                                        *menu_get()*
		返回一个 |List|，包含描述 |menus|（由 |:menu|、|:amenu| 等定义）的 |Dictionaries|，包括 |hidden-menus|。

		{path} 按名称匹配菜单，如果 {path} 是空字符串则匹配所有菜单。示例： >vim
			echo menu_get('File','')
			echo menu_get('')
<
		{modes} 是零个或多个模式的字符串（模式列表请参阅 |maparg()| 或 |creating-menus|）。“a” 表示 “所有”。

		示例： >vim
			nnoremenu &Test.Test inormal
			inoremenu Test.Test insert
			vnoremenu Test.Test x
			echo menu_get("")

<		返回类似这样的内容： >

			[ {
			  "hidden": 0,
			  "name": "Test",
			  "priority": 500,
			  "shortcut": 84,
			  "submenus": [ {
			    "hidden": 0,
			    "mappings": {
			      i": {
				"enabled": 1,
				"noremap": 1,
				"rhs": "insert",
				"sid": 1,
				"silent": 0
			      },
			      n": { ... },
			      s": { ... },
			      v": { ... }
			    },
			    "name": "Test",
			    "priority": 500,
			    "shortcut": 0
			  } ]
			} ]
<

                参数: ~
                  • {path} (`string`)
                  • {modes} (`string?`)

                返回: ~
                  (`any`)

menu_info({name} [, {mode}])                                       *menu_info()*
		返回关于指定菜单 {name} 在模式 {mode} 中的信息。
		菜单名称应不带快捷字符（'&'）指定。如果 {name} 是 ""，则返回顶级菜单名称。

		{mode} 可以是以下字符串之一：
			"n"	普通模式（Normal）
			"v"	可视模式（Visual）（包括选择模式 Select）
			"o"	操作符等待模式（Operator-pending）
			"i"	插入模式（Insert）
			"c"	命令行模式（Cmd-line）
			"s"	选择模式（Select）
			"x"	可视模式（Visual）
			"t"	终端-作业模式（Terminal-Job）
			""	普通模式、可视模式和操作符等待模式
			"!"	插入模式和命令行模式
		当 {mode} 被省略时，使用 "" 的模式。

		返回一个包含以下项的 |Dictionary|：
		  accel		菜单项加速器文本 |menu-text|
		  display	显示名称（不带 '&' 的名称）
		  enabled	v:true 如果此菜单项已启用
				参阅 |:menu-enable|
		  icon		图标文件的名称（用于工具栏）
				|toolbar-icon|
		  iconidx	内置图标的索引
		  modes		定义菜单的模式。除了上述模式之外，还将使用这些字符：
				" "	普通模式、可视模式和操作符等待模式
		  name		菜单项名称。
		  noremenu	v:true 如果菜单项的 {rhs} 不可重映射，否则为 v:false。
		  priority	菜单顺序优先级 |menu-priority|
		  rhs		菜单项的右侧（right-hand-side）。返回的字符串中的特殊字符会被转换，
				就像 ":menu" 命令列表的输出一样。当菜单项的 {rhs} 为空时，返回 "<Nop>"。
		  script	v:true 如果允许 {rhs} 的脚本局部重映射，否则为 v:false。参见 |:menu-script|。
		  shortcut	快捷键（菜单名称中 '&' 后面的字符） |menu-shortcut|
		  silent	v:true 如果菜单项是使用 <silent> 参数创建的 |:menu-silent|
		  submenus	|List|，包含所有子菜单的名称。仅当菜单项有子菜单时存在。

		如果未找到菜单项，则返回空字典。

		示例： >vim
			echo menu_info('Edit.Cut')
			echo menu_info('File.Save', 'n')

			" 在缓冲区中显示整个菜单层次结构
			func ShowMenu(name, pfx)
			  let m = menu_info(a:name)
			  call append(line('$'), a:pfx .. m.display)
			  for child in m->get('submenus', [])
			    call ShowMenu(a:name .. '.' .. escape(child, '.'),
							\ a:pfx .. '    ')
			  endfor
			endfunc
			new
			for topmenu in menu_info('').submenus
			  call ShowMenu(topmenu, '')
			endfor
<

                参数: ~
                  • {name} (`string`)
                  • {mode} (`string?`)

                返回: ~
                  (`any`)

min({expr})                                                              *min()*
		返回 {expr} 中所有项目的最小值。示例： >vim
			echo min([apples, pears, oranges])

<		{expr} 可以是 |List| 或 |Dictionary|。对于 Dictionary，它返回 Dictionary 中所有值的最小值。
		如果 {expr} 既不是 List 也不是 Dictionary，或者 {expr} 中的某个项目不能用作数字，则会导致错误。
		空的 |List| 或 |Dictionary| 导致零。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`number`)

mkdir({name} [, {flags} [, {prot}]])                              *mkdir()* *E739*
		创建目录 {name}。

		当存在 {flags} 时，它必须是一个字符串。空字符串没有效果。

		{flags} 可以包含这些字符标志：
		 "p"	将根据需要创建中间目录
		 "D"	{name} 将在当前函数结束时删除，但不会递归删除 |:defer|
		 "R"	{name} 将在当前函数结束时递归删除 |:defer|

		注意，当 {name} 有多个部分且使用 "p" 时，某些目录可能已经存在。
		只有第一个创建的目录及其内容会被计划删除。
		例如，当使用： >vim
			call mkdir('subdir/tmp/autoload', 'pR')
<		且 "subdir" 已存在时，"subdir/tmp" 将被计划删除，类似于： >vim
			defer delete('subdir/tmp', 'rf')
<
		如果给出 {prot}，则用于设置新目录的保护位。默认为 0o755 (rwxr-xr-x：用户可读/写，其他人可读)。
		使用 0o700 使其他人不可读。这用于新创建的目录。注意：umask 会应用于 {prot}（在 Unix 上）。
		示例： >vim
			call mkdir($HOME .. "/tmp/foo/bar", "p", 0o700)

<		此函数在 |sandbox| 中不可用。

		如果您尝试使用设置为 "p" 的 {flags} 创建现有目录，mkdir() 将静默退出。

		函数结果是一个数字（Number），如果调用成功则为 TRUE，如果目录创建失败或部分失败则为 FALSE。

                参数: ~
                  • {name} (`string`)
                  • {flags} (`string?`)
                  • {prot} (`string?`)

                返回: ~
                  (`integer`)

mode([{expr}])                                                          *mode()*
		返回一个表示当前模式的字符串。
		如果提供了 {expr} 并且它求值为非零数字（Number）或非空字符串（String）（|non-zero-arg|），
		则返回完整模式，否则仅返回第一个字母。另请参阅 |state()|。

		   n	    普通模式（Normal）
		   no	    操作符等待模式（Operator-pending）
		   nov	    操作符等待模式（强制字符方式 |o_v|）
		   noV	    操作符等待模式（强制行方式 |o_V|）
		   noCTRL-V 操作符等待模式（强制块方式 |o_CTRL-V|）
				CTRL-V 是一个字符
		   niI	    在 |Insert-mode| 中使用 |i_CTRL-O| 的普通模式
		   niR	    在 |Replace-mode| 中使用 |i_CTRL-O| 的普通模式
		   niV	    在 |Virtual-Replace-mode| 中使用 |i_CTRL-O| 的普通模式
		   nt	    |terminal-emulator| 中的普通模式（插入进入终端模式）
		   ntT	    在 |Terminal-mode| 中使用 |t_CTRL-\_CTRL-O| 的普通模式
		   v	    按字符的可视模式（Visual by character）
		   vs	    在选择模式中使用 |v_CTRL-O| 的按字符可视模式
		   V	    按行的可视模式（Visual by line）
		   Vs	    在选择模式中使用 |v_CTRL-O| 的按行可视模式
		   CTRL-V   按块的可视模式（Visual blockwise）
		   CTRL-Vs  在选择模式中使用 |v_CTRL-O| 的按块可视模式
		   s	    按字符的选择模式（Select by character）
		   S	    按行的选择模式（Select by line）
		   CTRL-S   按块的选择模式（Select blockwise）
		   i	    插入模式（Insert）
		   ic	    插入模式补全 |compl-generic|
		   ix	    插入模式 |i_CTRL-X| 补全
		   R	    替换模式 |R|
		   Rc	    替换模式补全 |compl-generic|
		   Rx	    替换模式 |i_CTRL-X| 补全
		   Rv	    虚拟替换模式 |gR|
		   Rvc	    虚拟替换模式补全 |compl-generic|
		   Rvx	    虚拟替换模式 |i_CTRL-X| 补全
		   c	    命令行编辑模式（Command-line editing）
		   cr	    命令行编辑覆盖模式 |c_<Insert>|
		   cv	    Vim Ex 模式 |gQ|
		   cvr	    Vim Ex 模式，处于覆盖模式 |c_<Insert>|
		   r	    按回车提示模式（Hit-enter prompt）
		   rm	    -- more -- 提示模式
		   r?	    某种 |:confirm| 查询
		   !	    正在执行 shell 或外部命令
		   t	    终端模式：按键传递给作业

		这在 'statusline' 选项或 RPC 调用中很有用。在大多数其他地方，它总是返回 "c" 或 "n"。
		请注意，将来可能会添加更多模式和更具体的模式。最好不要比较整个字符串，而只比较前导字符。
		另请参阅 |visualmode()|。

                参数: ~
                  • {expr} (`any?`)

                返回: ~
                  (`any`)


msgpackdump({list} [, {type}])                                   *msgpackdump()*
		将 Vimscript 对象列表转换为 msgpack。返回值是一个 |readfile()| 风格的列表。
		当 {type} 包含 "B" 时，返回一个 |Blob|。示例： >vim
			call writefile(msgpackdump([{}]), 'fname.mpack', 'b')
<		或者，使用 |Blob|： >vim
			call writefile(msgpackdump([{}], 'B'), 'fname.mpack')
<
		这将把单个 0x80 字节写入 `fname.mpack` 文件
		（具有零项的字典在 messagepack 中由 0x80 字节表示）。

		限制：				*E5004* *E5005*
		1. 无法转储 |Funcref|。
		2. 无法转储引用自身的容器。
		3. 字典键总是作为 STR 字符串转储。
		4. 其他字符串和 |Blob| 总是作为 BIN 字符串转储。
		5. 第 3 点和第 4 点不适用于 |msgpack-special-dict|。

                参数: ~
                  • {list} (`any`)
                  • {type} (`any?`)

                返回: ~
                  (`any`)

msgpackparse({data})                                            *msgpackparse()*
		将 |readfile()| 风格的列表或 |Blob| 转换为 Vimscript 对象列表。
		示例： >vim
			let fname = expand('~/.config/nvim/shada/main.shada')
			let mpack = readfile(fname, 'b')
			let shada_objects = msgpackparse(mpack)
<		这将把 ~/.config/nvim/shada/main.shada 文件读入 `shada_objects` 列表。

		限制：
		1. 除非使用通用映射（|msgpack-special-map|）转储 messagepack 映射，否则不保留映射顺序。
		2. 由于解析器旨在保留所有数据不变（除了第 1 点），某些字符串被解析为
		   |msgpack-special-dict| 格式，这种格式使用起来不方便。
							*msgpack-special-dict*
		某些 messagepack 字符串可能被解析为特殊字典。特殊字典是满足以下条件的字典：

		1. 恰好包含两个键：`_TYPE` 和 `_VAL`。
		2. `_TYPE` 键是 |v:msgpack_types| 变量中找到的类型之一。
		3. `_VAL` 的值具有以下格式（键列包含来自 |v:msgpack_types| 的键名）：

		键	值 ~
		nil	零，转储时忽略。自引入 |v:null| 后，|msgpackparse()| 不再返回。
		boolean	一或零。转储时仅检查值是否为 |Number|。自引入 |v:true| 和 |v:false| 后，|msgpackparse()| 不再返回。
		integer	|List|，包含四个数字：符号（-1 或 1）、最高的两位、第 62 位到第 31 位的数字、最低的 31 位。
			即，要获取实际数字，需要使用如下代码： >
				_VAL[0] * ((_VAL[1] << 62)
				           & (_VAL[2] << 31)
				           & _VAL[3])
<			在以下情况下，具有此类型的特殊字典将出现在 |msgpackparse()| 输出中：
			1. |Number| 是 32 位的，且值高于 INT32_MAX 或低于 INT32_MIN。
			2. |Number| 是 64 位的，且值高于 INT64_MAX。它不可能低于 INT64_MIN，因为 msgpack C 解析器不支持这样的值。
		float	|Float|。此值不可能出现在 |msgpackparse()| 输出中。
		string	|String|，或者如果二进制字符串包含零字节则为 |Blob|。自引入 blob 后，此值不可能出现在 |msgpackparse()| 输出中。
		array	|List|。此值不可能出现在 |msgpackparse()| 输出中。
							*msgpack-special-map*
		map	|List|，包含两个项目（键和值）的 |List| 列表。
			如果解析的映射包含以下任一键，此值将出现在 |msgpackparse()| 输出中：
			1. 任何非字符串的键（包括是二进制字符串的键）。
			2. 内部有 NUL 字节的字符串。
			3. 重复的键。
		ext	|List|，包含两个值：第一个是表示扩展类型的有符号整数。
			第二个是 |readfile()| 风格的字符串列表。

                参数: ~
                  • {data} (`any`)

                返回: ~
                  (`any`)

nextnonblank({lnum})                                            *nextnonblank()*
		返回在 {lnum} 处或之下第一个非空行的行号。示例： >vim
			if getline(nextnonblank(1)) =~ "Java" | endif
<		当 {lnum} 无效或在其处或之下没有非空行时，返回零。
		{lnum} 的用法与 |getline()| 相同。
		另请参阅 |prevnonblank()|。

                参数: ~
                  • {lnum} (`integer|string`)

                返回: ~
                  (`integer`)

nr2char({expr} [, {utf8}])                                           *nr2char()*
		返回一个包含单个字符的字符串，该字符具有数字值 {expr}。示例： >vim
			echo nr2char(64)		" 返回 '@'
			echo nr2char(32)		" 返回 ' '
<		"utf-8" 示例： >vim
			echo nr2char(300)		" 返回带弓形符号的 I
<
		始终使用 UTF-8 编码，{utf8} 选项无效，仅为了向后兼容而存在。
		请注意，文件中的 NUL 字符用 nr2char(10) 指定，因为 NUL 用换行符表示。
		nr2char(0) 是真正的 NUL 并终止字符串，因此导致空字符串。

                参数: ~
                  • {expr} (`integer`)
                  • {utf8} (`boolean?`)

                返回: ~
                  (`string`)

nvim_...({...})                                      *nvim_...()* *E5555* *eval-api*
		调用 nvim |api| 函数。参数的类型检查将比大多数其他内置函数更严格。
		例如，如果期望的是整数（Integer），则必须传入 |Number|，|String| 不会自动转换。
		缓冲区编号，如由 |bufnr()| 返回的，可用作 nvim_buf_... 函数的第一个参数。
		所有期望对象（缓冲区、窗口或标签页）的函数也可以接受数值 0 来表示当前（聚焦的）对象。

                参数: ~
                  • {...} (`any`)

                返回: ~
                  (`any`)

or({expr}, {expr})                                                        *or()*
		对两个参数进行按位或运算。参数被转换为数字。列表（List）、字典（Dict）或浮点数（Float）参数会导致错误。
		另请参阅 `and()` 和 `xor()`。
		示例： >vim
			let bits = or(bits, 0x80)

<		理由：之所以这是一个函数而不是像许多语言那样使用 "|" 字符，是因为 Vi 一直使用 "|" 来分隔命令。
		在许多地方，不清楚 "|" 是运算符还是命令分隔符。

                参数: ~
                  • {expr} (`number`)
                  • {expr1} (`number`)

                返回: ~
                  (`any`)

pathshorten({path} [, {len}])                                    *pathshorten()*
		缩短路径 {path} 中的目录名称并返回结果。尾部，即文件名，保持不变。
		路径中的其他组件被缩减为 {len} 个字母的长度。
		如果省略 {len} 或小于 1，则使用 1（单个字母）。保留前导 '~' 和 '.' 字符。示例： >vim
			echo pathshorten('~/.config/nvim/autoload/file1.vim')
<			~/.c/n/a/file1.vim ~
>vim
			echo pathshorten('~/.config/nvim/autoload/file2.vim', 2)
<			~/.co/nv/au/file2.vim ~
		路径是否存在并不重要。
		出错时返回空字符串。

                参数: ~
                  • {path} (`string`)
                  • {len} (`integer?`)

                返回: ~
                  (`string`)

perleval({expr})                                                    *perleval()*
		计算 |perl| 表达式 {expr} 并将其结果转换为 Vim 数据结构。
		数字和字符串按原样返回（不过字符串会被复制）。
		列表表示为 Vim |List| 类型。
		字典表示为 Vim |Dictionary| 类型，非字符串键会导致错误。

		注意：如果您想要数组或哈希，{expr} 必须返回对它的引用。
		示例： >vim
			echo perleval('[1 .. 4]')
<			[1, 2, 3, 4]

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`any`)

pow({x}, {y})                                                            *pow()*
		返回 {x} 的 {y} 次幂作为 |Float|。
		{x} 和 {y} 必须求值为 |Float| 或 |Number|。
		如果 {x} 或 {y} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo pow(3, 3)
<			27.0 >vim
			echo pow(2, 16)
<			65536.0 >vim
			echo pow(32, 0.20)
<			2.0

                参数: ~
                  • {x} (`number`)
                  • {y} (`number`)

                返回: ~
                  (`number`)

prevnonblank({lnum})                                            *prevnonblank()*
		返回在 {lnum} 处或之上第一个非空行的行号。示例： >vim
			let ind = indent(prevnonblank(v:lnum - 1))
<		当 {lnum} 无效或在其处或之上没有非空行时，返回零。
		{lnum} 的用法与 |getline()| 相同。
		另请参阅 |nextnonblank()|。

                参数: ~
                  • {lnum} (`integer|string`)

                返回: ~
                  (`integer`)

printf({fmt}, {expr1} ...)                                            *printf()*
		返回一个字符串，其中 {fmt} 中的 "%" 项被其各自参数的格式化形式替换。示例： >vim
			echo printf("%4d: E%d %.30s", lnum, errno, msg)
<		可能结果：
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		当用作 |method| 时，基础作为第二个参数传递： >vim
			Compute()->printf("result: %d")
<
		您可以使用 `call()` 将项目作为列表传递。

		常用项有：
		  %s	字符串
		  %6S	在 6 个显示单元格中右对齐的字符串
		  %6s	在 6 个字节中右对齐的字符串
		  %.9s	截断为 9 个字节的字符串
		  %c	单个字节
		  %d	十进制数
		  %5d	用空格填充到 5 个字符的十进制数
		  %b	二进制数
		  %08b	用零填充到至少 8 个字符的二进制数
		  %B	使用大写字母的二进制数
		  %x	十六进制数
		  %04x	用零填充到至少 4 个字符的十六进制数
		  %X	使用大写字母的十六进制数
		  %o	八进制数
		  %f	浮点数，形式为 12.23、inf、-inf 或 nan
		  %F	浮点数，形式为 12.23、INF、-INF 或 NAN
		  %e	浮点数，形式为 1.23e3、inf、-inf 或 nan
		  %E	浮点数，形式为 1.23E3、INF、-INF 或 NAN
		  %g	浮点数，根据值使用 %f 或 %e
		  %G	浮点数，根据值使用 %F 或 %E
		  %%	% 字符本身
		  %p	指向容器的指针的表示

		转换规范以 '%' 开始，以转换类型结束。所有其他字符原样复制到结果中。

		"%" 开始一个转换规范。以下参数按顺序出现：

			% [位置参数] [标志] [字段宽度] [.精度] 类型

		位置参数
			最多一个位置参数说明符。形式为 {n$}，其中 n >= 1。

		标志
			零个或多个以下标志：

		    #	      值应转换为“交替形式”。对于 c、d 和 s 转换，此选项无效。
			      对于 o 转换，数字的精度会增加以强制输出字符串的第一个字符为零
			      （除非零值以显式精度零打印）。
			      对于 x 和 X 转换，非零结果会在前面加上字符串 "0x"（对于 X 转换则为 "0X"）。

		    0 (零)  零填充。对于所有转换，转换后的值在左侧用零而不是空格填充。
			      如果给定了数字转换（d、o、x 和 X）的精度，则忽略 0 标志。

		    -	      负字段宽度标志；转换后的值在字段边界左对齐。
			      转换后的值在右侧用空格填充，而不是在左侧用空格或零填充。
			      如果同时给出 - 和 0，则 - 覆盖 0。

		    ' ' (空格)  在由有符号转换（d）产生的正数前应留一个空格。

		    +	      在有符号转换产生的数字前必须始终放置一个符号。如果同时使用 + 和空格，则 + 覆盖空格。

		字段宽度
			可选的十进制数字字符串，指定最小字段宽度。
			如果转换后的值的字节数少于字段宽度，它将在左侧（或如果给出了左调整标志，则在右侧）
			用空格填充以填满字段宽度。对于 S 转换，计数以单元格为单位。

		.精度
			可选的精度，形式为句点 '.' 后跟一个可选的数字字符串。
			如果省略数字字符串，则精度视为零。
			这给出了 d、o、x 和 X 转换要显示的最小位数，
			s 转换要从字符串打印的最大字节数，
			或 S 转换要从字符串打印的最大单元格数。
			对于浮点数，它是小数点后的位数。

		类型
			指定要应用的转换类型的字符，见下文。

		字段宽度或精度，或两者，可以用星号 "*" 而不是数字字符串表示。
		在这种情况下，一个数字（Number）参数提供字段宽度或精度。
		负字段宽度被视为左调整标志后跟正字段宽度；负精度被视为缺失。
		示例： >vim
			echo printf("%d: %.*s", nr, width, line)
<		这将限制从 "line" 使用的文本长度为 "width" 字节。

		如果要格式化的参数使用位置参数说明符指定，并且使用 '*' 表示要使用数字参数来指定宽度或精度，
		则要使用的参数也必须使用 {n$} 位置参数说明符指定。参见 |printf-$|。

		转换说明符及其含义为：

				*printf-d* *printf-b* *printf-B* *printf-o* *printf-x* *printf-X*
		dbBoxX	数字（Number）参数转换为有符号十进制（d）、
			无符号二进制（b 和 B）、无符号八进制（o）或无符号十六进制（x 和 X）表示法。
			字母 "abcdef" 用于 x 转换；字母 "ABCDEF" 用于 X 转换。
			精度（如果有）给出了必须出现的最小位数；如果转换后的值需要更少的位数，
			则在左侧用零填充。在任何情况下，不存在或小的字段宽度不会导致数字字段被截断；
			如果转换结果比字段宽度宽，则扩展字段以包含转换结果。
			'h' 修饰符表示参数是 16 位的。
			'l' 修饰符表示参数是长整数。大小将是 32 位或 64 位，取决于您的平台。
			"ll" 修饰符表示参数是 64 位的。
			b 和 B 转换说明符从不接受宽度修饰符，并且总是假定其参数是 64 位整数。
			通常，这些修饰符没有用。当从参数中知道类型时，它们被忽略。

		i	d 的别名
		D	ld 的别名
		U	lu 的别名
		O	lo 的别名

							*printf-c*
		c	数字（Number）参数转换为一个字节，并写入结果字符。

							*printf-s*
		s	使用字符串（String）参数的文本。如果指定了精度，则使用的字节数不超过指定的数量。
			如果参数不是字符串（String）类型，它会自动转换为文本，格式与 ":echo" 相同。
							*printf-S*
		S	使用字符串（String）参数的文本。如果指定了精度，则使用的显示单元格数不超过指定的数量。

							*printf-f* *E807*
		f F	浮点（Float）参数转换为形式为 123.456 的字符串。
			精度指定小数点后的位数。当精度为零时，省略小数点。
			当未指定精度时，使用 6。一个非常大的数字（超出范围或除以零）会导致
			使用 %f 时出现 "inf" 或 "-inf"（使用 %F 时出现 INF 或 -INF）。
			"0.0 / 0.0" 使用 %f 会导致 "nan"（使用 %F 时为 NAN）。
			示例： >vim
				echo printf("%.2f", 12.115)
<				12.12
			请注意，舍入取决于系统库。如有疑问，请使用 |round()|。

							*printf-e* *printf-E*
		e E	浮点（Float）参数转换为形式为 1.234e+03 的字符串，或使用 'E' 时为 1.234E+03。
			精度指定小数点后的位数，与 'f' 相同。

							*printf-g* *printf-G*
		g G	浮点（Float）参数像 'f' 一样转换，如果值在 0.001（含）和 10000000.0（不含）之间。
			否则，'g' 使用 'e'，'G' 使用 'E'。
			当未指定精度时，会删除多余的零和 '+' 符号，除了紧接小数点后的零。
			因此 10000000.0 结果为 1.0e7。

							*printf-%*
		%	写入一个 '%'。不转换参数。完整的转换规范是 "%%"。

		当期望数字（Number）参数时，也接受字符串（String）参数并自动转换。
		当期望浮点（Float）或字符串（String）参数时，也接受数字（Number）参数并自动转换。
		任何其他参数类型都会导致错误消息。

							*E766* *E767*
		{exprN} 参数的数量必须与 "%" 项的数量完全匹配。
		如果参数不足或太多，会给出错误。最多可以使用 18 个参数。

							*printf-$*
		在某些语言中，错误和信息性消息在单词顺序与英语中相应消息不同时更易读。
		为了适应具有不同单词顺序的翻译，可以使用位置参数来指示这一点。例如： >vim

		    #, c-format
		    msgid "%s returning %s"
		    msgstr "waarde %2$s komt terug van %1$s"
<
		在此示例中，句子在输出中的两个字符串参数顺序颠倒了。 >vim

		    echo printf(
			"In The Netherlands, vim's creator's name is: %1$s %2$s",
			"Bram", "Moolenaar")
<		    In The Netherlands, vim's creator's name is: Bram Moolenaar >vim

		    echo printf(
			"In Belgium, vim's creator's name is: %2$s %1$s",
			"Bram", "Moolenaar")
<		    In Belgium, vim's creator's name is: Moolenaar Bram

		宽度（和精度）可以使用 '*' 说明符指定。
		在这种情况下，您必须在参数列表中指定字段宽度的位置。 >vim

		    echo printf("%1$*2$.*3$d", 1, 2, 3)
<		    001 >vim
		    echo printf("%2$*3$.*1$d", 1, 2, 3)
<		      2 >vim
		    echo printf("%3$*1$.*2$d", 1, 2, 3)
<		    03 >vim
		    echo printf("%1$*2$.*3$g", 1.4142, 2, 3)
<		    1.414

		您可以混合使用直接指定和通过位置参数指定宽度和/或精度： >vim

		    echo printf("%1$4.*2$f", 1.4142135, 6)
<		    1.414214 >vim
		    echo printf("%1$*2$.4f", 1.4142135, 6)
<		    1.4142 >vim
		    echo printf("%1$*2$.*3$f", 1.4142135, 6, 2)
<		      1.41

		当字段宽度或精度导致字符串长于 1 MB (1024*1024 = 1048576) 字符时，您将收到溢出错误 |E1510|。

							*E1500*
		您不能混合使用位置和非位置参数： >vim
		    echo printf("%s%1$s", "One", "Two")
<		    E1500: Cannot mix positional and non-positional arguments:
		    %s%1$s

							*E1501*
		您不能在格式字符串中跳过位置参数： >vim
		    echo printf("%3$s%1$s", "One", "Two", "Three")
<		    E1501: format argument 2 unused in $-style format:
		    %3$s%1$s

							*E1502*
		您可以重复使用 [字段宽度]（或 [精度]）参数： >vim
		    echo printf("%1$d at width %2$d is: %01$*2$d", 1, 2)
<		    1 at width 2 is: 01

		但是，您不能将其用作不同的类型： >vim
		    echo printf("%1$d at width %2$ld is: %01$*2$d", 1, 2)
<		    E1502: Positional argument 2 used as field width reused as
		    different type: long int/int

							*E1503*
		当使用位置参数但未给出正确数量的参数时，会引发错误： >vim
		    echo printf("%1$d at width %2$d is: %01$*2$.*3$d", 1, 2)
<		    E1503: Positional argument 3 out of bounds: %1$d at width
		    %2$d is: %01$*2$.*3$d

		仅报告第一个错误： >vim
		    echo printf("%01$*2$.*3$d %4$d", 1, 2)
<		    E1503: Positional argument 3 out of bounds: %01$*2$.*3$d
		    %4$d

							*E1504*
		位置参数可以多次使用： >vim
		    echo printf("%1$s %2$s %1$s", "One", "Two")
<		    One Two One

		但是，您不能在第二次使用时使用不同的类型： >vim
		    echo printf("%1$s %2$s %1$d", "One", "Two")
<		    E1504: Positional argument 1 type used inconsistently:
		    int/string

							*E1505*
		导致格式字符串格式错误的各种其他错误会导致： >vim
		    echo printf("%1$d at width %2$d is: %01$*2$.3$d", 1, 2)
<		    E1505: Invalid format specifier: %1$d at width %2$d is:
		    %01$*2$.3$d

							*E1507*
		此内部错误指示解析位置格式参数的逻辑遇到了无法以其他方式报告的问题。
		如果您遇到此问题，请提交关于 Vim 的错误报告，复制使用的确切格式字符串和参数。

                参数: ~
                  • {fmt} (`string`)
                  • {expr1} (`any?`)

                返回: ~
                  (`string`)

prompt_getinput({buf})                                       *prompt_getinput()*
		获取 |prompt-buffer| {buf} 中的当前用户输入，而不调用 prompt_callback。
		{buf} 可以是缓冲区名称或编号。

		如果缓冲区不存在或不是提示缓冲区，则返回空字符串。

                参数: ~
                  • {buf} (`integer|string`)

                返回: ~
                  (`any`)

prompt_getprompt({buf})                                     *prompt_getprompt()*
		返回缓冲区 {buf} 的有效提示文本。{buf} 可以是缓冲区名称或编号。参见 |prompt-buffer|。

		如果缓冲区不存在或不是提示缓冲区，则返回空字符串。

                参数: ~
                  • {buf} (`integer|string`)

                返回: ~
                  (`any`)

prompt_setcallback({buf}, {expr})                         *prompt_setcallback()*
		将缓冲区 {buf} 的提示回调设置为 {expr}。当 {expr} 为空字符串时，回调被移除。
		这仅在 {buf} 的 'buftype' 设置为 "prompt" 时有效。

		回调在按下 Enter 时调用。当前缓冲区将始终是提示缓冲区。
		在调用回调之前会为提示添加一个新行，因此调用回调的提示将位于倒数第二行。
		如果回调想要向缓冲区添加文本，它必须将其插入到最后一行之上，因为那是当前提示所在的位置。
		这也可以异步完成。
		回调调用时带有一个参数，即在提示处输入的文本。如果用户只键入了 Enter，这可以是空字符串。
		示例： >vim
		   func s:TextEntered(text)
		     if a:text == 'exit' || a:text == 'quit'
		       stopinsert
		       " 重置 'modified' 以允许关闭缓冲区。
		       " 我们假设没有有用的内容需要保存。
		       set nomodified
		       close
		     else
		       " 用 a:text 做一些有用的事情。在这个例子中我们只是重复它。
		       call append(line('$') - 1, 'Entered: "' .. a:text .. '"')
		     endif
		   endfunc
		   call prompt_setcallback(bufnr(), function('s:TextEntered'))
<

                参数: ~
                  • {buf} (`integer|string`)
                  • {expr} (`string|function`)

                返回: ~
                  (`any`)

prompt_setinterrupt({buf}, {expr})                       *prompt_setinterrupt()*
		为缓冲区 {buf} 设置一个回调 {expr}。当 {expr} 为空字符串时，回调被移除。
		这仅在 {buf} 的 'buftype' 设置为 "prompt" 时有效。

		此回调将在插入模式下按下 CTRL-C 时调用。如果不设置回调，Vim 将退出插入模式，就像在任何缓冲区中一样。

                参数: ~
                  • {buf} (`integer|string`)
                  • {expr} (`string|function`)

                返回: ~
                  (`any`)

prompt_setprompt({buf}, {text})                             *prompt_setprompt()*
		将缓冲区 {buf} 的提示设置为 {text}。您很可能希望 {text} 以空格结尾。
		仅当 {buf} 的 'buftype' 设置为 "prompt" 时，结果才可见。示例： >vim
			call prompt_setprompt(bufnr(''), 'command: ')
<

                参数: ~
                  • {buf} (`integer|string`)
                  • {text} (`string`)

                返回: ~
                  (`any`)

pum_getpos()                                                      *pum_getpos()*
		如果弹出菜单（参见 |ins-completion-menu|）不可见，则返回空 |Dictionary|，
		否则，返回包含以下键的 |Dictionary|：
			height		可见项数
			width		屏幕单元格数
			row		顶部屏幕行（0 为第一行）
			col		最左侧屏幕列（0 为第一列）
			size		总项数
			scrollbar	如果滚动条可见则为 |TRUE|

		这些值与 |CompleteChanged| 期间的 |v:event| 中的值相同。

                返回: ~
                  (`any`)

pumvisible()                                                      *pumvisible()*
		当弹出菜单可见时返回非零，否则返回零。参见 |ins-completion-menu|。
		这可用于避免某些会移除弹出菜单的操作。

                返回: ~
                  (`any`)

py3eval({expr})                                                      *py3eval()*
		计算 Python 表达式 {expr} 并将其结果转换为 Vim 数据结构。
		数字和字符串按原样返回（不过字符串会被复制，Unicode 字符串会额外转换为 UTF-8）。
		列表表示为 Vim |List| 类型。
		字典表示为 Vim |Dictionary| 类型，键转换为字符串。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`any`)

pyeval({expr})                                              *pyeval()* *E858* *E859*
		计算 Python 表达式 {expr} 并将其结果转换为 Vim 数据结构。
		数字和字符串按原样返回（不过字符串会被复制）。
		列表表示为 Vim |List| 类型。
		字典表示为 Vim |Dictionary| 类型，非字符串键会导致错误。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`any`)

pyxeval({expr})                                                      *pyxeval()*
		计算 Python 表达式 {expr} 并将其结果转换为 Vim 数据结构。
		使用 Python 2 或 3，参见 |python_x| 和 'pyxversion'。
		另请参阅：|pyeval()|, |py3eval()|

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`any`)

rand([{expr}])                                                          *rand()*
		使用种子 {expr} 通过 xoshiro128** 算法生成伪随机数。
		返回的数字是 32 位的，在 64 位系统上也是如此，以保持一致性。
		{expr} 可以由 |srand()| 初始化，并将由 rand() 更新。如果省略 {expr}，则使用并更新内部种子值。
		如果 {expr} 无效，返回 -1。

		示例： >vim
			echo rand()
			let seed = srand()
			echo rand(seed)
			echo rand(seed) % 16  " 随机数 0 - 15
<

                参数: ~
                  • {expr} (`number?`)

                返回: ~
                  (`any`)

range({expr} [, {max} [, {stride}]])                         *range()* *E726* *E727*
		返回一个包含数字的 |List|：
		- 如果仅指定 {expr}：[0, 1, ..., {expr} - 1]
		- 如果指定 {max}：[{expr}, {expr} + 1, ..., {max}]
		- 如果指定 {stride}：[{expr}, {expr} + {stride}, ..., {max}]
		  （每次将 {expr} 增加 {stride}，不产生超过 {max} 的值）。
		当最大值比开始值小一时，结果是一个空列表。
		当最大值比开始值小多于一时，这是一个错误。
		示例： >vim
			echo range(4)		" [0, 1, 2, 3]
			echo range(2, 4)	" [2, 3, 4]
			echo range(2, 9, 3)	" [2, 5, 8]
			echo range(2, -2, -1)	" [2, 1, 0, -1, -2]
			echo range(0)		" []
			echo range(2, 0)	" 错误！
<

                参数: ~
                  • {expr} (`any`)
                  • {max} (`integer?`)
                  • {stride} (`integer?`)

                返回: ~
                  (`any`)

readblob({fname} [, {offset} [, {size}]])                           *readblob()*
		以二进制模式读取文件 {fname} 并返回一个 |Blob|。
		如果指定 {offset}，则从指定偏移量开始读取文件。
		如果它是负值，则用作文件末尾的偏移量。例如，读取最后 12 个字节： >vim
			echo readblob('file.bin', -12)
<		如果指定 {size}，则仅读取指定的大小。
		例如，读取文件的前 100 个字节： >vim
			echo readblob('file.bin', 0, 100)
<		如果 {size} 是 -1 或省略，则读取从 {offset} 开始的全部数据。
		这也可用于在 Unix 上显式设置 {size} 时从字符设备读取数据。
		仅当设备支持寻址时，才能使用 {offset}。否则应为零。
		例如，从串行控制台读取 10 个字节： >vim
			echo readblob('/dev/ttyS0', 0, 10)
<		当无法打开文件时，会给出错误消息，结果是一个空 |Blob|。
		当偏移量超出文件末尾时，结果是一个空 blob。
		当尝试读取的字节数超过可用字节数时，结果会被截断。
		另请参阅 |readfile()| 和 |writefile()|。

                参数: ~
                  • {fname} (`string`)
                  • {offset} (`integer?`)
                  • {size} (`integer?`)

                返回: ~
                  (`any`)

readdir({directory} [, {expr}])                                      *readdir()*
		返回 {directory} 中的文件和目录名称列表。
		如果您不需要做复杂的事情，例如限制匹配数量，也可以使用 |glob()|。

		当省略 {expr} 时，包含所有条目。
		当给出 {expr} 时，会对其求值以检查要执行的操作：
			如果 {expr} 结果为 -1，则不会处理更多条目。
			如果 {expr} 结果为 0，则不会将此条目添加到列表中。
			如果 {expr} 结果为 1，则将此条目添加到列表中。
		每次求值 {expr} 时，|v:val| 被设置为条目名称。
		当 {expr} 是函数时，名称作为参数传递。
		例如，要获取以 ".txt" 结尾的文件列表： >vim
		  echo readdir(dirname, {n -> n =~ '.txt$'})
<		要跳过隐藏和备份文件： >vim
		  echo readdir(dirname, {n -> n !~ '^\.\|\~$'})

<		如果您想获取目录树： >vim
		  function! s:tree(dir)
		      return {a:dir : map(readdir(a:dir),
		      \ {_, x -> isdirectory(x) ?
		      \          {x : s:tree(a:dir .. '/' .. x)} : x})}
		  endfunction
		  echo s:tree(".")
<
		出错时返回空列表。

                参数: ~
                  • {directory} (`string`)
                  • {expr} (`integer?`)

                返回: ~
                  (`any`)

readfile({fname} [, {type} [, {max}]])                              *readfile()*
		读取文件 {fname} 并返回一个 |List|，文件的每一行作为一个项目。
		行在 NL 字符处断开。用 CR 分隔的 Macintosh 文件将导致一个长行
		（除非某处出现 NL）。
		所有 NUL 字符都被替换为 NL 字符。
		当 {type} 包含 "b" 时，使用二进制模式：
		- 当最后一行以 NL 结尾时，会添加一个额外的空列表项。
		- 不删除 CR 字符。
		否则：
		- 删除出现在 NL 之前的 CR 字符。
		- 最后一行是否以 NL 结尾无关紧要。
		- 从文本中删除任何 UTF-8 字节顺序标记。
		当给出 {max} 时，这指定要读取的最大行数。
		如果您只想检查文件的前十行，这很有用： >vim
			for line in readfile(fname, '', 10)
			  if line =~ 'Date' | echo line | endif
			endfor
<		当 {max} 为负数时，返回文件末尾的 -{max} 行，或尽可能多的行。
		当 {max} 为零时，结果是一个空列表。
		请注意，没有 {max} 时，整个文件会被读入内存。
		另请注意，不识别编码。如果需要，请将文件读入缓冲区。
		已弃用（改用 |readblob()|）：当 {type} 包含 "B" 时，返回一个 |Blob|，其中包含未修改的文件二进制数据。
		当无法打开文件时，会给出错误消息，结果是一个空列表。
		另请参阅 |writefile()|。

                参数: ~
                  • {fname} (`string`)
                  • {type} (`string?`)
                  • {max} (`integer?`)

                返回: ~
                  (`string[]`)

reduce({object}, {func} [, {initial}])                           *reduce()* *E998*
		为 {object} 中的每个项目调用 {func}，{object} 可以是 |String|、|List| 或 |Blob|。
		{func} 使用两个参数调用：迄今为止的结果和当前项目。处理完所有项目后，返回结果。

		{initial} 是初始结果。当省略时，使用 {object} 中的第一个项目，并且首先为第二个项目调用 {func}。
		如果未给出 {initial} 且 {object} 为空，则无法计算结果，会给出 E998 错误。

		示例： >vim
			echo reduce([1, 3, 5], { acc, val -> acc + val })
			echo reduce(['x', 'y'], { acc, val -> acc .. val }, 'a')
			echo reduce(0z1122, { acc, val -> 2 * acc + val })
			echo reduce('xyz', { acc, val -> acc .. ',' .. val })
<

                参数: ~
                  • {object} (`any`)
                  • {func} (`fun(accumulator: T, current: any): any`)
                  • {initial} (`any?`)

                返回: ~
                  (`T`)

reg_executing()                                                *reg_executing()*
		返回正在执行的寄存器的单字母名称。
		当没有寄存器正在执行时，返回空字符串。
		参见 |@|。

                返回: ~
                  (`any`)

reg_recorded()                                                  *reg_recorded()*
		返回最后记录的寄存器的单字母名称。
		当尚未记录任何内容时，返回空字符串。
		参见 |q| 和 |Q|。

                返回: ~
                  (`any`)

reg_recording()                                                *reg_recording()*
		返回正在记录的寄存器的单字母名称。
		当未在记录时，返回空字符串。参见 |q|。

                返回: ~
                  (`any`)

reltime()                                                            *reltime()*
reltime({start})
reltime({start}, {end})
		返回一个表示时间值的项目。该项目是一个列表，其项目取决于系统。
		该项目可以传递给 |reltimestr()| 以将其转换为字符串，或传递给 |reltimefloat()| 以转换为浮点数。

		没有参数时，它返回当前的“相对时间”，这是一个实现定义的值，仅在用作 |reltime()|、|reltimestr()| 和 |reltimefloat()| 的参数时有意义。

		有一个参数时，它返回自参数中指定时间以来经过的时间。
		有两个参数时，它返回 {start} 和 {end} 之间经过的时间。

		{start} 和 {end} 参数必须是 reltime() 返回的值。出错时返回零。

		注意：|localtime()| 返回当前（非相对）时间。

                参数: ~
                  • {start} (`any?`)
                  • {end} (`any?`)

                返回: ~
                  (`any`)

reltimefloat({time})                                            *reltimefloat()*
		返回一个表示 {time} 时间值的浮点数（Float）。时间单位是秒。
		示例：
			let start = reltime()
			call MyFunction()
			let seconds = reltimefloat(reltime(start))
		参见 reltimestr() 关于开销的说明。
		另请参阅 |profiling|。
		如果出错，返回空字符串

                参数: ~
                  • {time} (`any`)

                返回: ~
                  (`any`)

reltimestr({time})                                                *reltimestr()*
		返回一个表示 {time} 时间值的字符串（String）。
		这是秒数、一个小点和微秒数。示例： >vim
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		请注意，命令的开销将添加到时间中。
		使用前导空格使字符串对齐良好。您可以使用 split() 将其删除。 >vim
			echo split(reltimestr(reltime(start)))[0]
<		另请参阅 |profiling|。
		如果出错，返回空字符串

                参数: ~
                  • {time} (`any`)

                返回: ~
                  (`any`)

remove({list}, {idx})                                                 *remove()*
remove({list}, {idx}, {end})
		没有 {end}：从 |List| {list} 中移除 {idx} 处的项目并返回该项目。
		有 {end}：移除从 {idx} 到 {end}（含）的项目，并返回包含这些项目的 |List|。
		当 {idx} 指向与 {end} 相同的项目时，返回包含一个项目的列表。
		当 {end} 指向 {idx} 之前的项目时，这是一个错误。
		有关 {idx} 和 {end} 的可能值，请参阅 |list-index|。
		出错时返回零。
		示例： >vim
			echo "last item: " .. remove(mylist, -1)
			call remove(mylist, 0, 9)
<

		使用 |delete()| 移除文件。

                参数: ~
                  • {list} (`any[]`)
                  • {idx} (`integer`)
                  • {end} (`integer?`)

                返回: ~
                  (`any`)

remove({blob}, {idx})
remove({blob}, {idx}, {end})
		没有 {end}：从 |Blob| {blob} 中移除 {idx} 处的字节并返回该字节。
		有 {end}：移除从 {idx} 到 {end}（含）的字节，并返回包含这些字节的 |Blob|。
		当 {idx} 指向与 {end} 相同的字节时，返回包含一个字节的 |Blob|。
		当 {end} 指向 {idx} 之前的字节时，这是一个错误。
		出错时返回零。
		示例： >vim
			echo "last byte: " .. remove(myblob, -1)
			call remove(mylist, 0, 9)
<

                参数: ~
                  • {blob} (`any`)
                  • {idx} (`integer`)
                  • {end} (`integer?`)

                返回: ~
                  (`any`)

remove({dict}, {key})
		从 {dict} 中移除键为 {key} 的条目并返回它。
		示例： >vim
			echo "removed " .. remove(dict, "one")
<		如果 {dict} 中没有 {key}，这是一个错误。
		出错时返回零。

                参数: ~
                  • {dict} (`any`)
                  • {key} (`string`)

                返回: ~
                  (`any`)

rename({from}, {to})                                                  *rename()*
		将名为 {from} 的文件重命名为 {to}。这应该也适用于跨文件系统移动文件。
		结果是一个数字（Number），如果文件重命名成功则为 0，如果重命名失败则为非零。
		注意：如果 {to} 存在，它会被覆盖而不发出警告。
		此函数在 |sandbox| 中不可用。

                参数: ~
                  • {from} (`string`)
                  • {to} (`string`)

                返回: ~
                  (`integer`)

repeat({expr}, {count})                                               *repeat()*
		重复 {expr} {count} 次并返回连接的结果。示例： >vim
			let separator = repeat('-', 80)
<		当 {count} 为零或负数时，结果为空。
		当 {expr} 是 |List| 或 |Blob| 时，结果是 {expr} 连接 {count} 次。示例： >vim
			let longlist = repeat(['a', 'b'], 3)
<		结果为 ['a', 'b', 'a', 'b', 'a', 'b']。

                参数: ~
                  • {expr} (`any`)
                  • {count} (`integer`)

                返回: ~
                  (`any`)

resolve({filename})                                             *resolve()* *E655*
		在 MS-Windows 上，当 {filename} 是快捷方式（.lnk 文件）时，
		返回快捷方式指向的路径的简化形式。
		在 Unix 上，重复解析 {filename} 的所有路径组件中的符号链接，并返回简化结果。
		为了处理链接循环，符号链接的解析在 100 次迭代后停止。
		在其他系统上，返回简化的 {filename}。
		简化步骤与 |simplify()| 相同。
		resolve() 保留指定当前目录的前导路径组件（前提是结果仍然是相对路径名），
		并保留尾随路径分隔符。

                参数: ~
                  • {filename} (`string`)

                返回: ~
                  (`string`)

reverse({object})                                                    *reverse()*
		反转 {object} 中项目的顺序。{object} 可以是 |List|、|Blob| 或 |String|。
		对于 List 和 Blob，项目会就地反转，并返回 {object}。
		对于 String，返回一个新的 String。
		如果 {object} 不是 List、Blob 或 String，则返回零。
		如果您希望 List 或 Blob 保持未修改，请先制作副本： >vim
			let revlist = reverse(copy(mylist))
<

                参数: ~
                  • {object} (`T[]`)

                返回: ~
                  (`T[]`)

round({expr})                                                          *round()*
		将 {expr} 四舍五入到最接近的整数值，并将其作为 |Float| 返回。
		如果 {expr} 恰好位于两个整数值的中间，则使用较大的一个（远离零）。
		{expr} 必须求值为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo round(0.456)
<			0.0  >vim
			echo round(4.5)
<			5.0 >vim
			echo round(-4.5)
<			-5.0

                参数: ~
                  • {expr} (`number`)

                返回: ~
                  (`number`)

rpcnotify({channel}, {event} [, {args}...])                        *rpcnotify()*
		通过 |RPC| 向 {channel} 发送 {event} 并立即返回。
		如果 {channel} 为 0，则事件将广播到所有通道。
		示例： >vim
			au VimLeave call rpcnotify(0, "leaving")
<

                参数: ~
                  • {channel} (`integer`)
                  • {event} (`string`)
                  • {...} (`any`)

                返回: ~
                  (`integer`)

rpcrequest({channel}, {method} [, {args}...])                     *rpcrequest()*
		向 {channel} 发送请求以通过 |RPC| 调用 {method}，并阻塞直到收到响应。
		示例： >vim
			let result = rpcrequest(rpc_chan, "func", 1, 2, 3)
<

                参数: ~
                  • {channel} (`integer`)
                  • {method} (`string`)
                  • {...} (`any`)

                返回: ~
                  (`any`)

rubyeval({expr})                                                    *rubyeval()*
		计算 Ruby 表达式 {expr} 并将其结果转换为 Vim 数据结构。
		数字、浮点数和字符串按原样返回（不过字符串会被复制）。
		数组表示为 Vim |List| 类型。
		哈希表示为 Vim |Dictionary| 类型。
		其他对象表示为其 "Object#to_s" 方法产生的字符串。

                参数: ~
                  • {expr} (`any`)

                返回: ~
                  (`any`)

screenattr({row}, {col})                                          *screenattr()*
		类似于 |screenchar()|，但返回属性。这是一个相当任意的数字，
		只能用于与其他位置的属性进行比较。
		当行或列超出范围时返回 -1。

                参数: ~
                  • {row} (`integer`)
                  • {col} (`integer`)

                返回: ~
                  (`integer`)

screenchar({row}, {col})                                          *screenchar()*
		结果是一个数字（Number），表示屏幕上 [行, 列] 位置处的字符。
		这适用于所有可能的屏幕位置，包括状态行、窗口分隔符和命令行。
		左上角位置为第一行，第一列。
		该字符不包括组合字符。对于双字节编码，它可能只是第一个字节。
		这主要用于测试。
		当行或列超出范围时返回 -1。

                参数: ~
                  • {row} (`integer`)
                  • {col} (`integer`)

                返回: ~
                  (`integer`)

screenchars({row}, {col})                                        *screenchars()*
		结果是一个数字（Number）的 |List|。第一个数字与 |screenchar()| 返回的相同。
		后续数字是基础字符之上的组合字符。
		这主要用于测试。
		当行或列超出范围时返回空列表。

                参数: ~
                  • {row} (`integer`)
                  • {col} (`integer`)

                返回: ~
                  (`integer[]`)

screencol()                                                        *screencol()*
		结果是一个数字（Number），表示光标当前的屏幕列。最左侧的列编号为 1。
		此函数主要用于测试。

		注意：始终返回当前的屏幕列，因此如果在命令中使用（例如 ":echo screencol()"），
		它将返回命令行内的列，命令执行时为 1。
		要获取文件中的光标位置，请使用以下映射之一： >vim
			nnoremap <expr> GG ":echom " .. screencol() .. "\n"
			nnoremap <silent> GG :echom screencol()<CR>
			noremap GG <Cmd>echom screencol()<CR>
<

                返回: ~
                  (`integer[]`)

screenpos({winid}, {lnum}, {col})                                  *screenpos()*
		结果是一个字典（Dict），包含窗口 {winid} 中缓冲区行 {lnum} 和列 {col} 处
		文本字符的屏幕位置。{col} 是从 1 开始的字节索引。
		该字典包含以下成员：
			row	屏幕行
			col	第一个屏幕列
			endcol	最后一个屏幕列
			curscol	光标屏幕列
		如果指定位置不可见，所有值均为零。
		当字符占用多个屏幕单元格时，"endcol" 值不同于 "col"。例如，对于制表符，
		"col" 可能为 1，"endcol" 可能为 8。
		"curscol" 值是光标将放置的位置。对于制表符，它与 "endcol" 相同，
		而对于双宽度字符，它与 "col" 相同。
		此处忽略 |conceal| 特性，列号如同 'conceallevel' 为零。
		您可以将光标设置到正确位置并使用 |screencol()| 来获取考虑 |conceal| 的值。
		如果位置在闭合的折叠中，则返回第一个字符的屏幕位置，不使用 {col}。
		如果 {winid} 无效，返回空字典。

                参数: ~
                  • {winid} (`integer`)
                  • {lnum} (`integer`)
                  • {col} (`integer`)

                返回: ~
                  (`any`)

screenrow()                                                        *screenrow()*
		结果是一个数字（Number），表示光标当前的屏幕行。顶行编号为 1。
		此函数主要用于测试。
		或者，您可以使用 |winline()|。

		注意：与 |screencol()| 相同的限制。

                返回: ~
                  (`integer`)

screenstring({row}, {col})                                      *screenstring()*
		结果是一个字符串（String），包含屏幕上 [行, 列] 位置的基础字符和任何组合字符。
		这类似于 |screenchars()|，但返回一个包含字符的字符串。
		这主要用于测试。
		当行或列超出范围时返回空字符串。

                参数: ~
                  • {row} (`integer`)
                  • {col} (`integer`)

                返回: ~
                  (`string`)

search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]]) *search()*
		搜索正则表达式模式 {pattern}。搜索从光标位置开始（您可以使用 |cursor()| 设置它）。

		当找到匹配时，返回其行号。
		如果没有匹配，则返回 0，并且光标不移动。不给出错误消息。
		要获取匹配的字符串，请使用 |matchbufline()|。

		{flags} 是一个字符串，可以包含以下字符标志：
		'b'	向后搜索而不是向前
		'c'	接受光标位置的匹配
		'e'	移动到匹配的末尾
		'n'	不移动光标
		'p'	返回匹配子模式的数量（见下文）
		's'	在光标先前位置设置 ' 标记
		'w'	在文件末尾环绕
		'W'	不在文件末尾环绕
		'z'	从光标列开始搜索而不是从零列开始
		如果既未给出 'w' 也未给出 'W'，则应用 'wrapscan' 选项。

		如果提供了 's' 标志，则设置 ' 标记，仅当光标移动时。's' 标志不能与 'n' 标志结合使用。

		使用 'ignorecase'、'smartcase' 和 'magic'。

		当未给出 'z' 标志时，向前搜索总是从第零列开始，然后跳过光标前的匹配。
		当 'c' 标志存在于 'cpo' 中时，下一次搜索在匹配之后开始。
		没有 'c' 标志时，下一次搜索在匹配开始之后的一列开始。
		这对于重叠匹配很重要。参见 |cpo-c|。您也可以插入 "\ze" 来更改匹配结束的位置，参见 |/\ze|。

		当向后搜索且给出 'z' 标志时，搜索从第零列开始，因此不会在当前行找到匹配
		（除非环绕文件末尾）。

		当给出 {stopline} 参数时，搜索在搜索完该行后停止。
		这对于将搜索限制在行范围内很有用。示例： >vim
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		当使用 {stopline} 且其不为零时，这也意味着搜索不会环绕文件末尾。
		零值等同于未给出参数。

		当给出 {timeout} 参数时，搜索在超过这么多毫秒后停止。
		因此当 {timeout} 为 500 时，搜索在半秒后停止。
		该值不能为负数。零值等同于未给出参数。

		注意：超时仅在搜索时考虑，而不是在计算 {skip} 表达式时。

		如果给出 {skip} 表达式，它会在光标位于匹配开始时求值。
		如果求值为非零，则跳过此匹配。这可用于，例如，跳过注释或字符串中的匹配。
		{skip} 可以是一个字符串，它被作为表达式求值，一个函数引用或一个 lambda。
		当 {skip} 被省略或为空时，接受每个匹配。
		当求值 {skip} 导致错误时，搜索中止并返回 -1。
							*search()-sub-match*
		使用 'p' 标志时，返回值比 \(\). 中的第一个子匹配多一。
		如果它们都没有匹配但整个模式匹配了，则为一。
		要同时获取列号，请使用 |searchpos()|。

		光标将定位在匹配处，除非使用 'n' 标志。

		示例（遍历参数列表中的所有文件）： >vim
		    let n = 1
		    while n <= argc()	    " 遍历 arglist 中的所有文件
		      exe "argument " .. n
		      " 从文件的最后一个字符开始，并为第一次搜索环绕以找到文件开头的匹配
		      normal G$
		      let flags = "w"
		      while search("foo", flags) > 0
		        s/foo/bar/g
		        let flags = "W"
		      endwhile
		      update		    " 如果修改了则写入文件
		      let n = n + 1
		    endwhile
<
		使用某些标志的示例： >vim
		    echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
<		这将搜索光标下或之后的关键字 "if"、"else" 和 "endif"。
		由于 'p' 标志，它返回 1、2 或 3，取决于找到哪个关键字，如果搜索失败则返回 0。
		光标在行的第一个单词上：
		    if (foo == 0) | let foo = foo + 1 | endif ~
		函数返回 1。没有 'c' 标志，函数找到 "endif" 并返回 3。
		如果没有 'e' 标志且光标在 "if" 的 "f" 上，也会发生同样的情况。
		'n' 标志告诉函数不要移动光标。

                参数: ~
                  • {pattern} (`string`)
                  • {flags} (`string?`)
                  • {stopline} (`integer?`)
                  • {timeout} (`integer?`)
                  • {skip} (`string|function?`)

                返回: ~
                  (`integer`)

searchcount([{options}])                                         *searchcount()*
		获取或更新最后一次搜索计数，类似于 'shortmess' 中没有 "S" 标志时显示的内容。
		即使 'shortmess' 包含 "S" 标志，这也有效。

		返回一个 |Dictionary|。如果先前的模式未设置且未指定 "pattern"，则字典为空。

		  键		类型		含义 ~
		  current	|Number|	匹配的当前位置；
						如果光标位置在第一个匹配之前，则为 0
		  exact_match	|Boolean|	如果 "current" 在 "pos" 上匹配，则为 1，否则为 0
		  total		|Number|	找到的匹配总数
		  incomplete	|Number|	0: 搜索完全完成
						1: 重新计算超时
						2: 超过最大计数

		对于 {options}，请参见下文。

		要在按下 |n| 或 |N| 时获取最后一次搜索计数，使用 `recompute: 0` 调用此函数。
		由于 'maxsearchcount'，这有时会返回错误信息。
		如果计数超过 'maxsearchcount'，结果必须是 'maxsearchcount' + 1。
		如果您想获取正确信息，请指定 `recompute: 1`： >vim

			" 当有许多匹配时，result == 'maxsearchcount' + 1
			let result = searchcount(#{recompute: 0})

			" 下面返回正确结果（recompute 默认为 1）
			let result = searchcount()
<
		该函数对于将计数添加到 'statusline' 很有用： >vim
			function! LastSearchCount() abort
			  let result = searchcount(#{recompute: 0})
			  if empty(result)
			    return ''
			  endif
			  if result.incomplete ==# 1     " 超时
			    return printf(' /%s [?/??]', @/)
			  elseif result.incomplete ==# 2 " 超过最大计数
			    if result.total > result.maxcount &&
			    \  result.current > result.maxcount
			      return printf(' /%s [>%d/>%d]', @/,
			      \             result.current, result.total)
			    elseif result.total > result.maxcount
			      return printf(' /%s [%d/>%d]', @/,
			      \             result.current, result.total)
			    endif
			  endif
			  return printf(' /%s [%d/%d]', @/,
			  \             result.current, result.total)
			endfunction
			let &statusline ..= '%{LastSearchCount()}'

			" 或者如果您只想在 'hlsearch' 开启时显示计数
			" let &statusline ..=
			" \   '%{v:hlsearch ? LastSearchCount() : ""}'
<
		您也可以更新搜索计数，这在 |CursorMoved| 或 |CursorMovedI| 自动命令中很有用： >vim

			autocmd CursorMoved,CursorMovedI *
			  \ let s:searchcount_timer = timer_start(
			  \   200, function('s:update_searchcount'))
			function! s:update_searchcount(timer) abort
			  if a:timer ==# s:searchcount_timer
			    call searchcount(#{
			    \ recompute: 1, maxcount: 0, timeout: 100})
			    redrawstatus
			  endif
			endfunction
<
		这也可用于使用 "pattern" 统计当前缓冲区中指定模式的匹配文本： >vim

			" 统计此缓冲区中的 '\<foo\>'
			"（注意它也会更新搜索计数）
			let result = searchcount(#{pattern: '\<foo\>'})

			" 要通过旧模式恢复旧搜索计数，再次搜索
			call searchcount()
<
		{options} 必须是一个 |Dictionary|。它可以包含：
		  键		类型		含义 ~
		  recompute	|Boolean|	如果为 |TRUE|，则重新计算计数，如同执行了 |n| 或 |N|。
						否则返回最后计算的结果（当 |n| 或 |N| 被使用且 'shortmess' 中无 "S" 时，
						或调用此函数时）。
						（默认：|TRUE|）
		  pattern	|String|	如果给出且与 |@/| 不同，则重新计算。
						这等同于在执行以下命令后调用此函数 >vim
						  let @/ = pattern
<						（默认：|@/|）
		  timeout	|Number|	0 或负数为无超时。重新计算结果的超时毫秒数。
						（默认：0）
		  maxcount	|Number|	0 或负数为无限制。重新计算结果时的最大匹配文本计数。
						如果搜索超过总计数，"total" 值变为 `maxcount + 1`
						（默认：'maxsearchcount'）
		  pos		|List|		`[lnum, col, off]` 值，当重新计算结果时。
						这会改变 "current" 结果值。参见 |cursor()|, |getpos()|
						（默认：光标的位置）

                参数: ~
                  • {options} (`table?`)

                返回: ~
                  (`any`)

searchdecl({name} [, {global} [, {thisblock}]])                   *searchdecl()*
		搜索 {name} 的声明。

		使用非零 {global} 参数时，它像 |gD| 一样工作，在文件中查找第一个匹配项。
		否则，它像 |gd| 一样工作，在函数中查找第一个匹配项。

		使用非零 {thisblock} 参数时，忽略在光标位置之前结束的 {} 块中的匹配。
		避免找到仅在另一个作用域中有效的变量声明。

		将光标移动到找到的匹配处。
		成功返回零，失败返回非零。
		示例： >vim
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<

                参数: ~
                  • {name} (`string`)
                  • {global} (`boolean?`)
                  • {thisblock} (`boolean?`)

                返回: ~
                  (`any`)

*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline} [, {timeout}]]]])
		搜索嵌套的起始-结束对的匹配项。这可以用来查找匹配 "if" 的 "endif"，同时忽略中间的其他 if/endif 对。
		搜索从光标处开始。默认是向前搜索，在 {flags} 中包含 'b' 可以向后搜索。
		如果找到匹配项，光标将定位到该处并返回行号。如果未找到匹配项，则返回 0 或 -1 且光标不移动。不给出错误消息。

		{start}, {middle} 和 {end} 是模式，参见 |pattern|。它们不能包含 \( \) 对。允许使用 \%( \)。当
		{middle} 不为空时，从任一方向搜索都能找到它，但前提是不在嵌套的起始-结束对内。典型的用法是: >vim
			echo searchpair('\<if\>', '\<else\>', '\<endif\>')
<		通过将 {middle} 留空，可以跳过 "else"。

		{flags} 中的 'b', 'c', 'n', 's', 'w' 和 'W' 与 |search()| 中的用法类似。此外:
		'r'	重复直到找不到更多匹配项；将找到最外层的对。隐含 'W' 标志。
		'm'	返回匹配次数而不是匹配处的行号；当使用 'r' 时，返回值将 > 1。
		注意：使用 'W' 标志几乎总是一个好主意，以避免绕回文件末尾。

		当找到 {start}, {middle} 或 {end} 的匹配项时，会在光标定位到匹配项开头的情况下计算 {skip} 表达式。
		如果此匹配项应被跳过，它应返回非零值。例如，因为它位于注释或字符串内部。
		当 {skip} 被省略或为空时，接受每个匹配项。
		当计算 {skip} 导致错误时，搜索中止并返回 -1。
		{skip} 可以是字符串、lambda、函数引用或 partial。任何其他类型都会导致函数失败。

		关于 {stopline} 和 {timeout}，参见 |search()|。

		使用 'ignorecase' 的值。'magic' 被忽略，模式如同它开启时一样使用。

		搜索从光标处精确开始。在搜索方向上，下一个字符处的 {start}, {middle} 或 {end} 匹配项是找到的第一个匹配项。
		示例: >vim
			if 1
			  if 2
			  endif 2
			endif 1
<		当从 "if 2" 开始（光标在 "i" 上）并向前搜索时，会找到 "endif 2"。当从紧挨着 "if 2" 之前的字符开始时，将找到 "endif 1"。
		这是因为会先找到 "if 2"，然后这被视为从 "if 2" 到 "endif 2" 的嵌套 if/endif。
		当向后搜索且 {end} 多于一个字符时，在模式末尾放置 "\zs" 可能有用，这样当光标位于结束匹配项内部时，它能找到匹配的起始项。

		示例，在 Vim 脚本中查找 "endif" 命令: >vim

			echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		光标必须位于或晚于要查找匹配项的 "if"。注意，使用单引号字符串以避免双写反斜杠。
		skip 表达式仅捕获行首的注释，而非命令后的注释。此外，行中间的单词 "en" 或 "if" 也被视为匹配项。
		另一个示例，搜索匹配 "}" 的 "{": >vim

			echo searchpair('{', '', '}', 'bW')

<		这适用于光标位于或早于要查找匹配项的 "}" 的情况。要拒绝语法高亮识别为字符串的匹配项: >vim

			echo searchpair('{', '', '}', 'bW',
			     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<

                参数: ~
                  • {start} (`字符串`)
                  • {middle} (`字符串`)
                  • {end} (`字符串`)
                  • {flags} (`字符串?`)
                  • {skip} (`字符串|函数?`)
                  • {stopline} (`整数?`)
                  • {timeout} (`整数?`)

                返回: ~
                  (`整数`)

                                                               *searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline} [, {timeout}]]]])
		与 |searchpair()| 相同，但返回一个包含匹配行和列位置的 |List|。|List| 的第一个元素是行号，第二个元素是匹配项列位置的字节索引。
		如果未找到匹配项，返回 [0, 0]。 >vim

			let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		参见 |match-parens| 获取一个更大且更有用的示例。

                参数: ~
                  • {start} (`字符串`)
                  • {middle} (`字符串`)
                  • {end} (`字符串`)
                  • {flags} (`字符串?`)
                  • {skip} (`字符串|函数?`)
                  • {stopline} (`整数?`)
                  • {timeout} (`整数?`)

                返回: ~
                  (`[整数, 整数]`)

                                                                   *searchpos()*
searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		与 |search()| 相同，但返回一个包含匹配行和列位置的 |List|。|List| 的第一个元素是行号，第二个元素是匹配项列位置的字节索引。
		如果未找到匹配项，返回 [0, 0]。
		示例: >vim
			let [lnum, col] = searchpos('mypattern', 'n')

<		当给出 'p' 标志时，会有一个额外的项包含子模式匹配号 |search()-sub-match|。示例: >vim
			let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		在此示例中，当找到小写字母 |/\l| 时 "submatch" 为 2，当找到大写字母 |/\u| 时 "submatch" 为 3。

                参数: ~
                  • {pattern} (`字符串`)
                  • {flags} (`字符串?`)
                  • {stopline} (`整数?`)
                  • {timeout} (`整数?`)
                  • {skip} (`字符串|函数?`)

                返回: ~
                  (`任何类型`)

serverlist([{opts}])                                              *serverlist()*
		返回服务器地址列表，如果所有服务器都已停止则返回空列表。|serverstart()| |serverstop()|

		可选参数 {opts} 是一个 Dict，支持以下项目:

		  peer  : 如果为 |TRUE|，则也会返回非由 |serverstart()| 启动的服务器。(默认: |FALSE|)
		          在 Windows 上尚不支持。

		示例: >vim
			echo serverlist()
<

                参数: ~
                  • {opts} (`表?`)

                返回: ~
                  (`字符串[]`)

serverstart([{address}])                                         *serverstart()*
		在 {address} 处打开一个套接字或命名管道并监听 |RPC| 消息。客户端可以发送 |API| 命令到返回的地址来控制 Nvim。

		返回地址字符串（可能与 {address} 参数不同，见下文）。

		- 如果 {address} 包含冒号 (":")，则它是一个 TCP/IPv4/IPv6 地址，最后一个 ":" 分隔主机和端口（空或零表示分配随机端口）。
		- 否则 {address} 是命名管道的路径（Windows 除外）。
		  - 如果 {address} 没有斜杠 ("/")，它被视为生成路径的 "name" 部分，格式如下: >vim
			stdpath("run").."/{name}.{pid}.{counter}"
<		  - 如果 {address} 被省略，则名称为 "nvim"。 >vim
			echo serverstart()
<		 >
			=> /tmp/nvim.bram/oknANW/nvim.15430.5
<
		列出所有 Nvim 服务器的示例 bash 命令: >bash
			ls ${XDG_RUNTIME_DIR:-${TMPDIR}nvim.${USER}}/*/nvim.*.0

<		命名管道示例: >vim
			if has('win32')
			  echo serverstart('\\.\pipe\nvim-pipe-1234')
			else
			  echo serverstart('nvim.sock')
			endif
<
		TCP/IP 地址示例: >vim
			echo serverstart('::1:12345')
<

                参数: ~
                  • {address} (`字符串?`)

                返回: ~
                  (`字符串`)

serverstop({address})                                             *serverstop()*
		关闭 {address} 处的管道或套接字。
		如果 {address} 有效则返回 TRUE，否则返回 FALSE。
		如果 |v:servername| 被停止，它将被设置为 |serverlist()| 中下一个可用的地址。

                参数: ~
                  • {address} (`字符串`)

                返回: ~
                  (`整数`)

setbufline({buf}, {lnum}, {text})                                 *setbufline()*
		在缓冲区 {buf} 中将行 {lnum} 设置为 {text}。这类似于指定缓冲区的 |setline()|。

		此函数仅适用于已加载的缓冲区。如果需要，请先调用 |bufload()|。

		要插入行，请使用 |appendbufline()|。

		{text} 可以是一个字符串以设置一行，或一个字符串列表以设置多行。如果列表扩展到最后一行之后，则添加这些行。
		如果列表为空，则不进行任何更改并返回零。

		关于 {buf} 的使用，参见上面的 |bufname()|。

		{lnum} 的用法与 |setline()| 类似。
		使用 "$" 来引用缓冲区 {buf} 的最后一行。
		当 {lnum} 紧接在最后一行之后时，{text} 将被添加到最后一行的后面。
		成功返回 0，失败返回 1。

		如果 {buf} 不是有效的缓冲区或 {lnum} 无效，则给出错误消息。

                参数: ~
                  • {buf} (`整数|字符串`)
                  • {lnum} (`整数`)
                  • {text} (`字符串|字符串[]`)

                返回: ~
                  (`整数`)

setbufvar({buf}, {varname}, {val})                                 *setbufvar()*
		在缓冲区 {buf} 中设置选项或局部变量 {varname} 为 {val}。
		这也适用于全局或局部窗口选项，但不适用于全局或局部窗口变量。
		对于局部窗口选项，全局值不变。
		关于 {buf} 的使用，参见上面的 |bufname()|。
		{varname} 参数是一个字符串。
		注意，必须使用不带 "b:" 的变量名。
		示例: >vim
			call setbufvar(1, "&mod", 1)
			call setbufvar("todo", "myvar", "foobar")
<		此函数在 |sandbox| 中不可用。

                参数: ~
                  • {buf} (`整数|字符串`)
                  • {varname} (`字符串`)
                  • {val} (`任何类型`)

                返回: ~
                  (`任何类型`)

setcellwidths({list})                                          *setcellwidths()*
		指定字符范围的单元格宽度覆盖。这告诉 Vim 字符在终端中显示时的宽度（以屏幕单元格计数）。
		这些值会覆盖 'ambiwidth'。示例: >vim
		   call setcellwidths([
				\ [0x111, 0x111, 1],
				\ [0x2194, 0x2199, 2],
				\ ])

<		{list} 参数是一个包含三个数字的列表的列表: [{low}, {high}, {width}]。	*E1109* *E1110*
		{low} 和 {high} 可以相同，在这种情况下它指的是一个字符。否则它是从 {low} 到 {high}（包含）的字符范围。		*E1111* *E1114*
		只能使用值 0x80 及以上的字符。

		{width} 必须是 1 或 2，表示屏幕单元格中的字符宽度。			*E1112*
		如果参数无效，或者范围与另一个范围重叠，则会给出错误。		*E1113*

		如果新值导致 'fillchars' 或 'listchars' 变为无效，它将被拒绝并给出错误。

		要清除覆盖，传递一个空的 {list}: >vim
		   call setcellwidths([])

<		您可以使用脚本 $VIMRUNTIME/scripts/emoji_list.lua 来查看已知表情符号字符的效果。
		移动光标通过文本来检查您的终端的单元格宽度是否与 Vim 所知的每个表情符号匹配。如果看起来不对，您需要调整 {list} 参数。

                参数: ~
                  • {list} (`任何类型[]`)

                返回: ~
                  (`任何类型`)

setcharpos({expr}, {list})                                        *setcharpos()*
		与 |setpos()| 相同，但使用指定的列号作为行中的字符索引而不是字节索引。

		示例:
		在第 8 行有文本 "여보세요": >vim
			call setcharpos('.', [0, 8, 4, 0])
<		将光标定位在第四个字符 '요' 上。 >vim
			call setpos('.', [0, 8, 4, 0])
<		将光标定位在第二个字符 '보' 上。

                参数: ~
                  • {expr} (`字符串`)
                  • {list} (`整数[]`)

                返回: ~
                  (`任何类型`)

setcharsearch({dict})                                          *setcharsearch()*
		将当前字符搜索信息设置为 {dict}，它包含以下一个或多个条目:

		    char	将用于后续 |,| 或 |;| 命令的字符；空字符串清除字符搜索
		    forward	字符搜索的方向；1 表示向前，0 表示向后
		    until	字符搜索的类型；1 表示 |t| 或 |T| 字符搜索，0 表示 |f| 或 |F| 字符搜索

		这对于从脚本中保存/恢复用户的字符搜索很有用: >vim
			let prevsearch = getcharsearch()
			" 执行一个会破坏用户搜索的命令
			call setcharsearch(prevsearch)
<		另请参见 |getcharsearch()|。

                参数: ~
                  • {dict} (`字符串`)

                返回: ~
                  (`任何类型`)

setcmdline({str} [, {pos}])                                       *setcmdline()*
		将命令行设置为 {str} 并将光标位置设置为 {pos}。
		如果 {pos} 被省略，光标定位在文本之后。
		成功时返回 0，不在编辑命令行时返回 1。

                参数: ~
                  • {str} (`字符串`)
                  • {pos} (`整数?`)

                返回: ~
                  (`整数`)

setcmdpos({pos})                                                   *setcmdpos()*
		将命令行中的光标位置设置为字节位置 {pos}。第一个位置是 1。
		使用 |getcmdpos()| 获取当前位置。
		仅在编辑命令行时有效，因此您必须使用 |c_CTRL-\_e|, |c_CTRL-R_=| 或 |c_CTRL-R_CTRL-R| 配合 '='。
		对于 |c_CTRL-\_e| 和 |c_CTRL-R_CTRL-R| 配合 '='，位置是在命令行设置为表达式之后设置的。
		对于 |c_CTRL-R_=|，它是在计算表达式之后但在插入结果文本之前设置的。
		当数字太大时，光标放在行尾。小于 1 的数字会导致未定义的结果。
		成功时返回 0，不在编辑命令行时返回 1。

                参数: ~
                  • {pos} (`整数`)

                返回: ~
                  (`任何类型`)

setcursorcharpos({lnum}, {col} [, {off}])                   *setcursorcharpos()*
setcursorcharpos({list})
		与 |cursor()| 相同，但使用指定的列号作为行中的字符索引而不是字节索引。

		示例:
		在第 4 行有文本 "여보세요": >vim
			call setcursorcharpos(4, 3)
<		将光标定位在第三个字符 '세' 上。 >vim
			call cursor(4, 3)
<		将光标定位在第一个字符 '여' 上。

		当位置可以设置时返回 0，否则返回 -1。

                参数: ~
                  • {list} (`整数[]`)

                返回: ~
                  (`任何类型`)

setenv({name}, {val})                                                 *setenv()*
		将环境变量 {name} 设置为 {val}。示例: >vim
			call setenv('HOME', '/home/myhome')

<		当 {val} 是 |v:null| 时，环境变量被删除。
		另请参见 |expr-env|。

                参数: ~
                  • {name} (`字符串`)
                  • {val} (`字符串`)

                返回: ~
                  (`任何类型`)

setfperm({fname}, {mode})                                     *setfperm()* *chmod*
		将 {fname} 的文件权限设置为 {mode}。
		{mode} 必须是一个包含 9 个字符的字符串。它的形式是 "rwxrwxrwx"，其中每组 "rwx" 标志依次表示文件所有者的权限、
		文件所属组的权限以及其他用户的权限。'-' 字符表示权限关闭，任何其他字符表示开启。不支持多字节字符。

		例如 "rw-r-----" 表示用户可读写，组可读，其他人不可访问。"xx-x-----" 效果相同。

		成功返回非零，失败返回零。

		要读取权限，请参见 |getfperm()|。

                参数: ~
                  • {fname} (`字符串`)
                  • {mode} (`字符串`)

                返回: ~
                  (`任何类型`)

setline({lnum}, {text})                                              *setline()*
		将当前缓冲区的第 {lnum} 行设置为 {text}。要插入行，请使用 |append()|。要在另一个缓冲区中设置行，请使用 |setbufline()|。

		{lnum} 的用法与 |getline()| 类似。
		当 {lnum} 紧接在最后一行之后时，{text} 将被添加到最后一行的后面。
		{text} 可以是任何类型或任何类型的列表，每个项都被转换为字符串。当 {text} 是空列表时，不进行任何更改并返回 FALSE。

		如果成功，返回 FALSE。如果失败（最可能的原因是 {lnum} 无效），返回 TRUE。

		示例: >vim
			call setline(5, strftime("%c"))

<		当 {text} 是 |List| 时，第 {lnum} 行及后续行将被设置为列表中的项。示例: >vim
			call setline(5, ['aaa', 'bbb', 'ccc'])
<		这等价于: >vim
			for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			  call setline(n, l)
			endfor

<		注意：不设置 '[ 和 '] 标记。

                参数: ~
                  • {lnum} (`整数|字符串`)
                  • {text} (`任何类型`)

                返回: ~
                  (`任何类型`)

setloclist({nr}, {list} [, {action} [, {what}]])                  *setloclist()*
		为窗口 {nr} 创建、替换或添加到位置列表。
		{nr} 可以是窗口编号或 |window-ID|。
		当 {nr} 为零时，使用当前窗口。

		对于位置列表窗口，修改显示的位置列表。
		对于无效的窗口编号 {nr}，返回 -1。
		否则，与 |setqflist()| 相同。
		另请参见 |location-list|。

		关于 {action}，参见 |setqflist-action|。

		如果提供了可选的 {what} 字典参数，则只设置 {what} 中列出的项。有关 {what} 中支持的键的列表，请参考 |setqflist()|。

                参数: ~
                  • {nr} (`整数`)
                  • {list} (`任何类型`)
                  • {action} (`字符串?`)
                  • {what} (`表?`)

                返回: ~
                  (`任何类型`)

setmatches({list} [, {win}])                                      *setmatches()*
		为当前窗口恢复由 |getmatches()| 保存的匹配项列表。成功返回 0，否则返回 -1。在恢复列表之前，所有当前匹配项都被清除。
		参见 |getmatches()| 的示例。
		如果指定了 {win}，则使用此编号或窗口 ID 的窗口而不是当前窗口。

                参数: ~
                  • {list} (`vim.fn.getmatches.ret.item[]`)
                  • {win} (`整数?`)

                返回: ~
                  (`任何类型`)

setpos({expr}, {list})                                                *setpos()*
		设置字符串 {expr} 的位置。可能的值：
			.	光标
			'x	标记 x

		{list} 必须是一个包含四个或五个数字的 |List|：
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		"bufnum" 是缓冲区编号。零可用于当前缓冲区。
		设置大写标记时，"bufnum" 用于标记位置。对于其他标记，它指定要设置标记的缓冲区。
		您可以使用 |bufnr()| 函数将文件名转换为缓冲区编号。
		对于设置光标和 ' 标记，"bufnum" 被忽略，因为这些与窗口关联，而不是缓冲区。
		不改变跳转列表。

		"lnum" 和 "col" 是缓冲区中的位置。第一列是 1。使用零 "lnum" 来删除标记。
		如果 "col" 小于 1，则使用 1。要使用字符计数而不是字节计数，请使用 |setcharpos()|。

		仅当设置了 'virtualedit' 时才使用 "off" 数字。然后它是从字符开始的屏幕列偏移量。
		例如，<Tab> 内的位置或最后一个字符之后的位置。

		仅当设置光标位置时才使用 "curswant" 数字。它设置当垂直移动光标时的首选列。
		当缺少 "curswant" 数字时，不设置首选列。当它存在且设置标记位置时，不使用它。

		注意，对于 '< 和 '>，更改行号可能导致标记被有效地交换，使得 '< 总是在 '> 之前。

		当位置可以设置时返回 0，否则返回 -1。
		如果 {expr} 无效，则给出错误消息。

		另请参见 |setcharpos()|, |getpos()| 和 |getcurpos()|。

		这不恢复用于垂直移动的首选列；如果您用此设置光标位置，|j| 和 |k| 移动将跳转到之前的列！
		使用 |cursor()| 来同时设置首选列。另请参见 |winrestview()| 中的 "curswant" 键。

                参数: ~
                  • {expr} (`字符串`)
                  • {list} (`整数[]`)

                返回: ~
                  (`任何类型`)

setqflist({list} [, {action} [, {what}]])                          *setqflist()*
		创建或替换或添加到 quickfix 列表。

		如果提供了可选的 {what} 字典参数，则只设置 {what} 中列出的项。忽略第一个 {list} 参数。
		有关 {what} 中支持的项的列表，请参见下文。
							*setqflist-what*
		当 {what} 不存在时，使用 {list} 中的项。每个项必须是一个字典。{list} 中的非字典项被忽略。
		每个字典项可以包含以下条目：

		    bufnr	缓冲区编号；必须是有效缓冲区的编号
		    filename	文件名；仅当 "bufnr" 不存在或无效时使用
		    module	模块名；如果给出，它将在 quickfix 错误窗口中代替文件名使用
		    lnum	文件中的行号
		    end_lnum	行结束处，如果项跨越多行
		    pattern	用于定位错误的搜索模式
		    col		列号
		    vcol	当非零时："col" 是可视列
				当零时："col" 是字节索引
		    end_col	结束列，如果项跨越多列
		    nr		错误编号
		    text	错误描述
		    type	单字符错误类型，'E', 'W' 等
		    valid	已识别的错误消息
		    user_data
				与项关联的自定义数据，可以是任何类型

		"col", "vcol", "nr", "type" 和 "text" 条目是可选的。
		可以使用 "lnum" 或 "pattern" 条目来定位匹配的错误行。
		如果 "filename" 和 "bufnr" 条目不存在，或者 "lnum" 和 "pattern" 条目都不存在，则该项不会被当作错误行处理。
		如果 "pattern" 和 "lnum" 都存在，则将使用 "pattern"。
		如果未提供 "valid" 条目，则当 "bufnr" 是有效缓冲区或 "filename" 存在时设置有效标志。
		如果您提供一个空的 {list}，quickfix 列表将被清除。
		注意，该列表与 |getqflist()| 返回的并不完全相同。

		{action} 值：		*setqflist-action* *E927*
		'a'	将 {list} 中的项添加到现有的 quickfix 列表。如果没有现有列表，则创建一个新列表。

		'r'	用 {list} 中的项替换当前 quickfix 列表中的项。这也可用于清除列表： >vim
				call setqflist([], 'r')
<
		'u'	类似于 'r'，但尝试保留 quickfix 列表中的当前选择。
		'f'	释放 quickfix 堆栈中的所有 quickfix 列表。

		如果 {action} 不存在或设置为 ' '，则创建一个新列表。
		新的 quickfix 列表被添加到堆栈中当前 quickfix 列表之后，并且所有后续列表都被释放。
		要在堆栈末尾添加一个新的 quickfix 列表，请在 {what} 中将 "nr" 设置为 "$"。

		可以在字典 {what} 中指定以下项：
		    context	quickfix 列表上下文。参见 |quickfix-context|
		    efm		当解析 "lines" 中的文本时使用的 errorformat。如果此项不存在，则使用 'errorformat' 选项值。
				参见 |quickfix-parse|
		    id		quickfix 列表标识符 |quickfix-ID|
		    idx		由 "id" 或 "nr" 指定的 quickfix 列表中当前项的索引。如果设置为 '$'，
				则将列表中的最后一项设置为当前项。参见 |quickfix-index|
		    items	quickfix 条目列表。与 {list} 参数相同。
		    lines	使用 'errorformat' 解析行列表并将生成的条目添加到 quickfix 列表 {nr} 或 {id}。
				仅支持 |List| 值。参见 |quickfix-parse|
		    nr		在 quickfix 堆栈中的列表编号；零表示当前 quickfix 列表，"$" 表示最后一个 quickfix 列表。
		    quickfixtextfunc
				用于获取要在 quickfix 窗口中显示的文本的函数。
				值可以是函数名、函数引用或 lambda。
				有关如何编写函数的说明和示例，请参考 |quickfix-window-function|。
		    title	quickfix 列表标题文本。参见 |quickfix-title|
		{what} 中不支持的键被忽略。
		如果不存在 "nr" 项，则修改当前 quickfix 列表。
		创建新的 quickfix 列表时，"nr" 可以设置为比 quickfix 堆栈大小大一的值。
		修改 quickfix 列表时，为保证修改正确的列表，应使用 "id" 而不是 "nr" 来指定列表。

		示例（另请参见 |setqflist-examples|）： >vim
		   call setqflist([], 'r', {'title': 'My search'})
		   call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
		   call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})
<
		成功返回零，失败返回 -1。

		此函数可用于创建独立于 'errorformat' 设置的 quickfix 列表。
		使用像 `:cc 1` 这样的命令跳转到第一个位置。

                参数: ~
                  • {list} (`vim.quickfix.entry[]`)
                  • {action} (`字符串?`)
                  • {what} (`vim.fn.setqflist.what?`)

                返回: ~
                  (`整数`)

setreg({regname}, {value} [, {options}])                              *setreg()*
		将寄存器 {regname} 设置为 {value}。
		如果 {regname} 是 "" 或 "@"，则使用未命名寄存器 '"'。
		{regname} 参数是一个字符串。

		{value} 可以是 |getreg()| 或 |getreginfo()| 返回的任何值，包括 |List| 或 |Dict|。
		如果 {options} 包含 "a" 或 {regname} 是大写字母，则附加值。

		{options} 也可以包含寄存器类型说明：
		    "c" 或 "v"	      |charwise| 模式
		    "l" 或 "V"	      |linewise| 模式
		    "b" 或 "<CTRL-V>" |blockwise-visual| 模式
		如果数字紧跟在 "b" 或 "<CTRL-V>" 之后，则这用作选择的宽度 - 如果未指定，
		则块的宽度设置为最长行中的字符数（将 <Tab> 计为 1 个字符）。
		如果 {options} 包含 "u" 或 '"'，则将未命名寄存器设置为指向寄存器 {regname}。

		如果 {options} 不包含寄存器设置，则默认使用字符模式，除非字符串 {value} 以 <NL> 结尾，
		列表 {value} 使用行模式。从不自动选择块模式。
		成功返回零，失败返回非零。

							*E883*
		注意：您不能使用包含多个项的 |List| 来设置搜索和表达式寄存器。
		      不包含任何项的列表的行为类似于空字符串。

		示例： >vim
			call setreg(v:register, @*)
			call setreg('*', @%, 'ac')
			call setreg('a', "1\n2\n3", 'b5')
			call setreg('"', { 'points_to': 'a'})

<		此示例显示使用函数保存和恢复寄存器： >vim
			let var_a = getreginfo()
			call setreg('a', var_a)
<		或： >vim
			let var_a = getreg('a', 1, 1)
			let var_amode = getregtype('a')
			" ....
			call setreg('a', var_a, var_amode)
<		注意：如果不使用 |getreg()| 的第三个参数，您可能无法可靠地恢复寄存器值，
		因为如果没有它，换行符表示为换行符 AND Nul 字节也表示为换行符，参见 |NL-used-for-Nul|。

		您也可以通过附加空内容来更改寄存器的类型： >vim
			call setreg('a', '', 'al')
<

                参数: ~
                  • {regname} (`字符串`)
                  • {value} (`任何类型`)
                  • {options} (`字符串?`)

                返回: ~
                  (`任何类型`)

settabvar({tabnr}, {varname}, {val})                               *settabvar()*
		在标签页 {tabnr} 中将标签页局部变量 {varname} 设置为 {val}。
		|t:var|
		{varname} 参数是一个字符串。
		注意，必须使用不带 "t:" 的变量名。
		标签页从 1 开始编号。
		此函数在 |sandbox| 中不可用。

                参数: ~
                  • {tabnr} (`整数`)
                  • {varname} (`字符串`)
                  • {val} (`任何类型`)

                返回: ~
                  (`任何类型`)

settabwinvar({tabnr}, {winnr}, {varname}, {val})                *settabwinvar()*
		在窗口 {winnr} 中将选项或局部变量 {varname} 设置为 {val}。
		标签页从 1 开始编号。对于当前标签页，使用 |setwinvar()|。
		{winnr} 可以是窗口编号或 |window-ID|。
		当 {winnr} 为零时，使用当前窗口。
		这也适用于全局或局部缓冲区选项，但不适用于全局或局部缓冲区变量。
		对于局部缓冲区选项，全局值不变。
		注意，必须使用不带 "w:" 的变量名。
		示例： >vim
			call settabwinvar(1, 1, "&list", 0)
			call settabwinvar(3, 2, "myvar", "foobar")
<		此函数在 |sandbox| 中不可用。

                参数: ~
                  • {tabnr} (`整数`)
                  • {winnr} (`整数`)
                  • {varname} (`字符串`)
                  • {val} (`任何类型`)

                返回: ~
                  (`任何类型`)

settagstack({nr}, {dict} [, {action}])                           *settagstack()*
		使用 {dict} 修改窗口 {nr} 的标签堆栈。
		{nr} 可以是窗口编号或 |window-ID|。

		有关 {dict} 中支持的项的列表，请参考 |gettagstack()|。"curidx" 在更改标签堆栈之前生效。
							*E962*
		标签堆栈的修改方式取决于 {action} 参数：
		- 如果 {action} 不存在或设置为 'r'，则替换标签堆栈。
		- 如果 {action} 设置为 'a'，则将 {dict} 中的新条目推入（添加）到标签堆栈。
		- 如果 {action} 设置为 't'，则从标签堆栈中的当前条目或 {dict} 中的 "curidx" 开始删除所有条目，然后将新条目推送到堆栈。

		当前索引设置为修改后标签堆栈长度加一。

		成功返回零，失败返回 -1。

		示例（更多示例请参见 |tagstack-examples|）：
		    清空窗口 3 的标签堆栈： >vim
			call settagstack(3, {'items' : []})

<		    保存和恢复标签堆栈： >vim
			let stack = gettagstack(1003)
			" 做其他事情
			call settagstack(1003, stack)
			unlet stack
<

                参数: ~
                  • {nr} (`整数`)
                  • {dict} (`任何类型`)
                  • {action} (`字符串?`)

                返回: ~
                  (`任何类型`)

setwinvar({nr}, {varname}, {val})                                  *setwinvar()*
		类似于当前标签页的 |settabwinvar()|。
		示例： >vim
			call setwinvar(1, "&list", 0)
			call setwinvar(2, "myvar", "foobar")
<

                参数: ~
                  • {nr} (`整数`)
                  • {varname} (`字符串`)
                  • {val} (`任何类型`)

                返回: ~
                  (`任何类型`)

sha256({string})                                                      *sha256()*
		返回一个包含 64 个十六进制字符的字符串，它是 {string} 的 SHA256 校验和。

                参数: ~
                  • {string} (`字符串`)

                返回: ~
                  (`字符串`)

shellescape({string} [, {special}])                              *shellescape()*
		转义 {string} 以用作 shell 命令参数。

		在 Windows 上，当未设置 'shellslash' 时，将 {string} 用双引号括起来，并将 {string} 内的所有双引号加倍。
		否则，将 {string} 用单引号括起来，并将所有 "'" 替换为 "'\''"。

		{special} 参数添加了对 Vim 命令中使用的关键字的额外转义。如果它是 |non-zero-arg|：
		- 特殊项如 "!", "%", "#" 和 "<cword>"（如 |expand()| 中所列）将以反斜杠开头。
		  反斜杠将被 |:!| 命令再次移除。
		- <NL> 字符被转义。

		如果 'shell' 尾部包含 "csh"：
		- "!" 字符将被转义。这是因为 csh 和 tcsh 即使在单引号中也使用 "!" 进行历史替换。
		- <NL> 字符被转义（如果 {special} 是 |non-zero-arg|，则转义两次）。

		如果 'shell' 尾部包含 "fish"，"\" 字符将被转义，因为在 fish 中它在单引号内用作转义字符。

		与 |:!| 命令一起使用的示例： >vim
		    exe '!dir ' .. shellescape(expand('<cfile>'), 1)
<		这导致对光标下的文件进行目录列表。与 |system()| 一起使用的示例： >vim
		    call system("chmod +w -- " .. shellescape(expand("%")))
<		另请参见 |::S|。

                参数: ~
                  • {string} (`字符串`)
                  • {special} (`布尔值?`)

                返回: ~
                  (`字符串`)

shiftwidth([{col}])                                               *shiftwidth()*
		返回 'shiftwidth' 的有效值。这是 'shiftwidth' 值，除非它是零，在这种情况下它是 'tabstop' 值。
		为了在缩进插件中向后兼容，使用这个： >vim
			if exists('*shiftwidth')
			  func s:sw()
			    return shiftwidth()
			  endfunc
			else
			  func s:sw()
			    return &sw
			  endfunc
			endif
<		然后使用 s:sw() 代替 &sw。

		当有一个参数 {col} 时，这用作要返回 'shiftwidth' 值的列号。这对于 'vartabstop' 功能很重要。
		如果没有给出 {col} 参数，则假定为第 1 列。

                参数: ~
                  • {col} (`整数?`)

                返回: ~
                  (`整数`)

sign_define({name} [, {dict}])                                   *sign_define()*
sign_define({list})
		定义名为 {name} 的新标志或修改现有标志的属性。这类似于 |:sign-define| 命令。

		在 {name} 前加上唯一文本以避免名称冲突。没有像放置标志那样的 {group}。

		{name} 可以是字符串或数字。可选的 {dict} 参数指定标志属性。支持以下值：
		   icon		标志的位图文件的完整路径。
		   linehl	用于标志所在整行的突出显示组。
		   priority	标志的默认优先级值
		   numhl	用于标志所在行号的突出显示组。
		   text		当没有图标或未使用 GUI 时显示的文本。
		   texthl	用于文本项的突出显示组
		   culhl	当光标与标志在同一行且启用 'cursorline' 时用于文本项的突出显示组。

		如果名为 {name} 的标志已存在，则更新该标志的属性。

		单参数 {list} 可用于定义标志列表。每个列表项是一个字典，包含 {dict} 中的上述项和一个用于标志名的 "name" 项。

		成功返回 0，失败返回 -1。当使用单参数 {list} 时，返回一个值列表，每个定义的标志一个值。

		示例： >vim
			call sign_define("mySign", {
				\ "text" : "=>",
				\ "texthl" : "Error",
				\ "linehl" : "Search"})
			call sign_define([
				\ {'name' : 'sign1',
				\  'text' : '=>'},
				\ {'name' : 'sign2',
				\  'text' : '!!'}
				\ ])
<

                参数: ~
                  • {list} (`vim.fn.sign_define.dict[]`)

                返回: ~
                  (`(0|-1)[]`)

sign_getdefined([{name}])                                    *sign_getdefined()*
		获取已定义标志及其属性的列表。
		这类似于 |:sign-list| 命令。

		如果未提供 {name}，则返回所有已定义标志的列表。否则返回指定标志的属性。

		返回值中的每个列表项是一个包含以下条目的字典：
		   icon		标志的位图文件的完整路径
		   linehl	用于标志所在整行的突出显示组；如果未设置则不出现。
		   name		标志的名称
		   priority	标志的默认优先级值
		   numhl	用于标志所在行号的突出显示组；如果未设置则不出现。
		   text		当没有图标或未使用 GUI 时显示的文本。
		   texthl	用于文本项的突出显示组；如果未设置则不出现。
		   culhl	当光标与标志在同一行且启用 'cursorline' 时用于文本项的突出显示组；如果未设置则不出现。

		如果没有标志则返回空列表，当 {name} 未找到时也返回空列表。

		示例： >vim
			" 获取所有已定义标志的列表
			echo sign_getdefined()

			" 获取名为 mySign 的标志的属性
			echo sign_getdefined("mySign")
<

                参数: ~
                  • {name} (`字符串?`)

                返回: ~
                  (`vim.fn.sign_getdefined.ret.item[]`)

sign_getplaced([{buf} [, {dict}]])                            *sign_getplaced()*
		返回放置在缓冲区或所有缓冲区中的标志列表。
		这类似于 |:sign-place-list| 命令。

		如果指定了可选的缓冲区名称 {buf}，则仅返回放置在该缓冲区中的标志列表。
		关于 {buf} 的使用，参见 |bufname()|。可选的 {dict} 可以包含以下条目：
		   group	仅选择此组中的标志
		   id		选择具有此标识符的标志
		   lnum		select signs placed in this line. For the use
				选择放置在此行中的标志。关于 {lnum} 的使用，参见 |line()|。
		如果 {group} 是 "*"，则返回包括全局组在内的所有组中的标志。
		如果未提供 {group} 或为空字符串，则仅返回全局组中的标志。
		如果未提供任何参数，则返回所有缓冲区中全局组放置的标志。
		参见 |sign-group|。

		返回值中的每个列表项是一个包含以下条目的字典：
			bufnr	带有标志的缓冲区编号
			signs	放置在 {bufnr} 中的标志列表。每个列表项是一个包含下面列出条目的字典

		每个标志的字典包含以下条目：
			group	 标志组。对于全局组设置为 ''。
			id	 标志的标识符
			lnum	 放置标志的行号
			name	 已定义标志的名称
			priority 标志优先级

		缓冲区中返回的标志按其行号和优先级排序。

		失败或没有放置的标志时返回空列表。

		示例： >vim
			" 获取放置在 eval.c 中全局组的标志列表
			echo sign_getplaced("eval.c")

			" 获取组 'g1' 中放置在 eval.c 的标志列表
			echo sign_getplaced("eval.c", {'group' : 'g1'})

			" 获取放置在 eval.c 第 10 行的标志列表
			echo sign_getplaced("eval.c", {'lnum' : 10})

			" 获取放置在 a.py 中标识符为 10 的标志
			echo sign_getplaced("a.py", {'id' : 10})

			" 获取组 'g1' 中放置在 a.py 中 id 为 20 的标志
			echo sign_getplaced("a.py", {'group' : 'g1',
							\  'id' : 20})

			" 获取所有已放置标志的列表
			echo sign_getplaced()
<

                参数: ~
                  • {buf} (`整数|字符串?`)
                  • {dict} (`vim.fn.sign_getplaced.dict?`)

                返回: ~
                  (`vim.fn.sign_getplaced.ret.item[]`)

sign_jump({id}, {group}, {buf})                                    *sign_jump()*
		打开缓冲区 {buf} 或跳转到包含 {buf} 的窗口，并将光标定位在组 {group} 中的标志 {id} 处。
		这类似于 |:sign-jump| 命令。

		如果 {group} 是空字符串，则使用全局组。
		关于 {buf} 的使用，参见 |bufname()|。

		返回标志所在的行号。如果参数无效，返回 -1。

		示例： >vim
			" 跳转到当前缓冲区中的标志 10
			call sign_jump(10, '', '')
<

                参数: ~
                  • {id} (`整数`)
                  • {group} (`字符串`)
                  • {buf} (`整数|字符串`)

                返回: ~
                  (`整数`)

sign_place({id}, {group}, {name}, {buf} [, {dict}])               *sign_place()*
		将定义为 {name} 的标志放置在文件或缓冲区 {buf} 的第 {lnum} 行，并为标志分配 {id} 和 {group}。
		这类似于 |:sign-place| 命令。

		如果标志标识符 {id} 为零，则分配一个新的标识符。否则使用指定的数字。
		{group} 是标志组名。要使用全局标志组，请使用空字符串。
		{group} 作为 {id} 的命名空间，因此两个组可以使用相同的 ID。
		有关更多信息，请参考 |sign-identifier| 和 |sign-group|。

		{name} 引用已定义的标志。
		{buf} 引用缓冲区名称或编号。关于接受的值，参见 |bufname()|。

		可选的 {dict} 参数支持以下条目：
			lnum		文件或缓冲区 {buf} 中要放置标志的行号。
					关于接受的值，参见 |line()|。
			priority	标志的优先级。有关更多信息，参见 |sign-priority|。

		如果未指定可选的 {dict}，则修改组 {group} 中已放置的标志 {id} 以使用定义的标志 {name}。

		成功返回标志标识符，失败返回 -1。

		示例： >vim
			" 将名为 sign1、id 为 5 的标志放置在缓冲区 json.c 的第 20 行
			call sign_place(5, '', 'sign1', 'json.c',
							\ {'lnum' : 20})

			" 将缓冲区 json.c 中的标志 5 更新为使用 sign2
			call sign_place(5, '', 'sign2', 'json.c')

			" 将名为 sign3 的标志以新标识符放置在缓冲区 json.c 的第 30 行
			let id = sign_place(0, '', 'sign3', 'json.c',
							\ {'lnum' : 30})

			" 将名为 sign4、id 为 10、优先级为 90 的标志放置在组 'g3' 中缓冲区 json.c 的第 40 行
			call sign_place(10, 'g3', 'sign4', 'json.c',
					\ {'lnum' : 40, 'priority' : 90})
<

                参数: ~
                  • {id} (`整数`)
                  • {group} (`字符串`)
                  • {name} (`字符串`)
                  • {buf} (`整数|字符串`)
                  • {dict} (`vim.fn.sign_place.dict?`)

                返回: ~
                  (`整数`)

sign_placelist({list})                                        *sign_placelist()*
		放置一个或多个标志。这类似于 |sign_place()| 函数。
		{list} 参数指定要放置的标志列表。每个列表项是一个包含以下标志属性的字典：
		    buffer	缓冲区名称或编号。关于接受的值，参见 |bufname()|。
		    group	标志组。{group} 作为 {id} 的命名空间，因此两个组可以使用相同的 ID。
				如果未指定或设置为空字符串，则使用全局标志组。有关更多信息，参见 |sign-group|。
		    id		标志标识符。如果未指定或为零，则分配一个新的唯一标识符。
				否则使用指定的数字。有关更多信息，参见 |sign-identifier|。
		    lnum	缓冲区中要放置标志的行号。关于接受的值，参见 |line()|。
		    name	要放置的标志的名称。有关更多信息，参见 |sign_define()|。
		    priority	标志的优先级。当多个标志放置在一行上时，使用优先级最高的标志。
				如果未指定，则使用默认值 10，除非标志定义另有指定。
				有关更多信息，参见 |sign-priority|。

		如果 {id} 引用现有标志，则修改现有标志以使用指定的 {name} 和/或 {priority}。

		返回标志标识符列表。如果放置标志失败，相应的列表项设置为 -1。

		示例： >vim
			" 将名为 s1、id 为 5 的标志放置在 a.c 缓冲区的第 20 行，id 为 10 的标志放置在第 30 行
			let [n1, n2] = sign_placelist([
				\ {'id' : 5,
				\  'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 20},
				\ {'id' : 10,
				\  'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 30}
				\ ])

			" 将名为 s1 的标志以自动生成的标识符放置在 a.c 缓冲区的第 40 和 50 行
			let [n1, n2] = sign_placelist([
				\ {'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 40},
				\ {'name' : 's1',
				\  'buffer' : 'a.c',
				\  'lnum' : 50}
				\ ])
<

                参数: ~
                  • {list} (`vim.fn.sign_placelist.list.item[]`)

                返回: ~
                  (`整数[]`)

sign_undefine([{name}])                                        *sign_undefine()*
sign_undefine({list})
		删除先前定义的标志 {name}。这类似于 |:sign-undefine| 命令。
		如果未提供 {name}，则删除所有已定义的标志。

		单参数 {list} 可用于取消定义标志列表。每个列表项是一个标志的名称。

		成功返回 0，失败返回 -1。对于单参数 {list} 调用，返回一个值列表，每个未定义的标志一个值。

		示例： >vim
			" 删除名为 mySign 的标志
			call sign_undefine("mySign")

			" 删除标志 'sign1' 和 'sign2'
			call sign_undefine(["sign1", "sign2"])

			" 删除所有标志
			call sign_undefine()
<

                参数: ~
                  • {list} (`字符串[]?`)

                返回: ~
                  (`整数[]`)

sign_unplace({group} [, {dict}])                                *sign_unplace()*
		从一个或多个缓冲区中移除先前放置的标志。这类似于 |:sign-unplace| 命令。

		{group} 是标志组名。要使用全局标志组，请使用空字符串。
		如果 {group} 设置为 "*"，则使用包括全局组在内的所有组。
		根据 {dict} 中的条目选择 {group} 中的标志。{dict} 中支持以下可选条目：
			buffer	缓冲区名称或编号。参见 |bufname()|。
			id	标志标识符
		如果未提供 {dict}，则移除 {group} 中的所有标志。

		成功返回 0，失败返回 -1。

		示例： >vim
			" 从缓冲区 a.vim 中移除标志 10
			call sign_unplace('', {'buffer' : "a.vim", 'id' : 10})

			" 从缓冲区 3 中移除组 'g1' 中的标志 20
			call sign_unplace('g1', {'buffer' : 3, 'id' : 20})

			" 从缓冲区 10 中移除组 'g2' 中的所有标志
			call sign_unplace('g2', {'buffer' : 10})

			" 从所有缓冲区中移除组 'g3' 中的标志 30
			call sign_unplace('g3', {'id' : 30})

			" 移除缓冲区 5 中放置的所有标志
			call sign_unplace('*', {'buffer' : 5})

			" 从所有缓冲区中移除组 'g4' 中的标志
			call sign_unplace('g4')

			" 从所有缓冲区中移除标志 40
			call sign_unplace('*', {'id' : 40})

			" 从所有缓冲区中移除所有已放置的标志
			call sign_unplace('*')
<

                参数: ~
                  • {group} (`字符串`)
                  • {dict} (`vim.fn.sign_unplace.dict?`)

                返回: ~
                  (`0|-1`)

sign_unplacelist({list})                                    *sign_unplacelist()*
		从一个或多个缓冲区中移除先前放置的标志。这类似于 |sign_unplace()| 函数。

		{list} 参数指定要移除的标志列表。每个列表项是一个包含以下标志属性的字典：
		    buffer	缓冲区名称或编号。关于接受的值，参见 |bufname()|。
				如果未指定，则从所有缓冲区中移除指定的标志。
		    group	标志组名。如果未指定或设置为空字符串，则使用全局标志组。
				如果设置为 "*"，则使用包括全局组在内的所有组。
		    id		标志标识符。如果未指定，则移除指定组中的所有标志。

		返回一个列表，其中如果相应标志成功移除，则条目设置为 0，失败则为 -1。

		示例： >vim
			" 从缓冲区 a.vim 中移除 id 为 10 的标志，从缓冲区 b.vim 中移除 id 为 20 的标志
			call sign_unplacelist([
				\ {'id' : 10, 'buffer' : "a.vim"},
				\ {'id' : 20, 'buffer' : 'b.vim'},
				\ ])
<

                参数: ~
                  • {list} (`vim.fn.sign_unplacelist.list.item`)

                返回: ~
                  (`(0|-1)[]`)

simplify({filename})                                                *simplify()*
		尽可能简化文件名而不改变其含义。
		不解析快捷方式（在 MS-Windows 上）或符号链接（在 Unix 上）。
		如果 {filename} 中的第一个路径组件指定当前目录，则结果也将有效。
		尾随路径分隔符也不会被删除。
		在 Unix 上，"//path" 保持不变，但 "///path" 被简化为 "/path"（这遵循 Posix 标准）。
		示例： >vim
			simplify("./dir/.././/file/") == "./file/"
<		注意：仅当 "dir" 是可搜索目录或不存在时，才会移除组合 "dir/.."。
		在 Unix 上，当 "dir" 是同一目录中的符号链接时，也会移除它。
		为了在简化路径名之前解析所有涉及的符号链接，请使用 |resolve()|。

                参数: ~
                  • {filename} (`字符串`)

                返回: ~
                  (`字符串`)

sin({expr})                                                              *sin()*
		返回 {expr} 的正弦值，以弧度为单位，作为 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo sin(100)
<			-0.506366 >vim
			echo sin(-4.01)
<			0.763301

                参数: ~
                  • {expr} (`数字`)

                返回: ~
                  (`数字`)

sinh({expr})                                                            *sinh()*
		返回 {expr} 的双曲正弦值作为 |Float|，范围在 [-inf, inf]。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo sinh(0.5)
<			0.521095 >vim
			echo sinh(-0.9)
<			-1.026517

                参数: ~
                  • {expr} (`数字`)

                返回: ~
                  (`任何类型`)

slice({expr}, {start} [, {end}])                                       *slice()*
		类似于使用切片 "expr[start : end]"，但 "end" 是排他的。
		并且对于字符串，索引用作字符索引而不是字节索引。
		此外，组合字符被视为前一个基本字符的一部分。
		当省略 {end} 时，切片继续到最后一个项。
		当 {end} 为 -1 时，省略最后一个项。
		如果 {start} 或 {end} 无效，则返回空值。

                参数: ~
                  • {expr} (`任何类型`)
                  • {start} (`整数`)
                  • {end} (`整数?`)

                返回: ~
                  (`任何类型`)

sockconnect({mode}, {address} [, {opts}])                        *sockconnect()*
		将套接字连接到地址。如果 {mode} 是 "pipe"，则 {address} 应该是本地域套接字（在 unix 上）或命名管道（在 Windows 上）的路径。
		如果 {mode} 是 "tcp"，则 {address} 应该是 "host:port" 的形式，其中主机应该是 IP 地址或主机名，端口是端口号。

		对于 "pipe" 模式，参见 |luv-pipe-handle|。对于 "tcp" 模式，参见 |luv-tcp-handle|。

		返回一个 |channel| ID。使用 |chanclose()| 关闭套接字。
		使用 |chansend()| 通过字节套接字发送数据，使用 |rpcrequest()| 和 |rpcnotify()| 与 RPC 套接字通信。

		{opts} 是一个可选字典，包含以下键：
		  |on_data| : 从套接字读取数据时调用的回调
		  data_buffered : 以 |channel-buffered| 模式读取套接字数据。
		  rpc     : 如果设置，将使用 |msgpack-rpc| 通过套接字通信。
		返回：
		  - 成功时返回通道 ID（大于零）
		  - 参数无效或连接失败时返回 0。

                参数: ~
                  • {mode} (`字符串`)
                  • {address} (`字符串`)
                  • {opts} (`表?`)

                返回: ~
                  (`任何类型`)

sort({list} [, {how} [, {dict}]])                                  *sort()* *E702*
		原地排序 {list} 中的项。返回 {list}。

		如果您希望列表保持不变，请先复制： >vim
			let sortedlist = sort(copy(mylist))

<		当省略 {how} 或它是字符串时，sort() 使用每个项的字符串表示进行排序。
		数字排在字符串之后，|Lists| 排在数字之后。
		要对当前缓冲区中的文本进行排序，请使用 |:sort|。

		当给出 {how} 且它是 'i' 时，忽略大小写。
		为了向后兼容，可以使用值一来忽略大小写。零表示不忽略大小写。

		当给出 {how} 且它是 'l' 时，使用当前的排序区域设置进行排序。
		实现细节：使用 strcoll() 比较字符串。参见 |:language| 检查或设置排序区域设置。
		|v:collate| 也可用于检查当前区域设置。
		使用区域设置排序通常会忽略大小写。
		示例： >vim
			" 在英语区域设置中，ö 的排序与 o 类似。
			language collate en_US.UTF8
			echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'ö', 'p', 'z'] ~
>vim
			" 在瑞典语区域设置中，ö 排在 z 之后。
			language collate sv_SE.UTF8
			echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'p', 'z', 'ö'] ~
		这在 Mac 上无法正常工作。

		当给出 {how} 且它是 'n' 时，所有项将按数字排序（实现细节：这使用 strtod() 函数解析数字，
		字符串、列表、字典和函数引用将被视为 0）。

		当给出 {how} 且它是 'N' 时，所有项将按数字排序。这与 'n' 类似，但包含数字的字符串将用作它们表示的数字。

		当给出 {how} 且它是 'f' 时，所有项将按数字排序。所有值必须是数字或浮点数。

		当 {how} 是 |Funcref| 或函数名时，调用此函数来比较项。
		该函数使用两个项作为参数调用，如果它们相等则必须返回零，
		如果第一个项排在第二个之后则返回 1 或更大值，如果第一个项排在第二个之前则返回 -1 或更小值。

		{dict} 用于具有 "dict" 属性的函数。它将用于设置局部变量 "self"。|Dictionary-function|

		排序是稳定的，比较相等（作为数字或字符串）的项将保持它们的相对位置。
		例如，当按数字排序时，文本字符串将彼此相邻排序，顺序与它们最初相同。

		示例： >vim
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			eval mylist->sort("MyCompare")
<		针对这种特定简单情况的较短比较版本，忽略溢出： >vim
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<		对于简单表达式，可以使用 lambda： >vim
			eval mylist->sort({i1, i2 -> i1 - i2})
<

                参数: ~
                  • {list} (`T[]`)
                  • {how} (`字符串|函数?`)
                  • {dict} (`任何?`)

                返回: ~
                  (`T[]`)

soundfold({word})                                                  *soundfold()*
		返回 {word} 的 sound-folded 等效词。使用当前窗口 'spelllang' 中第一个支持 soundfolding 的语言。
		必须设置 'spell'。当无法进行 sound folding 时，返回未修改的 {word}。
		这可用于生成拼写建议。注意，该方法可能相当慢。

                参数: ~
                  • {word} (`字符串`)

                返回: ~
                  (`字符串`)

spellbadword([{sentence}])                                      *spellbadword()*
		无参数：结果是光标下或光标后的拼写错误单词。光标移动到错误单词的开头。
		如果在光标行中未找到错误单词，则结果为空字符串且光标不移动。

		有参数：结果是 {sentence} 中第一个拼写错误的单词。如果没有拼写错误，结果为空字符串。

		返回值是一个包含两个项的列表：
		- 拼写错误的单词或空字符串。
		- 拼写错误的类型：
			"bad"		拼写错误
			"rare"		稀有单词
			"local"		仅在另一个区域有效的单词
			"caps"		单词应以大写开头
		示例： >vim
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		使用当前窗口的拼写信息和 'spelllang' 的值。

                参数: ~
                  • {sentence} (`字符串?`)

                返回: ~
                  (`任何类型`)

spellsuggest({word} [, {max} [, {capital}]])                    *spellsuggest()*
		返回一个 |List|，包含用于替换 {word} 的拼写建议。
		当给出 {max} 时，最多返回此数量的建议。否则最多返回 25 条建议。

		当给出 {capital} 参数且非零时，仅返回首字母大写的建议。
		在与 'spellcapcheck' 匹配后使用此功能。

		{word} 可以是一个拼写错误的单词后跟其他文本。
		这允许连接被拆分的两个单词。建议也包括后续文本，因此您可以替换一行。

		{word} 也可能是一个正确的单词。然后将返回类似的单词。
		{word} 本身不包含在建议中，尽管它可能以大写形式出现。

		使用当前窗口的拼写信息。使用 'spelllang' 和 'spellsuggest' 的值。

                参数: ~
                  • {word} (`字符串`)
                  • {max} (`整数?`)
                  • {capital} (`布尔值?`)

                返回: ~
                  (`字符串[]`)

split({string} [, {pattern} [, {keepempty}]])                          *split()*
		将 {string} 转换为 |List|。
		当省略 {pattern} 或为空时，每个由空白分隔的字符序列成为一个项。
		否则，字符串在 {pattern} 匹配处分割，移除匹配的字符。
		此处不使用 'ignorecase'，添加 \c 以忽略大小写。|/\c|
		当第一项或最后一项为空时，它被省略，除非给出 {keepempty} 参数且非零。
		当 {pattern} 匹配至少一个字符或 {keepempty} 非零时，保留其他空项。
		示例： >vim
			let words = split(getline('.'), '\W\+')
<		要将字符串分割为单个字符： >vim
			for c in split(mystring, '\zs') | endfor
<		如果要保留分隔符，也可以在模式末尾使用 '\zs'： >vim
			echo split('abc:def:ghi', ':\zs')
<		 >
			['abc:', 'def:', 'ghi']
<
		分割第一个元素可能为空的表： >vim
			let items = split(line, ':', 1)
<		相反的函数是 |join()|。

                参数: ~
                  • {string} (`字符串`)
                  • {pattern} (`字符串?`)
                  • {keepempty} (`布尔值?`)

                返回: ~
                  (`字符串[]`)

sqrt({expr})                                                            *sqrt()*
		返回 Float {expr} 的非负平方根作为 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|。
		当 {expr} 为负数时，结果为 NaN（非数字）。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo sqrt(100)
<			10.0 >vim
			echo sqrt(-4.01)
<			str2float("nan")
		NaN 可能不同，这取决于系统库。

                参数: ~
                  • {expr} (`数字`)

                返回: ~
                  (`任何类型`)

srand([{expr}])                                                        *srand()*
		初始化 |rand()| 使用的种子：
		- 如果未给出 {expr}，则通过从 /dev/urandom 读取（如果可能）来初始化种子值，
		  否则使用 time(NULL)（也称为 epoch 时间）；这只有秒级精度。
		- 如果给出 {expr}，它必须是数字。它用于初始化种子值。
		  这对于测试或需要可预测序列时很有用。

		示例： >vim
			let seed = srand()
			let seed = srand(userinput)
			echo rand(seed)
<

                参数: ~
                  • {expr} (`数字?`)

                返回: ~
                  (`任何类型`)

state([{what}])                                                        *state()*
		返回一个包含指示当前状态的字符的字符串。
		主要在希望执行可能不总是安全的工作的回调中有用。
		大致工作方式如下：
		- 回调使用 state() 检查工作是否安全执行。
		  是：立即执行。
		  否：添加到工作队列并添加一个 |SafeState| 自动命令。
		- 当 SafeState 被触发并执行您的自动命令时，使用 `state()` 检查现在是否可以执行工作，
		  如果是，则从队列中移除并执行。
		  如果队列现在为空，则移除自动命令。
		另请参见 |mode()|。

		当给出 {what} 时，仅添加此字符串中的字符。
		例如，这检查屏幕是否已滚动： >vim
			if state('s') == ''
			   " 屏幕未滚动
<
		这些字符指示状态，通常表示某事物正忙：
		    m	映射、:normal 命令、feedkeys() 或 stuffed 命令执行到一半
		    o	操作符挂起，例如在 |d| 之后
		    a	插入模式自动补激活
		    x	正在执行自动命令
		    S	未触发 SafeState，例如在 |f| 或计数之后
		    c	已调用回调，包括计时器（递归性最多重复 "ccc"）
		    s	屏幕已为消息滚动

                参数: ~
                  • {what} (`字符串?`)

                返回: ~
                  (`任何类型`)

stdioopen({opts})                                                  *stdioopen()*
		使用 |--headless| 时，这将 stdin 和 stdout 作为 |channel| 打开。
		只能调用一次。参见 |channel-stdio|。
		stderr 不由此函数处理，参见 |v:stderr|。

		使用 |chanclose()| 关闭 stdio 句柄。
		使用 |chansend()| 向 stdout 发送数据，使用 |rpcrequest()| 和 |rpcnotify()| 通过 RPC 通信。

		{opts} 是一个包含以下键的字典：
		  |on_stdin| : 当 stdin 被写入时调用的回调。
		  on_print : 当 Nvim 需要打印消息时调用的回调，消息（类型为字符串）作为唯一参数。
		  stdin_buffered : 以 |channel-buffered| 模式读取 stdin。
		  rpc      : 如果设置，将使用 |msgpack-rpc| 通过 stdio 通信
		返回：
		  - 成功时为 |channel-id|（值始终为 1）
		  - 参数无效时为 0

                参数: ~
                  • {opts} (`表`)

                返回: ~
                  (`任何类型`)

stdpath({what})                                                *stdpath()* *E6100*
		返回各种默认文件和目录的 |standard-path| 位置。
		位置由 |base-directories| 驱动，您可以通过 |$NVIM_APPNAME| 或 `$XDG_…` 环境变量进行配置。

		{what}       类型    描述 ~
		cache        字符串  缓存目录：插件等的任意临时存储
		config       字符串  用户配置目录。|init.vim| 存储在此处。
		config_dirs  列表    其他配置目录。
		data         字符串  用户数据目录。
		data_dirs    列表    其他数据目录。
		log          字符串  日志目录（也可供插件使用）。
		run          字符串  运行目录：套接字、命名管道等的临时本地存储
		state        字符串  会话状态：backupdir、文件草稿、|shada|、交换文件、撤销文件、'viewdir' 的存储

		示例： >vim
			echo stdpath("config")
<

                参数: ~
                  • {what}
                    (`'cache'|'config'|'config_dirs'|'data'|'data_dirs'|'log'|'run'|'state'`)

                返回: ~
                  (`字符串|字符串[]`)

str2float({string} [, {quoted}])                                   *str2float()*
		将字符串 {string} 转换为 Float。
		这与在表达式中使用浮点数时大致相同，参见 |floating-point-format|。但它更宽松。
		例如，"1e40" 被接受，而在表达式中您需要编写 "1.0e40"。
		十六进制形式 "0x123" 也被接受，但其他形式（如二进制或八进制）不被接受。
		当存在 {quoted} 且非零时，点之前的嵌入单引号被忽略，因此 "1'000.0" 是一千。
		数字后的文本被静默忽略。
		小数点始终是 '.'，无论区域设置如何。
		逗号结束数字："12,345.67" 转换为 12.0。
		您可以使用 |substitute()| 去除千位分隔符： >vim
			let f = str2float(substitute(text, ',', '', 'g'))
<
		如果转换失败，返回 0.0。

                参数: ~
                  • {string} (`字符串`)
                  • {quoted} (`布尔值?`)

                返回: ~
                  (`任何类型`)

str2list({string} [, {utf8}])                                       *str2list()*
		返回一个包含表示字符串 {string} 中每个字符的数字值的列表。
		示例： >vim
			echo str2list(" ")		" 返回 [32]
			echo str2list("ABC")		" 返回 [65, 66, 67]
<		|list2str()| 执行相反操作。

		始终使用 UTF-8 编码，{utf8} 选项无效，仅为了向后兼容而存在。
		使用 UTF-8 时，组合字符得到正确处理： >vim
			echo str2list("á")		" 返回 [97, 769]
<

                参数: ~
                  • {string} (`字符串`)
                  • {utf8} (`布尔值?`)

                返回: ~
                  (`任何类型`)

str2nr({string} [, {base}])                                           *str2nr()*
		将字符串 {string} 转换为数字。
		{base} 是转换基数，可以是 2、8、10 或 16。
		当存在 {quoted} 且非零时，忽略嵌入的单引号，因此 "1'000'000" 是一百万。

		当省略 {base} 时，使用基数 10。
		这也意味着前导零不会导致使用八进制转换，就像默认的字符串到数字转换一样。
		示例： >vim
			let nr = str2nr('0123')
<
		当 {base} 为 16 时，忽略前导 "0x" 或 "0X"。
		使用不同的基数，结果将为零。
		类似地，当 {base} 为 8 时，忽略前导 "0"、"0o" 或 "0O"，
		当 {base} 为 2 时，忽略前导 "0b" 或 "0B"。
		数字后的文本被静默忽略。

		如果 {string} 为空或出错，返回 0。

                参数: ~
                  • {string} (`字符串`)
                  • {base} (`整数?`)

                返回: ~
                  (`任何类型`)

strcharlen({string})                                              *strcharlen()*
		结果是一个数字，表示字符串 {string} 中的字符数。忽略组合字符。
		|strchars()| 可以计算字符数，将组合字符单独计数。

		如果 {string} 为空或出错，返回 0。

		另请参见 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。

                参数: ~
                  • {string} (`字符串`)

                返回: ~
                  (`任何类型`)

strcharpart({src}, {start} [, {len} [, {skipcc}]])               *strcharpart()*
		类似于 |strpart()|，但使用字符索引和长度而不是字节索引和长度。
		当省略 {skipcc} 或为零时，组合字符单独计数。
		当 {skipcc} 设置为 1 时，组合字符被视为前一个基本字符的一部分，类似于 |slice()|。
		当使用的字符索引处不存在字符时，它被省略并计为一个字符。
		例如： >vim
			echo strcharpart('abc', -1, 2)
<		结果是 'a'。

		出错时返回空字符串。

                参数: ~
                  • {src} (`字符串`)
                  • {start} (`整数`)
                  • {len} (`整数?`)
                  • {skipcc} (`布尔值?`)

                返回: ~
                  (`任何类型`)

strchars({string} [, {skipcc}])                                     *strchars()*
		结果是一个数字，表示字符串 {string} 中的字符数。
		当省略 {skipcc} 或为零时，组合字符单独计数。
		当 {skipcc} 设置为 1 时，忽略组合字符。
		|strcharlen()| 总是这样做。

		出错时返回零。

		另请参见 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。

		{skipcc} 仅在 7.4.755 之后可用。为了向后兼容，您可以定义一个包装函数： >vim
		    if has("patch-7.4.755")
		      function s:strchars(str, skipcc)
			return strchars(a:str, a:skipcc)
		      endfunction
		    else
		      function s:strchars(str, skipcc)
			if a:skipcc
			  return strlen(substitute(a:str, ".", "x", "g"))
			else
			  return strchars(a:str)
			endif
		      endfunction
		    endif
<

                参数: ~
                  • {string} (`字符串`)
                  • {skipcc} (`布尔值?`)

                返回: ~
                  (`整数`)

strdisplaywidth({string} [, {col}])                          *strdisplaywidth()*
		结果是一个数字，表示字符串 {string} 在屏幕上从 {col} 开始（第一列为零）占用的显示单元格数。
		当省略 {col} 时，使用零。否则是开始的屏幕列。这对制表符很重要。
		使用当前窗口的选项设置。这对任何显示不同的内容都很重要，例如 'tabstop' 和 'display'。
		当 {string} 包含具有东亚宽度类别模糊的字符时，此函数的返回值取决于 'ambiwidth'。
		出错时返回零。
		另请参见 |strlen()|、|strwidth()| 和 |strchars()|。

                参数: ~
                  • {string} (`字符串`)
                  • {col} (`整数?`)

                返回: ~
                  (`整数`)

strftime({format} [, {time}])                                       *strftime()*
		结果是一个字符串，它是根据 {format} 字符串指定的格式化日期和时间。
		使用给定的 {time}，如果未给出时间，则使用当前时间。
		接受的 {format} 取决于您的系统，因此不可移植！
		有关格式，请参见 C 函数 strftime() 的手册页。
		结果的最大长度为 80 个字符。
		另请参见 |localtime()|、|getftime()| 和 |strptime()|。
		可以使用 |:language| 命令更改语言。
		示例： >vim
		  echo strftime("%c")		   " Sun Apr 27 11:49:23 1997
		  echo strftime("%Y %b %d %X")	   " 1997 Apr 27 11:53:25
		  echo strftime("%y%m%d %T")	   " 970427 11:53:55
		  echo strftime("%H:%M")		   " 11:55
		  echo strftime("%c", getftime("file.c"))
						   " 显示 file.c 的修改时间。
<

                参数: ~
                  • {format} (`字符串`)
                  • {time} (`数字?`)

                返回: ~
                  (`字符串`)

strgetchar({str}, {index})                                        *strgetchar()*
		获取与 {str} 中 {index} 处字符对应的数字。
		这使用从零开始的字符索引，而不是字节索引。
		此处组合字符被视为单独的字符。
		使用 |nr2char()| 将数字转换为字符串。
		如果 {index} 无效，返回 -1。
		另请参见 |strcharpart()| 和 |strchars()|。

                参数: ~
                  • {str} (`字符串`)
                  • {index} (`整数`)

                返回: ~
                  (`整数`)

stridx({haystack}, {needle} [, {start}])                              *stridx()*
		结果是一个数字，给出 {haystack} 中字符串 {needle} 第一次出现的字节索引。
		如果指定了 {start}，则搜索从索引 {start} 开始。
		这可用于查找第二个匹配项： >vim
			let colon1 = stridx(line, ":")
			let colon2 = stridx(line, ":", colon1 + 1)
<		搜索区分大小写。
		对于模式搜索，使用 |match()|。
		如果 {needle} 未出现在 {haystack} 中，则返回 -1。
		另请参见 |strridx()|。
		示例： >vim
		  echo stridx("An Example", "Example")     " 3
		  echo stridx("Starting point", "Start")   " 0
		  echo stridx("Starting point", "start")   " -1
<						*strstr()* *strchr()*
		stridx() 类似于 C 函数 strstr()。当用于单个字符时，它类似于 strchr()。

                参数: ~
                  • {haystack} (`字符串`)
                  • {needle} (`字符串`)
                  • {start} (`整数?`)

                返回: ~
                  (`整数`)

string({expr})                                                        *string()*
		返回转换为字符串的 {expr}。
		如果 {expr} 是数字、浮点数、字符串、二进制大对象或它们的组合，则可以使用 |eval()| 解析回结果。
			{expr} 类型	结果 ~
			String		'string'
			Number		123
			Float		123.123456 或 1.123456e8 或 `str2float('inf')`
			Funcref		`function('name')`
			Blob		0z00112233.44556677.8899
			List		[item, item]
			Dictionary	`{key: value, key: value}`
		注意，在字符串值中，' 字符被加倍。
		另请参见 |strtrans()|。
		注意 2：输出格式大多与 YAML 兼容，除了无限和 NaN 浮点值表示使用 |str2float()|。
		字符串也被字面转储，仅转义单引号，这不允许使用 YAML 解析回二进制字符串。
		不过，对于字符串和浮点数，|eval()| 应始终有效，并且这是唯一官方方法。
		如果您需要与其他应用程序共享数据，请使用 |msgpackdump()| 或 |json_encode()|。

                参数: ~
                  • {expr} (`任何类型`)

                返回: ~
                  (`字符串`)

strlen({string})                                                      *strlen()*
		结果是一个数字，表示字符串 {string} 的字节长度。
		如果参数是数字，则首先转换为字符串。
		对于其他类型，会给出错误并返回零。
		如果要计算多字节字符的数量，请使用 |strchars()|。
		另请参见 |len()|、|strdisplaywidth()| 和 |strwidth()|。

                参数: ~
                  • {string} (`字符串`)

                返回: ~
                  (`整数`)

strpart({src}, {start} [, {len} [, {chars}]])                        *strpart()*
		结果是一个字符串，它是 {src} 的一部分，从字节 {start} 开始，字节长度为 {len}。
		当存在 {chars} 且为 TRUE 时，{len} 是字符位置的数量（组合字符不单独计数，
		因此 "1" 表示一个基本字符及其后的任何组合字符）。
		要将 {start} 作为字符而不是字节计数，请使用 |strcharpart()|。

		当选择的字节不存在时，这不会导致错误，这些字节被简单地省略。
		如果 {len} 缺失，则从 {start} 开始复制直到 {src} 的末尾。 >vim
			echo strpart("abcdefg", 3, 2)    " 返回 'de'
			echo strpart("abcdefg", -2, 4)   " 返回 'ab'
			echo strpart("abcdefg", 5, 4)    " 返回 'fg'
			echo strpart("abcdefg", 3)	 " 返回 'defg'

<		注意：要获取第一个字符，{start} 必须为 0。
		例如，要获取光标下的字符： >vim
			strpart(getline("."), col(".") - 1, 1, v:true)
<
		出错时返回空字符串。

                参数: ~
                  • {src} (`字符串`)
                  • {start} (`整数`)
                  • {len} (`整数?`)
                  • {chars} (`0|1?`)

                返回: ~
                  (`字符串`)

strptime({format}, {timestring})                                    *strptime()*
		结果是一个数字，它是一个表示 {timestring} 中日期和时间的 unix 时间戳，
		{timestring} 预期与 {format} 中指定的格式匹配。

		接受的 {format} 取决于您的系统，因此不可移植！
		有关格式，请参见 C 函数 strptime() 的手册页。尤其避免 "%c"。
		$TZ 的值也很重要。

		如果 {timestring} 无法用 {format} 解析，则返回零。
		如果您不知道 {timestring} 的格式，可以尝试不同的 {format} 值，直到获得非零结果。

		另请参见 |strftime()|。
		示例： >vim
		  echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")
<		  862156163 >vim
		  echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))
<		  Sun Apr 27 11:53:55 1997 >vim
		  echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)
<		  Sun Apr 27 12:53:55 1997

                参数: ~
                  • {format} (`字符串`)
                  • {timestring} (`字符串`)

                返回: ~
                  (`整数`)

strridx({haystack}, {needle} [, {start}])                            *strridx()*
		结果是一个数字，给出 {haystack} 中字符串 {needle} 最后一次出现的字节索引。
		当指定 {start} 时，忽略此索引之后的匹配项。
		这可用于查找前一个匹配项之前的匹配项： >vim
			let lastcomma = strridx(line, ",")
			let comma2 = strridx(line, ",", lastcomma - 1)
<		搜索区分大小写。
		对于模式搜索，使用 |match()|。
		如果 {needle} 未出现在 {haystack} 中，则返回 -1。
		如果 {needle} 为空，则返回 {haystack} 的长度。
		另请参见 |stridx()|。示例： >vim
		  echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		当用于单个字符时，它类似于 C 函数 strrchr()。

                参数: ~
                  • {haystack} (`字符串`)
                  • {needle} (`字符串`)
                  • {start} (`整数?`)

                返回: ~
                  (`整数`)

strtrans({string})                                                  *strtrans()*
		结果是一个字符串，它是 {string} 中所有不可打印字符转换为可打印字符 'isprint' 的结果。
		就像它们在窗口中显示的那样。示例： >vim
			echo strtrans(@a)
<		这将在寄存器 a 中将换行符显示为 "^@" 而不是开始新行。

		出错时返回空字符串。

                参数: ~
                  • {string} (`字符串`)

                返回: ~
                  (`字符串`)

strutf16len({string} [, {countcc}])                              *strutf16len()*
		结果是一个数字，表示字符串 {string} 中的 UTF-16 代码单元数量（在将其转换为 UTF-16 之后）。

		当 {countcc} 为 TRUE 时，组合字符单独计数。
		当省略 {countcc} 或为 FALSE 时，忽略组合字符。

		出错时返回零。

		另请参见 |strlen()| 和 |strcharlen()|。
		示例： >vim
		    echo strutf16len('a')		" 返回 1
		    echo strutf16len('©')		" 返回 1
		    echo strutf16len('😊')		" 返回 2
		    echo strutf16len('ą́')		" 返回 1
		    echo strutf16len('ą́', v:true)	" 返回 3
<

                参数: ~
                  • {string} (`字符串`)
                  • {countcc} (`0|1?`)

                返回: ~
                  (`整数`)

strwidth({string})                                                  *strwidth()*
		结果是一个数字，表示字符串 {string} 占用的显示单元格数。
		制表符计为一个单元格，或者使用 |strdisplaywidth()|。
		当 {string} 包含具有东亚宽度类别模糊的字符时，此函数的返回值取决于 'ambiwidth'。
		出错时返回零。
		另请参见 |strlen()|、|strdisplaywidth()| 和 |strchars()|。

                参数: ~
                  • {string} (`字符串`)

                返回: ~
                  (`整数`)

submatch({nr} [, {list}])                                      *submatch()* *E935*
		仅用于 |:substitute| 命令或 substitute() 函数中的表达式。
		返回匹配文本的第 {nr} 个子匹配。当 {nr} 为 0 时，返回整个匹配的文本。
		注意，字符串中的 NL 可以代表多行匹配的换行符或文本中的 NUL 字符。
		另请参见 |sub-replace-expression|。

		如果存在 {list} 且非零，则 submatch() 返回一个字符串列表，类似于带有两个参数的 |getline()|。
		文本中的 NL 字符代表文本中的 NUL 字符。
		仅在 |:substitute| 中返回多个项，在 |substitute()| 内部，此列表将始终包含一个或零个项，
		因为没有真正的换行符。

		当递归使用 substitute() 时，只能获取当前（最深层）调用中的子匹配。

		出错时返回空字符串或列表。

		示例： >vim
			s/\d\+/\=submatch(0) + 1/
			echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
<		这查找行中的第一个数字并将其加一。
		换行符包含为换行字符。

                参数: ~
                  • {nr} (`整数`)
                  • {list} (`nil?`)

                返回: ~
                  (`字符串`)

substitute({string}, {pat}, {sub}, {flags})                       *substitute()*
		结果是一个字符串，它是 {string} 的副本，其中 {pat} 的第一个匹配项被替换为 {sub}。
		当 {flags} 为 "g" 时，{string} 中 {pat} 的所有匹配项都被替换。否则 {flags} 应为 ""。

		这类似于 ":substitute" 命令（没有任何标志）。
		但是与 {pat} 的匹配总是像设置了 'magic' 选项且 'cpoptions' 为空一样完成（为了使脚本可移植）。
		'ignorecase' 仍然相关，如果您想忽略或匹配大小写并忽略 'ignorecase'，请使用 |/\c| 或 |/\C|。
		不使用 'smartcase'。有关如何使用 {pat}，请参见 |string-match|。

		{sub} 中的 "~" 不会被先前的 {sub} 替换。
		注意 {sub} 中的一些代码具有特殊含义 |sub-replace-special|。
		例如，要用 "\n"（两个字符）替换某些内容，请使用 "\\\\n" 或 '\\n'。

		当 {pat} 在 {string} 中不匹配时，返回未修改的 {string}。

		示例： >vim
			let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		这移除 'path' 选项的最后一个组件。 >vim
			echo substitute("testing", ".*", "\\U\\0", "")
<		结果为 "TESTING"。

		当 {sub} 以 "\=" 开头时，其余部分被解释为表达式。参见 |sub-replace-expression|。
		示例： >vim
			echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" .. submatch(1))', 'g')

<		当 {sub} 是 Funcref 时，调用该函数，带有一个可选参数。
		示例： >vim
		   echo substitute(s, '%\(\x\x\)', SubNr, 'g')
<		可选参数是一个列表，包含整个匹配的字符串和最多九个子匹配，就像 |submatch()| 返回的那样。
		示例： >vim
		   echo substitute(s, '%\(\x\x\)', {m -> '0x' .. m[1]}, 'g')

<		出错时返回空字符串。

                参数: ~
                  • {string} (`字符串`)
                  • {pat} (`字符串`)
                  • {sub} (`字符串`)
                  • {flags} (`字符串`)

                返回: ~
                  (`字符串`)

swapfilelist()                                                  *swapfilelist()*
		返回交换文件名称的列表，类似于 "vim -r" 显示的内容。
		参见 |-r| 命令参数。'directory' 选项用于要检查的目录。
		如果您只想获取当前目录中的交换文件列表，请临时将 'directory' 设置为点： >vim
			let save_dir = &directory
			let &directory = '.'
			let swapfiles = swapfilelist()
			let &directory = save_dir
<

                返回: ~
                  (`字符串[]`)

swapinfo({fname})                                                   *swapinfo()*
		结果是一个字典，其中包含有关交换文件 {fname} 的信息。可用字段有：
			version Vim 版本
			user	用户名
			host	主机名
			fname	原始文件名
			pid	创建交换文件的 Nvim 进程的 PID，如果未运行则为零。
			mtime	最后修改时间（秒）
			inode	可选：文件的 INODE 号
			dirty	1 如果文件被修改，0 如果未修改
		失败时添加一个 "error" 项，原因如下：
			无法打开文件：文件未找到或不可访问
			无法读取文件：无法读取第一个块
			不是交换文件：不包含正确的块 ID
			幻数不匹配：第一个块中的信息无效

                参数: ~
                  • {fname} (`字符串`)

                返回: ~
                  (`任何类型`)

swapname({buf})                                                     *swapname()*
		结果是缓冲区 {buf} 的交换文件路径。
		关于 {buf} 的使用，参见上面的 |bufname()|。
		如果缓冲区 {buf} 是当前缓冲区，则结果等于 |:swapname|（除非没有交换文件）。
		如果缓冲区 {buf} 没有交换文件，返回空字符串。

                参数: ~
                  • {buf} (`整数|字符串`)

                返回: ~
                  (`字符串`)

synID({lnum}, {col}, {trans})                                          *synID()*
		结果是一个数字，它是当前窗口中位置 {lnum} 和 {col} 处的语法 ID。
		语法 ID 可用于 |synIDattr()| 和 |synIDtrans()| 以获取有关文本的语法信息。

		{col} 为 1 表示最左边的列，{lnum} 为 1 表示第一行。
		应用 'synmaxcol'，在较长的行中返回零。
		注意，当位置在最后一个字符之后时，即光标在插入模式下的位置，synID() 返回零。
		{lnum} 的用法与 |getline()| 类似。

		当 {trans} 为 |TRUE| 时，透明项被简化为它们揭示的项。这在想知道有效颜色时很有用。
		当 {trans} 为 |FALSE| 时，返回透明项。这在想知道哪个语法项有效时很有用（例如在括号内）。
		警告：此函数可能非常慢。最佳速度是通过向前方向遍历文件获得的。

		出错时返回零。

		示例（回显光标下的语法项名称）： >vim
			echo synIDattr(synID(line("."), col("."), 1), "name")
<

                参数: ~
                  • {lnum} (`整数|字符串`)
                  • {col} (`整数`)
                  • {trans} (`0|1`)

                返回: ~
                  (`整数`)

synIDattr({synID}, {what} [, {mode}])                              *synIDattr()*
		结果是一个字符串，它是语法 ID {synID} 的 {what} 属性。
		这可用于获取有关语法项的信息。
		{mode} 可以是 "gui" 或 "cterm"，以获取该模式的属性。
		当省略 {mode} 或使用无效值时，使用当前活动高亮的属性（GUI 或 cterm）。
		使用 synIDtrans() 跟踪链接的高亮组。
		{what}		结果
		"name"		语法项的名称
		"fg"		前景色（GUI：用于设置颜色的颜色名称，
				cterm：颜色编号作为字符串，
				term：空字符串）
		"bg"		背景色（与 "fg" 相同）
		"font"		字体名称（仅在 GUI 中可用）
				|highlight-font|
		"sp"		特殊颜色（与 "fg" 相同） |guisp|
		"fg#"		类似于 "fg"，但对于 GUI 且 GUI 正在运行，名称为 "#RRGGBB" 形式
		"bg#"		类似于 "fg#"，用于 "bg"
		"sp#"		类似于 "fg#"，用于 "sp"
		"bold"		"1" 如果为粗体
		"italic"	"1" 如果为斜体
		"reverse"	"1" 如果为反转
		"inverse"	"1" 如果为反转（= reverse）
		"standout"	"1" 如果为突出显示
		"underline"	"1" 如果带下划线
		"undercurl"	"1" 如果带下曲线
		"underdouble"	"1" 如果带双下划线
		"underdotted"	"1" 如果带点下划线
		"underdashed"	"1" 如果带虚线了下划线
		"strikethrough"	"1" 如果带删除线
		"altfont"	"1" 如果为替代字体
		"nocombine"	"1" 如果为不组合

		出错时返回空字符串。

		示例（回显光标下语法项的颜色）： >vim
			echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
		也可以用作 |method|： >vim
			echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")
<

                参数: ~
                  • {synID} (`整数`)
                  • {what} (`字符串`)
                  • {mode} (`字符串?`)

                返回: ~
                  (`字符串`)

synIDtrans({synID})                                               *synIDtrans()*
		结果是一个数字，它是 {synID} 的翻译后语法 ID。
		这是用于高亮字符的语法组 ID。遵循使用 ":highlight link" 给出的高亮链接。

		出错时返回零。

                参数: ~
                  • {synID} (`整数`)

                返回: ~
                  (`整数`)

synconcealed({lnum}, {col})                                     *synconcealed()*
		结果是一个 |List|，目前包含三个项：
		1. 列表中的第一项是 0，如果位置 {lnum} 和 {col} 处的字符不是可隐藏区域的一部分，则为 1 如果是。
		   {lnum} 的用法与 |getline()| 类似。
		2. 列表中的第二项是一个字符串。如果第一项是 1，则第二项包含将显示代替隐藏文本的文本，
		   取决于 'conceallevel' 和 'listchars' 的当前设置。
		3. 列表中的第三项也是最后一项是一个数字，表示行中匹配的特定语法区域。
		   当字符未隐藏时，值为零。这允许检测新的可隐藏区域的开始，
		   如果有两个具有相同替换字符的连续区域。
		   例如，如果文本是 "123456" 并且 "23" 和 "45" 都被隐藏并替换为字符 "X"，那么：
			调用		返回 ~
			synconcealed(lnum, 1)   [0, '', 0]
			synconcealed(lnum, 2)   [1, 'X', 1]
			synconcealed(lnum, 3)   [1, 'X', 1]
			synconcealed(lnum, 4)   [1, 'X', 2]
			synconcealed(lnum, 5)   [1, 'X', 2]
			synconcealed(lnum, 6)   [0, '', 0]

		注意：不考虑 |matchadd()| 高亮项，因为语法和高亮匹配是两个不同的机制 |syntax-vs-match|。

                参数: ~
                  • {lnum} (`整数|字符串`)
                  • {col} (`整数`)

                返回: ~
                  (`[整数, 字符串, 整数]`)

synstack({lnum}, {col})                                             *synstack()*
		返回一个 |List|，它是当前窗口中位置 {lnum} 和 {col} 处的语法项堆栈。
		{lnum} 的用法与 |getline()| 类似。
		列表中的每个项都是一个 ID，就像 |synID()| 返回的那样。
		列表中的第一项是外部区域，后面是包含在其中的项。
		最后一项是 |synID()| 返回的内容，除非整个项未高亮或它是透明项。
		此函数对于调试语法文件很有用。
		显示光标下语法堆栈的示例： >vim
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
<		当用 {lnum} 和 {col} 指定的位置无效时，返回空列表。
		行中最后一个字符之后的位置和空行中的第一列是有效位置。

                参数: ~
                  • {lnum} (`整数|字符串`)
                  • {col} (`整数`)

                返回: ~
                  (`整数[]`)

system({cmd} [, {input}])                                        *system()* *E677*
		注意：在 Lua 中优先使用 |vim.system()|。

		获取 {cmd} 的输出作为 |string|（|systemlist()| 返回 |List|）并设置 |v:shell_error| 为错误代码。
		{cmd} 的处理方式与 |jobstart()| 中相同：
		如果 {cmd} 是列表，则直接运行（无 'shell'）。
		如果 {cmd} 是字符串，则在 'shell' 中运行，如下所示： >vim
		  call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])

<		不用于交互式命令。

		结果是一个字符串，经过过滤以避免平台特定的怪癖：
		- <CR><NL> 被替换为 <NL>
		- NUL 字符被替换为 SOH (0x01)

		示例： >vim
		    echo system(['ls', expand('%:h')])

<		如果 {input} 是字符串，则将其写入管道并作为 stdin 传递给命令。
		字符串按原样写入，行分隔符不更改。
		如果 {input} 是 |List|，则将其写入管道，就像 |writefile()| 使用 {binary} 设置为 "b" 那样
		（即在每个列表项之间使用换行符，列表项内部的换行符转换为 NUL）。
		当给定 {input} 且是有效的缓冲区 id 时，缓冲区的内容逐行写入文件，每行以 NL 终止
		（文本有 NL 的地方用 NUL）。
								*E5677*
		注意：system() 无法写入或读取后台（"&"）shell 命令，例如： >vim
		    echo system("cat - &", "foo")
<		这等价于： >
		    $ echo foo | bash -c 'cat - &'
<		管道在输入到达之前断开（除非被 shell 重定向语法覆盖）。请改用 |jobstart()|。

		注意：使用 |shellescape()| 或 |::S| 与 |expand()| 或 |fnamemodify()| 来转义命令参数中的特殊字符。
		必须正确配置 'shellquote' 和 'shellxquote'。
		示例： >vim
		    echo system('ls '..shellescape(expand('%:h')))
		    echo system('ls '..expand('%:h:S'))

<		与 ":!cmd" 不同，没有对更改文件的自动检查。使用 |:checktime| 强制检查。

                参数: ~
                  • {cmd} (`字符串|字符串[]`)
                  • {input} (`字符串|字符串[]|整数?`)

                返回: ~
                  (`字符串`)

systemlist({cmd} [, {input} [, {keepempty}]])                     *systemlist()*
		与 |system()| 相同，但返回一个 |List|，其中包含行（由 NL 分隔的输出部分），NUL 转换为 NL。
		输出与 |readfile()| 在 {binary} 参数设置为 "b" 时的输出相同，除非 {keepempty} 非零，否则不保留最后的换行符。
		注意，在 MS-Windows 上可能会得到尾随的 CR 字符。

		要查看 "echo hello" 和 "echo -n hello" 之间的区别，请使用 |system()| 和 |split()|： >vim
			echo split(system('echo hello'), '\n', 1)
<
		出错时返回空字符串。

                参数: ~
                  • {cmd} (`字符串|字符串[]`)
                  • {input} (`字符串|字符串[]|整数?`)
                  • {keepempty} (`整数?`)

                返回: ~
                  (`字符串[]`)

tabpagebuflist([{arg}])                                       *tabpagebuflist()*
		结果是一个 |List|，其中每个项是与当前标签页中每个窗口关联的缓冲区编号。
		{arg} 指定要使用的标签页编号。省略时使用当前标签页。
		当 {arg} 无效时，返回数字零。
		要获取所有标签页中所有缓冲区的列表，请使用： >vim
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		注意，一个缓冲区可能出现在多个窗口中。

                参数: ~
                  • {arg} (`整数?`)

                返回: ~
                  (`任何类型`)

tabpagenr([{arg}])                                                 *tabpagenr()*
		结果是一个数字，表示当前标签页的编号。第一个标签页编号为 1。

		可选参数 {arg} 支持以下值：
			$	最后一个标签页的编号（标签页计数）。
			#	最后访问的标签页的编号（|g<Tab>| 去往的位置）。
				如果没有先前的标签页，则返回 0。
		该数字可用于 |:tab| 命令。

		出错时返回零。

                参数: ~
                  • {arg} (`'$'|'#'?`)

                返回: ~
                  (`整数`)

tabpagewinnr({tabarg} [, {arg}])                                *tabpagewinnr()*
		类似于 |winnr()|，但用于标签页 {tabarg}。
		{tabarg} 指定要使用的标签页编号。
		{arg} 的用法与 |winnr()| 类似：
		- 省略时返回当前窗口编号。这是转到此标签页时将使用的窗口。
		- 为 "$" 时返回窗口数量。
		- 为 "#" 时返回前一个窗口编号。
		有用的示例： >vim
		    tabpagewinnr(1)	    " 标签页 1 的当前窗口
		    tabpagewinnr(4, '$')    " 标签页 4 中的窗口数量
<		当 {tabarg} 无效时返回零。

                参数: ~
                  • {tabarg} (`整数`)
                  • {arg} (`'$'|'#'?`)

                返回: ~
                  (`整数`)

tagfiles()                                                          *tagfiles()*
		返回一个 |List|，其中包含用于为当前缓冲区搜索标签的文件名。这是扩展后的 'tags' 选项。

                返回: ~
                  (`字符串[]`)

taglist({expr} [, {filename}])                                       *taglist()*
		返回与正则表达式 {expr} 匹配的标签的 |List|。

		如果传递了 {filename}，则用于优先化结果，方式与 |:tselect| 相同。参见 |tag-priority|。
		{filename} 应为文件的完整路径。

		每个列表项是一个至少包含以下条目的字典：
			name		标签的名称。
			filename	定义标签的文件名。
				        它要么是相对于当前目录的，要么是完整路径。
			cmd		用于在文件中定位标签的 Ex 命令。
			kind		标签的类型。
				        此条目的值取决于语言特定的种类值。
				        仅在使用 Universal/Exuberant ctags 或 hdrtag 生成的标签文件时可用。
			static		文件特定的标签。有关更多信息，请参阅 |static-tag|。
		根据标签文件的内容，可能存在更多条目：access、implementation、inherits 和 signature。
		有关这些字段的信息，请参阅 ctags 文档。
		对于 C 代码，可能会出现 "struct"、"class" 和 "enum" 字段，它们给出标签所包含实体的名称。

		ex-command "cmd" 可以是 ex 搜索模式、行号或后跟字节号的行号。

		如果没有匹配的标签，则返回空列表。

		要获得精确的标签匹配，应在 {expr} 中使用锚点 '^' 和 '$'。这也使函数工作更快。
		有关标签搜索正则表达式模式的更多信息，请参阅 |tag-regexp|。

		有关 Vim 如何定位标签文件的信息，请参阅 'tags'。
		有关不同 ctags 工具生成的标签文件格式，请参阅 |tags-file-format|。

                参数: ~
                  • {expr} (`任何类型`)
                  • {filename} (`字符串?`)

                返回: ~
                  (`任何类型`)

tan({expr})                                                              *tan()*
		返回 {expr} 的正切值，以弧度为单位，作为范围 [-inf, inf] 中的 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo tan(10)
<			0.648361 >vim
			echo tan(-4.01)
<			-1.181502

                参数: ~
                  • {expr} (`数字`)

                返回: ~
                  (`数字`)

tanh({expr})                                                            *tanh()*
		返回 {expr} 的双曲正切值作为范围 [-1, 1] 中的 |Float|。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo tanh(0.5)
<			0.462117 >vim
			echo tanh(-1)
<			-0.761594

                参数: ~
                  • {expr} (`数字`)

                返回: ~
                  (`数字`)

tempname()                                                          *tempname()*
		生成一个（不存在的）文件名，位于 Nvim 根 |tempdir| 中。
		脚本可以使用该文件名作为临时文件。
		示例： >vim
			let tmpfile = tempname()
			exe "redir > " .. tmpfile
<

                返回: ~
                  (`字符串`)

test_garbagecollect_now()                            *test_garbagecollect_now()*
		类似于 |garbagecollect()|，但立即执行。
		必须直接调用以避免任何结构内部存在，并且在调用任何函数之前必须设置 |v:testing|。   *E1142*

                返回: ~
                  (`任何类型`)

timer_info([{id}])                                                *timer_info()*
		返回包含有关计时器信息的列表。
		当给定 {id} 时，仅返回有关此计时器的信息。
		当计时器 {id} 不存在时，返回空列表。
		当省略 {id} 时，返回所有计时器的信息。

		对于每个计时器，信息存储在一个 |Dictionary| 中，包含以下项：
		    "id"	    计时器 ID
		    "time"	    启动计时器的时间
		    "repeat"	    计时器还将触发的次数；
				    -1 表示永远
		    "callback"	    回调函数

                参数: ~
                  • {id} (`整数?`)

                返回: ~
                  (`任何类型`)

timer_pause({timer}, {paused})                                   *timer_pause()*
		暂停或取消暂停计时器。暂停的计时器在其时间到期时不会调用其回调。
		取消暂停计时器可能导致回调几乎立即调用，如果已经过了足够的时间。

		暂停计时器对于避免在短时间内调用回调很有用。

		如果 {paused} 计算结果为非零数字或非空字符串，则暂停计时器，否则取消暂停。
		参见 |non-zero-arg|。

                参数: ~
                  • {timer} (`整数`)
                  • {paused} (`布尔值`)

                返回: ~
                  (`任何类型`)

timer_start({time}, {callback} [, {options}])              *timer_start()* *timer*
		创建一个计时器并返回计时器 ID。

		{time} 是等待时间，以毫秒为单位。这是调用回调前的最短时间。
		当系统繁忙或 Vim 未等待输入时，时间会更长。
		零可用于在 Vim 返回到主循环时执行回调。

		{callback} 是要调用的函数。它可以是函数名或 |Funcref|。
		它使用一个参数调用，该参数是计时器 ID。
		仅当 Vim 等待输入时才会调用回调。

		{options} 是一个字典。支持的条目：
		   "repeat"	重复回调的次数。
				-1 表示永远。默认为 1。
				如果计时器连续三次导致错误，则取消重复。

		出错时返回 -1。

		示例： >vim
			func MyHandler(timer)
			  echo 'Handler called'
			endfunc
			let timer = timer_start(500, 'MyHandler',
				\ {'repeat': 3})
<		这将在 500 毫秒间隔内调用 MyHandler() 三次。

                参数: ~
                  • {time} (`数字`)
                  • {callback} (`字符串|函数`)
                  • {options} (`表?`)

                返回: ~
                  (`任何类型`)

timer_stop({timer})                                               *timer_stop()*
		停止计时器。计时器回调将不再被调用。
		{timer} 是 timer_start() 返回的 ID，因此它必须是数字。
		如果 {timer} 不存在，则不会报错。

                参数: ~
                  • {timer} (`整数`)

                返回: ~
                  (`任何类型`)

timer_stopall()                                                *timer_stopall()*
		停止所有计时器。计时器回调将不再被调用。
		如果某些计时器行为异常，这很有用。
		如果没有计时器，则不会报错。

                返回: ~
                  (`任何类型`)

tolower({expr})                                                      *tolower()*
		结果是给定字符串的副本，其中所有大写字符转换为小写（就像对字符串应用 |gu| 一样）。
		出错时返回空字符串。

                参数: ~
                  • {expr} (`字符串`)

                返回: ~
                  (`字符串`)

toupper({expr})                                                      *toupper()*
		结果是给定字符串的副本，其中所有小写字符转换为大写（就像对字符串应用 |gU| 一样）。
		出错时返回空字符串。

                参数: ~
                  • {expr} (`字符串`)

                返回: ~
                  (`字符串`)

tr({src}, {fromstr}, {tostr})                                             *tr()*
		结果是 {src} 字符串的副本，其中所有出现在 {fromstr} 中的字符替换为 {tostr} 字符串中该位置的字符。
		因此，{fromstr} 中的第一个字符被翻译为 {tostr} 中的第一个字符，依此类推。
		完全类似于 unix "tr" 命令。
		此代码还正确处理多字节字符。

		出错时返回空字符串。

		示例： >vim
			echo tr("hello there", "ht", "HT")
<		返回 "Hello THere" >vim
			echo tr("<blob>", "<>", "{}")
<		返回 "{blob}"

                参数: ~
                  • {src} (`字符串`)
                  • {fromstr} (`字符串`)
                  • {tostr} (`字符串`)

                返回: ~
                  (`字符串`)

trim({text} [, {mask} [, {dir}]])                                       *trim()*
		返回 {text} 作为字符串，其中从 {text} 的开头和/或结尾移除 {mask} 中的任何字符。

		如果未给出 {mask}，或为空字符串，则 {mask} 是所有直到 0x20 的字符，
		包括 Tab、空格、NL 和 CR，以及非换行空格字符 0xa0。

		可选的 {dir} 参数指定从何处移除字符：
			0	从 {text} 的开头和结尾移除
			1	仅在 {text} 的开头移除
			2	仅在 {text} 的结尾移除
		省略时，两端都会被修整。

		此函数正确处理多字节字符。
		出错时返回空字符串。

		示例： >vim
			echo trim("   some text ")
<		返回 "some text" >vim
			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") .. "_TAIL"
<		返回 "RESERVE_TAIL" >vim
			echo trim("rm<Xrm<>X>rrm", "rm<>")
<		返回 "Xrm<>X"（中间的字符不会被移除） >vim
			echo trim("  vim  ", " ", 2)
<		返回 "  vim"

                参数: ~
                  • {text} (`字符串`)
                  • {mask} (`字符串?`)
                  • {dir} (`0|1|2?`)

                返回: ~
                  (`字符串`)

trunc({expr})                                                          *trunc()*
		返回幅度小于或等于 {expr} 的最大整数值作为 |Float|（向零截断）。
		{expr} 必须计算为 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，则返回 0.0。
		示例： >vim
			echo trunc(1.456)
<			1.0  >vim
			echo trunc(-5.456)
<			-5.0  >vim
			echo trunc(4.0)
<			4.0

                参数: ~
                  • {expr} (`数字`)

                返回: ~
                  (`整数`)

type({expr})                                                            *type()*
		结果是一个数字，表示 {expr} 的类型。
		最好不要直接使用数字，而是使用具有该值的 v:t_ 变量：
			Number:	    0  |v:t_number|
			String:	    1  |v:t_string|
			Funcref:    2  |v:t_func|
			List:	    3  |v:t_list|
			Dictionary: 4  |v:t_dict|
			Float:	    5  |v:t_float|
			Boolean:    6  |v:t_bool| (|v:false| 和 |v:true|)
			Null:	    7  (|v:null|)
			Blob:	   10  |v:t_blob|
		为了向后兼容，可以使用此方法： >vim
			if type(myvar) == type(0) | endif
			if type(myvar) == type("") | endif
			if type(myvar) == type(function("tr")) | endif
			if type(myvar) == type([]) | endif
			if type(myvar) == type({}) | endif
			if type(myvar) == type(0.0) | endif
			if type(myvar) == type(v:true) | endif
<		代替检查 |v:null| 类型，最好直接检查 |v:null|，因为它是此类型的唯一值： >vim
			if myvar is v:null | endif
<		要检查 v:t_ 变量是否存在，请使用： >vim
			if exists('v:t_number') | endif
<

                参数: ~
                  • {expr} (`任何类型`)

                返回: ~
                  (`整数`)

undofile({name})                                                    *undofile()*
		返回将用于名为 {name} 的文件写入时的撤销文件的名称。
		这使用 'undodir' 选项，查找存在的目录。它不检查撤销文件是否存在。
		{name} 总是扩展为完整路径，因为这是内部使用的。
		如果 {name} 为空，undofile() 返回空字符串，因为没有文件名的缓冲区不会写入撤销文件。
		与 |:wundo| 和 |:rundo| 结合使用很有用。

                参数: ~
                  • {name} (`字符串`)

                返回: ~
                  (`字符串`)

undotree([{buf}])                                                   *undotree()*
		返回当前缓冲区的撤销树的当前状态，或者如果给定 {buf}，则返回特定缓冲区的状态。
		结果是一个包含以下项的字典：
		  "seq_last"	使用的最高撤销序列号。
		  "seq_cur"	撤销树中当前位置的序列号。
				当某些更改被撤销时，这与 "seq_last" 不同。
		  "time_cur"	最后用于 |:earlier| 和相关命令的时间。
				使用 |strftime()| 转换为可读形式。
		  "save_last"	最后文件写入的编号。尚未写入时为零。
		  "save_cur"	撤销树中当前位置的编号。
		  "synced"	当最后一个撤销块已同步时为非零。
				这在等待用户输入时发生。参见 |undo-blocks|。
		  "entries"	包含有关撤销块信息的字典列表。

		"entries" 列表中的第一项是最旧的撤销项。
		每个列表项是一个 |Dictionary|，包含以下项：
		  "seq"		撤销序列号。与 |:undolist| 中出现的相同。
		  "time"	更改发生的时间戳。
				使用 |strftime()| 转换为可读形式。
		  "newhead"	仅出现在最后添加的项中。
				这标记了最后一次更改以及将进一步添加更改的位置。
		  "curhead"	仅出现在最后撤销的项中。
				这标记了撤销树中的当前位置，即重做命令将使用的块。
				如果在最后一次更改后没有撤销任何内容，则此项不会出现在任何地方。
		  "save"	仅出现在文件写入前的最后一个块上。
				数字是写入计数。
				第一次写入编号为 1，最后一次写入是上面提到的 "save_last"。
		  "alt"		备用条目。这又是一个撤销块列表。
				每个项可能又有一个 "alt" 项。

                参数: ~
                  • {buf} (`整数|字符串?`)

                返回: ~
                  (`vim.fn.undotree.ret`)

uniq({list} [, {func} [, {dict}]])                                 *uniq()* *E882*
		注意：在 Lua 中优先使用 |vim.list.unique()|。

		就地移除 {list} 中重复相邻项的第二份和后续副本。返回 {list}。
		如果您希望列表保持不变，请先复制： >vim
			let newlist = uniq(copy(mylist))
<		默认比较函数使用每个项的字符串表示。
		关于 {func} 和 {dict} 的使用，请参见 |sort()|。
		关于去重当前缓冲区中的文本，请参见 |:uniq|。

		如果 {list} 不是 |List|，则返回零。

                参数: ~
                  • {list} (`任何类型`)
                  • {func} (`任何?`)
                  • {dict} (`任何?`)

                返回: ~
                  (`任何[]|0`)


utf16idx({string}, {idx} [, {countcc} [, {charidx}]])               *utf16idx()*
		与 |charidx()| 相同，但返回 {string} 中位于 {idx} 的字节的 UTF-16 代码单元索引（在将其转换为 UTF-16 之后）。

		当存在 {charidx} 且为 TRUE 时，{idx} 被用作字符串 {string} 中的字符索引，而不是字节索引。
		位于 UTF-8 序列中间的 {idx} 会向下舍入到该序列的开头。

		如果参数无效，或者 {string} 中的字节数少于 {idx}，则返回 -1。如果正好有 {idx} 个字节，则返回字符串的 UTF-16 代码单元长度。

		有关从 UTF-16 索引获取字节索引，请参阅 |byteidx()| 和 |byteidxcomp()|；有关从 UTF-16 索引获取字符索引，请参阅 |charidx()|。
		更多信息请参考 |string-offset-encoding|。
		示例: >vim
			echo utf16idx('a😊😊', 3)	" 返回 2
			echo utf16idx('a😊😊', 7)	" 返回 4
			echo utf16idx('a😊😊', 1, 0, 1)	" 返回 2
			echo utf16idx('a😊😊', 2, 0, 1)	" 返回 4
			echo utf16idx('aą́c', 6)		" 返回 2
			echo utf16idx('aą́c', 6, 1)	" 返回 4
			echo utf16idx('a😊😊', 9)	" 返回 -1
<

                参数: ~
                  • {string} (`string`)
                  • {idx} (`integer`)
                  • {countcc} (`boolean?`)
                  • {charidx} (`boolean?`)

                返回值: ~
                  (`integer`)

values({dict})                                                        *values()*
		返回一个包含 {dict} 所有值的 |List|。该 |List| 的顺序是任意的。另请参阅 |items()| 和 |keys()|。
		如果 {dict} 不是 |Dict|，则返回零。

                参数: ~
                  • {dict} (`any`)

                返回值: ~
                  (`any`)

virtcol({expr} [, {list} [, {winid}]])                               *virtcol()*
		结果是一个数字（Number），它是给定 {expr} 文件位置所在的屏幕列。也就是说，当屏幕宽度无限时，该位置字符占据的最后一个屏幕位置。
		如果该位置是一个 <Tab>，返回的数字将是 <Tab> 末尾的列。例如，对于位于第 1 列的 <Tab>，且 'ts' 设置为 8，它将返回 8。|conceal| 被忽略。
		关于字节位置，请使用 |col()|。

		关于 {expr} 的使用，请参阅 |getpos()| 和 |col()|。
		当 {expr} 是 "$" 时，它表示光标行的末尾，因此结果是光标行中的单元格数加一。

		当使用 'virtualedit' 时，{expr} 可以是 [lnum, col, off]，其中 "off" 是从字符起始处算起的屏幕列偏移量。例如，位于 <Tab> 内或最后一个字符之后的位置。当省略 "off" 时，使用零。
		当虚拟编辑在当前模式下激活时，可以返回超出行尾的位置。另请参阅 'virtualedit'

		如果 {list} 存在且非零，则 virtcol() 返回一个列表，包含该字符占据的第一个和最后一个屏幕位置。

		使用可选的 {winid} 参数，可以获取该窗口的值，而不是当前窗口的值。

		注意只能使用当前文件中的标记。
		示例: >vim
			" 文本为 "foo^Lbar" 且光标在 "^L" 上:

			echo virtcol(".")	" 返回 5
			echo virtcol(".", 1)	" 返回 [4, 5]
			echo virtcol("$")	" 返回 9

			" 文本为 "	  there"，光标在 'h' 上 (标记 't'):

			echo virtcol("'t")	" 返回 6
<
		第一列是 1。出错时返回 0 或 [0, 0]。

		一个更高级的示例，回显所有行的最大长度: >vim
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))
<

                参数: ~
                  • {expr} (`string|any[]`)
                  • {list} (`boolean?`)
                  • {winid} (`integer?`)

                返回值: ~
                  (`integer|[integer, integer]`)

virtcol2col({winid}, {lnum}, {col})                              *virtcol2col()*
		结果是一个数字（Number），它是窗口 {winid} 中缓冲区行 {lnum} 和虚拟列 {col} 处的字符的字节索引。

		如果缓冲区行 {lnum} 是空行，则返回 0。

		如果 {col} 大于行 {lnum} 中的最后一个虚拟列，则返回最后一个虚拟列处字符的字节索引。

		对于多字节字符，返回该字符第一个字节的列号。

		{winid} 参数可以是窗口编号或 |window-ID|。如果为零，则使用当前窗口。

		如果窗口 {winid} 不存在，或者缓冲区行 {lnum} 或虚拟列 {col} 无效，则返回 -1。

		另请参阅 |screenpos()|、|virtcol()| 和 |col()|。

                参数: ~
                  • {winid} (`integer`)
                  • {lnum} (`integer`)
                  • {col} (`integer`)

                返回值: ~
                  (`integer`)

visualmode([{expr}])                                              *visualmode()*
		结果是一个字符串（String），它描述了当前缓冲区中最后使用的 Visual 模式。最初它返回一个空字符串，但一旦使用过 Visual 模式，它将分别返回 "v"、"V" 或 "<CTRL-V>"（单个 CTRL-V 字符）来表示字符方式、行方式或块方式的 Visual 模式。
		示例: >vim
			exe "normal " .. visualmode()
<		这将进入与之前相同的 Visual 模式。如果你希望根据所使用的 Visual 模式进行不同的操作，这在脚本中也很有用。
		如果 Visual 模式处于活动状态，请使用 |mode()| 来获取 Visual 模式（例如，在 |:vmap| 中）。
		如果提供了 {expr} 并且其计算结果为非零数字或非空字符串，则将清除 Visual 模式并返回旧值。请参阅 |non-zero-arg|。

                参数: ~
                  • {expr} (`boolean?`)

                返回值: ~
                  (`string`)

wait({timeout}, {condition} [, {interval}])                             *wait()*
		等待直到 {condition} 的计算结果为 |TRUE|，其中 {condition} 是一个 |Funcref| 或包含表达式的 |string|。

		{timeout} 是最大等待时间（毫秒），-1 表示永远等待。

		条件会在用户事件、内部事件以及每 {interval} 毫秒（默认值：200）评估一次。

		返回一个状态整数：
			0 如果条件在超时前得到满足
			-1 如果超过超时时间
			-2 如果函数被中断（通过 |CTRL-C|）
			-3 如果发生错误

                参数: ~
                  • {timeout} (`integer`)
                  • {condition} (`any`)
                  • {interval} (`number?`)

                返回值: ~
                  (`any`)

wildmenumode()                                                  *wildmenumode()*
		当 wildmenu 处于活动状态时返回 |TRUE|，否则返回 |FALSE|。请参阅 'wildmenu' 和 'wildmode'。
		这可以用于映射中，以优雅地处理 'wildcharm' 选项。（仅对 |mapmode-c| 映射有意义）。

		例如，要使 <c-j> 在 wildmode 中像 <down> 一样工作，请使用: >vim
		    cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		（注意：这需要适当地设置 'wildcharm' 选项）。

                返回值: ~
                  (`any`)

wildtrigger()                                                    *wildtrigger()*
		在命令行中启动通配符扩展，使用由 'wildmode' 和 'wildoptions' 设置定义的行为。
		请参阅 |cmdline-completion|。

		此函数还启用了搜索模式中的补全，例如 |/|、|?|、|:s|、|:g|、|:v| 和 |:vimgrep|。

		与手动按下 'wildchar' 不同，此函数在未找到匹配项时不会产生蜂鸣声，并且通常操作更安静。这使得它适合自动触发补全，例如从 |:autocmd| 中触发。
						*cmdline-autocompletion*
		示例：要在键入命令行时自动弹出补全菜单，请使用: >vim
			autocmd CmdlineChanged [:/\?] call wildtrigger()
			set wildmode=noselect:lastused,full wildoptions=pum
<
		要保留正常的历史记录导航（向上/向下键）: >vim
			cnoremap <Up>   <C-U><Up>
			cnoremap <Down> <C-U><Down>
<
		要专门在执行搜索时设置选项，例如设置 'pumheight': >vim
			autocmd CmdlineEnter [/\?] set pumheight=8
			autocmd CmdlineLeave [/\?] set pumheight&
<
		返回值始终为 0。

                返回值: ~
                  (`number`)

win_execute({id}, {command} [, {silent}])                        *win_execute()*
		类似于 `execute()`，但在窗口 {id} 的上下文中执行。
		该窗口将临时成为当前窗口，不会触发自动命令或更改目录。执行 {command} 时将触发自动命令，这可能会产生意外的副作用。如果需要，请使用 `:noautocmd`。
		示例: >vim
			call win_execute(winid, 'syntax enable')
<		使用 `setwinvar()` 做同样的事情不会触发自动命令，也不会实际显示语法高亮。

		当窗口 {id} 不存在时，不会给出错误，并返回一个空字符串。

                参数: ~
                  • {id} (`integer`)
                  • {command} (`string`)
                  • {silent} (`boolean?`)

                返回值: ~
                  (`any`)

win_findbuf({bufnr})                                             *win_findbuf()*
		返回一个包含包含缓冲区 {bufnr} 的窗口的 |window-ID| 的 |List|。如果没有这样的窗口，则列表为空。

                参数: ~
                  • {bufnr} (`integer`)

                返回值: ~
                  (`integer[]`)

win_getid([{win} [, {tab}]])                                       *win_getid()*
		获取指定窗口的 |window-ID|。
		当 {win} 缺失时，使用当前窗口。
		使用 {win} 时，这是窗口编号。顶部窗口的编号为 1。
		没有 {tab} 时使用当前标签页，否则使用编号为 {tab} 的标签页。第一个标签页的编号为一。
		如果找不到窗口，则返回零。

                参数: ~
                  • {win} (`integer?`)
                  • {tab} (`integer?`)

                返回值: ~
                  (`integer`)

win_gettype([{nr}])                                              *win_gettype()*
		返回窗口的类型：
			"autocmd"	自动命令窗口。用于执行自动命令的临时窗口。
			"command"	命令行窗口 |cmdwin|
			(empty)		普通窗口
			"loclist"	|location-list-window|
			"popup"		浮动窗口 |api-floatwin|
			"preview"	预览窗口 |preview-window|
			"quickfix"	|quickfix-window|
			"unknown"	未找到窗口 {nr}

		当省略 {nr} 时，返回当前窗口的类型。
		当给定 {nr} 时，按编号或 |window-ID| 返回该窗口的类型。

		另请参阅 'buftype' 选项。

                参数: ~
                  • {nr} (`integer?`)

                返回值: ~
                  (`'autocmd'|'command'|''|'loclist'|'popup'|'preview'|'quickfix'|'unknown'`)

win_gotoid({expr})                                                *win_gotoid()*
		跳转到 ID 为 {expr} 的窗口。这也可能会更改当前标签页。
		如果成功返回 TRUE，如果找不到窗口则返回 FALSE。

                参数: ~
                  • {expr} (`integer`)

                返回值: ~
                  (`0|1`)

win_id2tabwin({expr})                                          *win_id2tabwin()*
		返回一个列表，包含 ID 为 {expr} 的窗口的标签页编号和窗口编号：[tabnr, winnr]。
		如果找不到该窗口，则返回 [0, 0]。

                参数: ~
                  • {expr} (`integer`)

                返回值: ~
                  (`any`)

win_id2win({expr})                                                *win_id2win()*
		返回 ID 为 {expr} 的窗口的窗口编号。
		如果在当前标签页中找不到该窗口，则返回 0。

                参数: ~
                  • {expr} (`integer`)

                返回值: ~
                  (`integer`)

win_move_separator({nr}, {offset})                        *win_move_separator()*
		移动窗口 {nr} 的垂直分隔符（即右边框）{offset} 列，就像用鼠标拖动一样。{nr} 可以是窗口编号或 |window-ID|。正的 {offset} 向右移动，负的 {offset} 向左移动。移动窗口的垂直分隔符将改变该窗口的宽度以及与该垂直分隔符相邻的其他窗口的宽度。移动的幅度可能小于指定的值（例如，作为维持 'winminwidth' 的结果）。如果找到窗口则返回 TRUE，否则返回 FALSE。
		这对于最右边的窗口和全宽窗口将失败，因为它右侧没有分隔符。
		仅适用于当前标签页。*E1308*

                参数: ~
                  • {nr} (`integer`)
                  • {offset} (`integer`)

                返回值: ~
                  (`any`)

win_move_statusline({nr}, {offset})                      *win_move_statusline()*
		移动窗口 {nr} 的状态行（即底边框）{offset} 行，就像用鼠标拖动一样。{nr} 可以是窗口编号或 |window-ID|。正的 {offset} 向下移动，负的 {offset} 向上移动。移动窗口的状态行将改变该窗口的高度以及与该状态行相邻的其他窗口的高度。移动的幅度可能小于指定的值（例如，作为维持 'winminheight' 的结果）。如果找到窗口则返回 TRUE，否则返回 FALSE。
		仅适用于当前标签页。

                参数: ~
                  • {nr} (`integer`)
                  • {offset} (`integer`)

                返回值: ~
                  (`any`)

win_screenpos({nr})                                            *win_screenpos()*
		将窗口 {nr} 的屏幕位置作为一个包含两个数字的列表返回：[行, 列]。第一个窗口的位置始终是 [1, 1]，除非存在标签行（tabline），那么它是 [2, 1]。
		{nr} 可以是窗口编号或 |window-ID|。使用零表示当前窗口。
		如果找不到窗口，则返回 [0, 0]。

                参数: ~
                  • {nr} (`integer`)

                返回值: ~
                  (`any`)

win_splitmove({nr}, {target} [, {options}])                    *win_splitmove()*
		临时切换到窗口 {target}，然后将窗口 {nr} 移动到与 {target} 相邻的新分割中。
		与 |:split| 等命令不同，不会创建新窗口（移动后窗口 {nr} 的 |window-ID| 保持不变）。

		{nr} 和 {target} 都可以是窗口编号或 |window-ID|。两者必须在当前标签页中。

		成功返回零，失败返回非零。

		{options} 是一个 |Dictionary|，包含以下可选条目：
		  "vertical"	为 TRUE 时，垂直创建分割，类似于 |:vsplit|。
		  "rightbelow"	为 TRUE 时，分割创建在下方或右侧（如果是垂直的）。为 FALSE 时，创建在上方或左侧（如果是垂直的）。如果未指定，则使用 'splitbelow' 和 'splitright' 的值。

                参数: ~
                  • {nr} (`integer`)
                  • {target} (`integer`)
                  • {options} (`table?`)

                返回值: ~
                  (`any`)

winbufnr({nr})                                                      *winbufnr()*
		结果是一个数字（Number），它是与窗口 {nr} 关联的缓冲区编号。{nr} 可以是窗口编号或 |window-ID|。
		当 {nr} 为零时，返回当前窗口中的缓冲区编号。
		当窗口 {nr} 不存在时，返回 -1。
		示例: >vim
		  echo "The file in the current window is " .. bufname(winbufnr(0))
<

                参数: ~
                  • {nr} (`integer`)

                返回值: ~
                  (`integer`)

wincol()                                                              *wincol()*
		结果是一个数字（Number），它是光标在窗口中的虚拟列。这是从窗口左侧开始计算的屏幕单元格数。最左边的列为一。

                返回值: ~
                  (`integer`)

windowsversion()                                              *windowsversion()*
		结果是一个字符串（String）。对于 MS-Windows，它指示操作系统版本。例如，Windows 10 是 "10.0"，Windows 8 是 "6.2"，Windows XP 是 "5.1"。对于非 MS-Windows 系统，结果是一个空字符串。

                返回值: ~
                  (`string`)

winheight({nr})                                                    *winheight()*
		获取 |window-ID| 为 {nr} 的窗口的高度（零表示“当前窗口”），不包括任何 'winbar' 和 'statusline'。如果窗口 {nr} 不存在，则返回 -1。一个存在的窗口总是具有零或更大的高度。

		示例: >vim
		  echo "Current window has " .. winheight(0) .. " lines."
<

                参数: ~
                  • {nr} (`integer`)

                返回值: ~
                  (`integer`)

winlayout([{tabnr}])                                               *winlayout()*
		结果是一个嵌套的列表（List），包含标签页中窗口的布局。

		没有 {tabnr} 时使用当前标签页，否则使用编号为 {tabnr} 的标签页。如果未找到标签页 {tabnr}，则返回一个空列表。

		对于一个叶子窗口，它返回: >
			["leaf", {winid}]
<
		对于水平分割的窗口（它们形成一列），它返回: >
			["col", [{嵌套的窗口列表}]]
<		对于垂直分割的窗口（它们形成一行），它返回: >
			["row", [{嵌套的窗口列表}]]
<
		示例: >vim
			" 标签页中只有一个窗口
			echo winlayout()
<		 >
			['leaf', 1000]
<		 >vim
			" 两个水平分割的窗口
			echo winlayout()
<		 >
			['col', [['leaf', 1000], ['leaf', 1001]]]
<		 >vim
			" 第二个标签页，有三个水平分割的窗口，中间窗口有两个垂直分割的窗口
			echo winlayout(2)
<		 >
			['col', [['leaf', 1002], ['row', [['leaf', 1003],
					    ['leaf', 1001]]], ['leaf', 1000]]]
<

                参数: ~
                  • {tabnr} (`integer?`)

                返回值: ~
                  (`vim.fn.winlayout.ret`)


winline()                                                            *winline()*
		结果是一个数字（Number），它是光标在窗口中的屏幕行号。这是从窗口顶部开始计算的屏幕行数。第一行为一。
		如果光标被移动，将首先更新文件视图，这可能会导致滚动。

                返回值: ~
                  (`integer`)

winnr([{arg}])                                                         *winnr()*
		结果是一个数字（Number），它是当前窗口的编号。顶部窗口的编号为 1。
		对于隐藏的或不可 |focusable| 的窗口返回零，除非它是当前窗口。

		可选参数 {arg} 支持以下值：
			$	最后一个窗口的编号（窗口总数）。
			#	最后访问的窗口的编号（|CTRL-W_p| 会跳转到的地方）。如果没有前一个窗口或者它在另一个标签页中，则返回 0。在某些情况下可能指当前窗口（例如，在计算 'statusline' 表达式时）。
			{N}j	当前窗口下方第 N 个窗口的编号（|CTRL-W_j| 会跳转到的地方）。
			{N}k	当前窗口上方第 N 个窗口的编号（|CTRL-W_k| 会跳转到的地方）。
			{N}h	当前窗口左侧第 N 个窗口的编号（|CTRL-W_h| 会跳转到的地方）。
			{N}l	当前窗口右侧第 N 个窗口的编号（|CTRL-W_l| 会跳转到的地方）。
		该编号可用于 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。
		当 {arg} 无效时，会给出错误并返回零。
		另请参阅 |tabpagewinnr()| 和 |win_getid()|。
		示例: >vim
			let window_count = winnr('$')
			let prev_window = winnr('#')
			let wnum = winnr('3k')
<

                参数: ~
                  • {arg} (`string|integer?`)

                返回值: ~
                  (`integer`)

winrestcmd()                                                      *winrestcmd()*
		返回一个 |:resize| 命令序列，该序列应能恢复当前的窗口大小。仅当没有窗口被打开或关闭且当前窗口和标签页未更改时才能正常工作。
		示例: >vim
			let cmd = winrestcmd()
			call MessWithWindowSizes()
			exe cmd
<

                返回值: ~
                  (`string`)

winrestview({dict})                                              *winrestview()*
		使用由 |winsaveview()| 返回的 |Dictionary| 来恢复当前窗口的视图。
		注意：{dict} 不必包含 |winsaveview()| 返回的所有值。如果缺少某些值，则不会恢复这些设置。因此你可以使用: >vim
		    call winrestview({'curswant': 4})
<
		这将仅把光标移动的期望列值（curswant，光标在垂直移动时期望移动到的列）设置为第 5 列（是的，是 5），而所有其他设置将保持不变。这在手动设置光标位置时很有用。

		如果你更改了这些值，结果是不可预测的。
		如果窗口大小发生了变化，结果将不会相同。

                参数: ~
                  • {dict} (`vim.fn.winrestview.dict`)

                返回值: ~
                  (`any`)

winsaveview()                                                    *winsaveview()*
		返回一个 |Dictionary|，其中包含用于恢复当前窗口视图的信息。使用 |winrestview()| 来恢复视图。
		如果你有一个在缓冲区中跳转的映射，并且希望返回到原始视图，这将非常有用。
		这不保存折叠信息。使用 'foldenable' 选项可以临时关闭折叠，以便在移动时不会打开折叠。这可能会产生副作用。
		返回值包括：
			lnum		光标行号
			col		光标列（注意：第一列是零，与 |getcurpos()| 返回的不同）
			coladd		用于 'virtualedit' 的光标列偏移量
			curswant	用于垂直移动的列（注意：第一列是零，与 |getcurpos()| 返回的不同）。在 |$| 命令之后，它将是一个等于 |v:maxcol| 的非常大的数字。
			topline		窗口中的第一行
			topfill		填充行，仅在差异模式下存在
			leftcol		显示的第一列；仅在 'wrap' 关闭时使用
			skipcol		跳过的列数
		注意，不会保存选项值。

                返回值: ~
                  (`vim.fn.winsaveview.ret`)

winwidth({nr})                                                      *winwidth()*
		获取 |window-ID| 为 {nr} 的窗口的宽度（零表示“当前窗口”），包括列（|sign-column|、'statuscolumn' 等）。如果窗口 {nr} 不存在，则返回 -1。一个存在的窗口总是具有零或更大的宽度。

		示例: >vim
		  echo "Current window has " .. winwidth(0) .. " columns."
		  if winwidth(0) <= 50
		    50 wincmd |
		  endif
<
		要获取缓冲区的“视口”，请使用 |getwininfo()|: >vim
		    :echo getwininfo(win_getid())[0].width - getwininfo(win_getid())[0].textoff
<
		要获取 Nvim 屏幕大小，请参阅 'columns' 选项。

                参数: ~
                  • {nr} (`integer`)

                返回值: ~
                  (`integer`)

wordcount()                                                        *wordcount()*
		结果是一个包含当前缓冲区的字节/字符/字数统计的字典。这与 |g_CTRL-G| 提供的信息相同。
		返回值包括：
			bytes		缓冲区中的字节数
			chars		缓冲区中的字符数
			words		缓冲区中的单词数
			cursor_bytes   光标位置前的字节数（不在 Visual 模式下）
			cursor_chars   光标位置前的字符数（不在 Visual 模式下）
			cursor_words   光标位置前的单词数（不在 Visual 模式下）
			visual_bytes   视觉选择的字节数（仅在 Visual 模式下）
			visual_chars   视觉选择的字符数（仅在 Visual 模式下）
			visual_words   视觉选择的单词数（仅在 Visual 模式下）

                返回值: ~
                  (`any`)

writefile({object}, {fname} [, {flags}])                           *writefile()*
		当 {object} 是 |List| 时，将其写入文件 {fname}。每个列表项用 NL（换行符）分隔。每个列表项必须是字符串（String）或数字（Number）。
		所有的 NL 字符都被替换为 NUL 字符。
		插入 CR 字符需要在将 {list} 传递给 writefile() 之前完成。

		当 {object} 是 |Blob| 时，将字节原样写入文件 {fname}，即使未指定二进制模式也是如此。

		{flags} 必须是一个字符串（String）。可以识别以下字符：

		'b'  使用二进制模式：最后一个列表项后面不会有 NL。末尾的空项确实会导致文件最后一行的结尾是 NL。

		'a'  使用追加模式，行被追加到文件: >vim
			call writefile(["foo"], "event.log", "a")
			call writefile(["bar"], "event.log", "a")
<
		'D'  在当前函数结束时删除文件。这类似于: >vim
			defer delete({fname})
<		不在函数中时会失败。另请参阅 |:defer|。

		's'  写入文件后调用 fsync()。这会将文件刷新到磁盘（如果可能）。这需要更多时间，但可以避免系统崩溃时丢失文件。

		'S'  不调用 fsync()，即使设置了 'fsync' 选项。

		     当 {flags} 不包含 "S" 或 "s" 时，如果设置了 'fsync' 选项，则会调用 fsync()。

		如果可能，现有文件将被覆盖。

		写入失败时返回 -1，否则返回 0。如果无法创建文件或写入失败，会有错误消息。

		另请参阅 |readfile()|。
		要逐字节复制文件: >vim
			let fl = readfile("foo", "b")
			call writefile(fl, "foocopy", "b")
<

                参数: ~
                  • {object} (`any`)
                  • {fname} (`string`)
                  • {flags} (`string?`)

                返回值: ~
                  (`any`)

xor({expr}, {expr})                                                      *xor()*
		对两个参数进行按位异或运算。参数会被转换为数字。列表（List）、字典（Dict）或浮点数（Float）参数会导致错误。
		另请参阅 `and()` 和 `or()`。
		示例: >vim
			let bits = xor(bits, 0x80)
<

                参数: ~
                  • {expr} (`integer`)
                  • {expr1} (`integer`)

                返回值: ~
                  (`integer`)

==============================================================================
2. 在字符串中匹配模式			*string-match* (字符串匹配)

这是几个函数之间的共同点。如 |pattern| 中解释的正则表达式模式通常用于在缓冲区行中查找匹配。当模式用于在字符串（String）中查找匹配时，几乎所有的工作方式都相同。不同之处在于，字符串被视为一行。当它包含 "\n" 字符时，这对于模式来说不被视为换行符。它可以用模式中的 "\n" 或 "." 来匹配。示例:
>vim
	let a = "aaaa\nxxxx"
	echo matchstr(a, "..\n..")
	" 输出 aa
	" 输出 xx
	echo matchstr(a, "a.x")
	" 输出 a
	" 输出 x

不要忘记 "^" 只会匹配字符串的第一个字符，而 "$" 会匹配字符串的最后一个字符。它们不会在 "\n" 之前或之后匹配。

 vim:tw=78:ts=8:noet:ft=help:norl:
