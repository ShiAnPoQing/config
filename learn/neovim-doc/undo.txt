*undo.txt*      Nvim


		  VIM 参考手册    作者：Bram Moolenaar


撤销和重做						*undo-redo*

基础知识在用户手册的 |02.5| 节中解释。

                                      输入 |gO| 查看目录。

==============================================================================
1. 撤销和重做命令				*undo-commands*

<Undo>		或					*undo* *<Undo>* *u*
u			撤销 [count] 次更改。

							*:u* *:un* *:undo*
:u[ndo]			撤销一次更改。
								*E830*
:u[ndo] {N}		跳转到更改号 {N} 之后。参见 |undo-branches|
			了解 {N} 的含义。

:u[ndo]!		撤销一次更改并从撤销历史中删除它。
								*E5767*
:u[ndo]! {N}		类似于 ":u[ndo] {N}"，但会忘记当前撤销分支中
			直到 {N} 的所有更改。你只能使用 ":undo! {N}"
			在同一撤销分支中向后移动，不能重做或切换到
			不同的撤销分支。

							*CTRL-R*
CTRL-R			重做 [count] 次被撤销的更改。

							*:red* *:redo* *redo*
:red[o]			重做一次被撤销的更改。

							*U*
U			撤销一行上的所有最新更改，即最近一次
			更改所在的行。|U| 本身也算作一次更改，
			因此 |U| 会撤销前一次 |U|。

最近的更改会被记住。你可以使用上面的撤销和重做命令
来将文本恢复到每次更改之前的状态。你也可以再次应用
这些更改，恢复到撤销前的文本。

"U" 命令在撤销/重做中被视为任何其他命令。因此 "u"
命令会撤销 "U" 命令，而 'CTRL-R' 命令会重做它。当
混合使用 "U"、"u" 和 'CTRL-R' 时，你会注意到 "U"
命令会将一行的状态恢复到前一次 "U" 命令之前。这可能
会让人感到困惑。试试看以习惯它。
"U" 命令总是会将缓冲区标记为已更改。当 "U" 将缓冲区
改回未更改状态时，它仍然被视为已更改。使用 "u" 来
撤销更改，直到缓冲区变为未更改状态。

==============================================================================
2. 两种撤销方式					*undo-two-ways*

撤销和重做命令的工作方式取决于 'cpoptions' 中的 'u' 标志。
有 Vim 方式（排除 'u'）和 Vi 兼容方式（包含 'u'）。
在 Vim 方式中，"uu" 撤销两次更改。在 Vi 兼容方式中，
"uu" 什么都不做（撤销一次撤销）。

排除 'u'，Vim 方式：
你可以使用撤销命令回到过去。然后你可以使用重做命令
再次向前。如果在撤销命令之后进行新的更改，
重做将不再可能。

包含 'u'，Vi 兼容方式：
撤销命令撤销前一次更改，也撤销前一次撤销命令。
重做命令重复前一次撤销命令。它不会重复更改命令，
使用 "." 来做到这一点。

示例	Vim 方式			Vi 兼容方式	~
"uu"		撤销两次		无操作
"u CTRL-R"	无操作			撤销两次

理由：Nvi 使用 "." 命令代替 CTRL-R。不幸的是，这
	   不是 Vi 兼容的。例如，在 Vi 中 "dwdwu." 删除两个
	   词，在 Nvi 中它什么都不做。

==============================================================================
3. 撤销块						*undo-blocks*

一个撤销命令通常撤销一个输入的命令，无论该命令
做了多少更改。这些可撤销的更改序列形成一个撤销块。
因此，如果输入的键调用了一个函数，该函数中的所有
命令都会一起被撤销。

如果你想编写一个不创建新的可撤销更改而是与
前一次更改合并的函数或脚本，使用这个命令：

						*:undoj* *:undojoin* *E790*
:undoj[oin]		将进一步的更改与前一个撤销块合并。
			警告：谨慎使用，它可能会阻止用户
			正确撤销更改。不要在撤销或重做后使用。

这在需要中途提示用户时最有用。例如在调用
|getchar()| 的函数中。确保在这之前有一个必须
与之合并的相关更改。

这本身不起作用，因为下一个按键将再次开始新的
更改。但你可以这样做： >

	:undojoin | delete

之后 "u" 命令将撤销删除命令和前一次更改。
					*undo-break* *undo-close-block*
要做相反的事情，为下一次更改使用新的撤销块，在插入模式
中使用 CTRL-G u。如果你想让插入命令可以部分撤销，
这很有用。例如，对于每个句子。|i_CTRL-G_u|

设置 'undolevels' 的值也会关闭撤销块。即使新值
等于旧值。使用 `g:undolevels` 来显式读取和写入
'undolevels' 的全局值。 >
	let &g:undolevels = &g:undolevels

注意，类似的赋值 `let &undolevels=&undolevels` 不会
在本地选项被设置为不同值的情况下保留 'undolevels'
的全局选项值。例如： >
	" 以不同的全局和本地 'undolevels' 值开始。
	let &g:undolevels = 1000
	let &l:undolevels = 2000
	" 这个赋值将全局选项改为 2000：
	let &undolevels = &undolevels

==============================================================================
4. 撤销分支				*undo-branches* *undo-tree*

上面我们只讨论了一条撤销/重做线。但也可以分支。
这发生在你撤销几次更改然后进行新更改时。
被撤销的更改成为一个分支。你可以使用以下命令
转到该分支。

这在用户手册中有解释：|usr_32.txt|。

							*:undol* *:undolist*
:undol[ist]		列出更改树中的叶子。示例：
			   number changes  when               saved ~
			       88      88  2010/01/04 14:25:53
			      108     107  08/07 12:47:51
			      136      46  13:33:01             7
			      166     164  3 seconds ago

			"number" 列是更改号。这个数字
			持续增加，可用于标识特定的
			可撤销更改，参见 |:undo|。
			"changes" 列是从树根到此叶子
			的更改数。
			"when" 列是进行此更改的日期
			和时间。四种可能的格式是：
			    N seconds ago
			    HH:MM:SS             小时、分钟、秒
			    MM/DD HH:MM:SS       同上，带月份和日期
			    YYYY/MM/DD HH:MM:SS  同上，带年份
			"saved" 列指定，如果此更改
			被写入磁盘以及是第几次文件写入。
			这可以与 |:later| 和 |:earlier| 命令
			一起使用。更多细节使用 |undotree()| 函数。

							*g-*
g-			转到较旧的文本状态。带计数重复那么多次。
							*:ea* *:earlier*
:ea[rlier] {count}	转到较旧的文本状态 {count} 次。
:ea[rlier] {N}s		转到大约 {N} 秒前的较旧文本状态。
:ea[rlier] {N}m		转到大约 {N} 分钟前的较旧文本状态。
:ea[rlier] {N}h		转到大约 {N} 小时前的较旧文本状态。
:ea[rlier] {N}d		转到大约 {N} 天前的较旧文本状态。

:ea[rlier] {N}f		转到 {N} 次文件写入前的较旧文本状态。
			如果自上次写入以来有更改，
			":earlier 1f" 将文本恢复到写入时的
			状态。否则它将转到那次写入之前。
			当处于第一次文件写入状态，或文件
			未被写入时，":earlier 1f" 将转到
			第一次更改之前。

							*g+*
g+			转到较新的文本状态。带计数重复那么多次。
							*:lat* *:later*
:lat[er] {count}	转到较新的文本状态 {count} 次。
:lat[er] {N}s		转到大约 {N} 秒后的较新文本状态。
:lat[er] {N}m		转到大约 {N} 分钟后的较新文本状态。
:lat[er] {N}h		转到大约 {N} 小时后的较新文本状态。
:lat[er] {N}d		转到大约 {N} 天后的较新文本状态。

:lat[er] {N}f		转到 {N} 次文件写入后的较新文本状态。
			当处于最后一次文件写入状态时，
			":later 1f" 将转到最新的文本状态。


注意，当撤销信息因 'undolevels' 被清除时，文本状态
将变得不可访问。

当在时间中移动显示多个更改同时发生时，不要感到惊讶。
这发生在通过撤销树移动然后进行新更改时。

示例

从这段文本开始：
	one two three ~

通过按 "x" 三次删除第一个词：
	ne two three ~
	e two three ~
	 two three ~

现在通过按 "u" 三次撤销：
	e two three ~
	ne two three ~
	one two three ~

通过按 "x" 三次删除第二个词：
	one wo three ~
	one o three ~
	one  three ~

现在通过使用 "g-" 三次撤销：
	one o three ~
	one wo three ~
	 two three ~

你现在回到了第一个撤销分支，在删除 "one" 之后。重复
"g-" 现在会带你回到原始文本：
	e two three ~
	ne two three ~
	one two three ~

用 ":later 1h" 跳转到最后一次更改：
	one  three ~

再用 ":earlier 1h" 回到开始：
	one two three ~


注意，使用 "u" 和 CTRL-R 不会让你访问所有可能的文本状态，
而重复 "g-" 和 "g+" 可以。

==============================================================================
5. 撤销持久性		*undo-persistence* *persistent-undo*

当卸载缓冲区时，Vim 通常会销毁为该缓冲区创建的
撤销树。通过设置 'undofile' 选项，Vim 将在你写入
文件时自动保存你的撤销历史，并在你再次编辑文件时
恢复撤销历史。

'undofile' 选项在写入文件后检查，在 BufWritePost
自动命令之前。如果你想控制要为哪些文件写入撤销信息，
你可以使用 BufWritePre 自动命令： >
	au BufWritePre /tmp/* setlocal noundofile

Vim 在单独的撤销文件中保存撤销树，每个编辑的文件一个，
使用一个简单的方案，将文件系统路径直接映射到撤销文件。
Vim 将检测撤销文件是否与为其写入的文件不再同步（使用
文件内容的哈希），并在文件在撤销文件写入后被更改时
忽略它，以防止损坏。如果撤销文件的所有者与编辑文件的
所有者不同，也会忽略撤销文件，除非撤销文件的所有者是
当前用户。设置 'verbose' 以在打开文件时获取有关此的
消息。

撤销文件的位置由 'undodir' 选项控制，默认情况下它们
保存在应用程序数据文件夹中的专用目录中。

你也可以使用 ":wundo" 和 ":rundo" 分别保存和恢复
撤销历史：
							*:wundo* *:rundo*
:wundo[!] {file}
		将撤销历史写入 {file}。
		当 {file} 存在且看起来不像撤销文件
		（文件开头的魔数错误）时，这将失败，
		除非添加了 !。
		如果它存在且看起来像撤销文件，它将被
		覆盖。如果没有撤销历史，将不会写入
		任何内容。
		实现细节：覆盖是通过首先删除现有文件
		然后创建同名的新文件来完成的。因此
		不可能在写保护的目录中覆盖现有的撤销文件。

:rundo {file}	从 {file} 读取撤销历史。

你可以在自动命令中使用这些来明确指定历史文件的
名称。例如： >

	au BufReadPost * call ReadUndo()
	au BufWritePost * call WriteUndo()
	func ReadUndo()
	  if filereadable(expand('%:h') .. '/UNDO/' .. expand('%:t'))
	    rundo %:h/UNDO/%:t
	  endif
	endfunc
	func WriteUndo()
	  let dirname = expand('%:h') .. '/UNDO'
	  if !isdirectory(dirname)
	    call mkdir(dirname)
	  endif
	  wundo %:h/UNDO/%:t
	endfunc

你应该保持 'undofile' 关闭，否则你最终会为每次写入
得到两个撤销文件。

你可以使用 |undofile()| 函数来找出 Vim 将使用的
文件名。

注意，在读取/写入文件和 'undofile' 设置时，大多数
错误将是静默的，除非设置了 'verbose'。使用 :wundo
和 :rundo 你会得到更多错误消息，例如，当文件无法
读取或写入时。

注意：Vim 永远不会删除撤销文件。你需要自己删除它们。

读取现有撤销文件可能因几个原因而失败：
*E822*	无法打开，因为文件权限不允许。
*E823*	文件开头的魔数不匹配。这通常意味着它不是
	撤销文件。
*E824*	撤销文件的版本号表明它是由更新版本的 Vim
	写入的。你需要那个更新版本才能打开它。如果你
	想保留文件中的撤销信息，不要写入缓冲区。
"文件内容已更改，无法使用撤销信息"
	文件文本与写入撤销文件时不同。这意味着
	撤销文件无法使用，它会损坏文本。当 'encoding'
	与写入撤销文件时不同时也会发生这种情况。
*E825*  撤销文件不包含有效内容，无法使用。
"不读取撤销文件，所有者不同"
	撤销文件的所有者与文本文件的所有者不同。
	为了安全起见，不使用撤销文件。

写入撤销文件可能因这些原因而失败：
*E828*	要写入的文件无法创建。也许你在目录中没有
	写入权限。
"无法在 'undodir' 中的任何目录写入撤销文件"
	'undodir' 中的目录都不能使用。
"不会用撤销文件覆盖，无法读取"
	存在与要写入的撤销文件同名的文件，但无法
	读取它。你可能想要删除这个文件或重命名它。
"不会覆盖，这不是撤销文件"
	存在与要写入的撤销文件同名的文件，但它
	不是以正确的魔数开头。你可能想要删除
	这个文件或重命名它。
"跳过撤销文件写入，没有可撤销的内容"
	没有要写入的撤销信息，没有任何更改
	或 'undolevels' 为负。
*E829*	写入撤销文件时发生错误。你可能想要
	再试一次。

==============================================================================
6. 关于撤销的备注					*undo-remarks*

记住的更改数量由 'undolevels' 选项设置。
如果它为零，总是使用 Vi 兼容方式。如果它为负，
则无法撤销。如果你内存不足，使用这个。

							*clear-undo*
当你将 'undolevels' 设置为 -1 时，撤销信息不会立即
清除，这发生在下一次更改时。要强制清除撤销信息，
你可以使用这些命令： >
	:let old_undolevels = &l:undolevels
	:setlocal undolevels=-1
	:exe "normal a \<BS>\<Esc>"
	:let &l:undolevels = old_undolevels
	:unlet old_undolevels

注意使用 `&l:undolevels` 来显式读取 'undolevels' 的
本地值，使用 `:setlocal` 来只更改本地选项（它优先于
相应的全局选项值）。通过使用 `&undolevels` 保存选项值
是不可预测的；它读取本地值（如果已设置）或全局值
（否则）。此外，如果已设置本地值，通过 `:set undolevels`
更改选项将同时更改全局和本地值，需要额外的工作来
保存和恢复两个值。

缓冲区的标记（'a 到 'z）也会被保存和恢复，与文本
一起。

当所有更改都被撤销时，缓冲区不被视为已更改。
然后可以用 ":q" 而不是 ":q!" 退出 Vim。
注意这是相对于文件的最后一次写入。在 ":w" 之后
输入 "u" 实际上会更改缓冲区，与写入的内容相比，
因此缓冲区被视为已更改。

当使用手动 |folding| 时，折叠不会被保存和恢复。
只有完全在折叠内的更改才会保持折叠不变，因为
折叠的第一行和最后一行没有改变。

编号寄存器也可以用于撤销删除。每次你删除文本时，
它会被放入寄存器 "1。寄存器 "1 的内容会移到 "2，
依此类推。寄存器 "9 的内容会丢失。你现在可以用
放置命令获取最近删除的文本：'"1P'。（另外，如果
删除的文本是最后一次删除或复制操作的结果，'P'
或 'p' 也可以工作，因为这放置未命名寄存器的内容）。
你可以用 '"3P' 获取三次删除前的文本。

						*redo-register*
如果你想获取多个已删除文本的部分，你可以使用
重复命令 "." 的特殊功能。它会增加使用的寄存器
编号。所以如果你先做 '"1P'，接下来的 "." 将
导致 '"2P'。重复这将导致所有编号寄存器被插入。

示例：	如果你用 'dd....' 删除文本，可以用
		'"1P....' 恢复。

如果你不知道删除的文本在哪个寄存器中，你可以使用
:display 命令。另一种方法是尝试第一个寄存器 '"1P'，
如果不是你想要的，做 'u.'。这将删除第一次放置的
内容，并为第二个寄存器重复放置命令。重复 'u.'
直到你得到你想要的。

 vim:tw=78:ts=8:noet:ft=help:norl:
