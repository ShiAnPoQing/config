==============================================================================
4. Ex 命令行范围	*cmdline-ranges* *[range]* *E16*

一些 Ex 命令在前面接受一个行范围。这被记为 [range]。
它由一个或多个行说明符组成，用 ',' 或 ';' 分隔。

基础知识在用户手册的 |10.3| 节中说明。

								*:,* *:;*
当用 ';' 分隔时，在解释下一个行说明符之前，光标位置将被设置到该行。
这对于 ',' 不会发生。
示例： >
   4,/this line/
<	从第 4 行到光标行后匹配 "this line" 的行。 >
   5;/that line/
<	从第 5 行到第 5 行后匹配 "that line" 的行。

大多数命令的默认行说明符是光标位置，但命令 ":write" 和 ":global" 的默认是整个缓冲区 (1,$)。

如果给出的行说明符比命令需要的多，当用逗号分隔时，最左边的一个（些）将被忽略，
例如，这个中的 -2,+： >
	:-2,+,-2,. print
<当用分号分隔时，从最左边的说明符到倒数第二个说明符被求和，
例如，-4 + 3 - 1 = -2，在这个中： >
	:-4;+3;-1;+2 print
<

行号可以用以下方式指定：		*:range* *{address}*
	{number}	绝对行号  *E1247*
	.		当前行			   *:.*
	$		缓冲区的最后一行		   *:$*
	%		等于 1,$（整个缓冲区）	   *:%*
	*		等于 '<,'>（最后选择的 Visual 区域的行；见下面的 |:star|）
	'x		标记 x 位置的行		   *:'x*
			（其中 x 是任何 {a-z} 标记）
	'X		标记 X 位置的行		   *:'X*
			（其中 X 是任何 {A-Z0-9} 标记，尽管
			当 X 在另一个缓冲区中时，它不能
			在范围中使用）
	'[		最近一次更改或拉取的第一行	   *:'[*
	']		最近一次更改或拉取的最后一行	   *:']*
	'<		最近一次选择的 Visual 区域的第一行   *:'<*
	'>		最近一次选择的 Visual 区域的最后一行   *:'>*
	''		最近一次跳转之前的位置所在的行，   *:''*
			或最后一个 "m'"/"m`" 命令给出的位置所在的行
			（尽管如果它不在当前缓冲区中，'' 为 1）
	'"		上次退出缓冲区时光标位置所在的行   *:'quote*
	'^		上次停止插入模式时光标位置所在的行   *:'^*
	'.		缓冲区上次更改时光标位置所在的行   *:'.*
	'(		当前句子第一个字符所在的行	   *:'(*
	')		当前句子结束后的第一个字符所在的行   *:')*
	'{		包含光标的段落之前的第一个空行   *:'{*
	'}		包含光标的段落之后的第一个空行   *:'}*
	/{pattern}[/]	下一个匹配 {pattern} 的行	   *:/*
				另见下面的 |:range-pattern|
	?{pattern}[?]	上一个匹配 {pattern} 的行	   *:?*
				另见下面的 |:range-pattern|
	\/		下一个匹配最近搜索模式的行
	\?		上一个匹配最近搜索模式的行
	\&		下一个匹配最近替换模式的行

	注意：“下一行”和“上一行”不包括出现在当前行中的匹配。

						*:range-offset*
每个行说明符后面可以跟一个或多个 '+' 或 '-' 和一个可选的数字。
该值被添加或减去到前面的行号。
所以，例如，'x+2 是包含标记 x 的行之后两行。如果数字被省略，
对于每个 '+' 使用 +1，对于每个 '-' 使用 -1，所以，例如，'x++ 和 'x+2 是同义的。
如果在 '+' 或 '-' 之前没有任何内容，对于 [range] 中的第一个行号，当前行被用作相对起点。
所以，-,. 表示，“当前行之前的一行到当前行”。
[range] 中第二个行号的值取决于行号之间是用逗号还是分号分隔（参见 |:,| 和 |:;|）。
示例：如果光标在下面这一行内，以下任何命令都将打印标签行 ":range-offset" 和该行 "Each..."： >
	:-11;+1 print
	:-----------,-10 print
	:?Each line?-;+ print
	:'{+,'{+2 print
	:'{+1;')-1 print
<						*:range-closed-fold*
当逗号后的行号在闭合折叠中时，它被调整到折叠的最后一行，因此整个折叠被包括在内。

当添加一个数字时，这是在调整到折叠的最后一行之后完成的。
这意味着这些行被额外包括在范围内。例如： >
   :3,4+2print
在这个文本上：
	1 one ~
	2 two ~
	3 three ~
	4 four FOLDED ~
	5 five FOLDED ~
	6 six ~
	7 seven ~
	8 eight ~
其中第 4 和第 5 行是一个闭合折叠，最终打印第 3 到第 7 行。
7 来自范围中的 "4"，它被调整到闭合折叠的末尾，即 5，然后加上偏移量 2。

一个减法的例子（不是很有用）： >
   :2,4-1print
在这个文本上：
	1 one ~
	2 two ~
	3 three FOLDED ~
	4 four FOLDED ~
	5 five FOLDED ~
	6 six FOLDED ~
	7 seven ~
	8 eight ~
其中第 3 到第 6 行是一个闭合折叠，最终打印第 2 到第 6 行。
6 来自范围中的 "4"，它被调整到闭合折叠的末尾，即 6，然后减去 1，然后这仍然在闭合折叠中，使用该折叠的最后一行，即 6。

							*:range-pattern*
{pattern} 后的 "/" 和 "?" 是必需的，用于将模式与后面的任何内容分开。

"/" 和 "?" 可以在前面加上另一个地址。搜索从那里开始。
与使用 ';' 的区别是光标不会移动。
示例： >
	/pat1//pat2/	在包含 "pat1" 的行之后查找包含 "pat2" 的行，而不移动光标。
	7;/pat2/	在第 7 行之后查找包含 "pat2" 的行，将光标留在第 7 行。

{number} 必须在 0 和文件中的行数之间。
当使用 0（零）时，大多数命令将其解释为 1。将其用作计数的命令确实将其用作零（|:tag|、|:pop| 等）。
一些命令将零解释为“第一行之前”（|:read|、搜索模式等）。

示例： >
	.+3		光标后三行
	/that/+1	下一个包含 "that" 的行之后的行
	.,$		从当前行到文件末尾
	0;/that		第一个包含 "that" 的行，也匹配第一行。
	1;/that		第 1 行之后第一个包含 "that" 的行

一些命令允许在命令后使用计数。该计数被用作要使用的行数，从最后一个行说明符给出的行开始（默认为光标行）。
接受计数的命令是那些使用范围但没有文件名参数的命令（因为文件名也可以是数字）。计数不能为负。

示例： >
	:s/x/X/g 5	在当前行和随后的四行中将 'x' 替换为 'X'
	:23d 4		删除第 23、24、25 和 26 行


折叠和范围

当折叠激活时，行号被舍入以包括整个闭合折叠。参见 |fold-behavior|。


反向范围						*E493*

范围应该将较小的行号放在前面。如果不是这种情况，Vim 会询问你是否应该交换行号。
	给出了向后范围，确定要交换吗 ~
这在全局命令 ":g" 中不会完成。

你可以在命令前使用 ":silent" 来避免问题，那时范围将总是被交换。


计数和范围						*N:*

当在输入 ":" 之前给出计数时，这被翻译为： >
		:.,.+(count - 1)
换句话说：光标处及之后的 "count" 行。示例：要删除三行： >
		3:d<CR>		被翻译为： .,.+2d<CR>
<

可视模式和范围
							*v_:*
{Visual}:	用一个命令行开始，将可视选择的行作为范围。
		代码 `:'<,'>` 用于此范围，这使得可以从命令行历史中选择类似的行，
		以便在不同的可视选择行上重复命令。

:*						*:star* *:star-visual-range*
		当可视模式已经结束时，使用可视区域作为范围的一种简短方式是 `:*`。


vim:tw=78:ts=8:noet:ft=help:norl:

