*cmdline.txt*   Nvim


		  VIM 参考手册    作者 Bram Moolenaar


				*Cmdline-mode* *Command-line-mode* *Cmdline*
命令行模式		*cmdline* *Command-line* *mode-cmdline* *:*

命令行模式用于输入 Ex 命令（":"）、搜索模式（"/" 和 "?"）和过滤命令（"!"）。

基本的命令行编辑在用户手册的第 20 章 |usr_20.txt| 中说明。

                                      输入 |gO| 查看目录。

==============================================================================
1. 命令行编辑					*cmdline-editing*

通常字符被插入到光标位置之前。你可以使用左右光标键在命令行中移动。
使用 <Insert> 键，你可以在插入和覆盖字符之间切换。

注意，如果你的键盘没有可用的光标键或其他任何特殊键，你可以使用 ":cnoremap" 为它们定义另一个键。
例如，定义 tcsh 风格的编辑键：		*tcsh-style*  >
	:cnoremap <C-A> <Home>
	:cnoremap <C-F> <Right>
	:cnoremap <C-B> <Left>
	:cnoremap <Esc>b <S-Left>
	:cnoremap <Esc>f <S-Right>
(<> 表示法 |<>|；按字面输入所有内容)

							*cmdline-too-long*
当命令行变得比屏幕上能显示的更长时，只会显示适合的部分。
光标只能在这个可见部分移动，因此你无法编辑超出该部分的内容。

						*cmdline-history* *history*
你输入的命令行被记录在一个历史表中。你可以使用上下光标键重新调用它们。
实际上有五个历史表：

- 一个用于 ':' 命令
- 一个用于搜索字符串
- 一个用于表达式
- 一个为 |input()| 函数输入的输入行
- 一个用于调试模式命令

这些是完全独立的。每个历史只能在输入相同类型的行时访问。
使用 'history' 选项设置要记住的行数。

注意：

- 当你输入一个与旧命令完全相同的命令行时，旧命令会被移除（以避免重复命令将较旧的命令移出历史）。
- 只有键入的命令会被记住。完全来自映射的命令不会放入历史。
- 所有搜索都会被放入搜索历史，包括来自如 "*" 和 "#" 等命令的搜索。
  但对于映射，只记住最后一次搜索（以避免长映射破坏历史）。

命令行上有名称的自动补全；参见 |cmdline-completion|。

							*c_CTRL-V*
CTRL-V		按字面意义插入下一个非数字字符。最多三个数字构成单个字节的十进制值。
		非数字和三个数字不考虑映射。这与插入模式中的工作方式相同（参见上文 |i_CTRL-V|）。
		对于特殊键，CTRL 修饰符可能包含在键中以产生控制字符。
		如果该键没有控制字符，则插入其 |key-notation|。
		注意：在 Windows 下，CTRL-V 通常被映射为粘贴文本。
		那么请使用 CTRL-Q。
							*c_CTRL-Q*
CTRL-Q		与 CTRL-V 相同。但在某些终端上它用于控制流，那时它不起作用。

CTRL-SHIFT-V				*c_CTRL-SHIFT-V* *c_CTRL-SHIFT-Q*
CTRL-SHIFT-Q	工作方式类似 CTRL-V，但不尝试将 CTRL 修饰符包含到键中。
		注意：当 CTRL-SHIFT-V 被你的系统拦截时（例如，用于粘贴文本），
		你通常可以使用 CTRL-SHIFT-Q 代替。
		然而，在某些终端中（例如 GNOME Terminal），CTRL-SHIFT-Q 会不经确认退出终端。

							*c_<Left>* *c_Left*
<Left>		光标左移。关于在 wildmenu 补全模式下的行为，请参见 'wildmenu'。
							*c_<Right>* *c_Right*
<Right>		光标右移。关于在 wildmenu 补全模式下的行为，请参见 'wildmenu'。
							*c_<S-Left>*
<S-Left> 或 <C-Left>					*c_<C-Left>*
		光标向左移动一个 WORD
							*c_<S-Right>*
<S-Right> 或 <C-Right>					*c_<C-Right>*
		光标向右移动一个 WORD
CTRL-B 或 <Home>				*c_CTRL-B* *c_<Home>* *c_Home*
		光标移动到命令行开头
CTRL-E 或 <End>					*c_CTRL-E* *c_<End>* *c_End*
		光标移动到命令行末尾。关于在 wildmenu 补全模式下的行为，请参见 'wildmenu'。

							*c_<LeftMouse>*
<LeftMouse>	将光标移动到鼠标点击的位置。

							*c_<MiddleMouse>*
<MiddleMouse>	粘贴剪贴板的内容（对于 X11 是主选择）。
		这类似于使用 `CTRL-R *`，但行之间不会插入 CR 字符。

CTRL-H						*c_<BS>* *c_CTRL-H* *c_BS*
<BS>		删除光标前的字符。
							*c_<Del>* *c_Del*
<Del>		删除光标下的字符（在行尾时：光标前的字符）。
							*c_CTRL-W*
CTRL-W		删除光标前的 |word|。这取决于 'iskeyword' 选项。
							*c_CTRL-U*
CTRL-U		删除光标位置和行首之间的所有字符。旧版本的 vim
		会删除行上的所有字符。如果这是首选行为，请将以下内容添加到你的 vimrc 中： >
			:cnoremap <C-U> <C-E><C-U>
<
						*c_<Insert>* *c_Insert*
<Insert>	在插入和覆盖之间切换。

{char1} <BS> {char2}	或				*c_digraph*
CTRL-K {char1} {char2}					*c_CTRL-K*
		输入双字符组合（参见 |digraphs|）。当 {char1} 是特殊键时，该键的代码以 <> 形式插入。

CTRL-R {register}					*c_CTRL-R* *c_<C-R>*
		插入编号或命名寄存器的内容。在键入 CTRL-R 和第二个字符之间
		会显示 '"' 表示你应输入寄存器的名称。
		当使用命名或剪贴板寄存器 (A-Z,a-z,0-9,+) 时，
		文本会像用 "p" 粘贴一样按字面插入。对于其他寄存器，
		文本就像你键入它一样被插入，但不使用映射和缩写。
		不会触发通过 'wildchar' 进行的命令行补全。
		并且结束命令行的字符会按字面插入（<Esc>, <CR>, <NL>, <C-C>）。
		但是 <BS> 或 CTRL-W 可能仍然会结束命令行，然后剩余的字符
		将在另一种模式下被解释，这可能不是你的本意。
		特殊寄存器：
			'"'	未命名寄存器，包含最后一次删除或拉取的文本
			'%'	当前文件名
			'#'	备用文件名
			"*"	剪贴板内容（X11：主选择）
			'+'	剪贴板内容
			'/'	最后一次搜索模式
			':'	最后一次命令行
			'-'	最后一次小（少于一行）删除
			'.'	最后一次插入的文本
							*c_CTRL-R_=*
			'='	表达式寄存器：提示你输入一个表达式（参见 |expression|）
				（在表达式提示符下不起作用；不允许某些操作，
				例如更改缓冲区或当前窗口，以避免副作用）
				当结果是 |List| 时，项目被用作行。它们内部也可以有换行符。
				当结果是 Float 时，它会自动转换为 String。
				注意，当你只想移动光标而不插入任何内容时，你必须确保
				表达式求值为空字符串。例如： >
					<C-R><C-R>=setcmdpos(2)[-1]<CR>
<			你可以使用这个来插入一个寄存器，就像用 CTRL-R =@reg 键入的一样。
		关于寄存器，请参见 |registers|。
		实现细节：当使用 |expression| 寄存器并调用 setcmdpos() 时，
		这会在插入结果字符串之前设置位置。使用 CTRL-R CTRL-R 在之后设置位置。

CTRL-R CTRL-F				*c_CTRL-R_CTRL-F* *c_<C-R>_<C-F>*
CTRL-R CTRL-P				*c_CTRL-R_CTRL-P* *c_<C-R>_<C-P>*
CTRL-R CTRL-W				*c_CTRL-R_CTRL-W* *c_<C-R>_<C-W>*
CTRL-R CTRL-A				*c_CTRL-R_CTRL-A* *c_<C-R>_<C-A>*
CTRL-R CTRL-L				*c_CTRL-R_CTRL-L* *c_<C-R>_<C-L>*
		插入光标下的对象：
			CTRL-F	光标下的文件名
			CTRL-P	光标下的文件名，用 'path' 展开，如 |gf|
			CTRL-W	光标下的单词
			CTRL-A	光标下的 WORD；参见 |WORD|
			CTRL-L	光标下的行

		当设置了 'incsearch' 时，使用当前显示匹配项结束时的光标位置。
		对于 CTRL-W，已经键入的单词部分不会再次插入。

					*c_CTRL-R_CTRL-R* *c_<C-R>_<C-R>*
					*c_CTRL-R_CTRL-O* *c_<C-R>_<C-O>*
CTRL-R CTRL-R `{register CTRL-F CTRL-P CTRL-W CTRL-A CTRL-L}`
CTRL-R CTRL-O `{register CTRL-F CTRL-P CTRL-W CTRL-A CTRL-L}`
		插入寄存器或光标下的对象。工作方式类似 |c_CTRL-R| 但按字面插入文本。
		例如，如果寄存器 a 包含 "xy^Hz"（其中 ^H 是退格键），
		"CTRL-R a" 将插入 "xz"，而 "CTRL-R CTRL-R a" 将插入 "xy^Hz"。

CTRL-\ e {expr}						*c_CTRL-\_e*
		计算 {expr} 并用结果替换整个命令行。你将收到输入表达式的提示，
		输入 <Enter> 完成它。不过它在映射中最有用。参见 |expression|。
		关于插入表达式结果，请参见 |c_CTRL-R_=|。
		有用的函数是 |getcmdtype()|、|getcmdline()| 和 |getcmdpos()|。
		光标位置不变，除非光标在行尾，那么它保持在行尾。
		可以使用 |setcmdpos()| 来设置光标位置。
		使用 |sandbox| 来评估表达式以避免讨厌的副作用。
		示例： >
			:cmap <F7> <C-\>eAppendSome()<CR>
			:func AppendSome()
			   :let cmd = getcmdline() .. " Some()"
			   :" 将光标放在 ) 上
			   :call setcmdpos(strlen(cmd))
			   :return cmd
			:endfunc
<		这不能递归工作，因此在已经编辑表达式时不行。但可以在映射中使用。

							*c_CTRL-Y*
CTRL-Y		当存在无模式选择时，将选择复制到剪贴板。
		如果没有选择，CTRL-Y 作为字符插入。
		关于在 wildmenu 补全模式下的行为，请参见 'wildmenu'。

							*c_CTRL-Z*
CTRL-Z		触发 'wildmode'。与 'wildcharm' 相同，但始终可用。

CTRL-M 或 CTRL-J		*c_CTRL-M* *c_CTRL-J* *c_<NL>* *c_<CR>* *c_CR*
<CR> 或 <NL>	开始输入的命令

CTRL-[						*c_CTRL-[* *c_<Esc>* *c_Esc*
<Esc>		当键入且 'cpoptions' 中不存在 'x' 时，退出命令行模式而不执行。
		在宏中或当 'cpoptions' 中存在 'x' 时，开始输入的命令。
		注意：如果你的键盘上 <Esc> 键很难按，训练自己使用 CTRL-[。
						*c_META* *c_ALT*
		ALT (|META|) 如果和弦未被映射，可能像 <Esc> 一样动作。
		例如，如果 <A-x> 没有命令行模式映射，则 <A-x> 像 <Esc>x 一样动作。
							*c_CTRL-C*
CTRL-C		退出命令行而不执行

							*c_<Up>* *c_Up*
<Up>		从历史中召回较旧的命令行，其开头与当前命令行匹配（见下文）。
		关于在 wildmenu 补全模式下的行为，请参见 'wildmenu'。
							*c_<Down>* *c_Down*
<Down>		从历史中召回较新的命令行，其开头与当前命令行匹配（见下文）。
		关于在 wildmenu 补全模式下的行为，请参见 'wildmenu'。

							*c_<S-Up>* *c_<PageUp>*
<S-Up> 或 <PageUp>
		从历史中召回较旧的命令行
						*c_<S-Down>* *c_<PageDown>*
<S-Down> 或 <PageDown>
		从历史中召回较新的命令行

CTRL-D		命令行补全（参见 |cmdline-completion|）
'wildchar' 选项
		命令行补全（参见 |cmdline-completion|）
CTRL-N		命令行补全（参见 |cmdline-completion|）
CTRL-P		命令行补全（参见 |cmdline-completion|）
CTRL-A		命令行补全（参见 |cmdline-completion|）
CTRL-L		命令行补全（参见 |cmdline-completion|）

							*c_CTRL-^*
CTRL-^		切换使用语言 |:lmap| 映射和/或输入法。
		当为搜索命令键入模式且 'imsearch' 不为 -1 时，VAL 是 'imsearch' 的值，
		否则 VAL 是 'iminsert' 的值。
		当定义了语言映射时：
		- 如果 VAL 是 1（使用 langmap 映射）则变为 0（不使用 langmap 映射）。
		- 如果 VAL 不是 1 则变为 1，从而启用 langmap 映射。
		当没有定义语言映射时：
		- 如果 VAL 是 2（使用输入法）则变为 0（不使用输入法）
		- 如果 VAL 有其他值则变为 2，从而启用输入法。
		这些语言映射通常用于键入与键盘产生字符不同的字符。
		'keymap' 选项可用于安装大量这样的映射。
		当输入命令行时，langmap 映射被关闭，因为你期望键入命令。
		用 CTRL-^ 打开后，新状态不会在下一个命令或搜索模式中再次使用。

						*c_CTRL-]*
CTRL-]		触发缩写，而不插入字符。

关于命令行上的 Emacs 风格编辑，请参见 |emacs-keys|。

<Up> 和 <Down> 键将当前命令行作为搜索字符串。
下一个/上一个命令行的开头与该字符串进行比较。第一个匹配的行是新的命令行。
重复键入这两个键时，再次使用相同的字符串。例如，这可以用于找到之前的替换命令：
键入 ":s" 然后按 <Up>。同样可以通过键入 <S-Up> 多次直到显示所需的命令行来完成。
（注意：在所有终端上，移位的箭头键可能不起作用）

							*:his* *:history*
:his[tory]	打印最后输入命令的历史。

:his[tory] [{name}] [{first}][, [{last}]]
		列出历史 {name} 的内容，可以是：
		c[md]   或 :		命令行历史
		s[earch] 或 / 或 ?	搜索字符串历史
		e[xpr]   或 =		表达式寄存器历史
		i[nput]  或 @		输入行历史
		d[ebug]  或 >		调试命令历史
		a[ll]			以上所有

		如果给出了数字 {first} 和/或 {last}，则列出历史中相应的条目范围。
		这些数字可以以下列形式指定：
							*:history-indexing*
		正数表示条目的绝对索引，如 :history 列表第一列中所给。
		即使其他条目被删除，该数字也保持固定。（参见 |E1510|）

		负数表示条目的相对位置，从最新条目（索引为 -1）向后计数。

		示例：
		列出搜索历史中的第 6 到第 12 个条目： >
			:history / 6,12
<
		列出所有历史中的倒数第二个条目： >
			:history all -2
<
		列出所有历史中最近的两个条目： >
			:history all -2,

:keepp[atterns] {command}			*:keepp* *:keeppatterns*
		执行 {command}，不向搜索历史添加任何内容，
		并且在 |:s| 或 |:&| 的情况下，不修改最后一次替换模式或替换字符串。

==============================================================================
2. 命令行补全				*cmdline-completion*

编辑命令行时，可以使用一些命令来补全光标前的单词。这适用于：

- 命令名称：在命令行的开头。
- |++opt| 值。
- 标签：仅在 ":tag" 命令之后。
- 文件名：仅在接受文件名的命令或可以设置为文件名的选项设置之后。
  这称为文件名补全。
- Shell 命令名称：在 ":!cmd"、":r !cmd" 和 ":w !cmd" 之后。使用 $PATH。
- 选项：仅在 ":set" 命令之后。
- 映射：仅在 ":map" 或类似命令之后。
- 变量和函数名称：仅在 ":if"、":call" 或类似命令之后。

帮助项匹配的数量是有限的（目前为 300），以避免当匹配非常多时出现长时间延迟。

关于在你键入时自动补全（无需按像 <Tab> 这样的键），请参见 |cmdline-autocompletion|。

这些是可以使用的命令：

							*c_CTRL-D*
CTRL-D		列出与光标前模式匹配的名称。
		当显示文件名时，目录会被高亮显示（参见 |highlight-groups|）。
		匹配 'suffixes' 的名称被移到末尾。
		可以设置 'wildoptions' 选项为 "tagfile" 来列出匹配标签的文件。
				*c_CTRL-I* *c_wildchar* *c_<Tab>* */_<Tab>*
'wildchar' 选项
		对光标前的模式进行匹配。匹配项（如果有多个，则是第一个匹配项）
		被插入以替换模式。（注意：在宏内不起作用，因为 <Tab> 或 <Esc>
		大多用作 'wildchar'，而这些在某些宏中有特殊含义。）
		当再次键入且存在多个匹配项时，插入下一个匹配项。
		在最后一个匹配项之后，再次使用第一个（循环）。

		在搜索上下文中，使用 <CTRL-V><Tab> 或 "\t" 来搜索字面意义的 <Tab>，而不是触发补全。

		行为可以用 'wildmode' 选项改变。
							*c_<S-Tab>*
<S-Tab>		类似 'wildchar' 或 <Tab>，但从最后一个匹配项开始，然后转到上一个匹配项。
							*c_CTRL-N*
CTRL-N		在使用 'wildchar' 获得多个匹配项后，转到下一个匹配项。
		否则从历史中召回较新的命令行。
							*c_CTRL-P*
CTRL-P		在使用 'wildchar' 获得多个匹配项后，转到上一个匹配项。
		否则从历史中召回较旧的命令行。
							*c_CTRL-A*
CTRL-A		插入所有与光标前模式匹配的名称。
							*c_CTRL-L*
CTRL-L		对光标前的模式进行匹配。如果有一个匹配项，它被插入以替换模式。
		如果有多个匹配项，则插入最长的公共部分以替换模式。
		如果结果比模式短，则不进行补全。
							*/_CTRL-L*
		当设置了 'incsearch' 时，为 "/" 或 "?" 输入搜索模式
		并且当前匹配项被显示，然后 CTRL-L 将从当前匹配项的末尾添加一个字符。
		如果设置了 'ignorecase' 和 'smartcase' 并且命令行没有大写字符，
		则添加的字符将转换为小写。
	                                            *c_CTRL-G* */_CTRL-G*
CTRL-G		当设置了 'incsearch' 时，为 "/" 或 "?" 输入搜索模式
		并且当前匹配项被显示，然后 CTRL-G 将移动到下一个匹配项
		（不考虑 |search-offset|）
		使用 CTRL-T 移动到上一个匹配项。提示：在常规键盘上 G 在 T 下面。
	                                            *c_CTRL-T* */_CTRL-T*
CTRL-T		当设置了 'incsearch' 时，为 "/" 或 "?" 输入搜索模式
		并且当前匹配项被显示，然后 CTRL-T 将移动到上一个匹配项
		（不考虑 |search-offset|）。
		使用 CTRL-G 移动到下一个匹配项。提示：在常规键盘上 T 在 G 上面。

'wildchar' 选项默认为 <Tab>（在 Vi 兼容模式下为 CTRL-E；在旧版本中使用 <Esc>）。
在模式中，匹配文件名时接受标准 |wildcards|。

当重复 'wildchar' 或 CTRL-N 时，你循环遍历匹配项，最终回到键入的内容。
如果第一个匹配项不是你想要的，你可以使用 <S-Tab> 或 CTRL-P 直接回到你键入的内容。

可以设置 'wildmenu' 选项以在命令行上方显示匹配项。

'wildoptions' 选项提供了额外的配置，以使用弹出菜单作为 'wildmenu'，并使用模糊匹配。

可以设置 'wildignorecase' 选项以在文件名中忽略大小写。
对于补全其他文本（例如命令名称），则使用 'ignorecase' 选项（然而模糊匹配总是忽略大小写）。

如果你喜欢 tcsh 的 autolist 补全，你可以使用这个映射： >
	:cnoremap X <C-L><C-D>
（其中 X 是要使用的命令键，<C-L> 是 CTRL-L，<C-D> 是 CTRL-D）
这将找到最长的匹配项，然后列出所有匹配的文件。

如果你喜欢 tcsh 的 autolist 补全，你可以使用 'wildmode' 选项来模拟它。
例如，这模拟了 autolist=ambiguous： >
	:set wildmode=longest,list
这将用第一个 'wildchar' 找到最长的匹配项，然后用下一个列出所有匹配的文件。

					*complete-script-local-functions*
当补全用户函数名时，在前面加上 "s:" 来查找脚本局部函数。

							*suffixes*
对于文件名补全，你可以使用 'suffixes' 选项来设置具有几乎相同名称的文件之间的优先级。
如果有多个匹配项，那些扩展名在 'suffixes' 选项中的文件有时会被忽略。
默认是 ".bak,~,.o,.h,.info,.swp,.obj"，这意味着以 ".bak"、"~"、".o"、".h"、".info"、".swp" 和 ".obj" 结尾的文件有时会被忽略。

一个空条目，两个连续的逗号，匹配一个不包含 "." 的文件名，因此没有后缀。
这对于忽略 "prog" 而偏好 "prog.c" 很有用。

示例：

  模式:		文件:				匹配:	~
  test*	test.c test.h test.o		test.c
  test*	test.h test.o			test.h 和 test.o
  test*	test.i test.h test.c		test.i 和 test.c

忽略带有两个点的后缀是不可能的。

如果有多个匹配文件（在忽略与 'suffixes' 选项匹配的文件之后），则插入第一个文件名。
当你键入 'wildchar' 两次且完成的匹配项保持不变时，你可以看到只有一个匹配项。
你可以通过输入 'wildchar'、CTRL-N 或 CTRL-P 来获得其他匹配项。
所有文件都包括在内，也包括那些扩展名匹配 'suffixes' 选项的文件。

要完全忽略具有某些扩展名的文件，请使用 'wildignore'。

要仅匹配在键入文本末尾结束的文件，请附加一个 "$"。例如，要仅匹配以 ".c" 结尾的文件： >
	:e *.c$
这将不匹配以 ".cpp" 结尾的文件。没有 "$" 则会匹配。

如果你想在 xterm 中使用 <S-Tab> 作为 CTRL-P，请将此命令放入你的 .cshrc 中： >
	xmodmap -e "keysym Tab = Tab Find"
并将这个放入你的 vimrc 中： >
	:cmap <Esc>[1~ <C-P>
<						*complete-set-option*
当使用 |:set=| 设置选项时，可以通过在 '=' 后立即按 'wildchar' 来获取选项的旧值。
例如，在 ":set dir=" 后键入 'wildchar' 将插入 'dir' 的当前值。
这对于接受文件名的选项，这会覆盖文件名补全。

当使用 |:set=|、|:set+=| 或 |:set^=| 时，具有预定义名称或语法（例如 'diffopt'、'listchars'）
或者是单字符标志列表（例如 'shortmess'）的字符串选项在使用 'wildchar' 时也会显示可能的值以供补全。

当使用 |:set-=| 时，像 'diffopt' 或 'backupdir' 这样的逗号分隔选项将分别显示每个项目。
像 'shortmess' 这样的标志列表选项将显示整个旧值和各个标志。
否则补全将只填入整个旧值。

==============================================================================
3. Ex 命令行					*cmdline-lines*

Ex 命令有一些特殊之处：

							*:quote* *:comment*
'"' 在一行的开头导致整行被忽略。'"' 在命令后导致行的其余部分被忽略。
这可用于添加注释。示例： >
	:set ai		"设置 'autoindent' 选项
不可能向 shell 命令 ":!cmd" 或 ":map" 命令和少数其他命令（主要是期望表达式的命令）添加注释，
它们将 '"' 视为其参数的一部分：

    :argdo
    :autocmd
    :bufdo
    :cexpr（及类似命令）
    :cdo（及类似命令）
    :command
    :debug
    :display
    :echo（及类似命令）
    :elseif
    :execute
    :folddoopen
    :folddoclosed
    :for
    :grep（及类似命令）
    :help（及类似命令）
    :if
    :let
    :make
    :map（及类似命令，包括 :abbrev 命令）
    :menu（及类似命令）
    :mkspell
    :normal
    :popup
    :registers
    :return
    :sort
    :syntax
    :tabdo
    :tearoff
    :vimgrep（及类似命令）
    :while
    :windo

							*:bar* *:\bar*
'|' 可用于分隔命令，因此你可以在一个行中给出多个命令。
如果你想在参数中使用 '|'，请在它前面加上 '\'。

这些命令将 '|' 视为其参数，因此后面不能跟另一个 Vim 命令：
    :argdo
    :autocmd
    :bufdo
    :cdo
    :cfdo
    :command
    :debug
    :eval
    :folddoopen
    :folddoclosed
    :function
    :global
    :help
    :helpgrep
    :ldo
    :lfdo
    :lhelpgrep
    :make
    :normal
    :perlfile
    :pyfile
    :python
    :registers
    :read !
    :sign
    :tabdo
    :terminal
    :vglobal
    :windo
    :write !
    :[range]!
    没有 "-bar" 参数的用户定义命令 |:command|

注意这很令人困惑（继承自 Vi）：对于 ":g"，'|' 包含在命令中，对于 ":s" 则不是。

要能够使用另一个命令，请使用 ":execute" 命令。
示例（附加 "ls" 的输出并跳转到第一行）： >
	:execute 'r !ls' | '[

有一个例外：当 'cpoptions' 中存在 'b' 标志时，对于 ":map" 和 ":abbr" 命令及类似命令，
需要使用 CTRL-V 代替 '\'。你也可以使用 "<Bar>" 代替。另见 |map_bar|。

示例： >
	:!ls | wc		查看两个命令的输出
	:r !ls | wc		在文本中插入相同的输出
	:%g/foo/p|>		将所有匹配行移动一个 shiftwidth
	:%s/foo/bar/|>		将一行移动一个 shiftwidth
	:map q 10^V|		将 "q" 映射为 "10|"
	:map q 10\| map \ l	将 "q" 映射为 "10\" 并将 "\" 映射为 "l"
				（当 'cpoptions' 中存在 'b' 时）

你也可以使用 <NL> 以与 '|' 相同的方式分隔命令。
要插入 <NL>，请使用 CTRL-V CTRL-J。将显示 "^@"。使用 '|' 是首选方法。
但对于外部命令必须使用 <NL>，因为 '|' 包含在外部命令中。
为了避免 <NL> 的特殊含义，必须在它前面加上反斜杠。示例： >
	:r !date<NL>-join
这将当前日期读入文件并将其与前一行连接。

注意，如果 '|' 前的命令产生错误，则不会执行后续命令。

由于 Vi 兼容性，支持以下奇怪的命令： >
	:|			打印当前行（类似 ":p"）
	:3|			打印第 3 行（类似 ":3p"）
	:3			转到第 3 行

在范围和命令名之间允许使用冒号。它被忽略（这是 Vi 兼容的）。例如： >
	:1,$:s/pat/string

当在期望文件名的地方使用字符 '%' 或 '#' 时，它们被扩展为当前和备用文件名（参见“编辑文件”章节 |:_%| |:_#|）。

文件名中的尾随空格将被忽略，除非用反斜杠或 CTRL-V 转义。
注意，":next" 命令使用空格分隔文件名。
转义空格以将其包含在文件名中。示例： >
	:next foo\ bar goes\ to school\
开始编辑三个文件 "foo bar"、"goes to" 和 "school "。

当你想在命令中使用特殊字符 '"' 或 '|'，或者想在文件名中使用 '%' 或 '#' 时，请在它们前面加上反斜杠。
在范围和 ":substitute" 命令中不需要反斜杠。
另见 |`=|。

							*:_!*
Ex 命令后的 '!'（bang）字符使命令以不同的方式行为。
'!' 应紧接在命令之后，中间没有任何空白。如果你插入空白，'!' 将被视为命令的参数，具有不同的含义。
例如：
	:w! name	将当前缓冲区写入文件 "name"，覆盖任何现有文件
	:w !name	将当前缓冲区作为标准输入发送给命令 "name"

==============================================================================
4. Ex 命令行范围	*cmdline-ranges* *[range]* *E16*

一些 Ex 命令在前面接受一个行范围。这被记为 [range]。
它由一个或多个行说明符组成，用 ',' 或 ';' 分隔。

基础知识在用户手册的 |10.3| 节中说明。

								*:,* *:;*
当用 ';' 分隔时，在解释下一个行说明符之前，光标位置将被设置到该行。
这对于 ',' 不会发生。
示例： >
   4,/this line/
<	从第 4 行到光标行后匹配 "this line" 的行。 >
   5;/that line/
<	从第 5 行到第 5 行后匹配 "that line" 的行。

大多数命令的默认行说明符是光标位置，但命令 ":write" 和 ":global" 的默认是整个缓冲区 (1,$)。

如果给出的行说明符比命令需要的多，当用逗号分隔时，最左边的一个（些）将被忽略，
例如，这个中的 -2,+： >
	:-2,+,-2,. print
<当用分号分隔时，从最左边的说明符到倒数第二个说明符被求和，
例如，-4 + 3 - 1 = -2，在这个中： >
	:-4;+3;-1;+2 print
<

行号可以用以下方式指定：		*:range* *{address}*
	{number}	绝对行号  *E1247*
	.		当前行			   *:.*
	$		缓冲区的最后一行		   *:$*
	%		等于 1,$（整个缓冲区）	   *:%*
	*		等于 '<,'>（最后选择的 Visual 区域的行；见下面的 |:star|）
	'x		标记 x 位置的行		   *:'x*
			（其中 x 是任何 {a-z} 标记）
	'X		标记 X 位置的行		   *:'X*
			（其中 X 是任何 {A-Z0-9} 标记，尽管
			当 X 在另一个缓冲区中时，它不能
			在范围中使用）
	'[		最近一次更改或拉取的第一行	   *:'[*
	']		最近一次更改或拉取的最后一行	   *:']*
	'<		最近一次选择的 Visual 区域的第一行   *:'<*
	'>		最近一次选择的 Visual 区域的最后一行   *:'>*
	''		最近一次跳转之前的位置所在的行，   *:''*
			或最后一个 "m'"/"m`" 命令给出的位置所在的行
			（尽管如果它不在当前缓冲区中，'' 为 1）
	'"		上次退出缓冲区时光标位置所在的行   *:'quote*
	'^		上次停止插入模式时光标位置所在的行   *:'^*
	'.		缓冲区上次更改时光标位置所在的行   *:'.*
	'(		当前句子第一个字符所在的行	   *:'(*
	')		当前句子结束后的第一个字符所在的行   *:')*
	'{		包含光标的段落之前的第一个空行   *:'{*
	'}		包含光标的段落之后的第一个空行   *:'}*
	/{pattern}[/]	下一个匹配 {pattern} 的行	   *:/*
				另见下面的 |:range-pattern|
	?{pattern}[?]	上一个匹配 {pattern} 的行	   *:?*
				另见下面的 |:range-pattern|
	\/		下一个匹配最近搜索模式的行
	\?		上一个匹配最近搜索模式的行
	\&		下一个匹配最近替换模式的行

	注意：“下一行”和“上一行”不包括出现在当前行中的匹配。

						*:range-offset*
每个行说明符后面可以跟一个或多个 '+' 或 '-' 和一个可选的数字。
该值被添加或减去到前面的行号。
所以，例如，'x+2 是包含标记 x 的行之后两行。如果数字被省略，
对于每个 '+' 使用 +1，对于每个 '-' 使用 -1，所以，例如，'x++ 和 'x+2 是同义的。
如果在 '+' 或 '-' 之前没有任何内容，对于 [range] 中的第一个行号，当前行被用作相对起点。
所以，-,. 表示，“当前行之前的一行到当前行”。
[range] 中第二个行号的值取决于行号之间是用逗号还是分号分隔（参见 |:,| 和 |:;|）。
示例：如果光标在下面这一行内，以下任何命令都将打印标签行 ":range-offset" 和该行 "Each..."： >
	:-11;+1 print
	:-----------,-10 print
	:?Each line?-;+ print
	:'{+,'{+2 print
	:'{+1;')-1 print
<						*:range-closed-fold*
当逗号后的行号在闭合折叠中时，它被调整到折叠的最后一行，因此整个折叠被包括在内。

当添加一个数字时，这是在调整到折叠的最后一行之后完成的。
这意味着这些行被额外包括在范围内。例如： >
   :3,4+2print
在这个文本上：
	1 one ~
	2 two ~
	3 three ~
	4 four FOLDED ~
	5 five FOLDED ~
	6 six ~
	7 seven ~
	8 eight ~
其中第 4 和第 5 行是一个闭合折叠，最终打印第 3 到第 7 行。
7 来自范围中的 "4"，它被调整到闭合折叠的末尾，即 5，然后加上偏移量 2。

一个减法的例子（不是很有用）： >
   :2,4-1print
在这个文本上：
	1 one ~
	2 two ~
	3 three FOLDED ~
	4 four FOLDED ~
	5 five FOLDED ~
	6 six FOLDED ~
	7 seven ~
	8 eight ~
其中第 3 到第 6 行是一个闭合折叠，最终打印第 2 到第 6 行。
6 来自范围中的 "4"，它被调整到闭合折叠的末尾，即 6，然后减去 1，然后这仍然在闭合折叠中，使用该折叠的最后一行，即 6。

							*:range-pattern*
{pattern} 后的 "/" 和 "?" 是必需的，用于将模式与后面的任何内容分开。

"/" 和 "?" 可以在前面加上另一个地址。搜索从那里开始。
与使用 ';' 的区别是光标不会移动。
示例： >
	/pat1//pat2/	在包含 "pat1" 的行之后查找包含 "pat2" 的行，而不移动光标。
	7;/pat2/	在第 7 行之后查找包含 "pat2" 的行，将光标留在第 7 行。

{number} 必须在 0 和文件中的行数之间。
当使用 0（零）时，大多数命令将其解释为 1。将其用作计数的命令确实将其用作零（|:tag|、|:pop| 等）。
一些命令将零解释为“第一行之前”（|:read|、搜索模式等）。

示例： >
	.+3		光标后三行
	/that/+1	下一个包含 "that" 的行之后的行
	.,$		从当前行到文件末尾
	0;/that		第一个包含 "that" 的行，也匹配第一行。
	1;/that		第 1 行之后第一个包含 "that" 的行

一些命令允许在命令后使用计数。该计数被用作要使用的行数，从最后一个行说明符给出的行开始（默认为光标行）。
接受计数的命令是那些使用范围但没有文件名参数的命令（因为文件名也可以是数字）。计数不能为负。

示例： >
	:s/x/X/g 5	在当前行和随后的四行中将 'x' 替换为 'X'
	:23d 4		删除第 23、24、25 和 26 行


折叠和范围

当折叠激活时，行号被舍入以包括整个闭合折叠。参见 |fold-behavior|。


反向范围						*E493*

范围应该将较小的行号放在前面。如果不是这种情况，Vim 会询问你是否应该交换行号。
	给出了向后范围，确定要交换吗 ~
这在全局命令 ":g" 中不会完成。

你可以在命令前使用 ":silent" 来避免问题，那时范围将总是被交换。


计数和范围						*N:*

当在输入 ":" 之前给出计数时，这被翻译为： >
		:.,.+(count - 1)
换句话说：光标处及之后的 "count" 行。示例：要删除三行： >
		3:d<CR>		被翻译为： .,.+2d<CR>
<

可视模式和范围
							*v_:*
{Visual}:	用一个命令行开始，将可视选择的行作为范围。
		代码 `:'<,'>` 用于此范围，这使得可以从命令行历史中选择类似的行，
		以便在不同的可视选择行上重复命令。

:*						*:star* *:star-visual-range*
		当可视模式已经结束时，使用可视区域作为范围的一种简短方式是 `:*`。

==============================================================================
5. Ex 命令行标志				*ex-flags*

这些标志受到一部分 Ex 命令的支持。它们打印命令执行后光标所在的行：

	l	输出类似 |:list|
	#	添加行号
	p	输出类似 |:print|

标志可以组合，因此 "l#" 同时使用行号和 |:list| 风格的输出。

==============================================================================
6. Ex 特殊字符				*cmdline-special*

注意：这些是在执行的命令行中的特殊字符。如果你想在键入时插入特殊内容，可以使用 CTRL-R 命令。
例如，"%" 代表当前文件名，而 CTRL-R % 立即插入当前文件名。参见 |c_CTRL-R|。

注意：如果你想在 Vim 脚本中避免特殊字符的影响，你可能想使用 |fnameescape()|。另见 |`=|。

在 Ex 命令中，在可以使用文件名的地方，以下字符具有特殊含义。这些也可以在表达式函数 |expand()| 中使用。
	%	被替换为当前文件名。		  *:_%* *c_%*
	#	被替换为备用文件名。		  *:_#* *c_#*
		这会为每个窗口记住。
	#n	（其中 n 是一个数字）被替换为		  *:_#0* *:_#n*
		缓冲区 n 的文件名。"#0" 与 "#" 相同。     *c_#n*
	##	被替换为参数列表中的所有名称，	  *:_##* *c_##*
		用空格连接。名称中的每个空格
		前面都有一个反斜杠。
	#<n	（其中 n 是一个数字 > 0）被替换为旧	  *:_#<* *c_#<*
		文件名 n。参见 |:oldfiles| 或 |v:oldfiles| 来获取
		编号。							*E809*

注意这些，除了 "#<n"，给出的是键入时的文件名。如果需要绝对路径（当从不同目录使用文件名时），
你需要添加 ":p"。参见 |filename-modifiers|。

"#<n" 项返回一个绝对路径，但对于你家目录下的文件，它将以 "~/" 开头。

注意，在空格之前插入了反斜杠，以便命令正确解释文件名。
但这对于 shell 命令不会发生。对于这些，你可能必须使用引号（这对于包含引号和通配符的文件会失败）： >
	:!ls "%"
	:r !spell "%"

为了避免 '%' 和 '#' 的特殊含义，在它前面插入一个反斜杠。
细节：当它前面有反斜杠时，特殊含义总是被转义，无论有多少反斜杠。
	你键入：		结果	~
	  #			alternate.file
	  \#			#
	  \\#			\#
另见 |`=|。

							*E499* *E500*
注意：这些是字面键入的，它们不是特殊键！
							*:<cword>* *<cword>*
	<cword>    被替换为光标下的单词（类似 |star|）
							*:<cWORD>* *<cWORD>*
	<cWORD>    被替换为光标下的 WORD（参见 |WORD|）
							*:<cexpr>* *<cexpr>*
	<cexpr>    被替换为光标下的单词，包括更多以形成 C 表达式。
		   例如，当光标在 "ptr->arg" 的 "arg" 上时，结果是 "ptr->arg"；
		   当光标在 "list[idx]" 的 "]" 上时，结果是 "list[idx]"。
							*:<cfile>* *<cfile>*
	<cfile>    被替换为光标下的路径名（类似 |gf| 使用的）
							*:<afile>* *<afile>*
	<afile>    当执行自动命令时，被替换为被操作的缓冲区的文件名，
		   或用于读取或写入的文件。  *E495*
							*:<abuf>* *<abuf>*
	<abuf>     当执行自动命令时，被替换为当前有效的缓冲区编号。
		   并非所有事件都设置它，另见 |bufnr()|。
		   对于 ":r file" 和 ":so file"，它是当前缓冲区，
		   被读取/源的文件不在缓冲区中。  *E496*
							*:<amatch>* *<amatch>*
	<amatch>   当执行自动命令时，被替换为执行此自动命令所匹配的内容。  *E497*
		   当文件名不用于匹配时（对于 FileType、Syntax 和 SpellFileMissing
		   事件），它与 <afile> 不同。
		   当匹配的是文件名时，它被扩展为完整路径。
							*:<stack>* *<stack>*
	<stack>	   被替换为调用堆栈，使用
		   "function {function-name}[{lnum}]" 表示函数行，
		   "script {file-name}[{lnum}]" 表示脚本行，
		   以及 ".." 在项目之间。例如：
		   "function {function-name1}[{lnum}]..{function-name2}[{lnum}]"
		   如果没有调用堆栈，你会得到错误 *E489* 。
							*:<script>* *<script>* *E498*
	<script>   当执行 `:source` 命令时，被替换为源文件的文件名。
		   当执行函数时，被替换为定义它的脚本的文件名。
		   如果无法确定文件名，你会得到错误 *E1274* 。
							*:<slnum>* *<slnum>*
	<slnum>	   当执行 `:source` 命令时，被替换为行号。  *E842*
		   当执行函数时，它是相对于函数开始的行号。
							*:<sflnum>* *<sflnum>*
	<sflnum>   当执行脚本时，被替换为行号。
		   它与 <slnum> 的不同之处在于 <sflnum> 在任何情况下都被替换为
		   脚本行号。  *E961*

							 *filename-modifiers*
*:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs* *::S*
     *%:8* *%:p* *%:.* *%:~* *%:h* *%:t* *%:r* *%:e* *%:s* *%:gs* *%:S*
文件名修饰符可以在 "%"、"#"、"#n"、"<cfile>"、"<script>"、"<afile>" 或 "<abuf>" 之后使用。
它们也与 |fnamemodify()| 函数一起使用。

可以给出这些修饰符，按此顺序：
	:p	使文件名成为完整路径。必须是第一个修饰符。
		也将 "~/"（对于 Unix 还有 "~user/"）更改为家目录的路径。
		如果名称是目录，则在末尾添加路径分隔符。
		对于不存在且没有绝对路径的文件名，结果是不可预测的。
		在 MS-Windows 上，8.3 文件名被扩展为长名称。
	:8	将路径转换为 8.3 短格式（目前仅在 MS-Windows 上）。
		将对尽可能多的现有路径部分进行操作。
	:~	将文件名缩减为相对于家目录，如果可能的话。
		如果文件名不在家目录下，则文件名不变。
	:.	将文件名缩减为相对于当前目录，如果可能的话。
		如果文件名不在当前目录下，则文件名不变。
		为了最大程度的简短，使用 ":~:."。
	:h	文件名的头部（移除最后一个组成部分和任何分隔符）。
		不能与 :e、:r 或 :t 一起使用。
		可以重复以移除末尾的几个组成部分。
		当文件名以路径分隔符结尾时，只移除路径分隔符。
		因此，在目录名上使用 ":p:h" 的结果是目录名本身（没有尾部斜杠）。
		当文件名是绝对路径（对于 Unix 以 "/" 开头；对于 Win32 以 "x:\" 开头）时，该部分不会被移除。
		当没有头部（路径相对于当前目录）时，结果为空。
	:t	文件名的尾部（名称的最后一个组成部分）。必须
		在任何 :r 或 :e 之前。
	:r	文件名的根（移除最后一个扩展名）。当
		只有一个扩展名（以 '.' 开头的文件名，
		例如 ".nvimrc"）时，它不会被移除。可以重复以
		移除多个扩展名（最后一个先移除）。
	:e	文件名的扩展名。仅在单独使用时有意义。
		当没有扩展名时，结果为空。
		当只有一个扩展名（以 '.' 开头的文件名）时，结果为空。
		可以重复以包含更多扩展名。如果没有足够的扩展名（但至少
		一个），则尽可能多地包含。
	:s?pat?sub?
		用 "sub" 替换 "pat" 的第一次出现。
		这工作方式类似 |:s| 命令。"pat" 是一个正则表达式。
		任何字符都可以用作 '?'，但它不能出现在 "pat" 或 "sub" 中。
		在此之后，可以再次使用先前的修饰符。例如
		":p"，在替换后生成完整路径。
	:gs?pat?sub?
		用 "sub" 替换 "pat" 的所有出现。
		否则这工作方式类似 ":s"。
	:S	为用于 shell 命令转义特殊字符（参见 |shellescape()|）。
		必须是最后一个。示例： >
		    :!dir <cfile>:S
		    :call system('chmod +w -- ' .. expand('%:S'))

示例，当文件名为 "src/version.c"，当前目录为 "/home/mool/vim"： >
  :p			/home/mool/vim/src/version.c
  :p:.				       src/version.c
  :p:~				 ~/vim/src/version.c
  :h				       src
  :p:h			/home/mool/vim/src
  :p:h:h		/home/mool/vim
  :t					   version.c
  :p:t					   version.c
  :r				       src/version
  :p:r			/home/mool/vim/src/version
  :t:r					   version
  :e						   c
  :s?version?main?		       src/main.c
  :s?version?main?:p	/home/mool/vim/src/main.c
  :p:gs?/?\\?		\home\mool\vim\src\version.c

示例，当文件名为 "src/version.c.gz"： >
  :p			/home/mool/vim/src/version.c.gz
  :e						     gz
  :e:e						   c.gz
  :e:e:e					   c.gz
  :e:e:r					   c
  :r				       src/version.c
  :r:e						   c
  :r:r				       src/version
  :r:r:r			       src/version
<
					*extension-removal* *:_%<*
如果 "<" 被附加到 "%"、"#"、"#n" 或 "CTRL-V p"，则文件名的扩展名被移除
（文件名中最后一个 '.' 之后的所有内容，包括 '.'）。
这是为了与 3.0 版本向后兼容而包含的，首选 ":r" 形式。示例： >

	%		当前文件名
	%<		当前文件名无扩展名
	#		当前窗口的备用文件名
	#<		同上，无扩展名
	#31		备用文件编号 31
	#31<		同上，无扩展名
	<cword>		光标下的单词
	<cWORD>		光标下的 WORD（参见 |WORD|）
	<cfile>		光标下的路径名
	<cfile><	同上，无扩展名

注意：在期望文件名的地方，会进行通配符扩展。在 Unix 上，除非可以在内部完成（为了速度），否则使用 shell 进行此操作。
反引号也工作，例如： >
	:n `echo *.c`
但只有在扩展 '%'、'#' 等之前有任何通配符时才会进行扩展。这避免了在文件名内部扩展通配符。
如果你想扩展 <cfile> 的结果，向它添加一个通配符。
示例：（备用文件名是 "?readme?"）
	命令		扩展为 >
	:e #		:e ?readme?
	:e `ls #`	:e {匹配 "?readme?" 的文件}
	:e #.*		:e {匹配 "?readme?.*" 的文件}
	:cd <cfile>	:cd {光标下的文件名}
	:cd <cfile>*	:cd {光标下的文件名加上 "*" 然后扩展}
另见 |`=|。

当扩展的参数包含 "!" 并且它用于 shell 命令（":!cmd"、":r !cmd" 或 ":w !cmd"）时，
"!" 用反斜杠转义以避免它被扩展为之前使用的命令。当 'shell' 选项包含 "sh" 时，这会被做两次，以避免 shell 尝试扩展 "!"。

							*filename-backslash*
对于使用反斜杠作为目录分隔符的文件系统（Windows 文件系统），
识别用于转义下一个字符特殊含义的反斜杠有点困难。一般规则是：
如果反斜杠后面跟着一个正常的文件名字符，它没有特殊含义。
因此 "\file\foo" 是一个有效的文件名，你不需要键入反斜杠两次。

一个例外是 '$' 符号。它是文件名中的有效字符。
但为了避免像 "$home" 这样的文件名被解释为环境变量，它需要在前面加上反斜杠。
因此你需要使用 "/\$home" 来表示根目录中的文件 "$home"。一些示例：

	文件名		解释为	~
	$home		扩展为环境变量 $home 的值
	\$home		当前目录中的文件 "$home"
	/\$home		根目录中的文件 "$home"
	\\$home		文件 "\\"，后跟扩展的 $home

另见 |`=|。

==============================================================================
7. 命令行窗口				*cmdline-window* *cmdwin*
							*command-line-window*
在命令行窗口中，可以像编辑任何窗口中的文本一样编辑命令行。
它是一种特殊类型的窗口，因为你无法以正常方式离开它。


打开						*c_CTRL-F* *q:* *q/* *q?*

有两种方式打开命令行窗口：
1. 从命令行模式，使用 'cedit' 选项指定的键。
2. 从普通模式，使用 "q:"、"q/" 或 "q?" 命令。
   这开始编辑 Ex 命令行（"q:"）或搜索字符串（"q/" 或 "q?"）。
   注意，这在录制进行时是不可能的（"q" 会停止录制）。

当窗口打开时，它被命令行历史填充。最后一行包含到目前为止键入的命令。
左列将显示一个字符，指示正在编辑的命令行类型，参见 |cmdwin-char|。

当编辑器打开时，Vim 将处于普通模式。

窗口的高度由 'cmdwinheight' 指定（如果没有空间则更小）。窗口总是全宽，并定位在命令行正上方。


编辑

你现在可以使用命令在窗口中移动和编辑文本。在普通模式和插入模式中都可以。

可以使用 ":"、"/" 和其他使用命令行的命令，但那时不可能打开另一个命令行窗口。没有嵌套。
							*E11* *E1188*
命令行窗口不是普通窗口。不可能移动到另一个窗口或编辑另一个缓冲区。
所有会这样做的命令在命令行窗口中被禁用。当然，你_可以_执行在命令行窗口中输入的任何命令。
其他文本编辑在关闭窗口时被丢弃。


关闭							*E199*

有几种方式离开命令行窗口：

<CR>		执行光标下的命令行。在插入模式和普通模式下都工作。
CTRL-C		继续命令行模式。光标下的命令行被用作命令行。
		在插入模式和普通模式下都工作。没有重绘，因此窗口将保持可见。
:quit		丢弃命令行并返回普通模式。
		":close"、CTRL-W c、":exit"、":xit" 和 CTRL-\ CTRL-N 也工作。
:qall		退出 Vim，除非某些缓冲区有更改。
:qall!		退出 Vim，丢弃任何缓冲区的更改。

一旦命令行窗口关闭，旧的窗口大小会被恢复。执行的命令应用于启动命令行的窗口和缓冲区。
这工作起来就像命令行窗口不存在一样，只是会有一个额外的屏幕重绘。
用于命令行窗口的缓冲区被删除。对除了用 <CR> 执行的行以外的任何行的更改都会丢失。

如果你想执行光标下的命令然后再次打开命令行窗口，你可能会发现这个映射有用： >

	:autocmd CmdwinEnter * map <buffer> <F5> <CR>q:


其他

当已经有一个命令行窗口时，不能使用命令行窗口（没有嵌套）。

打开命令行窗口时设置了一些选项：
'filetype'	"vim"，当编辑 Ex 命令行时；如果启用了 Vim 语法高亮，则开始
'rightleft'	关闭
'modifiable'	开启
'buftype'	"nofile"
'swapfile'	关闭

允许将缓冲区内容写入文件。这是保存命令行历史并在以后读回的简单方法。

如果 'wildchar' 选项设置为 <Tab>，并且命令行窗口用于 Ex 命令，
那么将添加两个映射来使用 <Tab> 在命令行窗口中进行补全，像这样： >
	:inoremap <buffer> <Tab> <C-X><C-V>
	:nnoremap <buffer> <Tab> a<C-X><C-V>
注意在普通模式下按 <Tab> 将在下一个字符上进行补全。这样它在行尾工作。
如果你不想要这些映射，用以下方式禁用它们： >
	au CmdwinEnter [:>] iunmap <buffer> <Tab>
	au CmdwinEnter [:>] nunmap <buffer> <Tab>
你可以将这些行放在你的 vimrc 文件中。

在命令行窗口中时，你不能使用鼠标将光标放在另一个窗口中，或拖动其他窗口的状态行。
你可以拖动命令行窗口本身及其上方的状态行。
因此你可以调整命令行窗口的大小，但不能调整其他窗口。

|getcmdwintype()| 函数返回正在编辑的命令行类型，如 |cmdwin-char| 中所述。

Nvim 在 "nvim.cmdwin" 组中定义了这个默认的 CmdwinEnter 自动命令： >
    autocmd CmdwinEnter [:>] syntax sync minlines=1 maxlines=1
<
你可以在你的配置中使用 "autocmd! nvim.cmdwin" 来禁用它。|default-autocmds|


自动命令

使用了两个自动命令事件：|CmdwinEnter| 和 |CmdwinLeave|。你可以使用 Cmdwin 事件专门为命令行窗口进行设置。
注意不要引起副作用！
示例： >
	:au CmdwinEnter :  let b:cpt_save = &cpt | set cpt=.
	:au CmdwinLeave :  let &cpt = b:cpt_save
这将设置 'complete' 以使用当前窗口进行 |i_CTRL-N| 补全。
另一个示例： >
	:au CmdwinEnter [/\?]  startinsert
这将使 Vim 在命令行窗口中以插入模式启动。
注意："?" 需要转义，因为这是一个 |file-pattern|。另见 |cmdline-autocompletion|。

					*cmdline-char* *cmdwin-char*
用于模式的字符指示命令行的类型：
	:	普通 Ex 命令
	>	调试模式命令 |debug-mode|
	/	向前搜索字符串
	?	向后搜索字符串
	=	"= 的表达式 |expr-register|
	@	|input()| 的字符串
	`-`	|:insert| 或 |:append| 的文本

==============================================================================
8. 命令行自动补全			 *cmdline-autocompletion*

自动补全通过在你键入时自动显示建议的弹出菜单，使命令行更高效且更易于导航，
无论是在搜索（/ 或 ?）还是输入命令（:）时。

一个基本设置是： >
	autocmd CmdlineChanged [:\/\?] call wildtrigger()
	set wildmode=noselect:lastused,full
	set wildoptions=pum

使用此配置，建议会立即出现，你可以使用 <Tab> 或箭头键在它们之间移动。

要保留使用 <Up>/<Down> 的正常命令行历史导航： >
	cnoremap <expr> <Up>   wildmenumode() ? "\<C-E>\<Up>"   : "\<Up>"
	cnoremap <expr> <Down> wildmenumode() ? "\<C-E>\<Down>" : "\<Down>"

选项也可以仅应用于特定的命令行。例如，仅在搜索期间使用较短的弹出菜单高度： >
	autocmd CmdlineEnter [\/\?] set pumheight=8
	autocmd CmdlineLeave [\/\?] set pumheight&

额外功能					*fuzzy-file-picker* *live-grep*

命令行自动补全也可以扩展用于高级用途。
例如，你可以将原生 |:find| 命令转变为模糊的、交互式的文件选择器： >

	set findfunc=Find
	func Find(arg, _)
	  if empty(s:filescache)
	    let s:filescache = globpath('.', '**', 1, 1)
	    call filter(s:filescache, '!isdirectory(v:val)')
	    call map(s:filescache, "fnamemodify(v:val, ':.')")
	  endif
	  return a:arg == '' ? s:filescache : matchfuzzy(s:filescache, a:arg)
	endfunc
	let s:filescache = []
	autocmd CmdlineEnter : let s:filescache = []

`:Grep` 命令搜索与模式匹配的行，并在你键入时动态更新结果
（在两个字符后触发；注意：需要下一节的 `CmdlineLeavePre` 自动命令）： >

	command! -nargs=+ -complete=customlist,<SID>Grep
		\ Grep call <SID>VisitFile()

	func s:Grep(arglead, cmdline, cursorpos)
	  if match(&grepprg, '\$\*') == -1 | let &grepprg ..= ' $*' | endif
	  let cmd = substitute(&grepprg, '\$\*', shellescape(escape(a:arglead, '\')), '')
	  return len(a:arglead) > 1 ? systemlist(cmd) : []
	endfunc

	func s:VisitFile()
	  let item = getqflist(#{lines: [s:selected]}).items[0]
	  let pos  = '[0,\ item.lnum,\ item.col,\ 0]'
	  exe $':b +call\ setpos(".",\ {pos}) {item.bufnr}'
	  call setbufvar(item.bufnr, '&buflisted', 1)
	endfunc

当离开命令行时自动选择补全列表中的第一项，对于 `:Grep`，将键入的模式添加到命令行历史： >

	autocmd CmdlineLeavePre :
	      \ if get(cmdcomplete_info(), 'matches', []) != [] |
	      \   let s:info = cmdcomplete_info() |
	      \   if getcmdline() =~ '^\s*fin\%[d]\s' && s:info.selected == -1 |
	      \     call setcmdline($'find {s:info.matches[0]}') |
	      \   endif |
	      \   if getcmdline() =~ '^\s*Grep\s' |
	      \     let s:selected = s:info.selected != -1
	      \         ? s:info.matches[s:info.selected] : s:info.matches[0] |
	      \     call setcmdline(s:info.cmdline_orig) |
	      \   endif |
	      \ endif

关于插入模式下的自动补全，请参见 |ins-autocompletion|。

 vim:tw=78:ts=8:noet:ft=help:norl:
