*usr_10.txt*	Nvim

		     VIM 用户手册 - 作者：Bram Moolenaar

				进行大更改


第4章解释了几种进行小更改的方法。本章深入探讨如何进行重复的更改或可能影响大量文本的更改。可视模式允许对文本块进行各种操作。使用外部程序来处理真正复杂的事情。

|10.1|	录制和回放命令
|10.2|	替换
|10.3|	命令范围
|10.4|	全局命令
|10.5|	可视块模式
|10.6|	读取和写入文件的一部分
|10.7|	格式化文本
|10.8|	更改大小写
|10.9|	使用外部程序

     下一章: |usr_11.txt|  从崩溃中恢复
 上一章: |usr_09.txt|  使用 GUI
     目录: |usr_toc.txt|

==============================================================================
*10.1*	录制和回放命令

"." 命令重复前一个更改。但是如果您想做的事情比单个更改更复杂呢？这时命令录制就派上用场了。有三个步骤：

1. "q{register}" 命令开始将击键录制到名为 {register} 的寄存器中。寄存器名称必须在 a 到 z 之间。
2. 输入您的命令。
3. 要结束录制，按 q（不带任何额外字符）。

现在您可以通过输入命令 "@{register}" 来执行宏。

看看如何在实践中使用这些命令。您有一个如下所示的文件名列表：

	stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~

而您想要的是：

	#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~

您首先移动到第一行的第一个字符。接下来执行以下命令：

	qa			开始在寄存器 a 中录制宏。
	^			移动到行首。
	i#include "<Esc>	在行首插入字符串 #include "。
	$			移动到行尾。
	a"<Esc>			在行尾追加字符双引号 (")。
	j			转到下一行。
	q			停止录制宏。

既然您已经完成了一次工作，您可以通过输入命令 "@a" 三次来重复更改。
   "@a" 命令前面可以加一个计数，这将导致宏执行该次数。在这种情况下，您需要输入：>

	3@a


移动并执行

您可能想要更改的行位于不同的位置。只需将光标移动到每个位置并使用 "@a" 命令。如果您这样做过一次，您可以使用 "@@" 再次执行。这样输入起来更容易一些。如果您现在使用 "@b" 执行寄存器 b，那么下一个 "@@" 将使用寄存器 b。
   如果将回放方法与使用 "." 进行比较，有几个区别。首先，"." 只能重复一个更改。如上例所示，"@a" 可以进行多个更改，并且也可以移动。其次，"." 只能记住最后一个更改。执行寄存器允许您进行任何更改，然后仍然使用 "@a" 回放录制的命令。最后，您可以使用 26 个不同的寄存器。因此您可以记住 26 个不同的要执行的命令序列。


使用寄存器

用于录制的寄存器与您用于拉取和删除命令的寄存器相同。这允许您将录制与其他操作寄存器的命令混合使用。
   假设您已经在寄存器 n 中录制了一些命令。当您使用 "@n" 执行时，您注意到您做错了什么。您可以尝试重新录制，但也许您会犯另一个错误。相反，使用这个技巧：

	G			转到文件末尾。
	o<Esc>			创建一个空行。
	"np			将文本从 n 寄存器放入。您现在在文件中看到您输入的命令作为文本。
	{edits}			更改错误的命令。这就像编辑文本一样。
	0			转到行首。
	"ny$			将更正后的命令拉取到 n 寄存器中。
	dd			删除临时行。

现在您可以使用 "@n" 执行更正后的命令。（如果您录制的命令包含换行符，请调整示例中的最后两项以包含所有行。）


追加到寄存器

到目前为止，我们使用小写字母作为寄存器名称。要追加到寄存器，请使用大写字母。
   假设您已经录制了一个将单词更改为寄存器 c 的命令。它工作正常，但您想添加搜索下一个要更改的单词。这可以通过以下方式完成：>

	qC/word<Enter>q

您以 "qC" 开始，它录制到 c 寄存器并追加。因此，写入大写寄存器名称意味着追加到具有相同字母但小写的寄存器。

这对于录制以及拉取和删除命令都有效。例如，您想将一系列行收集到 a 寄存器中。用以下命令拉取第一行：>

	"ayy

现在移动到第二行，并输入：>

	"Ayy

对所有行重复此命令。a 寄存器现在包含所有这些行，按照您拉取它们的顺序。

==============================================================================
*10.2*	替换						*查找替换*

":substitute" 命令使您能够对整行范围执行字符串替换。此命令的一般形式如下：>

	:[range]substitute/from/to/[flags]

此命令将指定 [range] 的行中的 "from" 字符串更改为 "to" 字符串。例如，您可以使用以下命令将所有行中的 "Professor" 更改为 "Teacher"：>

	:%substitute/Professor/Teacher/
<
	注意:
	":substitute" 命令几乎从不完整拼写。大多数时候，人们使用缩写版本 ":s"。从这里开始将使用缩写。

命令前的 "%" 指定命令在所有行上工作。没有范围，":s" 只在当前行工作。关于范围的更多信息在下一节 |10.3|。

默认情况下，":substitute" 命令只更改每行上的第一个匹配项。例如，前面的命令将行：

	Professor Smith criticized Professor Johnson today. ~

更改为：

	Teacher Smith criticized Professor Johnson today. ~

要更改行上的每个匹配项，您需要添加 g（全局）标志。命令：>

	:%s/Professor/Teacher/g

结果是（从原始行开始）：

	Teacher Smith criticized Teacher Johnson today. ~

其他标志包括 p（打印），它使 ":substitute" 命令打印出它更改的最后一行。c（确认）标志告诉 ":substitute" 在执行每个替换之前询问您确认。输入以下内容：>

	:%s/Professor/Teacher/c

Vim 找到 "Professor" 的第一个匹配项并显示它将要更改的文本。您会得到以下提示：>

	replace with Teacher? (y)es/(n)o/(a)ll/(q)uit/(l)ast/scroll up(^E)/down(^Y)

此时，您必须输入以下答案之一：

	y		是；进行此更改。
	n		否；跳过此匹配。
	a		全部；进行此更改及所有剩余的更改，无需进一步确认。
	q		退出；不再进行任何更改。
	l		最后一个；进行此更改然后退出。
	CTRL-E		将文本向上滚动一行。
	CTRL-Y		将文本向下滚动一行。


替换命令的 "from" 部分实际上是一个模式。与搜索命令使用的类型相同。例如，此命令仅当 "the" 出现在行首时才替换它：>

	:s/^the/these/

如果您要替换的 "from" 或 "to" 部分包含斜杠，您需要在它前面放一个反斜杠。更简单的方法是使用另一个字符代替斜杠。例如，加号： >

	:s+one/two+one or two+

==============================================================================
*10.3*	命令范围

":substitute" 命令和许多其他 : 命令可以应用于选定的行。这称为范围。
   范围的简单形式是 {number},{number}。例如：>

	:1,5s/this/that/g

在行 1 到 5 上执行替换命令。包括第 5 行。范围总是放在命令之前。

单个数字可用于寻址一个特定的行：>

	:54s/President/Fool/

一些命令在您不指定范围时对整个文件工作。要使它们对当前行工作，使用 "." 地址。":write" 命令就是这样工作的。没有范围，它写入整个文件。要使其仅将当前行写入文件：>

	:.write otherfile

第一行总是编号为一。最后一行呢？"$" 字符用于此。例如，要替换从光标到末尾的行：>

	:.,$s/yes/no/

我们之前使用的 "%" 范围，实际上是 "1,$" 的简写方式，从第一行到最后一行。


在范围中使用模式

假设您正在编辑一本书的一章，并希望将所有 "grey" 的出现替换为 "gray"。但仅在本章中，而不是下一章。您知道只有章节边界在首列有单词 "Chapter"。那么这个命令将起作用：>

	:?^Chapter?,/^Chapter/s=grey=gray=g

您可以看到搜索模式被使用了两次。第一个 "?^Chapter?" 找到当前位置上方匹配此模式的行。因此 ?pattern? 范围用于向后搜索。类似地，"/^Chapter/" 用于向前搜索下一章的开始。
   为了避免与斜杠混淆，这里在替换命令中使用了 "=" 字符。斜杠或其他字符也可以工作。


加和减

上述命令有一个小错误：如果下一章的标题包含 "grey"，它也会被替换。也许那是您想要的，但如果不是呢？那么您可以指定一个偏移量。
   要搜索一个模式然后使用它上方的一行：>

	/Chapter/-1

您可以使用任何数字代替 1。要寻址匹配下方第二行：>

	/Chapter/+2

偏移量也可以用于范围中的其他项目。看看这个：>

	:.+3,$-5

这指定了从光标下方三行开始到文件最后一行之前五行结束的范围。


使用标记

与其找出某些位置的行号、记住它们并在范围中输入它们，您可以使用标记。
   如第3章所述放置标记。例如，使用 "mt" 标记区域顶部，使用 "mb" 标记底部。然后您可以使用这个范围来指定标记之间的行（包括带有标记的行）：>

	:'t,'b


可视模式和范围

您可以使用可视模式选择文本。如果您然后按 ":" 开始一个冒号命令，您将看到：>

	:'<,'>

现在您可以输入命令，它将应用于可视选择的行范围。

	注意:
	当使用可视模式选择行的一部分，或使用 CTRL-V 选择文本块时，冒号命令仍然适用于整行。这在 Vim 的未来版本中可能会改变。

'< 和 '> 实际上是标记，放置在可视选择的开始和结束处。标记保持在其位置，直到进行另一个可视选择。因此您可以使用 "'<" 命令跳转到可视区域开始的位置。并且您可以将标记与其他项目混合：>

	:'>,$

这寻址从可视区域结束到文件末尾的行。


一定数量的行

当您知道要更改多少行时，您可以输入数字然后 ":"。例如，当您输入 "5:" 时，您将得到：>

	:.,.+4

现在您可以输入要使用的命令。它将使用范围 "."（当前行）直到 ".+4"（向下四行）。因此它跨越五行。

另请参阅 |:range|，以获取指定范围的所有可能方式的概述。

==============================================================================
*10.4*	全局命令

":global" 命令是 Vim 更强大的功能之一。它允许您查找模式的匹配项并在那里执行命令。一般形式是：>

	:[range]global/{pattern}/{command}

这与 ":substitute" 命令类似。但是，它不是用其他文本替换匹配的文本，而是执行命令 {command}。

	注意:
	为 ":global" 执行的命令必须是以冒号开头的命令。不能直接使用普通模式命令。|:normal| 命令可以为您做到这一点。

假设您想将 "foobar" 更改为 "barfoo"，但仅在 C++ 样式的注释中。这些注释以 "//" 开头。使用此命令：>

	:g+//+s/foobar/barfoo/g

这以 ":g" 开始。那是 ":global" 的缩写，就像 ":s" 是 ":substitute" 的缩写一样。然后是模式，用加号字符括起来。由于我们正在查找的模式包含斜杠，这里使用加号字符来分隔模式。接下来是替换命令，将 "foobar" 更改为 "barfoo"。
   全局命令的默认范围是整个文件。因此在此示例中没有指定范围。这与 ":substitute" 不同，后者在没有范围时在一行上工作。
   该命令并不完美，因为它也匹配 "//" 出现在行中间的行，并且替换也将在 "//" 之前进行。

就像 ":substitute" 一样，可以使用任何模式。当您以后学习更复杂的模式时，您可以在这里使用它们。

==============================================================================
*10.5*	可视块模式

使用 CTRL-V 您可以开始选择文本的矩形区域。有一些命令对文本块做一些特殊的事情。

在可视块模式中使用 "$" 命令有一些特殊之处。当最后使用的移动命令是 "$" 时，可视选择中的所有行将延伸到行尾，即使光标所在的行较短。这保持有效，直到您使用水平移动光标的移动命令。因此使用 "j" 保持它，"h" 停止它。


插入文本

命令 "I{string}<Esc>" 在每个行中插入文本 {string}，就在可视块的左侧。您通过按 CTRL-V 进入可视块模式开始。现在您移动光标来定义您的块。接下来您输入 I 进入插入模式，后跟要插入的文本。当您输入时，文本仅出现在第一行。
   在您按 <Esc> 结束插入后，文本将神奇地插入到可视选择中包含的其余行中。示例：

	include one ~
	include two ~
	include three ~
	include four ~

将光标移动到 "one" 的 "o" 并按 CTRL-V。用 "3j" 向下移动到 "four"。您现在有一个跨越四行的块选择。现在输入：>

	Imain.<Esc>

结果：

	include main.one ~
	include main.two ~
	include main.three ~
	include main.four ~

如果块跨越未延伸到块中的短行，则不会在该行中插入文本。例如，创建一个可视块选择，包括此文本第一行和最后一行中的单词 "long"，因此在第二行中没有选择文本：

	This is a long line ~
	short ~
	Any other long line ~

		  ^^^^ 选定的块

现在使用命令 "Ivery <Esc>"。结果是：

	This is a very long line ~
	short ~
	Any other very long line ~

在短行中没有插入文本。

如果您插入的字符串包含换行符，"I" 的行为就像普通插入命令一样，仅影响块的第一行。

"A" 命令的工作方式相同，只是它在块的右侧追加。并且它确实在短行中插入文本。因此您可以选择是否要追加文本到短行。
   "A" 有一个特殊情况：选择一个可视块，然后使用 "$" 使块延伸到每行的末尾。现在使用 "A" 将在每行的末尾追加文本。
   使用上面的相同示例，然后输入 "$A XXX<Esc>"，您得到这个结果：

	This is a long line XXX ~
	short XXX ~
	Any other long line XXX ~

这确实需要使用 "$" 命令。Vim 记住它被使用过。通过其他移动命令将光标移动到最长行的末尾来进行相同的选择不会产生相同的结果。


更改文本

可视块 "c" 命令删除块，然后将您抛入插入模式，使您能够输入字符串。该字符串将被插入到块中的每一行。
   从上面相同的 "long" 单词选择开始，然后输入 "c_LONG_<Esc>"，您得到：

	This is a _LONG_ line ~
	short ~
	Any other _LONG_ line ~

就像 "I" 一样，短行不会被更改。此外，您不能在新文本中输入换行符。

"C" 命令删除从块左边缘到行尾的文本。然后将您置于插入模式，以便您可以输入字符串，该字符串将被添加到每行的末尾。
   再次从相同的文本开始，并输入 "Cnew text<Esc>" 您得到：

	This is a new text ~
	short ~
	Any other new text ~

请注意，即使只选择了 "long" 单词，它后面的文本也被删除了。因此只有可视块左边缘的位置真正重要。
   同样，未延伸到块中的短行被排除在外。

其他更改块中字符的命令：

	~	交换大小写	(a -> A 和 A -> a)
	U	变为大写  (a -> A 和 A -> A)
	u	变为小写  (a -> a 和 A -> a)


用字符填充

要用一个字符填充整个块，使用 "r" 命令。再次，从上面相同的示例文本开始，然后输入 "rx"：

	This is a xxxx line ~
	short ~
	Any other xxxx line ~


	注意:
	如果您想在块中包含超出行尾的字符，请查看第25章中的 'virtualedit' 功能。


移动

命令 ">" 将选定的文本向右移动一个移动量，插入空白。此移动的起点是可视块的左边缘。
   再次使用相同的示例，">" 给出这个结果：

	This is a	  long line ~
	short ~
	Any other	  long line ~

移动量由 'shiftwidth' 选项指定。要将其更改为使用 4 个空格：>

	:set shiftwidth=4

"<" 命令在块的左边缘删除一个移动量的空白。此命令受限于那里有多少文本；因此如果可用的空白少于一个移动量，它会删除它能删除的部分。


连接行

"J" 命令将所有选定的行连接成一行。因此它删除了换行符。实际上，换行符、前导空白和尾随空白被一个空格替换。在行结束（句点）后使用两个空格（这可以通过 'joinspaces' 选项更改）。
   让我们使用我们现在已经非常熟悉的示例。使用 "J" 命令的结果：

	This is a long line short Any other long line ~

"J" 命令不需要块状选择。它与 "v" 和 "V" 选择的工作方式完全相同。

如果您不希望空白被更改，请使用 "gJ" 命令。

==============================================================================
*10.6*	读取和写入文件的一部分

当您编写电子邮件时，可能想要包含另一个文件。这可以通过 ":read {filename}" 命令完成。文件的文本被放在光标行下方。
   从此文本开始：

	Hi John, ~
	Here is the diff that fixes the bug: ~
	Bye, Pierre. ~

将光标移动到第二行并输入：>

	:read patch

名为 "patch" 的文件将被插入，结果如下：

	Hi John, ~
	Here is the diff that fixes the bug: ~
	2c2 ~
	<	for (i = 0; i <= length; ++i) ~
	--- ~
	>	for (i = 0; i < length; ++i) ~
	Bye, Pierre. ~

":read" 命令接受一个范围。文件将被放在此范围的最后一行号下方。因此 ":$r patch" 在文件末尾追加文件 "patch"。
   如果您想在第一行上方读取文件怎么办？这可以使用行号零来完成。这一行并不真正存在，当您将其与大多数命令一起使用时会出现错误消息。但此命令是允许的：>
	:0read patch

文件 "patch" 将被放在文件第一行的上方。


写入一定范围的行

要将一定范围的行写入文件，可以使用 ":write" 命令。没有范围时，它写入整个文件。有范围时，只有指定的行被写入：>

	:.,$write tempo

这将从光标直到文件末尾的行写入文件 "tempo"。如果此文件已存在，您将收到错误消息。Vim 保护您免于意外覆盖现有文件。如果您知道自己在做什么并想要覆盖文件，请追加 !：>

	:.,$write! tempo

小心：! 必须紧跟在 ":write" 命令之后，没有空白。否则它将成为过滤器命令，本章稍后解释。


追加到文件

在本章第一节中解释了如何将多行收集到寄存器中。同样可以完成将行收集到文件中。使用此命令写入第一行：>

	:.write collection

现在将光标移动到您想要收集的第二行，并输入此命令：>

	:.write >>collection

">>" 告诉 Vim "collection" 文件不是作为新文件写入，而是该行必须追加到末尾。您可以重复此操作任意次数。

==============================================================================
*10.7*	格式化文本

当您键入纯文本时，如果每行的长度自动调整以适应窗口，那会很好。要在插入文本时实现这一点，请设置 'textwidth' 选项：>

	:set textwidth=78

您可能记得在示例 vimrc 文件中，此命令用于每个文本文件。因此，如果您正在使用该 vimrc 文件，您已经在使用它。要检查 'textwidth' 的当前值：>

	:set textwidth

现在行将被断开，最多只占用 78 个字符。但是，当您在一行的中间插入文本，或者删除几个单词时，行会变得太长或太短。Vim 不会自动重新格式化文本。要告诉 Vim 格式化当前段落：>

	gqap

这以 "gq" 命令开始，这是一个操作符。后面是 "ap"，代表"一个段落"的文本对象。段落通过空行与下一个段落分隔。

	注意:
	包含空白行的空行不会分隔段落。这很难注意到！

代替 "ap"，您可以使用任何移动或文本对象。如果您的段落被正确分隔，您可以使用此命令格式化整个文件：>

	gggqG

"gg" 带您到第一行，"gq" 是格式化操作符，"G" 是跳转到最后一行的移动。

如果您的段落没有明确定义，您可以仅格式化您手动选择的行。将光标移动到您要格式化的第一行。以命令 "gqj" 开始。这格式化当前行及其下一行。如果第一行很短，下一行的单词将被追加。如果它太长，单词将被移动到下一行。光标移动到第二行。现在您可以使用 "." 重复命令。继续这样做，直到您到达要格式化的文本的末尾。

==============================================================================
*10.8*	更改大小写

您有带有小写章节标题的文本。您想使单词 "section" 全部大写。使用 "gU" 操作符完成此操作。从光标在第一列开始：>

			     gUw
<	section header	    ---->      SECTION header

"gu" 操作符做完全相反的事情：>

			     guw
<	SECTION header	    ---->      section header

您也可以使用 "g~" 来交换大小写。所有这些都是操作符，因此它们可以与任何移动命令、文本对象一起使用，并且在可视模式下工作。
   要使操作符在行上工作，您将其加倍。删除操作符是 "d"，因此要删除一行，您使用 "dd"。类似地，"gugu" 使整行变为小写。这可以缩短为 "guu"。"gUgU" 缩短为 "gUU"，"g~g~" 缩短为 "g~~"。示例：>

				g~~
<	Some GIRLS have Fun    ---->   sOME girls HAVE fUN ~

==============================================================================
*10.9*	使用外部程序

Vim 有一套非常强大的命令，它可以做任何事情。但仍然可能有一些外部命令可以做得更好或更快。
   命令 "!{motion}{program}" 获取一个文本块并通过外部程序过滤它。换句话说，它运行由 {program} 表示的系统命令，将 {motion} 表示的文本块作为输入。此命令的输出然后替换选定的块。
   因为如果您不熟悉 Unix 过滤器，这很难总结，请看一个示例。sort 命令对文件进行排序。如果您执行以下命令，未排序的文件 input.txt 将被排序并写入 output.txt。这在 Unix 和 Windows 上都有效。>

	sort <input.txt >output.txt

现在在 Vim 中做同样的事情。您想要对文件的第 1 到第 5 行进行排序。您首先将光标放在第 1 行。接下来执行以下命令：>

	!5G

"!" 告诉 Vim 您正在执行过滤操作。Vim 编辑器期望后面跟着一个移动命令，指示要过滤文件的哪一部分。"5G" 命令告诉 Vim 转到第 5 行，所以它现在知道要过滤第 1 行（当前行）到第 5 行。
   在预期的过滤中，光标下降到屏幕底部并显示一个 ! 提示。您现在可以输入过滤器程序的名称，在这种情况下是 "sort"。因此，您的完整命令如下：>

	!5Gsort<Enter>

结果是 sort 程序在前 5 行上运行。程序的输出替换了这些行。

	line 55			      line 11
	line 33			      line 22
	line 11		-->	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line

"!!" 命令通过过滤器过滤当前行。在 Unix 中，"date" 命令打印当前时间和日期。"!!date<Enter>" 用 "date" 的输出替换当前行。这对于向文件添加时间戳很有用。

注意："!cmd"（例如，不使用任何文件范围）和 "{range}!cmd" 之间有区别。前者将简单地执行外部命令，Vim 将显示输出，而后者将通过过滤器过滤 {range} 行，并用过滤器命令的结果替换该范围。有关详细信息，请参阅 |:!| 和 |:range!|。

当它不起作用时

启动 shell、向其发送文本并捕获输出需要 Vim 确切知道 shell 是如何工作的。当您在过滤方面遇到问题时，请检查这些选项的值：

	'shell'		指定 Vim 用于执行外部程序的程序。
	'shellcmdflag'	用于将命令传递给 shell 的参数
	'shellquote'	用于围绕命令的引号
	'shellxquote'	用于围绕命令和重定向的引号
	'shellslash'	在命令中使用正斜杠（仅适用于 MS-Windows 及类似系统）
	'shellredir'	用于将命令输出写入文件的字符串

在 Unix 上，这几乎不是问题，因为有两种 shell："sh" 类和 "csh" 类。Vim 检查 'shell' 选项并根据它是否在 'shell' 中看到 "csh" 自动设置相关选项。
   然而，在 MS-Windows 上，有许多不同的 shell，您可能必须调整选项才能使过滤工作。有关更多信息，请查看选项的帮助。


读取命令输出

将当前目录的内容读入文件，使用：

在 Unix 上：>
	:read !ls
在 MS-Windows 上：>
	:read !dir

"ls" 或 "dir" 命令的输出被捕获并插入到文本中，光标下方。这类似于读取文件，只是使用 "!" 告诉 Vim 后面跟着一个命令。
   命令可以有参数。并且可以使用范围来告诉 Vim 应该将行放在哪里：>

	:0read !date -u

这在文件顶部插入当前的时间和日期（UTC 格式）。（嗯，如果您有一个接受 "-u" 参数的 date 命令。）注意与使用 "!!date" 的区别：后者替换一行，而 ":read !date" 将插入一行。


将文本写入命令

Unix 命令 "wc" 计数单词。要计算当前文件中的单词数：>

	:write !wc

这与之前的 write 命令相同，但代替文件名的是 "!" 字符和外部命令的名称。写入的文本将作为其标准输入传递给指定的命令。输出可能如下所示：

       4      47     249 ~

"wc" 命令不详细。这意味着您有 4 行、47 个单词和 249 个字符。

注意这个错误：>

	:write! wc

这将在当前目录中写入文件 "wc"，并强制写入。这里空白很重要！


重绘屏幕

如果外部命令产生错误消息，显示可能已被搞乱。Vim 非常高效，只重绘它知道需要重绘的屏幕部分。但它无法知道另一个程序写了什么。要告诉 Vim 重绘屏幕：>
	CTRL-L
<
==============================================================================

下一章: |usr_11.txt|  从崩溃中恢复

版权: 参见 |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
