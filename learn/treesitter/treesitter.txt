*treesitter.txt*    Nvim


                            NVIM 参考手册


Treesitter 集成                                 *treesitter*

Nvim 集成了 `tree-sitter` 库用于缓冲区的增量解析：
https://tree-sitter.github.io/tree-sitter/

警告：Treesitter 支持仍处于实验阶段，可能会频繁更改。
本文档也可能无法完全反映最新的更改。

                                      输入 |gO| 查看目录。

==============================================================================
解析器文件                                              *treesitter-parsers*

解析器是 treesitter 的核心。它们是 treesitter 将在 `parser` 运行时目录中
搜索的库。

Nvim 包含以下解析器：

- C
- Lua
- Markdown
- Vimscript
- Vimdoc
- Treesitter 查询文件 |ft-query-plugin|

你可以手动安装更多解析器，或使用插件如
https://github.com/nvim-treesitter/nvim-treesitter 。

解析器在 'runtimepath' 目录中作为 `parser/{lang}.*` 被搜索。
如果找到同一语言的多个解析器，将使用第一个。
（注意：这通常意味着优先级是"用户配置 > 插件 > 内置"。）

要从文件路径加载解析器： >lua

    vim.treesitter.language.add('python', { path = "/path/to/python.so" })
<
如果文件系统区分大小写，解析器名称假定为小写。

要将某些 |filetypes| 与 treesitter 语言（解析器名称）关联，
使用 |vim.treesitter.language.register()|。例如，要对文件类型为
`svg` 或 `xslt` 的缓冲区使用 `xml` treesitter 解析器： >lua

    vim.treesitter.language.register('xml', { 'svg', 'xslt' })
<
                                                    *treesitter-parsers-wasm*

如果 Nvim 是用 `ENABLE_WASMTIME` 构建的，那么也可以加载 wasm 解析器： >lua

    vim.treesitter.language.add('python', { path = "/path/to/python.wasm" })
<

==============================================================================
TREESITTER 查询                                          *treesitter-query*

Treesitter 查询是一种从解析的 |TSTree| 中提取信息的方式，
例如，用于高亮显示。简而言之，一个 `query` 包含一个或多个
模式。一个 `pattern` 是在语法树中的节点类型上定义的。
一个 `match` 对应于语法树中匹配模式的特定元素。模式可以
选择性地定义捕获和谓词。一个 `capture` 允许你将名称与模式中
的特定节点关联。一个 `predicate` 为匹配添加任意元数据和
条件数据。

查询用一种类似 lisp 的语言编写，在
https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax
中有文档说明
注意：那里列出的谓词与 Nvim 支持的谓词不同。参见
|treesitter-predicates| 获取 Nvim 支持的谓词的完整列表。

Nvim 在 'runtimepath' 下的 `queries` 目录中查找查询作为 `*.scm` 文件，
其中每个文件包含特定语言和用途的查询，例如，
`queries/lua/highlights.scm` 用于高亮显示 Lua 文件。
默认情况下，使用 'runtimepath' 上的第一个查询（这通常意味着
用户配置优先于插件，插件优先于 Nvim 内置的查询）。如果查询
应该扩展其他查询而不是替换它们，使用 |treesitter-query-modeline-extends|。

Lua 接口在 |lua-treesitter-query| 中描述。


TREESITTER 查询谓词                            *treesitter-predicates*

谓词是特殊的 scheme 节点，它们被评估以有条件地捕获节点。
例如，`eq?` 谓词可以如下使用： >query

    ((identifier) @variable.builtin
      (#eq? @variable.builtin "self"))
<
只匹配对应于 `"self"` 文本的标识符。这样的查询可以用于
以不同方式高亮显示内置函数或变量。

以下是内置谓词：

    `eq?`                                            *treesitter-predicate-eq?*
        将字符串与节点对应的文本匹配： >query
            ((identifier) @variable.builtin (#eq? @variable.builtin "self"))
            ((node1) @left (node2) @right (#eq? @left @right))
<
    `any-eq?`                                    *treesitter-predicate-any-eq?*
        类似于 `eq?`，但对于量化模式，只有一个捕获的节点必须
        匹配。

    `match?`                                      *treesitter-predicate-match?*
    `vim-match?`                              *treesitter-predicate-vim-match?*
         将 |regexp| 与节点对应的文本匹配： >query
            ((identifier) @constant (#match? @constant "^[A-Z_]+$"))
<
         注意：`^` 和 `$` 锚点将匹配节点文本的开始和结束。

    `any-match?`                              *treesitter-predicate-any-match?*
    `any-vim-match?`                      *treesitter-predicate-any-vim-match?*
        类似于 `match?`，但对于量化模式，只有一个捕获的节点必须
        匹配。

    `lua-match?`                              *treesitter-predicate-lua-match?*
         将 |lua-patterns| 与节点对应的文本匹配，
         类似于 `match?`

    `any-lua-match?`                      *treesitter-predicate-any-lua-match?*
         类似于 `lua-match?`，但对于量化模式，只有一个捕获的节点
         必须匹配。

    `contains?`                                *treesitter-predicate-contains?*
        将字符串与节点对应文本的部分匹配： >query
            ((identifier) @foo (#contains? @foo "foo"))
            ((identifier) @foo-bar (#contains? @foo-bar "foo" "bar"))
<
    `any-contains?`                        *treesitter-predicate-any-contains?*
        类似于 `contains?`，但对于量化模式，只有一个捕获的节点必须
        匹配。

    `any-of?`                                    *treesitter-predicate-any-of?*
        将给定字符串中的任何一个与节点对应的文本匹配： >query
            ((identifier) @foo (#any-of? @foo "foo" "bar"))
<
        这是检查节点是否匹配多个关键字中任何一个的推荐方式，
        因为它已经为此进行了优化。

    `has-ancestor?`                        *treesitter-predicate-has-ancestor?*
        将给定的节点类型与节点的所有祖先匹配： >query
            ((identifier) @variable.builtin
              (#any-of? @variable.builtin "begin" "end")
              (#has-ancestor? @variable.builtin range_expression))
<
    `has-parent?`                            *treesitter-predicate-has-parent?*
        将给定的节点类型与节点的直接祖先匹配： >query
            (((field_expression
                 (field_identifier) @method)) @_parent
             (#has-parent? @_parent template_method function_declarator))
<
                                                    *treesitter-predicate-not*
每个谓词都有一个带 `not-` 前缀的谓词，它只是谓词的否定。

                                                    *treesitter-predicate-all*
                                                    *treesitter-predicate-any*
查询可以使用量词来捕获多个节点。当捕获包含多个节点时，
谓词只有在捕获包含的所有节点都匹配谓词时才匹配。一些谓词
（`eq?`、`match?`、`lua-match?`、`contains?`）接受 `any-` 前缀
来改为在捕获包含的任何节点匹配谓词时匹配。

例如，考虑以下 Lua 代码： >lua

  -- TODO: This is a
  -- very long
  -- comment (just imagine it)
<
使用以下带谓词的查询：
>query
    (((comment)+ @comment)
     (#match? @comment "TODO"))
<
这个查询不会匹配，因为不是 @comment 捕获的所有节点都匹配
谓词。相反，使用：
>query
    (((comment)+ @comment)
     (#any-match? @comment "TODO"))
<

可以通过 |vim.treesitter.query.add_predicate()| 添加更多谓词。
使用 |vim.treesitter.query.list_predicates()| 列出所有可用的谓词。


TREESITTER 查询指令                            *treesitter-directives*

Treesitter 指令存储节点或匹配的元数据并执行副作用。
例如，`set!` 指令在匹配或节点上设置元数据： >query

        ((identifier) @foo (#set! type "parameter"))
<
以下是内置指令：

    `set!`                                          *treesitter-directive-set!*
        为特定匹配或捕获设置键/值元数据。值可以作为
        `metadata[key]`（匹配特定）或 `metadata[capture_id][key]`
        （捕获特定）访问。

        参数： ~
            {capture_id}（可选）
            {key}
            {value}

        示例： >query
            ((identifier) @foo (#set! @foo kind "parameter"))
            ((node1) @left (node2) @right (#set! type "pair"))
            ((codeblock) @markup.raw.block (#set! priority 90))
<
    `offset!`                                      *treesitter-directive-offset!*
        获取捕获节点的范围并应用偏移。这将为捕获节点设置
        一个新的范围，形式为 { {start_row}, {start_col},
        {end_row}, {end_col} }，作为 `metadata[capture_id].range`。
        对于 |treesitter-language-injections| 很有用。

        参数： ~
            {capture_id}
            {start_row}
            {start_col}
            {end_row}
            {end_col}

        示例： >query
            ((identifier) @constant (#offset! @constant 0 1 0 -1))
<
    `gsub!`                                          *treesitter-directive-gsub!*
        使用 |lua-pattern| 转换节点的内容。这将设置
        一个新的 `metadata[capture_id].text`。

        参数： ~
            {capture_id}
            {pattern}
            {replacement}

        示例： >query
            (#gsub! @_node ".*%.(.*)" "%1")
<
    `trim!`                                          *treesitter-directive-trim!*
        从节点中修剪空白。设置一个新的
        `metadata[capture_id].range`。接受一个捕获 ID 和可选的四个
        整数来自定义修剪行为（`1` 表示修剪，`0` 表示不修剪）。
        当只给出捕获 ID 时，从节点末尾修剪空行（只包含空白
        的行，或空行）（为了向后兼容）。如果给出参数，可以
        从节点两侧修剪所有空白。

        示例： >query
            ; 只从节点末尾修剪空行
            ; （等同于 (#trim! @fold 0 0 1 0)）
            (#trim! @fold)

            ; 从节点两侧修剪空行
            (#trim! @fold 1 0 1 0)

            ; 修剪节点周围的所有空白
            (#trim! @fold 1 1 1 1)
<
        参数： ~
            {capture_id}
            {trim_start_linewise}
            {trim_start_charwise}
            {trim_end_linewise}（如果只给出 {capture_id}，默认为 `1`）
            {trim_end_charwise}

可以通过 |vim.treesitter.query.add_directive()| 添加更多指令。
使用 |vim.treesitter.query.list_directives()| 列出所有可用的指令。


TREESITTER 查询模式行                          *treesitter-query-modeline*

Nvim 支持使用一组"模式行"来自定义查询的行为，即查询中
以 `;` 开头的注释。以下是当前支持的模式行替代方案：

    `inherits: {lang}...`                     *treesitter-query-modeline-inherits*
        指定此查询应该继承来自 {lang} 的查询。
        这将递归地下降到 {lang} 的查询中，除非用
        括号括起来：`({lang})`。
        注意：这旨在用于包含来自另一种语言的查询。
        如果你希望你的查询扩展同一语言的查询，使用 `extends`。

    `extends`                                  *treesitter-query-modeline-extends*
        指定此查询应该用作查询的扩展，即它应该
        与其他查询合并。
        注意：扩展的顺序，以及将用作基础的查询
        取决于你的 'runtimepath' 值。

注意：这些模式行注释必须在查询的顶部，但可以重复，
例如，以下两个模式行块都是有效的：
>query
    ;; inherits: typescript,jsx
    ;; extends
<
>query
    ;; extends
    ;;
    ;; inherits: css
<



==============================================================================
TREESITTER 语法高亮                          *treesitter-highlight*

语法高亮通过名为 `highlights.scm` 的查询指定，这些查询将
解析的 |TSTree| 中的 |TSNode| 匹配到可以分配高亮组的
`capture`。例如，查询 >query

    (parameters (identifier) @variable.parameter)
<
将函数 `parameters` 节点内的任何 `identifier` 节点匹配到
名为 `@variable.parameter` 的捕获。例如，对于 Lua 代码 >lua

    function f(foo, bar) end
<
它将被解析为（参见 |:InspectTree|）： >query

    (function_declaration ; [1:1 - 24]
      name: (identifier) ; [1:10 - 10]
      parameters: (parameters ; [1:11 - 20]
        name: (identifier) ; [1:12 - 14]
        name: (identifier))) ; [1:17 - 19]
<
上面的查询将把 `foo` 和 `bar` 高亮显示为 `@variable.parameter`。

也可以匹配字面表达式（如果解析器返回它们）：
>query
    [
      "if"
      "else"
    ] @keyword.conditional
<
假设在 runtimepath 中找到合适的解析器和 `highlights.scm` 查询，
可以通过 |vim.treesitter.start()| 简单地启用当前缓冲区的
treesitter 高亮。

                                                 *treesitter-highlight-groups*
捕获名称，前缀为 `@`，可以直接用作高亮组。
对于许多常用的捕获，相应的捕获组默认链接到 Nvim 的
标准 |highlight-groups|（例如，`@comment` 链接到 `Comment`），
但可以在颜色方案中覆盖。

实现了一个回退系统，使更具体的组回退到更通用的组。
例如，在具有单独文档注释的语言中（例如，c、java 等），
可以使用 `@comment.documentation`。如果未定义此组，
则使用普通 `@comment` 的高亮。这样，现有的颜色方案
已经可以开箱即用，但可以为使它们可用的查询添加
更具体的变体。

作为附加规则，捕获高亮始终可以通过在附加点后附加
语言名称来专门化。例如，要按语言不同地高亮显示注释： >vim

    hi @comment.c guifg=Blue
    hi @comment.lua guifg=DarkBlue
    hi link @comment.documentation.java String
<
以下是 Nvim 查询中使用的标准捕获列表，根据当前颜色方案
高亮显示（使用 |:Inspect| 查看一个以查看确切定义）：

@variable                       各种变量名
@variable.builtin               内置变量名（例如 `this`、`self`）
@variable.parameter             函数参数
@variable.parameter.builtin     特殊参数（例如 `_`、`it`）
@variable.member                对象和结构体字段

@constant               常量标识符
@constant.builtin       内置常量值
@constant.macro         预处理器定义的常量

@module                模块或命名空间
@module.builtin        内置模块或命名空间
@label                 `GOTO` 和其他标签（例如 C 中的 `label:`），包括 heredoc 标签

@string                字符串字面量
@string.documentation  记录代码的字符串（例如 Python 文档字符串）
@string.regexp         正则表达式
@string.escape         转义序列
@string.special        其他特殊字符串（例如日期）
@string.special.symbol 符号或原子
@string.special.path   文件名
@string.special.url    URI（例如超链接）

@character             字符字面量
@character.special     特殊字符（例如通配符）

@boolean               布尔字面量
@number                数字字面量
@number.float          浮点数字面量

@type                  类型或类定义和注解
@type.builtin          内置类型
@type.definition       类型定义中的标识符（例如 C 中的 `typedef <type> <identifier>`）

@attribute             属性注解（例如 Python 装饰器、Rust 生命周期）
@attribute.builtin     内置注解（例如 Python 中的 `@property`）
@property              键值对中的键

@function              函数定义
@function.builtin      内置函数
@function.call         函数调用
@function.macro        预处理器宏

@function.method       方法定义
@function.method.call  方法调用

@constructor           构造函数调用和定义
@operator              符号运算符（例如 `+`、`*`）

@keyword               不适合特定类别的关键字
@keyword.coroutine     与协程相关的关键字（例如 Go 中的 `go`，Python 中的 `async/await`）
@keyword.function      定义函数的关键字（例如 Go 中的 `func`，Python 中的 `def`）
@keyword.operator      是英文单词的运算符（例如 `and`、`or`）
@keyword.import        用于包含或导出模块的关键字（例如 Python 中的 `import`、`from`）
@keyword.type          描述命名空间和复合类型的关键字（例如 `struct`、`enum`）
@keyword.modifier      修改其他构造的关键字（例如 `const`、`static`、`public`）
@keyword.repeat        与循环相关的关键字（例如 `for`、`while`）
@keyword.return        像 `return` 和 `yield` 这样的关键字
@keyword.debug         与调试相关的关键字
@keyword.exception     与异常相关的关键字（例如 `throw`、`catch`）

@keyword.conditional        与条件相关的关键字（例如 `if`、`else`）
@keyword.conditional.ternary 三元运算符（例如 `?`、`:`）

@keyword.directive          各种预处理器指令和 shebang
@keyword.directive.define   预处理器定义指令

@punctuation.delimiter  分隔符（例如 `;`、`.`、`,`）
@punctuation.bracket    括号（例如 `()`、`{}`、`[]`）
@punctuation.special    特殊符号（例如字符串插值中的 `{}`）

@comment               行注释和块注释
@comment.documentation 记录代码的注释

@comment.error         错误类型注释（例如 `ERROR`、`FIXME`、`DEPRECATED`）
@comment.warning       警告类型注释（例如 `WARNING`、`FIX`、`HACK`）
@comment.todo          todo 类型注释（例如 `TODO`、`WIP`）
@comment.note          note 类型注释（例如 `NOTE`、`INFO`、`XXX`）

@markup.strong         粗体文本
@markup.italic         斜体文本
@markup.strikethrough  删除线文本
@markup.underline      下划线文本（仅用于字面下划线标记！）

@markup.heading        标题、标题（包括标记）
@markup.heading.1      顶级标题
@markup.heading.2      章节标题
@markup.heading.3      小节标题
@markup.heading.4      以此类推
@markup.heading.5      以此类推
@markup.heading.6      六个级别应该足够任何人使用

@markup.quote          块引用
@markup.math           数学环境（例如 LaTeX 中的 `$ ... $`）

@markup.link           文本引用、脚注、引用等
@markup.link.label     链接、引用描述
@markup.link.url       URL 样式链接

@markup.raw            字面或逐字文本（例如内联代码）
@markup.raw.block      作为独立块的字面或逐字文本

@markup.list           列表标记
@markup.list.checked   已检查的 todo 样式列表标记
@markup.list.unchecked 未检查的 todo 样式列表标记

@diff.plus             添加的文本（用于 diff 文件）
@diff.minus            删除的文本（用于 diff 文件）
@diff.delta            更改的文本（用于 diff 文件）

@tag                   XML 样式标签名（例如在 XML、HTML 等中）
@tag.builtin          内置标签名（例如 HTML5 标签）
@tag.attribute        XML 样式标签属性
@tag.delimiter        XML 样式标签分隔符

                                                  *treesitter-highlight-spell*
特殊的 `@spell` 捕获可用于指示节点应该由 Nvim 的内置
|spell| 检查器检查。例如，以下捕获将注释标记为要检查： >query

    (comment) @spell
<

还有 `@nospell` 用于禁用带有 `@spell` 的区域的拼写检查。

                                                *treesitter-highlight-conceal*
Treesitter 高亮支持通过 `conceal` 和 `conceal_lines` 元数据
进行 |conceal|。按照惯例，要隐藏的节点被捕获为 `@conceal`，
但可以使用任何捕获。例如，以下查询可用于隐藏
Markdown 中的代码块分隔符： >query

    ((fenced_code_block_delimiter) @conceal (#set! conceal ""))
<
也可以用单个字符替换节点，与旧语法不同，可以给它
一个自定义高亮。例如，以下（不明智的）查询将 `!=` 运算符
替换为 Unicode 字形，它仍然与其他运算符高亮相同： >query

    "!=" @operator (#set! conceal "≠")
<
要隐藏整行（完全不绘制它），可以使用带有 `conceal_lines`
元数据的查询： >query

    ((comment) @comment @spell
      (#set! conceal_lines ""))
<
以这种方式指定的隐藏尊重 'conceallevel' 和 'concealcursor'。

注意，虽然你可以为 `conceal` 使用任何字符串，但只会使用
第一个字符： >query

    ; 标识符将被 'f' 隐藏。
    ((identifier) @conceal (#set! conceal "foo"))
<

                                               *treesitter-highlight-priority*
Treesitter 使用 |nvim_buf_set_extmark()| 设置高亮，默认
优先级为 100。这使插件可以设置低于或高于 treesitter 的
高亮优先级。也可以通过设置其 `"priority"` 元数据属性
手动更改单个查询模式的优先级： >query

    ((super_important_node) @superimportant (#set! priority 105))
<

                                          *treesitter-highlight-commentstring*
Treesitter 高亮支持更细粒度的 'commentstring'，由内置的
|commenting| 插件使用。当光标在设置 `bo.commentstring` 元数据
属性的节点内时（|treesitter-directive-set!|），该属性定义
注释分隔符（其中"最内层获胜"）。这对于像 `JSX` 这样根据
代码区域有不同注释语法的语言很有用，例如： >query

    ((jsx_element) @_tag (#set! @_tag bo.commentstring "{/* %s */}"))
<
当多个捕获在区域上设置此元数据时，只有最内层（最具体）
的一个应用于给定区域。

==============================================================================
TREESITTER 语言注入                *treesitter-language-injections*
<

注意以下信息改编自：
  https://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection

一些源文件包含用多种不同语言编写的代码。
示例包括：

    • HTML 文件，可以在 `<script>` 标签中包含 JavaScript，
      在 `<style>` 标签中包含 CSS
    • ERB 文件，在 `<%` `%>` 标签中包含 Ruby，在这些标签
      之外包含 HTML
    • PHP 文件，可以在 `<php` 标签之间包含 HTML
    • JavaScript 文件，在正则表达式字面量中包含正则表达式语法
    • Ruby，可以在 heredoc 字面量中包含代码片段，其中
      heredoc 分隔符通常指示语言
    • Lua，可以在 |vim.cmd()| 调用中包含 Vimscript 片段。
    • Vimscript，可以在 |:lua-heredoc| 块中包含 Lua 片段。

所有这些示例都可以用父语法树和一个或多个注入的语法树来建模，
这些语法树位于父树中的某些节点内。语言注入查询允许你使用
以下捕获来指定这些"注入"：

    • `@injection.content` - 指示捕获的节点应该使用另一种语言
      重新解析其内容。
    • `@injection.language` - 指示捕获节点的文本可能包含
      应该用于重新解析 `@injection.content` 的语言名称。
    • `@injection.filename` - 指示捕获节点的文本可能包含
      文件名；然后通过 |vim.filetype.match()| 查找相应的
      文件类型，并视为应该用于重新解析 `@injection.content`
      的语言名称。

语言注入行为也可以通过与模式关联的一些属性来配置：

    • `injection.language` - 可用于硬编码特定语言的名称。
    • `injection.combined` - 指示树中所有匹配的节点应该
      将其内容作为一个嵌套文档解析。
    • `injection.include-children` - 指示应该重新解析
      `@injection.content` 节点的整个文本，包括其子节点
      的文本。默认情况下，子节点的文本将从注入的文档中
      排除。
    • `injection.self` - 指示节点的文本应该用与节点的
      LanguageTree 相同的语言解析。
    • `injection.parent` - 指示捕获节点的文本应该用与
      节点的父 LanguageTree 相同的语言解析。

注入查询当前在整个缓冲区上运行，这对于大型缓冲区可能很慢。
要禁用注入，例如，对于 `c`，只需在 'runtimepath' 中放置一个
空的 `queries/c/injections.scm` 文件。

==============================================================================
VIM.TREESITTER                                                *lua-treesitter*

本文档的其余部分是 `vim.treesitter` Lua 模块的参考手册，
这是 Nvim 的 treesitter 集成的主要接口。
以下大部分内容是从函数文档自动生成的。


                                             *vim.treesitter.language_version*
捆绑的 treesitter 库支持的最新解析器 ABI 版本。

                                     *vim.treesitter.minimum_language_version*
捆绑的 treesitter 库支持的最早解析器 ABI 版本。

==============================================================================
TREESITTER 树                                    *treesitter-tree* *TSTree*

"treesitter 树"表示缓冲区的解析内容，可用于执行进一步
的分析。它是 treesitter 库持有的对象的 |userdata| 引用。

treesitter 树的实例 `TSTree` 支持以下方法。


TSTree:copy()                                                  *TSTree:copy()*
    返回 `TSTree` 的副本。

    返回： ~
        (`TSTree`)

TSTree:root()                                                  *TSTree:root()*
    返回此树的根节点。

    返回： ~
        (`TSNode`)


==============================================================================
TREESITTER 节点                                    *treesitter-node* *TSNode*

"treesitter 节点"表示缓冲区解析内容中的一个特定元素，
可以由 |Query| 捕获，例如，用于高亮显示。它是 treesitter
库持有的对象的 |userdata| 引用。

treesitter 节点的实例 `TSNode` 支持以下方法。


TSNode:byte_length()                                    *TSNode:byte_length()*
    返回此节点跨越的字节数。

    返回： ~
        (`integer`)

TSNode:child({index})                                         *TSNode:child()*
    获取给定 {index} 处的节点的子节点，其中零表示第一个
    子节点。

    参数： ~
      • {index}  (`integer`)

    返回： ~
        (`TSNode?`)

TSNode:child_count()                                    *TSNode:child_count()*
    获取节点的子节点数。

    返回： ~
        (`integer`)

                                              *TSNode:child_with_descendant()*
TSNode:child_with_descendant({descendant})
    获取包含 {descendant} 的节点的子节点（包括 {descendant}）。

    例如，使用以下节点层次结构： >
        a -> b -> c

        a:child_with_descendant(c) == b
        a:child_with_descendant(b) == b
        a:child_with_descendant(a) == nil
<

    参数： ~
      • {descendant}  (`TSNode`)

    返回： ~
        (`TSNode?`)

                                               *TSNode:descendant_for_range()*
TSNode:descendant_for_range({start_row}, {start_col}, {end_row}, {end_col})
    获取此节点内跨越给定（行、列）位置范围的最小节点

    参数： ~
      • {start_row}  (`integer`)
      • {start_col}  (`integer`)
      • {end_row}    (`integer`)
      • {end_col}    (`integer`)

    返回： ~
        (`TSNode?`)

TSNode:end_()                                                  *TSNode:end_()*
    获取节点的结束位置。返回三个值：行、列和总字节数
    （都从零开始）。

    返回（多个）： ~
        (`integer`)
        (`integer`)
        (`integer`)

TSNode:equal({node})                                          *TSNode:equal()*
    检查 {node} 是否引用同一树中的同一节点。

    参数： ~
      • {node}  (`TSNode`)

    返回： ~
        (`boolean`)

TSNode:extra()                                                *TSNode:extra()*
    检查节点是否是额外的。额外节点表示像注释这样的东西，
    它们不是语法所必需的，但可以出现在任何地方。

    返回： ~
        (`boolean`)

TSNode:field({name})                                          *TSNode:field()*
    返回具有给定字段名的所有节点子节点的列表。

    参数： ~
      • {name}  (`string`)

    返回： ~
        (`TSNode[]`)

TSNode:has_changes()                                    *TSNode:has_changes()*
    检查语法节点是否已被编辑。

    返回： ~
        (`boolean`)

TSNode:has_error()                                        *TSNode:has_error()*
    检查节点是否是语法错误或包含任何语法错误。

    返回： ~
        (`boolean`)

TSNode:id()                                                      *TSNode:id()*
    获取节点在其自己的树中的唯一标识符。

    不对此标识符的内部表示做任何保证，除了是
    具有值相等性的原始 Lua 类型（所以不是表）。
    目前它是一个（不可打印的）字符串。

    注意：`id` 不保证对于来自不同树的节点是唯一的。

    返回： ~
        (`string`)

TSNode:iter_children()                                *TSNode:iter_children()*
    迭代 {TSNode} 的所有直接子节点，无论它们是否命名。
    返回子节点加上与此子节点对应的字段名。

    返回： ~
        (`fun(): TSNode, string`)

TSNode:missing()                                            *TSNode:missing()*
    检查节点是否缺失。缺失节点由解析器插入以从
    某些类型的语法错误中恢复。

    返回： ~
        (`boolean`)

TSNode:named()                                                *TSNode:named()*
    检查节点是否命名。命名节点对应于语法中的命名规则，
    而匿名节点对应于语法中的字符串字面量。

    返回： ~
        (`boolean`)

TSNode:named_child({index})                             *TSNode:named_child()*
    获取给定 {index} 处的节点的命名子节点，其中零表示
    第一个命名子节点。

    参数： ~
      • {index}  (`integer`)

    返回： ~
        (`TSNode?`)

TSNode:named_child_count()                        *TSNode:named_child_count()*
    获取节点的命名子节点数。

    返回： ~
        (`integer`)

TSNode:named_children()                              *TSNode:named_children()*
    返回节点的命名子节点列表。

    返回： ~
        (`TSNode[]`)

                                         *TSNode:named_descendant_for_range()*
TSNode:named_descendant_for_range({start_row}, {start_col}, {end_row},
                                  {end_col})
    获取此节点内跨越给定（行、列）位置范围的最小命名节点

    参数： ~
      • {start_row}  (`integer`)
      • {start_col}  (`integer`)
      • {end_row}    (`integer`)
      • {end_col}    (`integer`)

    返回： ~
        (`TSNode?`)

TSNode:next_named_sibling()                      *TSNode:next_named_sibling()*
    获取节点的下一个命名兄弟节点。

    返回： ~
        (`TSNode?`)

TSNode:next_sibling()                                  *TSNode:next_sibling()*
    获取节点的下一个兄弟节点。

    返回： ~
        (`TSNode?`)

TSNode:parent()                                              *TSNode:parent()*
    获取节点的直接父节点。对于迭代节点的祖先，
    优先使用 |TSNode:child_with_descendant()|。

    返回： ~
        (`TSNode?`)

TSNode:prev_named_sibling()                      *TSNode:prev_named_sibling()*
    获取节点的前一个命名兄弟节点。

    返回： ~
        (`TSNode?`)

TSNode:prev_sibling()                                  *TSNode:prev_sibling()*
    获取节点的前一个兄弟节点。

    返回： ~
        (`TSNode?`)

TSNode:range({include_bytes})                                 *TSNode:range()*
    获取节点的范围。

    返回四个或六个值：
    • 开始行
    • 开始列
    • 开始字节（如果 {include_bytes} 为 `true`）
    • 结束行
    • 结束列
    • 结束字节（如果 {include_bytes} 为 `true`）

    参数： ~
      • {include_bytes}  (`false?`)

    返回（多个）： ~
        (`integer`)
        (`integer`)
        (`integer`)
        (`integer`)

TSNode:sexpr()                                                *TSNode:sexpr()*
    获取表示节点的 S 表达式作为字符串。

    返回： ~
        (`string`)

TSNode:start()                                                *TSNode:start()*
    获取节点的开始位置。返回三个值：行、列和总字节数
    （都从零开始）。

    返回（多个）： ~
        (`integer`)
        (`integer`)
        (`integer`)

TSNode:symbol()                                              *TSNode:symbol()*
    获取节点的类型作为数字 id。

    返回： ~
        (`integer`)

TSNode:tree()                                                  *TSNode:tree()*
    获取节点的 |TSTree|。

    返回： ~
        (`TSTree`)

TSNode:type()                                                  *TSNode:type()*
    获取节点的类型作为字符串。

    返回： ~
        (`string`)


==============================================================================
Lua 模块：vim.treesitter                               *lua-treesitter-core*

foldexpr({lnum})                                   *vim.treesitter.foldexpr()*
    返回当前缓冲区中 {lnum} 的折叠级别。可以直接设置
    到 'foldexpr'： >lua
        vim.wo.foldexpr = 'v:lua.vim.treesitter.foldexpr()'
<

    属性： ~
        自：0.9.0

    参数： ~
      • {lnum}  (`integer?`) 要计算折叠级别的行号

    返回： ~
        (`string`)

                                     *vim.treesitter.get_captures_at_cursor()*
get_captures_at_cursor({winnr})
    返回光标下的高亮捕获名称列表

    参数： ~
      • {winnr}  (`integer?`) |window-ID| 或 0 表示当前窗口（默认）

    返回： ~
        (`string[]`) 捕获名称列表

                                        *vim.treesitter.get_captures_at_pos()*
get_captures_at_pos({bufnr}, {row}, {col})
    返回给定位置的高亮捕获列表

    每个捕获由一个表表示，该表包含捕获名称作为字符串、
    捕获的语言、元数据表（`priority`、`conceal` 等；
    如果没有定义则为空）和捕获的 id。

    参数： ~
      • {bufnr}  (`integer`) 缓冲区号（0 表示当前缓冲区）
      • {row}    (`integer`) 位置行
      • {col}    (`integer`) 位置列

    返回： ~
        (`{capture: string, lang: string, metadata: vim.treesitter.query.TSMetadata, id: integer}[]`)

get_node({opts})                                   *vim.treesitter.get_node()*
    返回给定位置的最小命名节点

    注意：在未解析的树上调用这可能产生无效节点。如果
    树不知道是否被解析，例如，通过活动的高亮器，首先
    通过 >lua
        vim.treesitter.get_parser(bufnr):parse(range)
< 解析树

    参数： ~
      • {opts}  (`table?`) 可选关键字参数：
                • {bufnr} (`integer?`) 缓冲区号（nil 或 0 表示当前
                  缓冲区）
                • {pos} (`[integer, integer]?`) 0 索引的（行、列）元组。
                  默认为当前窗口中的光标位置。如果 {bufnr} 不是
                  当前缓冲区，则需要
                • {lang} (`string?`) 解析器语言。（默认：从缓冲区
                  文件类型）
                • {ignore_injections} (`boolean?`) 忽略注入的语言
                  （默认 true）
                • {include_anonymous} (`boolean?`) 包括匿名节点
                  （默认 false）

    返回： ~
        (`TSNode?`) 给定位置的节点

get_node_range({node_or_range})              *vim.treesitter.get_node_range()*
    返回节点的范围或解包的范围表

    参数： ~
      • {node_or_range}  (`TSNode|Range4`) 节点或位置表

    返回（多个）： ~
        (`integer`) start_row
        (`integer`) start_col
        (`integer`) end_row
        (`integer`) end_col

                                              *vim.treesitter.get_node_text()*
get_node_text({node}, {source}, {opts})
    获取给定节点对应的文本

    参数： ~
      • {node}    (`TSNode`)
      • {source}  (`integer|string`) 从中提取 {node} 的缓冲区或字符串
      • {opts}    (`table?`) 可选参数。
                  • metadata (table) 特定捕获的元数据。这
                    在使用 |vim.treesitter.query.add_directive()| 时
                    将设置为 `metadata[capture_id]`。

    返回： ~
        (`string`)

get_parser({bufnr}, {lang}, {opts})              *vim.treesitter.get_parser()*
    返回特定缓冲区的解析器并将其附加到缓冲区

    如果需要，这将创建解析器。

    如果无法创建解析器，将抛出错误。设置 `opts.error = false`
    来抑制此错误并返回 nil（和错误消息）。警告：
    此行为将在 Nvim 0.12 中成为默认行为，并且该选项将
    被删除。

    参数： ~
      • {bufnr}  (`integer?`) 解析器应该绑定到的缓冲区（默认：
                当前缓冲区）
      • {lang}   (`string?`) 此解析器的语言（默认：从缓冲区
                文件类型）
      • {opts}   (`table?`) 传递给创建的语言树的选项

    返回（多个）： ~
        (`vim.treesitter.LanguageTree?`) 用于解析的对象
        (`string?`) 错误消息（如果适用）

get_range({node}, {source}, {metadata})           *vim.treesitter.get_range()*
    获取 |TSNode| 的范围。也可以提供 {source} 和 {metadata} 来
    获取应用了指令的范围。

    参数： ~
      • {node}      (`TSNode`)
      • {source}    (`integer|string?`) 从中提取 {node} 的缓冲区或字符串
      • {metadata}  (`vim.treesitter.query.TSMetadata?`)

    返回： ~
        (`table`) 具有以下字段的表：
        • {[1]} (`integer`) 开始行
        • {[2]} (`integer`) 开始列
        • {[3]} (`integer`) 开始字节
        • {[4]} (`integer`) 结束行
        • {[5]} (`integer`) 结束列
        • {[6]} (`integer`) 结束字节

                                          *vim.treesitter.get_string_parser()*
get_string_parser({str}, {lang}, {opts})
    返回字符串解析器

    参数： ~
      • {str}   (`string`) 要解析的文本
      • {lang}  (`string`) 此字符串的语言
      • {opts}  (`table?`) 传递给创建的语言树的选项

    返回： ~
        (`vim.treesitter.LanguageTree`) 用于解析的对象

inspect_tree({opts})                           *vim.treesitter.inspect_tree()*
    打开一个窗口，显示语言树中节点的文本表示。

    在窗口中，按 "a" 切换匿名节点的显示，"I" 切换
    每个节点的源语言显示，"o" 切换查询编辑器，按
    <Enter> 跳转到源缓冲区中光标下的节点。折叠也
    有效（试试 |zo|、|zc| 等）。

    也可以用 `:InspectTree` 显示。                      *:InspectTree*

    属性： ~
        自：0.9.0

    参数： ~
      • {opts}  (`table?`) 可选选项表，具有以下可能的
               键：
               • lang (string|nil)：源缓冲区的语言。如果
                 省略，从源缓冲区的文件类型检测。
               • bufnr (integer|nil)：要绘制树的缓冲区。如果
                 省略，创建新缓冲区。
               • winid (integer|nil)：显示树缓冲区的窗口 id。
                 如果省略，用 {command} 创建新窗口。
               • command (string|nil)：创建窗口的 Vimscript
                 命令。默认值为 "60vnew"。仅在 {winid} 为
                 nil 时使用。
               • title (string|fun(bufnr:integer):string|nil)：
                 窗口的标题。如果是函数，它接受源缓冲区的
                 缓冲区号作为其唯一参数，并应返回一个字符串。

is_ancestor({dest}, {source})                   *vim.treesitter.is_ancestor()*
    确定一个节点是否是另一个节点的祖先

    参数： ~
      • {dest}    (`TSNode`) 可能的祖先
      • {source}  (`TSNode`) 可能的后代

    返回： ~
        (`boolean`) 如果 {dest} 是 {source} 的祖先则为 true

                                           *vim.treesitter.is_in_node_range()*
is_in_node_range({node}, {line}, {col})
    确定（行、列）位置是否在节点范围内

    参数： ~
      • {node}  (`TSNode`) 定义范围
      • {line}  (`integer`) 行（从零开始）
      • {col}   (`integer`) 列（从零开始）

    返回： ~
        (`boolean`) 如果位置在节点范围内则为 true

node_contains({node}, {range})                *vim.treesitter.node_contains()*
    确定节点是否包含范围

    参数： ~
      • {node}   (`TSNode`)
      • {range}  (`table`)

    返回： ~
        (`boolean`) 如果 {node} 包含 {range} 则为 true

start({bufnr}, {lang})                                *vim.treesitter.start()*
    开始缓冲区的 treesitter 高亮

    可以在 ftplugin 或 FileType 自动命令中使用。

    注意：默认情况下，禁用正则表达式语法高亮，这可能
    是某些插件所需的。在这种情况下，在调用 `start` 后
    添加 `vim.bo.syntax = 'on'`。

    注意：默认情况下，高亮器异步解析代码，使用 3ms 的
    段时。

    示例： >lua
        vim.api.nvim_create_autocmd( 'FileType', { pattern = 'tex',
            callback = function(args)
                vim.treesitter.start(args.buf, 'latex')
                vim.bo[args.buf].syntax = 'on'  -- 仅在需要额外旧语法时
            end
        })
<

    参数： ~
      • {bufnr}  (`integer?`) 要高亮的缓冲区（默认：当前
                缓冲区）
      • {lang}   (`string?`) 解析器的语言（默认：从缓冲区
                文件类型）

stop({bufnr})                                          *vim.treesitter.stop()*
    停止缓冲区的 treesitter 高亮

    参数： ~
      • {bufnr}  (`integer?`) 要停止高亮的缓冲区（默认：当前
                缓冲区）


==============================================================================
Lua 模块：vim.treesitter.language                      *treesitter-language*

add({lang}, {opts})                            *vim.treesitter.language.add()*
    加载名为 {lang} 的解析器

    在 `parser` 运行时目录中搜索解析器，或提供的
    {path}。可用于在启用 treesitter 功能之前检查
    可用的解析器，例如， >lua
          if vim.treesitter.language.add('markdown') then
            vim.treesitter.start(bufnr, 'markdown')
          end
<

    参数： ~
      • {lang}  (`string`) 解析器名称（仅字母数字和 `_`）
      • {opts}  (`table?`) 选项：
                • {path}? (`string`) 解析器所在的可选路径
                • {symbol_name}? (`string`) 要加载的语言的内部符号名

    返回（多个）： ~
        (`boolean?`) 如果解析器已加载则为 true
        (`string?`) 如果无法加载解析器则为错误

get_filetypes({lang})                *vim.treesitter.language.get_filetypes()*
    返回使用名为 {lang} 的解析器的文件类型。

    该列表包括 {lang} 本身加上通过
    |vim.treesitter.language.register()| 注册的所有文件类型。

    参数： ~
      • {lang}  (`string`) 解析器名称

    返回： ~
        (`string[]`) 文件类型

get_lang({filetype})                      *vim.treesitter.language.get_lang()*
    返回为 {filetype} 加载解析器时要使用的语言名称。

    如果没有通过 |vim.treesitter.language.register()| 显式
    注册语言，默认为 {filetype}。对于像 `html.glimmer`
    这样的复合文件类型，只返回主文件类型。

    参数： ~
      • {filetype}  (`string`)

    返回： ~
        (`string?`)

inspect({lang})                            *vim.treesitter.language.inspect()*
    检查提供的语言。

    检查提供了一些关于语言的有用信息，如 ABI
    版本、解析器状态计数（解析器复杂性的度量）、
    节点和字段名称，以及语言是否来自 WASM 模块。

    节点名称在表中返回，将每个节点名称映射到
    表示节点是否命名的 `boolean`（即不是匿名的）。
    匿名节点用双引号（`"`）括起来。

    对于 ABI 15 解析器，还显示解析器元数据（主版本、
    次版本、补丁版本）和超类型及其各自子类型的表。

    参数： ~
      • {lang}  (`string`) 语言

    返回： ~
        (`TSLangInfo`)

register({lang}, {filetype})              *vim.treesitter.language.register()*
    注册名为 {lang} 的解析器以用于 {filetype}(s)。

    注意：这会添加或覆盖 {filetype} 的映射，任何
    从其他文件类型到 {lang} 的现有映射都将保留。

    参数： ~
      • {lang}      (`string`) 解析器名称
      • {filetype}  (`string|string[]`) 要与 lang 关联的文件类型


==============================================================================
Lua 模块：vim.treesitter.query                        *lua-treesitter-query*

这个 Lua |treesitter-query| 接口允许你创建查询并使用
它们来解析文本。参见 |vim.treesitter.query.parse()| 获取
工作示例。


*vim.treesitter.Query*
    解析的查询，参见 |vim.treesitter.query.parse()|

    字段： ~
      • {lang}                     (`string`) 解析器语言名称
      • {captures}                 (`string[]`) 查询中定义的（唯一）
                                   捕获名称列表
      • {info}                     (`vim.treesitter.QueryInfo`) 查询上下文
                                   （例如捕获、谓词、指令）
      • {has_conceal_line}         (`boolean`) 查询是否设置
                                   conceal_lines 元数据
      • {has_combined_injections}  (`boolean`) 查询是否包含
                                   组合注入
      • {query}                    (`TSQuery`) userdata 查询对象
      • {iter_captures}            (`fun(self: vim.treesitter.Query, node: TSNode, source: integer|string, start: integer?, stop: integer?, opts: table?): fun(end_line: integer?): integer, TSNode, vim.treesitter.query.TSMetadata, TSQueryMatch, TSTree`)
                                   参见 |Query:iter_captures()|。
      • {iter_matches}             (`fun(self: vim.treesitter.Query, node: TSNode, source: integer|string, start: integer?, stop: integer?, opts: table?): fun(): integer, table<integer, TSNode[]>, vim.treesitter.query.TSMetadata, TSTree`)
                                   参见 |Query:iter_matches()|。


                                        *vim.treesitter.query.add_directive()*
add_directive({name}, {handler}, {opts})
    添加要在查询中使用的新指令

    处理程序可以通过直接在元数据对象上设置来设置
    匹配级别数据 `metadata.key = value`。此外，处理程序
    可以通过在元数据表上使用捕获 id 来设置节点级别
    数据 `metadata[capture_id].key = value`

    参数： ~
      • {name}     (`string`) 指令名称，不带前导 #
      • {handler}  (`fun(match: table<integer,TSNode[]>, pattern: integer, source: integer|string, predicate: any[], metadata: vim.treesitter.query.TSMetadata)`)
                   • match：将捕获 ID 映射到捕获的
                     节点列表的表
                   • pattern：查询文件中匹配模式的
                     索引
                   • predicate：包含正在调用的完整指令的
                     字符串列表，例如 `(node (#set! conceal "-"))`
                     将获得谓词 `{ "#set!", "conceal", "-" }`
      • {opts}     (`table`) 具有以下字段的表：
                   • {force}? (`boolean`) 覆盖同名谓词
                   • {all}? (`boolean`) 使用匹配表的正确实现，
                     其中捕获 ID 映射到节点列表而不是单个
                     节点。默认为 true。此选项将在未来版本中
                     删除。

                                        *vim.treesitter.query.add_predicate()*
add_predicate({name}, {handler}, {opts})
    添加要在查询中使用的新谓词

    参数： ~
      • {name}     (`string`) 谓词名称，不带前导 #
      • {handler}  (`fun(match: table<integer,TSNode[]>, pattern: integer, source: integer|string, predicate: any[], metadata: vim.treesitter.query.TSMetadata): boolean?`)
                   • 参见 |vim.treesitter.query.add_directive()| 了解参数
                     含义
      • {opts}     (`table?`) 具有以下字段的表：
                   • {force}? (`boolean`) 覆盖同名谓词
                   • {all}? (`boolean`) 使用匹配表的正确实现，
                     其中捕获 ID 映射到节点列表而不是单个
                     节点。默认为 true。此选项将在未来版本中
                     删除。

edit({lang})                                     *vim.treesitter.query.edit()*
    打开一个实时编辑器来查询你开始的缓冲区。

    也可以用 *:EditQuery* 显示。

    如果你将光标移动到捕获名称（"@foo"），匹配捕获的
    文本会在源缓冲区中高亮显示。查询编辑器是一个临时
    缓冲区，使用 `:write` 保存它。你可以在
    `$VIMRUNTIME/queries/` 找到示例查询。

    参数： ~
      • {lang}  (`string?`) 要打开查询编辑器的语言。如果省略，
               从当前缓冲区的文件类型推断。

get({lang}, {query_name})                         *vim.treesitter.query.get()*
    返回 {lang} 的运行时查询 {query_name}。

    参数： ~
      • {lang}        (`string`) 用于查询的语言
      • {query_name}  (`string`) 查询名称（例如 "highlights"）

    返回： ~
        (`vim.treesitter.Query?`) 解析的查询。如果未找到查询文件，
        则为 `nil`。参见 |vim.treesitter.Query|。

                                            *vim.treesitter.query.get_files()*
get_files({lang}, {query_name}, {is_included})
    获取组成查询的文件列表

    参数： ~
      • {lang}         (`string`) 要获取查询的语言
      • {query_name}   (`string`) 要加载的查询名称（例如，
                       "highlights"）
      • {is_included}  (`boolean?`) 内部参数，大多数时候
                      保持为 `nil`

    返回： ~
        (`string[]`) query_files 为给定查询和语言加载的文件列表

lint({buf}, {opts})                              *vim.treesitter.query.lint()*
    使用安装的解析器检查 treesitter 查询，或清除检查错误。

    使用 runtimepath 中的 |treesitter-parsers| 检查 {buf} 中的
    查询文件是否有错误：
    • 验证使用的节点是否是语法中的有效标识符。
    • 验证谓词和指令是否有效。
    • 验证顶级 s 表达式是否有效。

    发现的诊断使用 |diagnostic-api| 报告。默认情况下，用于
    验证的解析器由查询文件的包含文件夹确定，例如，如果
    路径以 `/lua/highlights.scm` 结尾，将使用 `lua` 语言的
    解析器。

    参数： ~
      • {buf}   (`integer`) 缓冲区句柄
      • {opts}  (`table?`) 可选关键字参数：
                • {langs}? (`string|string[]`) 用于检查查询的
                  语言。如果指定了多种语言，查询将针对所有
                  语言进行验证
                • {clear} (`boolean`) 仅清除当前检查错误

list_directives()                     *vim.treesitter.query.list_directives()*
    列出当前可用于查询的指令。

    返回： ~
        (`string[]`) 支持的指令。

list_predicates()                     *vim.treesitter.query.list_predicates()*
    列出当前可用于查询的谓词。

    返回： ~
        (`string[]`) 支持的谓词。

omnifunc({findstart}, {base})                *vim.treesitter.query.omnifunc()*
    treesitter 查询中完成节点名称和谓词的 omnifunc。

    通过 >lua
        vim.bo.omnifunc = 'v:lua.vim.treesitter.query.omnifunc'
< 使用

    参数： ~
      • {findstart}  (`0|1`)
      • {base}       (`string`)

parse({lang}, {query})                          *vim.treesitter.query.parse()*
    解析 {query} 字符串并返回 `Query` 对象
    （|lua-treesitter-query|），可用于在树中搜索查询模式
    （通过 |Query:iter_captures()|、|Query:iter_matches()|），或
    通过这些字段检查/修改查询：
    • `captures`：查询中定义的唯一捕获名称列表（别名：
      `info.captures`）。
    • `info.patterns`：关于谓词的信息。
    • `query`：可用于禁用模式或捕获的基础 |TSQuery|。

    示例： >lua
        local query = vim.treesitter.query.parse('vimdoc', [[
          ; query
          ((h1) @str
            (#trim! @str 1 1 1 1))
        ]])
        local tree = vim.treesitter.get_parser():parse()[1]
        for id, node, metadata in query:iter_captures(tree:root(), 0) do
           -- 打印节点名称和源文本。
           vim.print({node:type(), vim.treesitter.get_node_text(node, vim.api.nvim_get_current_buf())})
        end
<

    参数： ~
      • {lang}   (`string`) 用于查询的语言
      • {query}  (`string`) 查询文本，使用 s-expr 语法

    返回： ~
        (`vim.treesitter.Query`) 解析的查询。参见 |vim.treesitter.Query|。

    另见： ~
      • |vim.treesitter.query.get()|

                                                       *Query:iter_captures()*
Query:iter_captures({node}, {source}, {start}, {stop}, {opts})
    迭代 {node} 中所有匹配的所有捕获。

    如果查询包含谓词，则需要 {source}；然后调用者必须
    确保使用与缓冲区当前文本一致的新解析树（如果相关）。
    {start} 和 {stop} 可用于限制行范围内的匹配（这通常
    与根节点一起使用作为 {node}，即，获取当前视口中
    的语法高亮匹配）。当省略时，使用给定节点的 {start}
    和 {stop} 行值。

    迭代器返回四个值：
    1. 标识捕获的数字 id
    2. 捕获的节点
    3. 来自处理匹配的任何指令的元数据
    4. 匹配本身

    示例：如何按名称获取捕获： >lua
        for id, node, metadata, match in query:iter_captures(tree:root(), bufnr, first, last) do
          local name = query.captures[id] -- 查询中捕获的名称
          -- 通常有用的节点信息：
          local type = node:type() -- 捕获节点的类型
          local row1, col1, row2, col2 = node:range() -- 捕获的范围
          -- ... 在这里使用信息 ...
        end
<

    注意： ~
      • 仅当特定捕获的查询模式包含谓词时才返回捕获。

    参数： ~
      • {node}    (`TSNode`) 搜索将在其下进行
      • {source}  (`integer|string`) 从中提取文本的源缓冲区或字符串
      • {start}   (`integer?`) 搜索的起始行。默认为
                 `node:start()`。
      • {stop}    (`integer?`) 搜索的停止行（不包括结束）。
                 默认为 `node:end_()`。
      • {opts}    (`table?`) 可选关键字参数：
                  • max_start_depth (integer) 如果非零，设置每个
                    匹配的最大起始深度。这用于防止遍历
                    太深的树。
                  • match_limit (integer) 设置进行中匹配的
                    最大数量（默认：256）。

    返回： ~
        (`fun(end_line: integer?): integer, TSNode, vim.treesitter.query.TSMetadata, TSQueryMatch, TSTree`)
        捕获 id、捕获节点、元数据、匹配、树

                                                        *Query:iter_matches()*
Query:iter_matches({node}, {source}, {start}, {stop}, {opts})
    迭代给定范围内的自身匹配。

    迭代 {node} 内的所有匹配。参数与 |Query:iter_captures()|
    相同，但迭代的值不同：查询中模式的（1 基）索引、
    将捕获索引映射到节点列表的表，以及来自处理匹配的
    任何指令的元数据。

    示例： >lua
        for pattern, match, metadata in cquery:iter_matches(tree:root(), bufnr, 0, -1) do
          for id, nodes in pairs(match) do
            local name = query.captures[id]
            for _, node in ipairs(nodes) do
              -- `node` 在匹配中被 `name` 捕获捕获

              local node_data = metadata[id] -- 节点级别元数据
              -- ... 在这里使用信息 ...
            end
          end
        end
<

    参数： ~
      • {node}    (`TSNode`) 搜索将在其下进行
      • {source}  (`integer|string`) 要搜索的源缓冲区或字符串
      • {start}   (`integer?`) 搜索的起始行。默认为
                 `node:start()`。
      • {stop}    (`integer?`) 搜索的停止行（不包括结束）。
                 默认为 `node:end_()`。
      • {opts}    (`table?`) 可选关键字参数：
                  • max_start_depth (integer) 如果非零，设置每个
                    匹配的最大起始深度。这用于防止遍历
                    太深的树。
                  • match_limit (integer) 设置进行中匹配的
                    最大数量（默认：256）。all (boolean) 当
                    `false`（默认 `true`）时，返回的表将捕获
                    ID 映射到单个（最后）节点，而不是匹配
                    节点的完整列表。此选项仅用于向后
                    兼容性，将在未来版本中删除。

    返回： ~
        (`fun(): integer, table<integer, TSNode[]>, vim.treesitter.query.TSMetadata, TSTree`)
        模式 id、匹配、元数据、树

set({lang}, {query_name}, {text})                 *vim.treesitter.query.set()*
    设置 {lang} 的运行时查询 {query_name}

    这允许用户覆盖或扩展插件设置的任何运行时文件和/或
    配置。

    例如，你可以使用以下代码启用 `C` 标识符的拼写检查： >lua
        vim.treesitter.query.set(
          'c',
          'highlights',
          [[;inherits c
          (identifier) @spell]])
        ]])
<

    参数： ~
      • {lang}        (`string`) 用于查询的语言
      • {query_name}  (`string`) 查询名称（例如，"highlights"）
      • {text}        (`string`) 查询文本（未解析）。




*TSQuery*
    扩展：|userdata|

    treesitter 库持有的对象的引用，用作 |vim.treesitter.Query| 的
    组件，用于语言功能支持。有关查询的更多信息，请参见
    |treesitter-query|，或参见 |vim.treesitter.query.parse()| 获取
    如何获取查询对象的示例。

    字段： ~
      • {disable_capture}  (`fun(self: TSQuery, capture_name: string)`) 参见
                           |TSQuery:disable_capture()|。
      • {disable_pattern}  (`fun(self: TSQuery, pattern_index: integer)`) 参见
                           |TSQuery:disable_pattern()|。


TSQuery:disable_capture({capture_name})            *TSQuery:disable_capture()*
    在此查询中禁用特定捕获；一旦禁用，捕获就不能
    重新启用。{capture_name} 不应包含前导 "@"。

    示例：要从 vimdoc 高亮查询中禁用 `@variable.parameter` 捕获： >lua
        local query = vim.treesitter.query.get('vimdoc', 'highlights')
        query.query:disable_capture("variable.parameter")
        vim.treesitter.get_parser():parse()
<

    参数： ~
      • {capture_name}  (`string`)

TSQuery:disable_pattern({pattern_index})           *TSQuery:disable_pattern()*
    在此查询中禁用特定模式；一旦禁用，模式就不能
    重新启用。特定匹配的 {pattern_index} 可以通过
    |:Inspect!| 获取，或通过读取查询的源代码（即从
    |vim.treesitter.query.get_files()|）获取。

    示例：要在 vimdoc 中禁用 `|` 链接但保持其他 `@markup.link`s
    高亮： >lua
        local link_pattern = 9 -- 来自 :Inspect!
        local query = vim.treesitter.query.get('vimdoc', 'highlights')
        query.query:disable_pattern(link_pattern)
        local tree = vim.treesitter.get_parser():parse()[1]
<

    参数： ~
      • {pattern_index}  (`integer`)


==============================================================================
Lua 模块：vim.treesitter.languagetree              *treesitter-languagetree*

*LanguageTree* 包含解析器树：{lang} 的根 treesitter 解析器
和任何"注入"的语言解析器，它们本身可能递归地注入其他
语言。例如，包含一些 Vimscript 命令的 Lua 缓冲区需要
多个解析器来完全理解其内容。

要为给定缓冲区和语言创建 LanguageTree（解析器对象），请使用： >lua
    local parser = vim.treesitter.get_parser(bufnr, lang)
<

（其中 `bufnr=0` 表示当前缓冲区）。`lang` 默认为 'filetype'。
注意：目前解析器在缓冲区的生命周期内保留，但这可能
改变；如果插件想要增量更新，应该保留对解析器对象的
引用。

每当需要访问当前语法树时，解析缓冲区： >lua
    local tree = parser:parse({ start_row, end_row })
<

这返回表示缓冲区当前状态的不可变 |treesitter-tree| 对象
表。当插件想要在（可能的）编辑后访问状态时，它必须
再次调用 `parse()`。如果缓冲区未被编辑，将再次返回
相同的树，无需额外工作。如果缓冲区之前被解析过，
将对更改的部分进行增量解析。

注意：要在 |nvim_buf_attach()| Lua 回调中直接使用解析器，
你必须在注册回调之前调用 |vim.treesitter.get_parser()|。
但最好解析不应该直接在更改回调中完成，因为它们会
非常频繁。相反，对树进行任何分析的插件应该使用
计时器来限制过于频繁的更新。


LanguageTree:children()                              *LanguageTree:children()*
    返回语言到子树的映射。

    返回： ~
        (`table<string,vim.treesitter.LanguageTree>`)

LanguageTree:contains({range})                       *LanguageTree:contains()*
    确定 {range} 是否包含在 |LanguageTree| 中。

    参数： ~
      • {range}  (`table`) 具有以下字段的表：
                 • {[1]} (`integer`) 开始行
                 • {[2]} (`integer`) 开始列
                 • {[3]} (`integer`) 结束行
                 • {[4]} (`integer`) 结束列

    返回： ~
        (`boolean`)

LanguageTree:destroy()                                *LanguageTree:destroy()*
    销毁此 |LanguageTree| 及其所有子节点。

    应在此处执行任何清理逻辑。

    注意：这不会从父节点中删除此树。相反，必须在
    父节点上调用 `remove_child` 来删除它。

LanguageTree:for_each_tree({fn})                *LanguageTree:for_each_tree()*
    递归地为每个 |LanguageTree| 调用回调。

    注意：这包括调用树的子树。

    参数： ~
      • {fn}  (`fun(tree: TSTree, ltree: vim.treesitter.LanguageTree)`)

LanguageTree:included_regions()              *LanguageTree:included_regions()*
    获取由此 LanguageTree 管理的包含区域集。这可能与
    注入查询设置的区域不同，因为部分 |LanguageTree:parse()|
    会丢弃请求范围之外的区域。每个列表表示一个范围，
    形式为 { {start_row}, {start_col}, {start_bytes},
    {end_row}, {end_col}, {end_bytes} }。

    返回： ~
        (`table<integer, Range6[]>`)

LanguageTree:invalidate({reload})                  *LanguageTree:invalidate()*
    使此解析器及其子节点无效。

    仅当 LanguageTree 跟踪的状态与 treesitter 中的
    解析树不一致时才应调用。不清除文件系统缓存。
    经常调用，所以需要快速。

    参数： ~
      • {reload}  (`boolean?`)

                                                     *LanguageTree:is_valid()*
LanguageTree:is_valid({exclude_children}, {range})
    返回此 LanguageTree 是否有效，即 |LanguageTree:trees()|
    反映源的最新状态。如果无效，用户应该调用
    |LanguageTree:parse()|。

    参数： ~
      • {exclude_children}  (`boolean?`) 是否忽略子节点的
                                 有效性（默认 `false`）
      • {range}             (`Range?`) 要检查有效性的范围

    返回： ~
        (`boolean`)

LanguageTree:lang()                                      *LanguageTree:lang()*
    获取此树节点的语言。

    返回： ~
        (`string`)

                                           *LanguageTree:language_for_range()*
LanguageTree:language_for_range({range})
    获取包含 {range} 的适当语言。

    参数： ~
      • {range}  (`table`) 具有以下字段的表：
                 • {[1]} (`integer`) 开始行
                 • {[2]} (`integer`) 开始列
                 • {[3]} (`integer`) 结束行
                 • {[4]} (`integer`) 结束列

    返回： ~
        (`vim.treesitter.LanguageTree`) 管理 {range} 的树

                                         *LanguageTree:named_node_for_range()*
LanguageTree:named_node_for_range({range}, {opts})
    获取包含 {range} 的最小命名节点。

    参数： ~
      • {range}  (`table`) 具有以下字段的表：
                 • {[1]} (`integer`) 开始行
                 • {[2]} (`integer`) 开始列
                 • {[3]} (`integer`) 结束行
                 • {[4]} (`integer`) 结束列
      • {opts}   (`table?`) 具有以下字段的表：
                 • {ignore_injections}? (`boolean`, 默认：`true`) 忽略
                   注入的语言

    返回： ~
        (`TSNode?`)

                                               *LanguageTree:node_for_range()*
LanguageTree:node_for_range({range}, {opts})
    获取包含 {range} 的最小节点。

    参数： ~
      • {range}  (`table`) 具有以下字段的表：
                 • {[1]} (`integer`) 开始行
                 • {[2]} (`integer`) 开始列
                 • {[3]} (`integer`) 结束行
                 • {[4]} (`integer`) 结束列
      • {opts}   (`table?`) 具有以下字段的表：
                 • {ignore_injections}? (`boolean`, 默认：`true`) 忽略
                   注入的语言

    返回： ~
        (`TSNode?`)

LanguageTree:parent()                                  *LanguageTree:parent()*
    返回父树。根树为 `nil`。

    返回： ~
        (`vim.treesitter.LanguageTree?`)

LanguageTree:parse({range}, {on_parse})                 *LanguageTree:parse()*
    使用相应语言的 |treesitter-parsers| 递归解析语言树中的
    所有区域，并在解析的树上运行注入查询以确定是否应该
    创建和解析子树。

    任何具有空范围的区域（`{}`，通常只有根树）始终被解析；
    否则（通常是注入）仅当它与 {range} 相交时（或如果
    {range} 是 `true`）。

    参数： ~
      • {range}     (`boolean|Range?`) 在解析器的源中解析此范围。
                   设置为 `true` 以运行源的完整解析（注意：可能很慢！）
                   设置为 `false|nil` 以仅解析具有空范围的区域
                   （通常只有没有注入的根树）。
      • {on_parse}  (`fun(err?: string, trees?: table<integer, TSTree>)?`)
                   解析完成时调用的函数。当提供且未设置
                   `vim.g._ts_force_sync_parsing` 时，解析将
                   异步运行。函数的第一个参数是表示错误类型
                   的字符串，在失败的情况下（目前仅可能超时）。
                   第二个参数是解析返回的树列表（成功时），
                   如果解析超时则为 `nil`（由 'redrawtime' 确定）。

                   如果解析仍然能够同步完成（在 3ms 内），
                   `parse()` 返回树列表。否则，它返回 `nil`。

    返回： ~
        (`table<integer, TSTree>?`)

                                                 *LanguageTree:register_cbs()*
LanguageTree:register_cbs({cbs}, {recursive})
    为 |LanguageTree| 注册回调。

    参数： ~
      • {cbs}        (`table<TSCallbackNameOn,function>`) 一个
                     |nvim_buf_attach()|-like 表参数，具有以下
                     处理程序：
                     • `on_bytes`：参见 |nvim_buf_attach()|。
                     • `on_changedtree`：每次树有语法更改时
                       调用的回调。它将传递两个参数：更改的
                       范围（作为节点范围）表和更改的树。
                     • `on_child_added`：当子节点添加到树时
                       发出。
                     • `on_child_removed`：当子节点从树中
                       移除时发出。
                     • `on_detach`：当缓冲区分离时发出，参见
                       |nvim_buf_detach_event|。接受一个参数，
                       缓冲区的编号。
      • {recursive}  (`boolean?`) 递归地为所有子节点应用
                    回调。任何新的子节点也将继承回调。

LanguageTree:source()                                  *LanguageTree:source()*
    返回语言树的源内容（缓冲区号或字符串）。

    返回： ~
        (`integer|string`)

                                               *LanguageTree:tree_for_range()*
LanguageTree:tree_for_range({range}, {opts})
    获取包含 {range} 的树。

    参数： ~
      • {range}  (`table`) 具有以下字段的表：
                 • {[1]} (`integer`) 开始行
                 • {[2]} (`integer`) 开始列
                 • {[3]} (`integer`) 结束行
                 • {[4]} (`integer`) 结束列
      • {opts}   (`table?`) 具有以下字段的表：
                 • {ignore_injections}? (`boolean`, 默认：`true`) 忽略
                   注入的语言

    返回： ~
        (`TSTree?`)

LanguageTree:trees()                                    *LanguageTree:trees()*
    返回由此解析器解析的区域的所有树。不包括子语言。
    如果
    • 此 LanguageTree 是根，在这种情况下结果是空或
      单例列表；或
    • 根 LanguageTree 完全解析。
    则结果是列表式的。

    返回： ~
        (`table<integer, TSTree>`)


 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
