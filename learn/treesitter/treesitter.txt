*treesitter.txt*    Nvim


                            NVIM 参考手册


Treesitter 集成                                 *treesitter*

Nvim 集成了 `tree-sitter` 库用于缓冲区的增量解析：
https://tree-sitter.github.io/tree-sitter/

警告：Treesitter 支持仍处于实验阶段，可能会频繁更改。
本文档也可能无法完全反映最新的更改。

                                      输入 |gO| 查看目录。

==============================================================================
解析器文件                                              *treesitter-parsers*

解析器是 treesitter 的核心。
它们是 treesitter 将在 `parser` 运行时目录中搜索的库。

Nvim 包含以下解析器：

- C
- Lua
- Markdown
- Vimscript
- Vimdoc
- Treesitter 查询文件 |ft-query-plugin|

你可以手动安装更多解析器，或使用插件如 https://github.com/nvim-treesitter/nvim-treesitter 。

解析器在 'runtimepath' 目录中作为 `parser/{lang}.*` 被搜索。
如果找到同一语言的多个解析器，将使用第一个。
（注意：这通常意味着优先级是"用户配置 > 插件 > 内置"。）

要从文件路径加载解析器： >lua

    vim.treesitter.language.add('python', { path = "/path/to/python.so" })
<
如果文件系统区分大小写，解析器名称假定为小写。

要将某些 |filetypes| 与 treesitter 语言（解析器名称）关联，
使用 |vim.treesitter.language.register()|。
例如，要对文件类型为 `svg` 或 `xslt` 的缓冲区使用 `xml` treesitter 解析器： >lua

    vim.treesitter.language.register('xml', { 'svg', 'xslt' })
<
                                                    *treesitter-parsers-wasm*

如果 Nvim 是用 `ENABLE_WASMTIME` 构建的，那么也可以加载 wasm 解析器： >lua

    vim.treesitter.language.add('python', { path = "/path/to/python.wasm" })
<

==============================================================================
TREESITTER 查询                                          *treesitter-query*

Treesitter 查询是一种从解析的 |TSTree| 中提取信息的方式，
例如，用于高亮显示。简而言之，一个 `query` 包含一个或多个
模式。一个 `pattern` 是在语法树中的节点类型上定义的。
一个 `match` 对应于语法树中匹配模式的特定元素。模式可以
选择性地定义捕获和谓词。一个 `capture` 允许你将名称与模式中
的特定节点关联。一个 `predicate` 为匹配添加任意元数据和
条件数据。

查询用一种类似 lisp 的语言编写，在
https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax
中有文档说明
注意：那里列出的谓词与 Nvim 支持的谓词不同。参见
|treesitter-predicates| 获取 Nvim 支持的谓词的完整列表。

Nvim 在 'runtimepath' 下的 `queries` 目录中查找查询作为 `*.scm` 文件，
其中每个文件包含特定语言和用途的查询，例如，
`queries/lua/highlights.scm` 用于高亮显示 Lua 文件。
默认情况下，使用 'runtimepath' 上的第一个查询（这通常意味着
用户配置优先于插件，插件优先于 Nvim 内置的查询）。如果查询
应该扩展其他查询而不是替换它们，使用 |treesitter-query-modeline-extends|。

Lua 接口在 |lua-treesitter-query| 中描述。


TREESITTER 查询谓词                            *treesitter-predicates*

谓词是特殊的 scheme 节点，它们被评估以有条件地捕获节点。
例如，`eq?` 谓词可以如下使用： >query

    ((identifier) @variable.builtin
      (#eq? @variable.builtin "self"))
<
只匹配对应于 `"self"` 文本的标识符。这样的查询可以用于
以不同方式高亮显示内置函数或变量。

以下是内置谓词：

    `eq?`                                            *treesitter-predicate-eq?*
        将字符串与节点对应的文本匹配： >query
            ((identifier) @variable.builtin (#eq? @variable.builtin "self"))
            ((node1) @left (node2) @right (#eq? @left @right))
<
    `any-eq?`                                    *treesitter-predicate-any-eq?*
        类似于 `eq?`，但对于量化模式，只有一个捕获的节点必须
        匹配。

    `match?`                                      *treesitter-predicate-match?*
    `vim-match?`                              *treesitter-predicate-vim-match?*
         将 |regexp| 与节点对应的文本匹配： >query
            ((identifier) @constant (#match? @constant "^[A-Z_]+$"))
<
         注意：`^` 和 `$` 锚点将匹配节点文本的开始和结束。

    `any-match?`                              *treesitter-predicate-any-match?*
    `any-vim-match?`                      *treesitter-predicate-any-vim-match?*
        类似于 `match?`，但对于量化模式，只有一个捕获的节点必须
        匹配。

    `lua-match?`                              *treesitter-predicate-lua-match?*
         将 |lua-patterns| 与节点对应的文本匹配，
         类似于 `match?`

    `any-lua-match?`                      *treesitter-predicate-any-lua-match?*
         类似于 `lua-match?`，但对于量化模式，只有一个捕获的节点
         必须匹配。

    `contains?`                                *treesitter-predicate-contains?*
        将字符串与节点对应文本的部分匹配： >query
            ((identifier) @foo (#contains? @foo "foo"))
            ((identifier) @foo-bar (#contains? @foo-bar "foo" "bar"))
<
    `any-contains?`                        *treesitter-predicate-any-contains?*
        类似于 `contains?`，但对于量化模式，只有一个捕获的节点必须
        匹配。

    `any-of?`                                    *treesitter-predicate-any-of?*
        将给定字符串中的任何一个与节点对应的文本匹配： >query
            ((identifier) @foo (#any-of? @foo "foo" "bar"))
<
        这是检查节点是否匹配多个关键字中任何一个的推荐方式，
        因为它已经为此进行了优化。

    `has-ancestor?`                        *treesitter-predicate-has-ancestor?*
        将给定的节点类型与节点的所有祖先匹配： >query
            ((identifier) @variable.builtin
              (#any-of? @variable.builtin "begin" "end")
              (#has-ancestor? @variable.builtin range_expression))
<
    `has-parent?`                            *treesitter-predicate-has-parent?*
        将给定的节点类型与节点的直接祖先匹配： >query
            (((field_expression
                 (field_identifier) @method)) @_parent
             (#has-parent? @_parent template_method function_declarator))
<
                                                    *treesitter-predicate-not*
每个谓词都有一个带 `not-` 前缀的谓词，它只是谓词的否定。

                                                    *treesitter-predicate-all*
                                                    *treesitter-predicate-any*
查询可以使用量词来捕获多个节点。当捕获包含多个节点时，
谓词只有在捕获包含的所有节点都匹配谓词时才匹配。一些谓词
（`eq?`、`match?`、`lua-match?`、`contains?`）接受 `any-` 前缀
来改为在捕获包含的任何节点匹配谓词时匹配。

例如，考虑以下 Lua 代码： >lua

  -- TODO: This is a
  -- very long
  -- comment (just imagine it)
<
使用以下带谓词的查询：
>query
    (((comment)+ @comment)
     (#match? @comment "TODO"))
<
这个查询不会匹配，因为不是 @comment 捕获的所有节点都匹配
谓词。相反，使用：
>query
    (((comment)+ @comment)
     (#any-match? @comment "TODO"))
<

可以通过 |vim.treesitter.query.add_predicate()| 添加更多谓词。
使用 |vim.treesitter.query.list_predicates()| 列出所有可用的谓词。


TREESITTER 查询指令                            *treesitter-directives*

Treesitter 指令存储节点或匹配的元数据并执行副作用。
例如，`set!` 指令在匹配或节点上设置元数据： >query

        ((identifier) @foo (#set! type "parameter"))
<
以下是内置指令：

    `set!`                                          *treesitter-directive-set!*
        为特定匹配或捕获设置键/值元数据。值可以作为
        `metadata[key]`（匹配特定）或 `metadata[capture_id][key]`
        （捕获特定）访问。

        参数： ~
            {capture_id}（可选）
            {key}
            {value}

        示例： >query
            ((identifier) @foo (#set! @foo kind "parameter"))
            ((node1) @left (node2) @right (#set! type "pair"))
            ((codeblock) @markup.raw.block (#set! priority 90))
<
    `offset!`                                      *treesitter-directive-offset!*
        获取捕获节点的范围并应用偏移。这将为捕获节点设置
        一个新的范围，形式为 { {start_row}, {start_col},
        {end_row}, {end_col} }，作为 `metadata[capture_id].range`。
        对于 |treesitter-language-injections| 很有用。

        参数： ~
            {capture_id}
            {start_row}
            {start_col}
            {end_row}
            {end_col}

        示例： >query
            ((identifier) @constant (#offset! @constant 0 1 0 -1))
<
    `gsub!`                                          *treesitter-directive-gsub!*
        使用 |lua-pattern| 转换节点的内容。这将设置
        一个新的 `metadata[capture_id].text`。

        参数： ~
            {capture_id}
            {pattern}
            {replacement}

        示例： >query
            (#gsub! @_node ".*%.(.*)" "%1")
<
    `trim!`                                          *treesitter-directive-trim!*
        从节点中修剪空白。设置一个新的
        `metadata[capture_id].range`。接受一个捕获 ID 和可选的四个
        整数来自定义修剪行为（`1` 表示修剪，`0` 表示不修剪）。
        当只给出捕获 ID 时，从节点末尾修剪空行（只包含空白
        的行，或空行）（为了向后兼容）。如果给出参数，可以
        从节点两侧修剪所有空白。

        示例： >query
            ; 只从节点末尾修剪空行
            ; （等同于 (#trim! @fold 0 0 1 0)）
            (#trim! @fold)

            ; 从节点两侧修剪空行
            (#trim! @fold 1 0 1 0)

            ; 修剪节点周围的所有空白
            (#trim! @fold 1 1 1 1)
<
        参数： ~
            {capture_id}
            {trim_start_linewise}
            {trim_start_charwise}
            {trim_end_linewise}（如果只给出 {capture_id}，默认为 `1`）
            {trim_end_charwise}

可以通过 |vim.treesitter.query.add_directive()| 添加更多指令。
使用 |vim.treesitter.query.list_directives()| 列出所有可用的指令。


TREESITTER 查询模式行                          *treesitter-query-modeline*

Nvim 支持使用一组"模式行"来自定义查询的行为，即查询中
以 `;` 开头的注释。以下是当前支持的模式行替代方案：

    `inherits: {lang}...`                     *treesitter-query-modeline-inherits*
        指定此查询应该继承来自 {lang} 的查询。
        这将递归地下降到 {lang} 的查询中，除非用
        括号括起来：`({lang})`。
        注意：这旨在用于包含来自另一种语言的查询。
        如果你希望你的查询扩展同一语言的查询，使用 `extends`。

    `extends`                                  *treesitter-query-modeline-extends*
        指定此查询应该用作查询的扩展，即它应该
        与其他查询合并。
        注意：扩展的顺序，以及将用作基础的查询
        取决于你的 'runtimepath' 值。

注意：这些模式行注释必须在查询的顶部，但可以重复，
例如，以下两个模式行块都是有效的：
>query
    ;; inherits: typescript,jsx
    ;; extends
<
>query
    ;; extends
    ;;
    ;; inherits: css
<



==============================================================================
TREESITTER 语法高亮                          *treesitter-highlight*

语法高亮通过名为 `highlights.scm` 的查询指定，这些查询将
解析的 |TSTree| 中的 |TSNode| 匹配到可以分配高亮组的
`capture`。例如，查询 >query

    (parameters (identifier) @variable.parameter)
<
将函数 `parameters` 节点内的任何 `identifier` 节点匹配到
名为 `@variable.parameter` 的捕获。例如，对于 Lua 代码 >lua

    function f(foo, bar) end
<
它将被解析为（参见 |:InspectTree|）： >query

    (function_declaration ; [1:1 - 24]
      name: (identifier) ; [1:10 - 10]
      parameters: (parameters ; [1:11 - 20]
        name: (identifier) ; [1:12 - 14]
        name: (identifier))) ; [1:17 - 19]
<
上面的查询将把 `foo` 和 `bar` 高亮显示为 `@variable.parameter`。

也可以匹配字面表达式（如果解析器返回它们）：
>query
    [
      "if"
      "else"
    ] @keyword.conditional
<
假设在 runtimepath 中找到合适的解析器和 `highlights.scm` 查询，
可以通过 |vim.treesitter.start()| 简单地启用当前缓冲区的
treesitter 高亮。

                                                 *treesitter-highlight-groups*
捕获名称，前缀为 `@`，可以直接用作高亮组。
对于许多常用的捕获，相应的捕获组默认链接到 Nvim 的
标准 |highlight-groups|（例如，`@comment` 链接到 `Comment`），
但可以在颜色方案中覆盖。

实现了一个回退系统，使更具体的组回退到更通用的组。
例如，在具有单独文档注释的语言中（例如，c、java 等），
可以使用 `@comment.documentation`。如果未定义此组，
则使用普通 `@comment` 的高亮。这样，现有的颜色方案
已经可以开箱即用，但可以为使它们可用的查询添加
更具体的变体。

作为附加规则，捕获高亮始终可以通过在附加点后附加
语言名称来专门化。例如，要按语言不同地高亮显示注释： >vim

    hi @comment.c guifg=Blue
    hi @comment.lua guifg=DarkBlue
    hi link @comment.documentation.java String
<
以下是 Nvim 查询中使用的标准捕获列表，根据当前颜色方案
高亮显示（使用 |:Inspect| 查看一个以查看确切定义）：

@variable                       各种变量名
@variable.builtin               内置变量名（例如 `this`、`self`）
@variable.parameter             函数参数
@variable.parameter.builtin     特殊参数（例如 `_`、`it`）
@variable.member                对象和结构体字段

@constant               常量标识符
@constant.builtin       内置常量值
@constant.macro         预处理器定义的常量

@module                模块或命名空间
@module.builtin        内置模块或命名空间
@label                 `GOTO` 和其他标签（例如 C 中的 `label:`），包括 heredoc 标签

@string                字符串字面量
@string.documentation  记录代码的字符串（例如 Python 文档字符串）
@string.regexp         正则表达式
@string.escape         转义序列
@string.special        其他特殊字符串（例如日期）
@string.special.symbol 符号或原子
@string.special.path   文件名
@string.special.url    URI（例如超链接）

@character             字符字面量
@character.special     特殊字符（例如通配符）

@boolean               布尔字面量
@number                数字字面量
@number.float          浮点数字面量

@type                  类型或类定义和注解
@type.builtin          内置类型
@type.definition       类型定义中的标识符（例如 C 中的 `typedef <type> <identifier>`）

@attribute             属性注解（例如 Python 装饰器、Rust 生命周期）
@attribute.builtin     内置注解（例如 Python 中的 `@property`）
@property              键值对中的键

@function              函数定义
@function.builtin      内置函数
@function.call         函数调用
@function.macro        预处理器宏

@function.method       方法定义
@function.method.call  方法调用

@constructor           构造函数调用和定义
@operator              符号运算符（例如 `+`、`*`）

@keyword               不适合特定类别的关键字
@keyword.coroutine     与协程相关的关键字（例如 Go 中的 `go`，Python 中的 `async/await`）
@keyword.function      定义函数的关键字（例如 Go 中的 `func`，Python 中的 `def`）
@keyword.operator      是英文单词的运算符（例如 `and`、`or`）
@keyword.import        用于包含或导出模块的关键字（例如 Python 中的 `import`、`from`）
@keyword.type          描述命名空间和复合类型的关键字（例如 `struct`、`enum`）
@keyword.modifier      修改其他构造的关键字（例如 `const`、`static`、`public`）
@keyword.repeat        与循环相关的关键字（例如 `for`、`while`）
@keyword.return        像 `return` 和 `yield` 这样的关键字
@keyword.debug         与调试相关的关键字
@keyword.exception     与异常相关的关键字（例如 `throw`、`catch`）

@keyword.conditional        与条件相关的关键字（例如 `if`、`else`）
@keyword.conditional.ternary 三元运算符（例如 `?`、`:`）

@keyword.directive          各种预处理器指令和 shebang
@keyword.directive.define   预处理器定义指令

@punctuation.delimiter  分隔符（例如 `;`、`.`、`,`）
@punctuation.bracket    括号（例如 `()`、`{}`、`[]`）
@punctuation.special    特殊符号（例如字符串插值中的 `{}`）

@comment               行注释和块注释
@comment.documentation 记录代码的注释

@comment.error         错误类型注释（例如 `ERROR`、`FIXME`、`DEPRECATED`）
@comment.warning       警告类型注释（例如 `WARNING`、`FIX`、`HACK`）
@comment.todo          todo 类型注释（例如 `TODO`、`WIP`）
@comment.note          note 类型注释（例如 `NOTE`、`INFO`、`XXX`）

@markup.strong         粗体文本
@markup.italic         斜体文本
@markup.strikethrough  删除线文本
@markup.underline      下划线文本（仅用于字面下划线标记！）

@markup.heading        标题、标题（包括标记）
@markup.heading.1      顶级标题
@markup.heading.2      章节标题
@markup.heading.3      小节标题
@markup.heading.4      以此类推
@markup.heading.5      以此类推
@markup.heading.6      六个级别应该足够任何人使用

@markup.quote          块引用
@markup.math           数学环境（例如 LaTeX 中的 `$ ... $`）

@markup.link           文本引用、脚注、引用等
@markup.link.label     链接、引用描述
@markup.link.url       URL 样式链接

@markup.raw            字面或逐字文本（例如内联代码）
@markup.raw.block      作为独立块的字面或逐字文本

@markup.list           列表标记
@markup.list.checked   已检查的 todo 样式列表标记
@markup.list.unchecked 未检查的 todo 样式列表标记

@diff.plus             添加的文本（用于 diff 文件）
@diff.minus            删除的文本（用于 diff 文件）
@diff.delta            更改的文本（用于 diff 文件）

@tag                   XML 样式标签名（例如在 XML、HTML 等中）
@tag.builtin          内置标签名（例如 HTML5 标签）
@tag.attribute        XML 样式标签属性
@tag.delimiter        XML 样式标签分隔符

                                                  *treesitter-highlight-spell*
特殊的 `@spell` 捕获可用于指示节点应该由 Nvim 的内置
|spell| 检查器检查。例如，以下捕获将注释标记为要检查： >query

    (comment) @spell
<

还有 `@nospell` 用于禁用带有 `@spell` 的区域的拼写检查。

                                                *treesitter-highlight-conceal*
Treesitter 高亮支持通过 `conceal` 和 `conceal_lines` 元数据
进行 |conceal|。按照惯例，要隐藏的节点被捕获为 `@conceal`，
但可以使用任何捕获。例如，以下查询可用于隐藏
Markdown 中的代码块分隔符： >query

    ((fenced_code_block_delimiter) @conceal (#set! conceal ""))
<
也可以用单个字符替换节点，与旧语法不同，可以给它
一个自定义高亮。例如，以下（不明智的）查询将 `!=` 运算符
替换为 Unicode 字形，它仍然与其他运算符高亮相同： >query

    "!=" @operator (#set! conceal "≠")
<
要隐藏整行（完全不绘制它），可以使用带有 `conceal_lines`
元数据的查询： >query

    ((comment) @comment @spell
      (#set! conceal_lines ""))
<
以这种方式指定的隐藏尊重 'conceallevel' 和 'concealcursor'。

注意，虽然你可以为 `conceal` 使用任何字符串，但只会使用
第一个字符： >query

    ; 标识符将被 'f' 隐藏。
    ((identifier) @conceal (#set! conceal "foo"))
<

                                               *treesitter-highlight-priority*
Treesitter 使用 |nvim_buf_set_extmark()| 设置高亮，默认
优先级为 100。这使插件可以设置低于或高于 treesitter 的
高亮优先级。也可以通过设置其 `"priority"` 元数据属性
手动更改单个查询模式的优先级： >query

    ((super_important_node) @superimportant (#set! priority 105))
<

                                          *treesitter-highlight-commentstring*
Treesitter 高亮支持更细粒度的 'commentstring'，由内置的
|commenting| 插件使用。当光标在设置 `bo.commentstring` 元数据
属性的节点内时（|treesitter-directive-set!|），该属性定义
注释分隔符（其中"最内层获胜"）。这对于像 `JSX` 这样根据
代码区域有不同注释语法的语言很有用，例如： >query

    ((jsx_element) @_tag (#set! @_tag bo.commentstring "{/* %s */}"))
<
当多个捕获在区域上设置此元数据时，只有最内层（最具体）
的一个应用于给定区域。

==============================================================================
TREESITTER 语言注入                *treesitter-language-injections*
<

注意以下信息改编自：
  https://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection

一些源文件包含用多种不同语言编写的代码。
示例包括：

    • HTML 文件，可以在 `<script>` 标签中包含 JavaScript，
      在 `<style>` 标签中包含 CSS
    • ERB 文件，在 `<%` `%>` 标签中包含 Ruby，在这些标签
      之外包含 HTML
    • PHP 文件，可以在 `<php` 标签之间包含 HTML
    • JavaScript 文件，在正则表达式字面量中包含正则表达式语法
    • Ruby，可以在 heredoc 字面量中包含代码片段，其中
      heredoc 分隔符通常指示语言
    • Lua，可以在 |vim.cmd()| 调用中包含 Vimscript 片段。
    • Vimscript，可以在 |:lua-heredoc| 块中包含 Lua 片段。

所有这些示例都可以用父语法树和一个或多个注入的语法树来建模，
这些语法树位于父树中的某些节点内。语言注入查询允许你使用
以下捕获来指定这些"注入"：

    • `@injection.content` - 指示捕获的节点应该使用另一种语言
      重新解析其内容。
    • `@injection.language` - 指示捕获节点的文本可能包含
      应该用于重新解析 `@injection.content` 的语言名称。
    • `@injection.filename` - 指示捕获节点的文本可能包含
      文件名；然后通过 |vim.filetype.match()| 查找相应的
      文件类型，并视为应该用于重新解析 `@injection.content`
      的语言名称。

语言注入行为也可以通过与模式关联的一些属性来配置：

    • `injection.language` - 可用于硬编码特定语言的名称。
    • `injection.combined` - 指示树中所有匹配的节点应该
      将其内容作为一个嵌套文档解析。
    • `injection.include-children` - 指示应该重新解析
      `@injection.content` 节点的整个文本，包括其子节点
      的文本。默认情况下，子节点的文本将从注入的文档中
      排除。
    • `injection.self` - 指示节点的文本应该用与节点的
      LanguageTree 相同的语言解析。
    • `injection.parent` - 指示捕获节点的文本应该用与
      节点的父 LanguageTree 相同的语言解析。

注入查询当前在整个缓冲区上运行，这对于大型缓冲区可能很慢。
要禁用注入，例如，对于 `c`，只需在 'runtimepath' 中放置一个
空的 `queries/c/injections.scm` 文件。

==============================================================================
VIM.TREESITTER                                                *lua-treesitter*

本文档的其余部分是 `vim.treesitter` Lua 模块的参考手册，
这是 Nvim 的 treesitter 集成的主要接口。
以下大部分内容是从函数文档自动生成的。


                                             *vim.treesitter.language_version*
捆绑的 treesitter 库支持的最新解析器 ABI 版本。

                                     *vim.treesitter.minimum_language_version*
捆绑的 treesitter 库支持的最早解析器 ABI 版本。

 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
