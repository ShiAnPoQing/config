iskeyword
;
,

CTRL-D
CTRL-U

zz

ZZ

nowrapscan

noincsearch

特殊标记

```
'	执行跳转前的光标位置
"	上次编辑文件时的光标位置
[	最后一次更改的开始
]	最后一次更改的结束
```

S

R <Insert>

:exe

'backup'

gq

filetype plugin indent on

cindent

```
command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
	  \ | wincmd p | diffthis
```

这添加了 ":DiffOrig" 命令。在修改后的缓冲区中使用此命令以查看与加载它的文件的差异。参见 |diff| 和 |:DiffOrig|。

>

```
set nolangremap
```

防止 langmap 选项应用于映射产生的字符。如果设置（默认），这可能会破坏插件（但它是向后兼容的）。参见 'langremap'。

\\ adsaf

:packadd

您可以使用 |:packadd| 来按需启用包。这对于您只想有时启用的插件很有用。要启用 `example_package`，请使用以下命令： >
packadd example_package

就这样！现在您可以找到关于此插件的帮助： >
:help example_package

这之所以有效，是因为当 `:packadd` 加载插件时，它还在 'runtimepath' 中添加了包目录，因此可以找到帮助文件。

包是一组可以添加到 Vim 的文件。有两种包：可选包和在启动时自动加载的包。

您可以在 Internet 上的各种地方找到包。它通常以存档或存储库的形式出现。对于存档，您可以按照以下步骤操作：
1\. 创建包目录： >
mkdir -p ~/.local/share/nvim/site/pack/fancy
< "fancy" 可以是您喜欢的任何名称。使用描述包的名称。
2\. 在该目录中解压存档。这假设存档中的顶级目录是 "start"： >
cd ~/.local/share/nvim/site/pack/fancy
unzip /tmp/fancy.zip
< 如果存档布局不同，请确保最终得到如下路径：
~/.local/share/nvim/site/pack/fancy/start/fancytext/plugin/fancy.vim ~
这里 "fancytext" 是包的名称，它可以是任何其他名称。

添加 nohlsearch 包 *nohlsearch-install* *package-nohlsearch*

使用此命令加载插件： >
packadd nohlsearch
\<
在 'updatetime' 之后或进入 |Insert| 模式后自动执行 |:nohlsearch|。
因此，假设默认的 updatetime，hlsearch 将在空闲 4 秒后暂停/关闭。

在插件加载后禁用其效果： >
au! nohlsearch
\<

有关包的更多信息可以在此处找到：|packages|。

nohlsearch

:options

:set iskeyword&

sidescroll

whichwrap

	设置文件类型也可以使用 |modeline| 完成，这样每次编辑文件时都会进行高亮。例如，这行可以用于 Makefile 中（将其放在文件的开头或结尾附近）： >

		# vim: syntax=make

<	您可能知道如何自己检测文件类型。通常可以使用文件名的扩展名（点之后的部分）。
	有关如何告诉 Vim 检测该文件类型的信息，请参阅 |new-filetype|。

  'background'


	Vim 会猜测您正在使用的背景颜色。如果是黑色（或其他深色），它将使用浅色文本。如果是白色（或其他浅色），它将使用深色文本。如果 Vim 猜错了，文本将难以阅读。要解决此问题，请设置 'background' 选项。对于深色背景： >

		:set background=dark

<	对于浅色背景： >

		:set background=light

<	确保将此命令放在 ":syntax enable" 命令 _之前_，否则颜色将已经被设置。您可以在设置 'background' 后执行 ":syntax reset"，让 Vim 再次设置默认颜色。

- 从底部向上滚动时颜色错误。
	Vim 不会读取整个文件来解析文本。它从您查看文件的任何位置开始解析。这节省了大量时间，但有时颜色会出错。一个简单的解决方法是按 CTRL-L。或者稍微向后滚动然后再向前滚动。
	要真正修复，请参阅 |:syn-sync|。一些语法文件有办法让它查看更远的位置，请参阅特定语法文件的帮助。例如，TeX 语法的 |ft-tex-syntax|。

  CTRL-L


如果您不喜欢默认颜色，可以选择另一个配色方案。在 GUI 中，使用 Edit/Color Scheme 菜单。您也可以键入命令： >

	:colorscheme evening

"evening" 是配色方案的名称。还有其他几个您可能想尝试的。查看目录 $VIMRUNTIME/colors。

当您找到喜欢的配色方案后，将 ":colorscheme" 命令添加到您的 |init.vim| 文件中。

您也可以编写自己的配色方案。方法如下：

1. 选择一个接近的配色方案。将此文件复制到您自己的 Vim 目录。对于 Unix，这应该可行： >

	!mkdir -p ~/.config/nvim/colors
	!cp $VIMRUNTIME/colors/morning.vim ~/.config/nvim/colors/mine.vim
<
   这是从 Vim 内部完成的，因为它知道 $VIMRUNTIME 的值。


  :runtime

如果您想查看最常用的颜色组合是什么样子，请使用此命令： >

	:runtime syntax/colortest.vim

以彩色显示文本需要大量努力。如果您发现显示速度太慢，您可能想暂时禁用语法高亮： >
  :syntax clear

如果您想完全停止高亮，请使用： >

	:syntax off

如果您只想对特定文件进行语法高亮，请使用： >

	:syntax manual

这将启用语法高亮功能，但在开始编辑缓冲区时不会自动开启。要为当前缓冲区开启高亮，请设置 'syntax' 选项： >

	:set syntax=ON



或者您可以使用强制 (!) 字符强制 Vim 放弃您的更改并编辑新文件：>

	:edit! foo.txt

如果您想编辑另一个文件，但还不想保存当前文件中的更改，可以将其设为隐藏：>

	:hide edit foo.txt

包含更改的文本仍然存在，但您看不到它。这将在第 |22.4| 节中进一步解释：缓冲区列表。



您可以启动 Vim 来编辑一系列文件。例如：>

	vim one.c two.c three.c

此命令启动 Vim 并告知您将编辑三个文件。Vim 仅显示第一个文件。当您在此文件中完成操作后，要编辑下一个文件，请使用此命令：>

	:next

如果您在当前文件中有未保存的更改，您将收到错误消息，并且 ":next" 将不起作用。这与上一节中提到的 ":edit" 的问题相同。要放弃更改：>

	:next!

但大多数情况下，您希望保存更改并继续处理下一个文件。有一个特殊的命令用于此：>

	:wnext

这与使用两个单独的命令作用相同：>

	:write
	:next


我在哪里？

要查看您正在编辑参数列表中的哪个文件，请查看窗口标题。它应显示类似 "(2 of 3)" 的内容。这意味着您正在编辑三个文件中的第二个文件。
   如果要查看文件列表，请使用此命令：>

	:args

这是 "arguments" 的缩写。输出可能如下所示：

	one.c [two.c] three.c ~

这些是您启动 Vim 时使用的文件。您当前正在编辑的文件 "two.c" 用方括号括起。


移动到其他参数

要返回上一个文件：>

	:previous

这就像 ":next" 命令，只是它向另一个方向移动。同样，有一个快捷命令用于当您想先写入文件时：>

	:wprevious

要移动到列表中的最后一个文件：>

	:last

要移回第一个文件：>

	:first

不过，没有 ":wlast" 或 ":wfirst" 命令！

您可以为 ":next" 和 ":previous" 使用计数。要向前跳过两个文件：>

	:2next



:set autowrite


编辑另一个文件列表

您无需退出 Vim 并重新启动即可重新定义文件列表。使用此命令编辑另外三个文件：>

	:args five.c six.c seven.h

或者使用通配符，就像在 shell 中使用的那样：>

	:args *.txt

Vim 将带您到列表中的第一个文件。同样，如果当前文件有更改，您可以先写入文件，或者使用 ":args!"（添加了 !）来放弃更改。


您编辑了最后一个文件吗？
							*arglist-quit*
当您使用文件列表时，Vim 假定您想要编辑所有文件。为了保护您不过早退出，当您尚未编辑列表中的最后一个文件时，您将收到此错误：

	E173: 还有 46 个文件要编辑 ~

如果您真的想退出，只需再执行一次退出命令。然后它就会起作用（但当您在中间执行了其他命令时则不行）。


==============================================================================
*07.3*	在文件间跳转

要快速在两个文件之间跳转，请按 CTRL-^（在美式英语键盘上，^ 在 6 键上方）。示例：>

	:args one.c two.c three.c

您现在在 one.c 中。>

	:next

现在您在 two.c 中。现在使用 CTRL-^ 返回到 one.c。再按一次 CTRL-^，您又回到了 two.c。再按一次 CTRL-^，您又回到了 one.c。如果您现在执行：>

	:next

您在 three.c 中。请注意，CTRL-^ 命令不会改变您在文件列表中的位置概念。只有像 ":next" 和 ":previous" 这样的命令才会改变。

您之前编辑的文件称为 "交替" 文件。当您刚启动 Vim 时，CTRL-^ 将不起作用，因为还没有上一个文件。



预定义标记

跳转到另一个文件后，您可以使用两个非常有用的预定义标记：>

	`"

这将带您到离开文件时光标所在的位置。记住的另一个标记是您最后一次更改的位置：>

	`.

假设您正在编辑文件 "one.txt"。在文件的某个中间位置，您使用 "x" 删除了一个字符。然后您用 "G" 转到最后一行，并用 ":w" 写入文件。您编辑了几个其他文件，然后使用 ":edit one.txt" 返回到 "one.txt"。如果您现在使用 `"，Vim 将跳转到文件的最后一行。使用 `. 将带您到删除字符的位置。即使您在文件中移动，`" 和 `. 也会将您带到记住的位置。至少在您进行另一个更改或离开文件之前是这样。


	:marks MCP


:set backup

'backupdir'

'writebackup'

'patchmode'

	:set patchmode=.orig


附加到文件

当将多行文本收集到一个文件中时，您可以使用此命令：>

	:write >> logfile

这将当前文件的文本写入 "logfile" 的末尾。因此它是附加的。这避免了您必须复制这些行、编辑日志文件并将它们放在那里。因此您节省了两个步骤。但您只能附加到文件的末尾。
   要仅附加几行，请在输入 ":write" 之前在可视模式下选择它们。在第 10 章中，您将学习选择一行范围的其他方法。

vim -R file

:view file

如果您真的想禁止在文件中进行更改，请执行以下操作：>

	vim -M file

现在每次更改文本的尝试都会失败。例如，帮助文件就是这样的。如果您尝试进行更改，您会收到此错误消息：

您可以使用 -M 参数来设置 Vim 以查看器模式工作。但这只是自愿的，因为以下命令将移除保护：>

	:set modifiable
	:set write



==============================================================================
*07.7*	更改文件名

开始编辑新文件的一种巧妙方法是使用包含您所需大部分内容的现有文件。例如，您开始编写一个移动文件的新程序。您知道您已经有一个复制文件的程序，因此您从以下开始：>

	:edit copy.c

您可以删除不需要的内容。现在您需要以新名称保存文件。":saveas" 命令可用于此：>

	:saveas move.c

Vim 将以给定名称写入文件，并编辑该文件。因此，下次您执行 ":write" 时，它将写入 "move.c"。"copy.c" 保持不变。
   当您想更改正在编辑的文件名，但还不想写入文件时，可以使用此命令：>

	:file move.c

Vim 会将文件标记为 "未编辑"。这意味着 Vim 知道这不是您开始编辑的文件。当您尝试写入文件时，您可能会收到此消息：

	E13: 文件已存在 (使用 ! 强制执行) ~

这可以保护您意外覆盖另一个文件。


CTRL-W W

:only


:new

:3split alpha.c

":split" 命令可以接受一个数字参数。如果指定，这将是新窗口的高度。例如，以下命令打开一个三行高的新窗口并开始编辑文件 alpha.c：>

	:3split alpha.c


要增加窗口大小：>

	CTRL-W +

要减小它：>

	CTRL-W -

这两个命令都接受一个计数，并按该行数增加或减少窗口大小。因此 "4 CTRL-W +" 使窗口增加四行高。


要将窗口高度设置为指定行数：>

	{height}CTRL-W _

即：一个数字 {height}，CTRL-W，然后是一个下划线（在美式英语键盘上是 Shift + - 键）。
   要使窗口尽可能高，请使用不带计数的 CTRL-W _ 命令。


   ：vertical new

	CTRL-W t	移动到最顶部 (TOP) 的窗口
	CTRL-W b	移动到最底部 (BOTTOM) 的窗口


  CTRL-W K
	CTRL-W H	将窗口移动到最左边
	CTRL-W J	将窗口移动到底部
	CTRL-W L	将窗口移动到最右边

	vim -o one.txt two.txt three.txt

"-O" 参数用于获得垂直分割的窗口。
   当 Vim 已经在运行时，":all" 命令为参数列表中的每个文件打开一个窗口。":vertical all" 以垂直分割的方式执行。

:all
:vertical all

	nvim -d main.c~ main.c

在 VIM 中进行差异比较

在差异模式下启动的另一种方法可以从 Vim 内部完成。编辑 "main.c" 文件，然后进行分割并显示差异：>

	:edit main.c
	:vertical diffsplit main.c~

":vertical" 命令用于使窗口垂直分割。如果省略此命令，您将获得水平分割。

如果您有补丁或差异文件，可以使用第三种方式启动差异模式。首先编辑补丁所应用的文件。然后告诉 Vim 补丁文件的名称：>

	:edit main.c
	:vertical diffpatch main.c.diff

警告：补丁文件必须仅包含一个适用于您正在编辑的文件的补丁。否则您将收到大量错误消息，并且某些文件可能会被意外地打补丁。
   打补丁将仅对 Vim 中的文件副本进行。硬盘上的文件将保持未修改状态（直到您决定写入文件）。


许多编辑另一个文件的命令都有一个分割窗口的变体。对于命令行命令，这是通过在前面加上 "s" 来完成的。例如：":tag" 跳转到一个标签，":stag" 分割窗口并跳转到一个标签。
   对于普通模式命令，在前面加上 CTRL-W。CTRL-^ 跳转到交替文件，CTRL-W CTRL-^ 分割窗口并编辑交替文件。

'splitbelow' 选项可以设置以使新窗口出现在当前窗口下方。'splitright' 选项可以设置以使垂直分割的窗口出现在当前窗口右侧。

当分割窗口时，您可以在前面加上修饰符命令以告知窗口出现的位置：

	:leftabove {cmd}	在当前窗口的左侧或上方
	:aboveleft {cmd}	同上
	:rightbelow {cmd}	在当前窗口的右侧或下方
	:belowright {cmd}	同上
	:topleft {cmd}		在 Vim 窗口的顶部或左侧
	:botright {cmd}		在 Vim 窗口的底部或右侧

:tabedit thatfile

现在让我们使用命令创建另一个标签页：>

	:tab split

这将创建一个新的标签页，其中包含一个窗口，该窗口编辑与我们所在窗口相同的缓冲区：


您可以在任何打开窗口的 Ex 命令前加上 ":tab"。该窗口将在新的标签页中打开。另一个例子：>

	:tab help gt


命令前的 "%" 指定命令在所有行上工作。没有范围，":s" 只在当前行工作。关于范围的更多信息在下一节 |10.3|。

如果您要替换的 "from" 或 "to" 部分包含斜杠，您需要在它前面放一个反斜杠。更简单的方法是使用另一个字符代替斜杠。例如，加号： >


":substitute" 命令和许多其他 : 命令可以应用于选定的行。这称为范围。
   范围的简单形式是 {number},{number}。例如：>

	:1,5s/this/that/g

在行 1 到 5 上执行替换命令。包括第 5 行。范围总是放在命令之前。

单个数字可用于寻址一个特定的行：>

	:54s/President/Fool/


一些命令在您不指定范围时对整个文件工作。要使它们对当前行工作，使用 "." 地址。":write" 命令就是这样工作的。没有范围，它写入整个文件。要使其仅将当前行写入文件：>

	:.write otherfile

第一行总是编号为一。最后一行呢？"$" 字符用于此。例如，要替换从光标到末尾的行：>

	:.,$s/yes/no/

我们之前使用的 "%" 范围，实际上是 "1,$" 的简写方式，从第一行到最后一行。


在范围中使用模式

假设您正在编辑一本书的一章，并希望将所有 "grey" 的出现替换为 "gray"。但仅在本章中，而不是下一章。您知道只有章节边界在首列有单词 "Chapter"。那么这个命令将起作用：>

	:?^Chapter?,/^Chapter/s=grey=gray=g

您可以看到搜索模式被使用了两次。第一个 "?^Chapter?" 找到当前位置上方匹配此模式的行。因此 ?pattern? 范围用于向后搜索。类似地，"/^Chapter/" 用于向前搜索下一章的开始。
   为了避免与斜杠混淆，这里在替换命令中使用了 "=" 字符。斜杠或其他字符也可以工作。


加和减

上述命令有一个小错误：如果下一章的标题包含 "grey"，它也会被替换。也许那是您想要的，但如果不是呢？那么您可以指定一个偏移量。
   要搜索一个模式然后使用它上方的一行：>

	/Chapter/-1

您可以使用任何数字代替 1。要寻址匹配下方第二行：>

	/Chapter/+2

偏移量也可以用于范围中的其他项目。看看这个：>

	:.+3,$-5

这指定了从光标下方三行开始到文件最后一行之前五行结束的范围。


使用标记

与其找出某些位置的行号、记住它们并在范围中输入它们，您可以使用标记。
   如第3章所述放置标记。例如，使用 "mt" 标记区域顶部，使用 "mb" 标记底部。然后您可以使用这个范围来指定标记之间的行（包括带有标记的行）：>

	:'t,'b

'< 和 '> 实际上是标记，放置在可视选择的开始和结束处。标记保持在其位置，直到进行另一个可视选择。因此您可以使用 "'<" 命令跳转到可视区域开始的位置。并且您可以将标记与其他项目混合：>

	:'>,$

这寻址从可视区域结束到文件末尾的行。

一定数量的行

当您知道要更改多少行时，您可以输入数字然后 ":"。例如，当您输入 "5:" 时，您将得到：>

	:.,.+4

现在您可以输入要使用的命令。它将使用范围 "."（当前行）直到 ".+4"（向下四行）。因此它跨越五行。

==============================================================================
*10.4*	全局命令

":global" 命令是 Vim 更强大的功能之一。它允许您查找模式的匹配项并在那里执行命令。一般形式是：>

	:[range]global/{pattern}/{command}

这与 ":substitute" 命令类似。但是，它不是用其他文本替换匹配的文本，而是执行命令 {command}。

	注意:
	为 ":global" 执行的命令必须是以冒号开头的命令。不能直接使用普通模式命令。|:normal| 命令可以为您做到这一点。

假设您想将 "foobar" 更改为 "barfoo"，但仅在 C++ 样式的注释中。这些注释以 "//" 开头。使用此命令：>

	:g+//+s/foobar/barfoo/g

这以 ":g" 开始。那是 ":global" 的缩写，就像 ":s" 是 ":substitute" 的缩写一样。然后是模式，用加号字符括起来。由于我们正在查找的模式包含斜杠，这里使用加号字符来分隔模式。接下来是替换命令，将 "foobar" 更改为 "barfoo"。
   全局命令的默认范围是整个文件。因此在此示例中没有指定范围。这与 ":substitute" 不同，后者在没有范围时在一行上工作。
   该命令并不完美，因为它也匹配 "//" 出现在行中间的行，并且替换也将在 "//" 之前进行。

就像 ":substitute" 一样，可以使用任何模式。当您以后学习更复杂的模式时，您可以在这里使用它们。


如果块跨越未延伸到块中的短行，则不会在该行中插入文本。例如，创建一个可视块选择，包括此文本第一行和最后一行中的单词 "long"，因此在第二行中没有选择文本：

	This is a long line ~
	short ~
	Any other long line ~

		  ^^^^ 选定的块

现在使用命令 "Ivery <Esc>"。结果是：

	This is a very long line ~
	short ~
	Any other very long line ~

在短行中没有插入文本。

如果您插入的字符串包含换行符，"I" 的行为就像普通插入命令一样，仅影响块的第一行。


"A" 命令的工作方式相同，只是它在块的右侧追加。并且它确实在短行中插入文本。因此您可以选择是否要追加文本到短行。
   "A" 有一个特殊情况：选择一个可视块，然后使用 "$" 使块延伸到每行的末尾。现在使用 "A" 将在每行的末尾追加文本。
   使用上面的相同示例，然后输入 "$A XXX<Esc>"，您得到这个结果：

	This is a long line XXX ~
	short XXX ~
	Any other long line XXX ~

这确实需要使用 "$" 命令。Vim 记住它被使用过。通过其他移动命令将光标移动到最长行的末尾来进行相同的选择不会产生相同的结果。


   从上面相同的 "long" 单词选择开始，然后输入 "c_LONG_<Esc>"，您得到：

	This is a _LONG_ line ~
	short ~
	Any other _LONG_ line ~

就像 "I" 一样，短行不会被更改。此外，您不能在新文本中输入换行符。

>移动量由 'shiftwidth' 选项指定。要将其更改为使用 4 个空格：>

	:set shiftwidth=4

"<" 命令在块的左边缘删除一个移动量的空白。此命令受限于那里有多少文本；因此如果可用的空白少于一个移动量，它会删除它能删除的部分。

"J" 命令将所有选定的行连接成一行。因此它删除了换行符。实际上，换行符、前导空白和尾随空白被一个空格替换。在行结束（句点）后使用两个空格（这可以通过 'joinspaces' 选项更改）。
   让我们使用我们现在已经非常熟悉的示例。使用 "J" 命令的结果：

"J" 命令不需要块状选择。它与 "v" 和 "V" 选择的工作方式完全相同。

如果您不希望空白被更改，请使用 "gJ" 命令。

当您编写电子邮件时，可能想要包含另一个文件。这可以通过 ":read {filename}" 命令完成。文件的文本被放在光标行下方。
   从此文本开始：

	Hi John, ~
	Here is the diff that fixes the bug: ~
	Bye, Pierre. ~

将光标移动到第二行并输入：>

	:read patch

名为 "patch" 的文件将被插入，结果如下：

	Hi John, ~
	Here is the diff that fixes the bug: ~
	2c2 ~
	<	for (i = 0; i <= length; ++i) ~
	--- ~
	>	for (i = 0; i < length; ++i) ~
	Bye, Pierre. ~



":read" 命令接受一个范围。文件将被放在此范围的最后一行号下方。因此 ":$r patch" 在文件末尾追加文件 "patch"。
   如果您想在第一行上方读取文件怎么办？这可以使用行号零来完成。这一行并不真正存在，当您将其与大多数命令一起使用时会出现错误消息。但此命令是允许的：>
	:0read patch

文件 "patch" 将被放在文件第一行的上方。


写入一定范围的行

要将一定范围的行写入文件，可以使用 ":write" 命令。没有范围时，它写入整个文件。有范围时，只有指定的行被写入：>

	:.,$write tempo

这将从光标直到文件末尾的行写入文件 "tempo"。如果此文件已存在，您将收到错误消息。Vim 保护您免于意外覆盖现有文件。如果您知道自己在做什么并想要覆盖文件，请追加 !：>

	:.,$write! tempo

小心：! 必须紧跟在 ":write" 命令之后，没有空白。否则它将成为过滤器命令，本章稍后解释。

追加到文件

在本章第一节中解释了如何将多行收集到寄存器中。同样可以完成将行收集到文件中。使用此命令写入第一行：>

	:.write collection

现在将光标移动到您想要收集的第二行，并输入此命令：>

	:.write >>collection

">>" 告诉 Vim "collection" 文件不是作为新文件写入，而是该行必须追加到末尾。您可以重复此操作任意次数。


gq + textwidth


g~g~
g~~

   命令 "!{motion}{program}" 获取一个文本块并通过外部程序过滤它。换句话说，它运行由 {program} 表示的系统命令，将 {motion} 表示的文本块作为输入。此命令的输出然后替换选定的块。


	!5Gsort<Enter>


"!!" 命令通过过滤器过滤当前行。在 Unix 中，"date" 命令打印当前时间和日期。"!!date<Enter>" 用 "date" 的输出替换当前行。这对于向文件添加时间戳很有用。


注意："!cmd"（例如，不使用任何文件范围）和 "{range}!cmd" 之间有区别。前者将简单地执行外部命令，Vim 将显示输出，而后者将通过过滤器过滤 {range} 行，并用过滤器命令的结果替换该范围。有关详细信息，请参阅 |:!| 和 |:range!|。

启动 shell、向其发送文本并捕获输出需要 Vim 确切知道 shell 是如何工作的。当您在过滤方面遇到问题时，请检查这些选项的值：

	'shell'		指定 Vim 用于执行外部程序的程序。
	'shellcmdflag'	用于将命令传递给 shell 的参数
	'shellquote'	用于围绕命令的引号
	'shellxquote'	用于围绕命令和重定向的引号
	'shellslash'	在命令中使用正斜杠（仅适用于 MS-Windows 及类似系统）
	'shellredir'	用于将命令输出写入文件的字符串

在 Unix 上，这几乎不是问题，因为有两种 shell："sh" 类和 "csh" 类。Vim 检查 'shell' 选项并根据它是否在 'shell' 中看到 "csh" 自动设置相关选项。
   然而，在 MS-Windows 上，有许多不同的 shell，您可能必须调整选项才能使过滤工作。有关更多信息，请查看选项的帮助。


读取命令输出

将当前目录的内容读入文件，使用：

在 Unix 上：>
	:read !ls
在 MS-Windows 上：>
	:read !dir

"ls" 或 "dir" 命令的输出被捕获并插入到文本中，光标下方。这类似于读取文件，只是使用 "!" 告诉 Vim 后面跟着一个命令。
   命令可以有参数。并且可以使用范围来告诉 Vim 应该将行放在哪里：>

	:0read !date -u

这在文件顶部插入当前的时间和日期（UTC 格式）。（嗯，如果您有一个接受 "-u" 参数的 date 命令。）注意与使用 "!!date" 的区别：后者替换一行，而 ":read !date" 将插入一行。



将文本写入命令

Unix 命令 "wc" 计数单词。要计算当前文件中的单词数：>

	:write !wc

这与之前的 write 命令相同，但代替文件名的是 "!" 字符和外部命令的名称。写入的文本将作为其标准输入传递给指定的命令。输出可能如下所示：

       4      47     249 ~

"wc" 命令不详细。这意味着您有 4 行、47 个单词和 249 个字符。

注意这个错误：>

	:write! wc

这将在当前目录中写入文件 "wc"，并强制写入。这里空白很重要！



在大多数情况下，恢复文件非常简单，假设您知道正在编辑哪个文件（并且硬盘仍然工作）。在文件上启动 Vim，并添加 "-r" 参数：>

	vim -r help.txt

Vim 将读取交换文件（用于存储您正在编辑的文本）并可能读取原始文件的片段。如果 Vim 恢复了您的更改，您将看到这些消息（当然，文件名会不同）：

	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. You should check if everything is OK. ~
	(You might want to write out this file under another name ~
	and run diff with the original file to check for changes) ~
	You may want to delete the .swp file now. ~

为了安全起见，将此文件以另一个名称写入：>

	:write help.txt.recovered

将文件与原始文件进行比较，以检查是否得到了预期的结果。差异模式对此非常有用 |08.7|。例如：>

	:write help.txt.recovered
	:edit #
	:diffsp help.txt

注意原始文件可能包含更新的版本（您在计算机崩溃前保存了文件）。并检查是否有行丢失（发生了 Vim 无法恢复的错误）。
   如果 Vim 在恢复时产生警告消息，请仔细阅读它们。不过这种情况很少见。

如果恢复的文本与文件内容完全相同，您将收到此消息：

	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. Buffer contents equals file contents. ~
	You may want to delete the .swp file now. ~

这通常发生在您已经恢复了更改，或者在更改后写入了文件的情况下。现在删除交换文件是安全的。

最后几次更改无法恢复是正常的。当您大约四秒没有输入时，或者在输入大约两百个字符后，Vim 会将更改刷新到磁盘。这是通过 'updatetime' 和 'updatecount' 选项设置的。因此，当系统关闭时 Vim 没有机会保存自己，最后一次刷新之后的更改将会丢失。

如果您在没有文件名的情况下进行编辑，请给出一个空字符串作为参数：>

	vim -r ""

您必须在正确的目录中，否则 Vim 找不到交换文件。


在多个文件中替换

假设您想在多个文件中替换一个单词。您可以编辑每个文件并手动输入命令。使用录制和回放要快得多。
   假设您有一个包含 C++ 文件的目录，所有文件都以 ".cpp" 结尾。有一个名为 "GetResp" 的函数，您想将其重命名为 "GetAnswer"。

	vim *.cpp		启动 Vim，定义参数列表包含所有 C++ 文件。您现在在第一个文件中。
	qq			开始录制到 q 寄存器
	:%s/\<GetResp\>/GetAnswer/g
				在第一个文件中进行替换。
	:wnext			写入此文件并移动到下一个文件。
	q			停止录制。
	@q			执行 q 寄存器。这将回放替换和 ":wnext"。您可以验证这不会产生错误消息。
	999@q			在剩余文件上执行 q 寄存器。


在最后一个文件，您将收到错误消息，因为 ":wnext" 无法移动到下一个文件。这将停止执行，所有操作都已完成。

	注意:
	当回放录制的序列时，错误会停止执行。因此，请确保在录制时不会收到错误消息。

有一个陷阱：如果某个 .cpp 文件不包含单词 "GetResp"，您将收到错误并且替换将停止。为避免这种情况，在替换命令中添加 "e" 标志：>

	:%s/\<GetResp\>/GetAnswer/ge

"e" 标志告诉 ":substitute" 未找到匹配项不是错误。


|:global| 命令可以与 |:move| 命令结合使用，将所有行移动到第一行之前，从而反转文件。命令是：>

	:global/^/move 0

缩写：>

	:g/^/m 0

"^" 正则表达式匹配行首（即使该行为空）。|:move| 命令将匹配的行移动到虚构的第零行之后，因此当前匹配的行成为文件的第一行。由于 |:global| 命令不会因行号变化而混淆，|:global| 继续匹配文件中的所有剩余行并将每一行作为第一行。

这也适用于一定范围的行。首先移动到第一行上方并用 "mt" 标记它。然后将光标移动到范围内的最后一行并输入：>

	:'t+1,.g/^/m 't


*12.5*	计数单词

有时您必须编写一个具有最大单词数的文本。Vim 可以为您计数单词。
   当整个文件是您想要计数的内容时，使用此命令：>

	g CTRL-G

不要在 g 后输入空格，这里使用空格只是为了便于阅读命令。
   输出看起来像这样：

	Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~

您可以看到您位于哪个单词（748），以及文件中的总单词数（774）。

当文本只是文件的一部分时，您可以移动到文本开头，输入 "g CTRL-G"，移动到文本结尾，再次输入 "g CTRL-G"，然后使用您的大脑计算单词位置的差异。这是一个很好的练习，但有一个更简单的方法。使用可视模式，选择您想要计数单词的文本。然后输入 g CTRL-G。结果：

	Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~

有关计数单词、行和其他项目的其他方法，请参阅 |count-items|。


*12.6*	查找手册页				*find-manpage*

在编辑 shell 脚本或 C 程序时，您正在使用一个命令或函数，您想查找其手册页（这是在 Unix 上）。让我们首先使用一个简单的方法：将光标移动到您想要查找帮助的单词上并按>

	K

Nvim 将在该单词上运行 |:Man|。如果找到手册页，它将显示出来。您也可以使用 |:Man| 命令在手册页上打开一个窗口：>

	:Man csh

您可以滚动查看，并且文本会高亮显示。这允许您找到您正在寻找的帮助。使用 CTRL-W w 跳转到您正在处理的文本窗口。
   要在特定部分查找手册页，请将节号放在前面。例如，要在第 3 节中查找 "echo"：>

	:Man 3 echo

要跳转到另一个手册页，该手册页在文本中具有典型形式 "word(1)"，请在其上按 CTRL-]。进一步的 ":Man" 命令将使用同一个窗口。

要显示光标下单词的手册页，请使用：>

	K

例如，在编辑此行时，您想知道 "strstr()" 的返回值：

	if ( strstr (input, "aap") == ) ~

将光标移动到 "strstr" 上的某处并输入 "K"。将打开一个窗口来显示 strstr() 的手册页。


*12.7*	修剪空白

有些人认为行尾的空格和制表符无用、浪费且丑陋。要删除每行末尾的空白，执行以下命令：>

	:%s/\s\+$//

使用了行范围 "%"，因此这在整个文件上工作。":substitute" 命令匹配的模式是 "\s\+$"。这找到空白字符 (\s)，一个或多个 (+)，在行尾 ($) 之前。稍后将解释如何编写这样的模式，请参阅 |usr_27.txt|。
   替换命令的 "to" 部分为空："//"。因此它用空替换，有效地删除匹配的空白。

另一种浪费使用空格的方式是在制表符之前放置空格。通常这些可以被删除而不改变空白量。但并非总是如此！因此，您最好手动执行此操作。使用此搜索命令：>

	/ 	

您看不到，但此命令中有一个空格在制表符之前。因此它是 "/<Space><Tab>"。现在使用 "x" 删除空格并检查空白量是否改变。如果改变，您可能必须插入一个制表符。输入 "n" 查找下一个匹配项。重复此操作，直到找不到更多匹配项。


如果您是 Unix 用户，您可以使用 Vim 和 grep 命令的组合来编辑包含给定单词的所有文件。如果您正在处理一个程序并希望查看或编辑包含特定变量的所有文件，这非常有用。
   例如，假设您想要编辑所有包含单词 "frame_counter" 的 C 程序文件。为此，您使用命令：>

	vim `grep -l frame_counter *.c`

让我们详细查看此命令。grep 命令在一组文件中搜索给定单词。由于指定了 -l 参数，该命令将仅列出包含该单词的文件，而不打印匹配的行。它搜索的单词是 "frame_counter"。实际上，这可以是任何正则表达式。（注意：grep 使用的正则表达式与 Vim 使用的并不完全相同。）
   整个命令用反引号 (`) 括起来。这告诉 Unix shell 运行此命令并假装结果是在命令行上输入的。所以发生的情况是 grep 命令运行并产生一个文件列表，这些文件被放在 Vim 命令行上。这导致 Vim 编辑作为 grep 输出的文件列表。然后您可以使用 ":next" 和 ":first" 等命令浏览文件。


查找每一行

上述命令仅找到单词所在的文件。您仍然必须在文件中找到该单词。
   Vim 有一个内置命令，您可以使用它在一组文件中搜索给定字符串。例如，如果您想在所有 C 程序文件中找到 "error_string" 的所有出现，输入以下命令：>

	:grep error_string *.c

这导致 Vim 在所有指定文件 (`*.c`) 中搜索字符串 "error_string"。编辑器现在将打开找到匹配的第一个文件，并将光标定位在第一个匹配行上。要转到下一个匹配行（无论在哪个文件中），使用 ":cnext" 命令。要转到上一个匹配，使用 ":cprev" 命令。使用 ":clist" 查看所有匹配及其位置。
   ":grep" 命令使用外部命令 grep（在 Unix 上）或 findstr（在 Windows 上）。您可以通过设置选项 'grepprg' 来更改此设置。

如果您在命令行的开头，按 <BS> 将取消命令。就像删除行首的 ":" 或 "/" 一样。

'wildmode' 选项可用于更改补全的工作方式。
'wildmenu' 选项可用于获得菜单式的匹配列表。
使用 'suffixes' 选项指定不太重要的文件，这些文件出现在文件列表的末尾。
'wildignore' 选项指定根本不列出的文件。



要查看历史记录中的所有行：>

	:history

那是 ":" 命令的历史记录。搜索历史记录用此命令显示：>

	:history /


CTRL-P 将像 <Up> 一样工作，只是它不在乎您已经键入了什么。类似地，CTRL-N 和 <Down> 也是如此。CTRL-P 代表 previous（上一个），CTRL-N 代表 next（下一个）。

用此命令打开命令行窗口：>

	q:

Vim 现在在底部打开一个（小）窗口。它包含命令行历史记录，并在末尾有一个空行：

您现在处于正常模式。您可以使用 "hjkl" 键移动。例如，用 "5k" 向上移动到 ":e config.h.in" 行。输入 "$h" 转到 "in" 的 "i" 并输入 "cwout"。现在您已将行更改为：
